{"./":{"url":"./","title":"前言","keywords":"","body":"1. 此文档为2020博学谷大数据课件1. 此文档为2020博学谷大数据课件 Copyright © MISIN 2022 | 豫ICP备2021006345号-1 all right reserved，powered by Gitbook该文件修订时间： 2022-12-16 11:31:53 "},"1.JAVA基础/day01-java基础语法.html":{"url":"1.JAVA基础/day01-java基础语法.html","title":"day01-java基础语法","keywords":"","body":"1.1. 1. Java概述1.1.1. 1.1 Java语言背景介绍（了解）1.1.2. 1.2 Java语言跨平台原理（理解）1.1.3. 1.3 JRE和JDK（记忆）1.1.4. 1.4 JDK的下载和安装（应用）1.2. 2. 第一个演示程序1.2.1. 2.1 常用DOS命令（应用）1.2.2. 2.2 Path环境变量的配置（应用）1.2.3. 2.3 HelloWorld案例（应用）1.2.4. 2.4 HelloWorld案例详解（理解）1.2.5. 2.5 HelloWorld案例常见问题（理解）1.2.6. 2.6 Notepad++软件的安装和使用（应用）1.3. 3. java基础语法1.3.1. 3.1 注释（理解）1.3.2. 3.2 关键字（理解）1.3.3. 3.3 常量（应用）1.3.4. 3.4 变量的介绍(理解)1.3.5. 3.5 数据类型（应用）1.3.6. 3.6 变量（应用）1.3.7. 3.7 变量的注意事项(理解)1.3.8. 3.8 键盘录入（理解）1.3.9. 3.9 标识符（理解）1.1. 1. Java概述 1.1.1. 1.1 Java语言背景介绍（了解） 语言：人与人交流沟通的表达方式 计算机语言：人与计算机之间进行信息交流沟通的一种特殊语言 Java语言是美国Sun公司（Stanford University Network）在1995年推出的计算机语言 Java之父：詹姆斯·高斯林（James Gosling） 2009年，Sun公司被甲骨文公司收购，所以我们现在访问oracle官网即可：https://www.oracle.com java语言的三个版本： ​ JavaSE: Java 语言的（标准版），用于桌面应用的开发，是其他两个版本的基础 ​ JavaME: Java 语言的（小型版），用于嵌入式消费类电子设备 ​ JavaEE: Java 语言的（企业版），用于 Web 方向的网站开发 1.1.2. 1.2 Java语言跨平台原理（理解） Java程序并非是直接运行的，Java编译器将Java源程序编译成与平台无关的字节码文件(class文件)，然后由Java虚拟机（JVM）对字节码文件解释执行。所以在不同的操作系统下，只需安装不同的Java虚拟机即可实现java程序的跨平台。 1.1.3. 1.3 JRE和JDK（记忆） JVM（Java Virtual Machine），Java虚拟机 JRE（Java Runtime Environment），Java运行环境，包含了JVM和Java的核心类库（Java API） JDK（Java Development Kit）称为Java开发工具，包含了JRE和开发工具 总结：我们只需安装JDK即可，它包含了java的运行环境和虚拟机。 1.1.4. 1.4 JDK的下载和安装（应用） 1.4.1 下载 通过官方网站获取JDK http://www.oracle.com 注意：针对不同的操作系统，需要下载对应版本的JDK。 1.4.2 安装 傻瓜式安装，下一步即可。但默认的安装路径是在C:\\Program Files下，为方便统一管理建议修改安装路径，将与开发相关的软件都安装到一个目录下，例如：E:\\develop。 注意：安装路径不要包含中文或者空格等特殊字符（使用纯英文目录）。 1.4.3 JDK的安装目录介绍 目录名称 说明 bin 该路径下存放了JDK的各种工具命令。javac和java就放在这个目录。 conf 该路径下存放了JDK的相关配置文件。 include 该路径下存放了一些平台特定的头文件。 jmods 该路径下存放了JDK的各种模块。 legal 该路径下存放了JDK各模块的授权文档。 lib 该路径下存放了JDK工具的一些补充JAR包。 1.2. 2. 第一个演示程序 1.2.1. 2.1 常用DOS命令（应用） 在接触集成开发环境之前，我们需要使用命令行窗口对java程序进行编译和运行，所以需要知道一些常用DOS命令。 1、打开命令行窗口的方式：win + r打开运行窗口，输入cmd，回车。 2、常用命令及其作用 操作 说明 盘符名称: 盘符切换。E:回车，表示切换到E盘。 dir 查看当前路径下的内容。 cd 目录 进入单级目录。cd itheima cd .. 回退到上一级目录。 cd 目录1\\目录2... 进入多级目录。cd itheima\\JavaSE cd \\ 回退到盘符目录。 cls 清屏。 exit 退出命令提示符窗口。 1.2.2. 2.2 Path环境变量的配置（应用） 2.2.1 为什么配置环境变量 开发Java程序，需要使用JDK提供的开发工具（比如javac.exe、java.exe等命令），而这些工具在JDK的安装目录的bin目录下，如果不配置环境变量，那么这些命令只可以在该目录下执行。我们不可能把所有的java文件都放到JDK的bin目录下，所以配置环境变量的作用就是可以使bin目录下的java相关命令可以在任意目录下使用。 1.2.3. 2.3 HelloWorld案例（应用） HelloWorld案例是指在计算机屏幕上输出“HelloWorld”这行文字。 各种计算机语言都习惯使用该案例作为第一个演示案例。 2.3.1 Java程序开发运行流程 开发Java程序，需要三个步骤：编写程序，编译程序，运行程序。 2.3.2 HelloWorld案例的编写 1、新建文本文档文件，修改名称为HelloWorld.java。 2、用记事本打开HelloWorld.java文件，输写程序内容。 public class HelloWorld { public static void main(String[] args) { System.out.println(\"HelloWorld\"); } } 2.3.3 HelloWorld案例的编译和运行 存文件，打开命令行窗口，将目录切换至java文件所在目录，编译java文件生成class文件，运行class文件。 编译：javac 文件名.java 范例：javac HelloWorld.java 执行：java 类名 范例：java HelloWorld 1.2.4. 2.4 HelloWorld案例详解（理解） 1.2.5. 2.5 HelloWorld案例常见问题（理解） 2.5.1 BUG 在电脑系统或程序中，隐藏着的一些未被发现的缺陷或问题统称为bug（漏洞）。 2.5.2 BUG的解决 1、具备识别BUG的能力：多看 2、具备分析BUG的能力：多思考，多查资料 3、具备解决BUG的能力：多尝试，多总结 2.5.3 HelloWorld案例常见问题 1、非法字符问题。Java中的符号都是英文格式的。 2、大小写问题。Java语言对大小写敏感（区分大小写）。 3、在系统中显示文件的扩展名，避免出现HelloWorld.java.txt文件。 4、编译命令后的java文件名需要带文件后缀.java 5、运行命令后的class文件名（类名）不带文件后缀 1.2.6. 2.6 Notepad++软件的安装和使用（应用） 2.6.1 什么要使用Notepad++软件 Notepad++功能比windows中的自带记事本功能强大，除了可以用来制作一般的纯文字说明文件，也十分适合编写计算机程序代码。Notepad++有行号，能够快速定位问题位置，还有语法高亮度显示、代码折叠等功能。而且它是免费的。 2.6.2 Notepad++软件安装 安装：傻瓜式安装，一直下一步即可。建议也安装到统一的开发软件目录下，比如E:\\develop。 2.6.3Notepad++软件配置 安装完毕之后，为了使用方便，做一个简单的配置：修改默认语言和编码。 1.3. 3. java基础语法 1.3.1. 3.1 注释（理解） 注释是对代码的解释和说明文字，可以提高程序的可读性，因此在程序中添加必要的注释文字十分重要。Java中的注释分为三种： 单行注释。单行注释的格式是使用//，从//开始至本行结尾的文字将作为注释文字。 // 这是单行注释文字 多行注释。多行注释的格式是使用/ 和 /将一段较长的注释括起来。 /* 这是多行注释文字 这是多行注释文字 这是多行注释文字 */ 注意：多行注释不能嵌套使用。 文档注释。文档注释以/**开始，以*/结束。（以后讲） 1.3.2. 3.2 关键字（理解） 关键字是指被java语言赋予了特殊含义的单词。 关键字的特点： ​ 关键字的字母全部小写。 ​ 常用的代码编辑器对关键字都有高亮显示，比如现在我们能看到的public、class、static等。 1.3.3. 3.3 常量（应用） 常量：在程序运行过程中，其值不可以发生改变的量。 Java中的常量分类： ​ 字符串常量 用双引号括起来的多个字符（可以包含0个、一个或多个），例如\"a\"、\"abc\"、\"中国\"等 ​ 整数常量 整数，例如：-10、0、88等 ​ 小数常量 小数，例如：-5.5、1.0、88.88等 ​ 字符常量 用单引号括起来的一个字符，例如：'a'、'5'、'B'、'中'等 ​ 布尔常量 布尔值，表示真假，只有两个值true和false ​ 空常量 一个特殊的值，空值，值为null 除空常量外，其他常量均可使用输出语句直接输出。 public class Demo { public static void main(String[] args) { System.out.println(10); // 输出一个整数 System.out.println(5.5); // 输出一个小数 System.out.println('a'); // 输出一个字符 System.out.println(true); // 输出boolean值true System.out.println(\"欢迎来到黑马程序员\"); // 输出字符串 } } 1.3.4. 3.4 变量的介绍(理解) 变量的定义格式： ​ 数据类型 变量名 = 数据值； ​ 数据类型：为空间中存储的数据加入类型限制。整数？小数？ ​ 变量名：自己要为空间起的名字，没有难度 ​ 数据值： 空间中要存储的数值，没有难度 1.3.5. 3.5 数据类型（应用） 3.5.1 计算机存储单元 我们知道计算机是可以用来存储数据的，但是无论是内存还是硬盘，计算机存储设备的最小信息单元叫“位（bit）”，我们又称之为“比特位”，通常用小写的字母”b”表示。而计算机中最基本的存储单元叫“字节（byte）”， 通常用大写字母”B”表示，字节是由连续的8个位组成。 除了字节外还有一些常用的存储单位，其换算单位如下： 1B（字节） = 8bit 1KB = 1024B 1MB = 1024KB 1GB = 1024MB 1TB = 1024GB 3.5.2 Java中的数据类型 Java是一个强类型语言，Java中的数据必须明确数据类型。在Java中的数据类型包括基本数据类型和引用数据类型两种。 Java中的基本数据类型： 数据类型 关键字 内存占用 取值范围 整数类型 byte 1 -128~127 short 2 -32768~32767 int(默认) 4 -2的31次方到2的31次方-1 long 8 -2的63次方到2的63次方-1 浮点类型 float 4 负数：-3.402823E+38到-1.401298E-45 正数： 1.401298E-45到3.402823E+38 double(默认) 8 负数：-1.797693E+308到-4.9000000E-324 正数：4.9000000E-324 到1.797693E+308 字符类型 char 2 0-65535 布尔类型 boolean 1 true，false 说明： ​ e+38表示是乘以10的38次方，同样，e-45表示乘以10的负45次方。 ​ 在java中整数默认是int类型，浮点数默认是double类型。 1.3.6. 3.6 变量（应用） 3.6.1 变量的定义 变量：在程序运行过程中，其值可以发生改变的量。 从本质上讲，变量是内存中的一小块区域，其值可以在一定范围内变化。 变量的定义格式： 数据类型 变量名 = 初始化值; // 声明变量并赋值 int age = 18; System.out.println(age); 或者(扩展) // 先声明，后赋值（使用前赋值即可） 数据类型 变量名; 变量名 = 初始化值; double money; money = 55.5; System.out.println(money); 还可以(扩展) 在同一行定义多个同一种数据类型的变量，中间使用逗号隔开。但不建议使用这种方式，降低程序的可读性。 int a = 10, b = 20; // 定义int类型的变量a和b，中间使用逗号隔开 System.out.println(a); System.out.println(b); int c,d; // 声明int类型的变量c和d，中间使用逗号隔开 c = 30; d = 40; System.out.println(c); System.out.println(d); 3.6.2 变量的修改 int a = 10; a = 30; //修改变量的值 System.out.println(a); 变量前面不加数据类型时，表示修改已存在的变量的值。 1.3.7. 3.7 变量的注意事项(理解) 在同一对花括号中，变量名不能重复。 变量在使用之前，必须初始化（赋值）。 定义long类型的变量时，需要在整数的后面加L（大小写均可，建议大写）。因为整数默认是int类型，整数太大可能超出int范围。 定义float类型的变量时，需要在小数的后面加F（大小写均可，建议大写）。因为浮点数的默认类型是double， double的取值范围是大于float的，类型不兼容。 1.3.8. 3.8 键盘录入（理解） 我们可以通过 Scanner 类来获取用户的输入。使用步骤如下： 1、导包。Scanner 类在java.util包下，所以需要将该类导入。导包的语句需要定义在类的上面。 import java.util.Scanner; 2、创建Scanner对象。 Scanner sc = new Scanner(System.in);// 创建Scanner对象，sc表示变量名，其他均不可变 3、接收数据 int i = sc.nextInt(); // 表示将键盘录入的值作为int数返回。 示例： import java.util.Scanner; public class ScannerDemo { public static void main(String[] args) { //创建对象 Scanner sc = new Scanner(System.in); //接收数据 int a = sc.nextInt(); //输出数据 System.out.println(a); } } 1.3.9. 3.9 标识符（理解） 标识符是用户编程时使用的名字，用于给类、方法、变量、常量等命名。 Java中标识符的组成规则： ​ 由字母、数字、下划线“_”、美元符号“$”组成，第一个字符不能是数字。 ​ 不能使用java中的关键字作为标识符。 ​ 标识符对大小写敏感（区分大小写）。 Java中标识符的命名约定： ​ 小驼峰式命名：变量名、方法名 ​ 首字母小写，从第二个单词开始每个单词的首字母大写。 ​ 大驼峰式命名：类名 ​ 每个单词的首字母都大写。 ​ 另外，标识符的命名最好可以做到见名知意 ​ 例如：username、studentNumber等。 Copyright © MISIN 2022 | 豫ICP备2021006345号-1 all right reserved，powered by Gitbook该文件修订时间： 2022-11-10 13:45:09 "},"1.JAVA基础/day02-Java基础语法.html":{"url":"1.JAVA基础/day02-Java基础语法.html","title":"day02-Java基础语法","keywords":"","body":"1. day02 - Java基础语法1.1. 1 类型转换1.1.1. 1.1 隐式转换(理解)1.1.2. 1.2 强制转换(理解)1.1.3. 1.3 类型转换案例(理解)1.2. 2. 运算符1.2.1. 2.1 算术运算符1.2.2. 2.2 自增自减运算符（理解）1.2.3. 2.3 赋值运算符（应用）1.2.4. 2.4 关系运算符（应用）1.2.5. 2.5 逻辑运算符（应用）1.2.6. 2.6 短路逻辑运算符（理解）1.2.7. 2.7 三元运算符（理解）1.2.8. 2.8 三元运算符案例(应用)1.3. 3. 流程控制语句1.3.1. 3.1 流程控制语句分类(了解)1.3.2. 3.2 顺序结构(了解)1.3.3. 3.3 分支结构之if语句1. day02 - Java基础语法 1.1. 1 类型转换 在Java中，一些数据类型之间是可以相互转换的。分为两种情况：自动类型转换和强制类型转换。 1.1.1. 1.1 隐式转换(理解) ​ 把一个表示数据范围小的数值或者变量赋值给另一个表示数据范围大的变量。这种转换方式是自动的，直接书写即可。例如： double num = 10; // 将int类型的10直接赋值给double类型 System.out.println(num); // 输出10.0 ​ 类型从小到大关系图： ​ 说明： 整数默认是int类型，byte、short和char类型数据参与运算均会自动转换为int类型。 byte b1 = 10; byte b2 = 20; byte b3 = b1 + b2; // 第三行代码会报错，b1和b2会自动转换为int类型，计算结果为int，int赋值给byte需要强制类型转换。 // 修改为: int num = b1 + b2; // 或者： byte b3 = (byte) (b1 + b2); boolean类型不能与其他基本数据类型相互转换。 1.1.2. 1.2 强制转换(理解) ​ 把一个表示数据范围大的数值或者变量赋值给另一个表示数据范围小的变量。 ​ 强制类型转换格式：目标数据类型 变量名 = (目标数据类型)值或者变量; ​ 例如： double num1 = 5.5; int num2 = (int) num1; // 将double类型的num1强制转换为int类型 System.out.println(num2); // 输出5（小数位直接舍弃） 1.1.3. 1.3 类型转换案例(理解) 案例代码： byte a = 3; byte b = 4; byte c = a + b; //错误。因为两个byte变量相加，会先提升为int类型 byte d = 3 + 4; //正确。常量优化机制 常量优化机制： ​ 在编译时，整数常量的计算会直接算出结果，并且会自动判断该结果是否在byte取值范围内， ​ 在：编译通过 ​ 不在：编译失败 1.2. 2. 运算符 1.2.1. 2.1 算术运算符 2.1.1 运算符和表达式（了解） 运算符：对常量或者变量进行操作的符号 表达式：用运算符把常量或者变量连接起来符合java语法的式子就可以称为表达式。 ​ 不同运算符连接的表达式体现的是不同类型的表达式。 举例说明： int a = 10; int b = 20; int c = a + b; +：是运算符，并且是算术运算符。 a + b：是表达式，由于+是算术运算符，所以这个表达式叫算术表达式。 2.1.2 算术运算符(应用) 符号 作用 说明 + 加 参看小学一年级 - 减 参看小学一年级 * 乘 参看小学二年级，与“×”相同 / 除 参看小学二年级，与“÷”相同 % 取余 获取的是两个数据做除法的余数 注意： /和%的区别：两个数据做除法，/取结果的商，%取结果的余数。 整数操作只能得到整数，要想得到小数，必须有浮点数参与运算。 int a = 10; int b = 3; System.out.println(a / b); // 输出结果3 System.out.println(a % b); // 输出结果1 2.1.3 字符的“+”操作（理解） char类型参与算术运算，使用的是计算机底层对应的十进制数值。需要我们记住三个字符对应的数值： 'a' -- 97 a-z是连续的，所以'b'对应的数值是98，'c'是99，依次递加 'A' -- 65 A-Z是连续的，所以'B'对应的数值是66，'C'是67，依次递加 '0' -- 48 0-9是连续的，所以'1'对应的数值是49，'2'是50，依次递加 // 可以通过使用字符与整数做算术运算，得出字符对应的数值是多少 char ch1 = 'a'; System.out.println(ch1 + 1); // 输出98，97 + 1 = 98 char ch2 = 'A'; System.out.println(ch2 + 1); // 输出66，65 + 1 = 66 char ch3 = '0'; System.out.println(ch3 + 1); // 输出49，48 + 1 = 49 算术表达式中包含不同的基本数据类型的值的时候，整个算术表达式的类型会自动进行提升。 提升规则： byte类型，short类型和char类型将被提升到int类型，不管是否有其他类型参与运算。 整个表达式的类型自动提升到与表达式中最高等级的操作数相同的类型 ​ 等级顺序：byte,short,char --> int --> long --> float --> double 例如： byte b1 = 10; byte b2 = 20; // byte b3 = b1 + b2; // 该行报错，因为byte类型参与算术运算会自动提示为int，int赋值给byte可能损失精度 int i3 = b1 + b2; // 应该使用int接收 byte b3 = (byte) (b1 + b2); // 或者将结果强制转换为byte类型 ------------------------------- int num1 = 10; double num2 = 20.0; double num3 = num1 + num2; // 使用double接收，因为num1会自动提升为double类型 2.1.4 字符串的“+”操作（理解） 当“+”操作中出现字符串时，这个”+”是字符串连接符，而不是算术运算。 System.out.println(\"itheima\"+ 666); // 输出：itheima666 在”+”操作中，如果出现了字符串，就是连接运算符，否则就是算术运算。当连续进行“+”操作时，从左到右逐个执行。 System.out.println(1 + 99 + \"年黑马\"); // 输出：100年黑马 System.out.println(1 + 2 + \"itheima\" + 3 + 4); // 输出：3itheima34 // 可以使用小括号改变运算的优先级 System.out.println(1 + 2 + \"itheima\" + (3 + 4)); // 输出：3itheima7 2.1.5 数值拆分（应用） 需求： ​ 键盘录入一个三位数，将其拆分为个位，十位，百位，打印在控制台 示例代码： import java.util.Scanner; public class Test { public static void main(String[] args) { // 1：使用Scanner键盘录入一个三位数 Scanner sc = new Scanner(System.in); System.out.println(\"请输入一个三位数\"); int num = sc.nextInt(); // 2：个位的计算：数值 % 10 int ge = num % 10; // 3：十位的计算：数值 / 10 % 10 int shi = num / 10 % 10; // 4：百位的计算：数值 / 100 int bai = num / 100; // 5：将个位, 十位, 百位拼接上正确的字符串, 打印即可 System.out.println(\"整数\"+num+\"个位为:\" + ge); System.out.println(\"整数\"+num+\"十位为:\" + shi); System.out.println(\"整数\"+num+\"百位为:\" + bai); } } 1.2.2. 2.2 自增自减运算符（理解） 符号 作用 说明 ++ 自增 变量的值加1 -- 自减 变量的值减1 注意事项： ​ ++和-- 既可以放在变量的后边，也可以放在变量的前边。 ​ 单独使用的时候， ++和-- 无论是放在变量的前边还是后边，结果是一样的。 ​ 参与操作的时候，如果放在变量的后边，先拿变量参与操作，后拿变量做++或者--。 ​ 参与操作的时候，如果放在变量的前边，先拿变量做++或者--，后拿变量参与操作。 ​ 最常见的用法：单独使用。 int i = 10; i++; // 单独使用 System.out.println(\"i:\" + i); // i:11 int j = 10; ++j; // 单独使用 System.out.println(\"j:\" + j); // j:11 int x = 10; int y = x++; // 赋值运算，++在后边，所以是使用x原来的值赋值给y，x本身自增1 System.out.println(\"x:\" + x + \", y:\" + y); // x:11，y:10 int m = 10; int n = ++m; // 赋值运算，++在前边，所以是使用m自增后的值赋值给n，m本身自增1 System.out.println(\"m:\" + m + \", m:\" + m); // m:11，m:11 练习： int x = 10; int y = x++ + x++ + x++; System.out.println(y); // y的值是多少？ /* 解析，三个表达式都是++在后，所以每次使用的都是自增前的值，但程序自左至右执行，所以第一次自增时，使用的是10进行计算，但第二次自增时，x的值已经自增到11了，所以第二次使用的是11，然后再次自增。。。 所以整个式子应该是：int y = 10 + 11 + 12; 输出结果为33。 */ 注意：通过此练习深刻理解自增和自减的规律，但实际开发中强烈建议不要写这样的代码！小心挨打！ 1.2.3. 2.3 赋值运算符（应用） 赋值运算符的作用是将一个表达式的值赋给左边，左边必须是可修改的，不能是常量。 符号 作用 说明 = 赋值 a=10，将10赋值给变量a += 加后赋值 a+=b，将a+b的值给a -= 减后赋值 a-=b，将a-b的值给a *= 乘后赋值 a*=b，将a×b的值给a /= 除后赋值 a/=b，将a÷b的商给a %= 取余后赋值 a%=b，将a÷b的余数给a 注意： 扩展的赋值运算符隐含了强制类型转换。 short s = 10; s = s + 10; // 此行代码报出，因为运算中s提升为int类型，运算结果int赋值给short可能损失精度 s += 10; // 此行代码没有问题，隐含了强制类型转换，相当于 s = (short) (s + 10); 1.2.4. 2.4 关系运算符（应用） 关系运算符有6种关系，分别为小于、小于等于、大于、等于、大于等于、不等于。 符号 说明 == a==b，判断a和b的值是否相等，成立为true，不成立为false != a!=b，判断a和b的值是否不相等，成立为true，不成立为false > a>b，判断a是否大于b，成立为true，不成立为false >= a>=b，判断a是否大于等于b，成立为true，不成立为false a a 注意事项： ​ 关系运算符的结果都是boolean类型，要么是true，要么是false。 ​ 千万不要把“==”误写成“=”，\"==\"是判断是否相等的关系，\"=\"是赋值。 int a = 10; int b = 20; System.out.println(a == b); // false System.out.println(a != b); // true System.out.println(a > b); // false System.out.println(a >= b); // false System.out.println(a b; System.out.println(flag); // 输出false 1.2.5. 2.5 逻辑运算符（应用） 逻辑运算符把各个运算的关系表达式连接起来组成一个复杂的逻辑表达式，以判断程序中的表达式是否成立，判断的结果是 true 或 false。 符号 作用 说明 & 逻辑与 a&b，a和b都是true，结果为true，否则为false \\ 逻辑或 a\\ b，a和b都是false，结果为false，否则为true ^ 逻辑异或 a^b，a和b结果不同为true，相同为false ! 逻辑非 !a，结果和a的结果正好相反 //定义变量 int i = 10; int j = 20; int k = 30; //& “与”，并且的关系，只要表达式中有一个值为false，结果即为false System.out.println((i > j) & (i > k)); //false & false,输出false System.out.println((i k)); //true & false,输出false System.out.println((i > j) & (i j) | (i > k)); //false | false,输出false System.out.println((i k)); //true | false,输出true System.out.println((i > j) | (i j) ^ (i > k)); //false ^ false,输出false System.out.println((i k)); //true ^ false,输出true System.out.println((i > j) ^ (i j)); //false System.out.println(!(i > j)); //!false，,输出true 1.2.6. 2.6 短路逻辑运算符（理解） 符号 作用 说明 && 短路与 作用和&相同，但是有短路效果 \\ \\ 短路或 作用和\\ 相同，但是有短路效果 在逻辑与运算中，只要有一个表达式的值为false，那么结果就可以判定为false了，没有必要将所有表达式的值都计算出来，短路与操作就有这样的效果，可以提高效率。同理在逻辑或运算中，一旦发现值为true，右边的表达式将不再参与运算。 逻辑与&，无论左边真假，右边都要执行。 短路与&&，如果左边为真，右边执行；如果左边为假，右边不执行。 逻辑或|，无论左边真假，右边都要执行。 短路或||，如果左边为假，右边执行；如果左边为真，右边不执行。 int x = 3; int y = 4; System.out.println((x++ > 4) & (y++ > 5)); // 两个表达都会运算 System.out.println(x); // 4 System.out.println(y); // 5 System.out.println((x++ > 4) && (y++ > 5)); // 左边已经可以确定结果为false，右边不参与运算 System.out.println(x); // 4 System.out.println(y); // 4 1.2.7. 2.7 三元运算符（理解） 三元运算符语法格式： 关系表达式 ? 表达式1 : 表达式2; 解释：问号前面的位置是判断的条件，判断结果为boolean型，为true时调用表达式1，为false时调用表达式2。其逻辑为：如果条件表达式成立或者满足则执行表达式1，否则执行第二个。 举例： int a = 10; int b = 20; int c = a > b ? a : b; // 判断 a>b 是否为真，如果为真取a的值，如果为假，取b的值 1.2.8. 2.8 三元运算符案例(应用) 需求： ​ 一座寺庙里住着三个和尚，已知他们的身高分别为150cm、210cm、165cm，请用程序实现获取这三个和尚的最高身高。 public class OperatorTest02 { public static void main(String[] args) { //1：定义三个变量用于保存和尚的身高，单位为cm，这里仅仅体现数值即可。 int height1 = 150; int height2 = 210; int height3 = 165; //2：用三元运算符获取前两个和尚的较高身高值，并用临时身高变量保存起来。 int tempHeight = height1 > height2 ? height1 : height2; //3：用三元运算符获取临时身高值和第三个和尚身高较高值，并用最大身高变量保存。 int maxHeight = tempHeight > height3 ? tempHeight : height3; //4：输出结果 System.out.println(\"maxHeight:\" + maxHeight); } } 1.3. 3. 流程控制语句 在一个程序执行的过程中，各条语句的执行顺序对程序的结果是有直接影响的。所以，我们必须清楚每条语句的执行流程。而且，很多时候要通过控制语句的执行顺序来实现我们想要的功能。 1.3.1. 3.1 流程控制语句分类(了解) ​ 顺序结构 ​ 分支结构(if, switch) ​ 循环结构(for, while, do…while) 1.3.2. 3.2 顺序结构(了解) 顺序结构是程序中最简单最基本的流程控制，没有特定的语法结构，按照代码的先后顺序，依次执行，程序中大多数的代码都是这样执行的。 顺序结构执行流程图： 1.3.3. 3.3 分支结构之if语句 3.3.1 if语句格式1（理解） 格式： if (关系表达式) { 语句体; } 执行流程： ①首先计算关系表达式的值 ②如果关系表达式的值为true就执行语句体 ③如果关系表达式的值为false就不执行语句体 ④继续执行后面的语句内容 示例： public class IfDemo { public static void main(String[] args) { System.out.println(\"开始\"); // 如果年龄大于18岁, 就可以上网吧 int age = 17; if(age >= 18){ // int a = 10; System.out.println(\"可以上网吧\"); } System.out.println(\"结束\"); } } 3.3.2 if语句格式2（理解） 格式： if (关系表达式) { 语句体1; } else { 语句体2; } 执行流程： ①首先计算关系表达式的值 ②如果关系表达式的值为true就执行语句体1 ③如果关系表达式的值为false就执行语句体2 ④继续执行后面的语句内容 示例：奇偶数 ​ 任意给出一个整数，请用程序实现判断该整数是奇数还是偶数，并在控制台输出该整数是奇数还是偶数。 public class Demo2If { public static void main(String[] args) { // 程序判断一个数, 是奇数还是偶数 int num = 9; if(num % 2 == 0){ System.out.println(\"偶数\"); }else{ System.out.println(\"奇数\"); } } } 3.3.3 if语句格式3（理解） 格式： if (关系表达式1) { 语句体1; } else if (关系表达式2) { 语句体2; } … else { 语句体n+1; } 执行流程： ①首先计算关系表达式1的值 ②如果值为true就执行语句体1；如果值为false就计算关系表达式2的值 ③如果值为true就执行语句体2；如果值为false就计算关系表达式3的值 ④… ⑤如果没有任何关系表达式为true，就执行语句体n+1。 示例： ​ 定义一个在0~100之间的变量a, 90~100优秀，80~89良好，70~79中等，60~69及格，0~59请努力加油！ public class Demo3If { public static void main(String[] args){ int score = 65; if(score >= 90 && score = 80 && score = 70 && score = 60 && score = 0 && score 3.3.4 if语句格式3案例（应用） 需求：小明快要期末考试了，小明爸爸对他说，会根据他不同的考试成绩，送他不同的礼物，假如你可以控制小明的得分，请用程序实现小明到底该获得什么样的礼物，并在控制台输出。 分析： ​ ①小明的考试成绩未知，可以使用键盘录入的方式获取值 ​ ②由于奖励种类较多，属于多种判断，采用if...else...if格式实现 ​ ③为每种判断设置对应的条件 ​ ④为每种判断设置对应的奖励 import java.util.Scanner; public class IfTest02 { public static void main(String[] args){ // 1. 使用Scanner录入考试成绩 Scanner sc = new Scanner(System.in); System.out.println(\"请输入您的成绩:\"); int score = sc.nextInt(); // 2. 判断成绩是否在合法范围内 0~100 if(score >=0 && score = 95 && score = 90 && score = 80 && score Copyright © MISIN 2022 | 豫ICP备2021006345号-1 all right reserved，powered by Gitbook该文件修订时间： 2022-11-10 13:07:18 "},"1.JAVA基础/day03 switch&循环语句.html":{"url":"1.JAVA基础/day03 switch&循环语句.html","title":"day03 switch&循环语句","keywords":"","body":"1.1. 1. switch语句1.1.1. 1.1 分支语句switch语句1.1.2. 1.2 switch案例-减肥计划1.1.3. 1.3 switch语句case穿透1.2. 2. for循环1.2.1. 2.1 循环语句-for循环1.2.2. 2.2 for循环案例-输出数据1-5和5-11.2.3. 2.3 for循环案例-求1-5数据和1.2.4. 2.4 for循环案例-求1-100偶数和1.2.5. 2.5 for循环案例-水仙花数1.2.6. 2.6 for循环案例-每行打印2个水仙花数(统计)1.3. 3. while循环1.3.1. 3.1 循环语句-while循环1.3.2. 3.2 while循环案例-珠穆朗玛峰1.4. 4. 循环细节1.4.1. 4.1 循环语句-dowhile循环1.4.2. 4.2 三种循环的区别1.4.3. 4.3 死循环1.4.4. 4.4 跳转控制语句1.5. 5. Random1.5.1. 5.1 Random产生随机数（掌握）1.5.2. 5.3 Random练习-猜数字（应用）1.1. 1. switch语句 1.1.1. 1.1 分支语句switch语句 格式 switch (表达式) { case 1: 语句体1; break; case 2: 语句体2; break; ... default: 语句体n+1; break; } 执行流程： 首先计算出表达式的值 其次，和case依次比较，一旦有对应的值，就会执行相应的语句，在执行的过程中，遇到break就会结 束。 最后，如果所有的case都和表达式的值不匹配，就会执行default语句体部分，然后程序结束掉。 1.1.2. 1.2 switch案例-减肥计划 需求：键盘录入星期数，显示今天的减肥活动 周一：跑步 周二：游泳 周三：慢走 周四：动感单车 周五：拳击 周六：爬山 周日：好好吃一顿 示例代码： public static void main(String[] args){ // 1. 键盘录入星期数据，使用变量接收 Scanner sc = new Scanner(System.in); System.out.println(\"请输入\"); int week = sc.nextInt(); // 2. 多情况判断，采用switch语句实现 switch(week){ // 3. 在不同的case中，输出对应的减肥计划 case 1: System.out.println(\"跑步\"); break; case 2: System.out.println(\"游泳\"); break; case 3: System.out.println(\"慢走\"); break; case 4: System.out.println(\"动感单车\"); break; case 5: System.out.println(\"拳击\"); break; case 6: System.out.println(\"爬山\"); break; case 7: System.out.println(\"好好吃一顿\"); break; default: System.out.println(\"您的输入有误\"); break; } } } 1.1.3. 1.3 switch语句case穿透 概述 : 如果switch语句中,case省略了break语句, 就会开始case穿透 需求 : 键盘录入星期数，输出工作日、休息日 (1-5)工作日，(6-7)休息日 示例代码： /* case穿透是如何产生的? 如果switch语句中,case省略了break语句, 就会开始case穿透. 现象： 当开始case穿透，后续的case就不会具有匹配效果，内部的语句都会执行 直到看见break，或者将整体switch语句执行完毕，才会结束。 */ public static void main(String[] args){ Scanner sc = new Scanner(System.in); System.out.println(\"请输入星期数:\"); int week = sc.nextInt(); switch(week){ case 1: case 2: case 3: case 4: case 5: System.out.println(\"工作日\"); break; case 6: case 7: System.out.println(\"休息日\"); break; default: System.out.println(\"您的输入有误\"); break; } } } 1.2. 2. for循环 1.2.1. 2.1 循环语句-for循环 循环： 循环语句可以在满足循环条件的情况下，反复执行某一段代码，这段被重复执行的代码被称为循环体语句，当反复 执行这个循环体时，需要在合适的时候把循环判断条件修改为false，从而结束循环，否则循环将一直执行下去，形 成死循环。 for循环格式： for (初始化语句;条件判断语句;条件控制语句) { 循环体语句; } 格式解释： 初始化语句： 用于表示循环开启时的起始状态，简单说就是循环开始的时候什么样 条件判断语句：用于表示循环反复执行的条件，简单说就是判断循环是否能一直执行下去 循环体语句： 用于表示循环反复执行的内容，简单说就是循环反复执行的事情 条件控制语句：用于表示循环执行中每次变化的内容，简单说就是控制循环是否能执行下去 执行流程： ①执行初始化语句 ②执行条件判断语句，看其结果是true还是false ​ 如果是false，循环结束 ​ 如果是true，继续执行 ③执行循环体语句 ④执行条件控制语句 ⑤回到②继续 1.2.2. 2.2 for循环案例-输出数据1-5和5-1 需求：在控制台输出1-5和5-1的数据 示例代码： public class ForTest01 { public static void main(String[] args) { //需求：输出数据1-5 for(int i=1; i=1; i--) { System.out.println(i); } } } 1.2.3. 2.3 for循环案例-求1-5数据和 需求：求1-5之间的数据和，并把求和结果在控制台输出 示例代码： public class ForTest02 { public static void main(String[] args) { //求和的最终结果必须保存起来，需要定义一个变量，用于保存求和的结果，初始值为0 int sum = 0; //从1开始到5结束的数据，使用循环结构完成 for(int i=1; i 本题要点： 今后遇到的需求中，如果带有求和二字，请立即联想到求和变量 求和变量的定义位置，必须在循环外部，如果在循环内部则计算出的数据将是错误的 1.2.4. 2.4 for循环案例-求1-100偶数和 需求：求1-100之间的偶数和，并把求和结果在控制台输出 } 示例代码： public class ForTest03 { public static void main(String[] args) { //求和的最终结果必须保存起来，需要定义一个变量，用于保存求和的结果，初始值为0 int sum = 0; //对1-100的数据求和与1-5的数据求和几乎完全一样，仅仅是结束条件不同 for(int i=1; i 1.2.5. 2.5 for循环案例-水仙花数 需求：在控制台输出所有的“水仙花数” 解释：什么是水仙花数？ 水仙花数，指的是一个三位数，个位、十位、百位的数字立方和等于原数 例如153 3*3*3 + 5*5*5 + 1*1*1 = 153 思路： 获取所有的三位数，准备进行筛选，最小的三位数为100，最大的三位数为999，使用for循环获取 获取每一个三位数的个位，十位，百位，做if语句判断是否是水仙花数 示例代码 public class ForTest04 { public static void main(String[] args) { //输出所有的水仙花数必然要使用到循环，遍历所有的三位数，三位数从100开始，到999结束 for(int i=100; i 1.2.6. 2.6 for循环案例-每行打印2个水仙花数(统计) 需求：在控制台输出所有的“水仙花数”，要求每行打印2个 示例代码： public class Demo6For { /* 需求：在控制台输出所有的“水仙花数”，要求每行打印2个 System.out.print (打印内容); 打印后不换行 System.out.println(打印内容); 打印后换行 分析: 1. 定义变量count，用于保存“打印过”的数量，初始值为0 2. 在判定和打印水仙花数的过程中，拼接空格, 但不换行，并在打印后让count变量+1，记录打印过的数量 3. 在每一次count变量+1后，判断是否到达了2的倍数，是的话，换行。 */ public static void main(String[] args){ // 1. 定义变量count，用于保存“打印过”的数量，初始值为0 int count = 0; for(int i = 100; i 本题要点： 今后如果需求带有统计xxx，请先想到计数器变量 计数器变量定义的位置，必须在循环外部 1.3. 3. while循环 1.3.1. 3.1 循环语句-while循环 while循环完整格式： 初始化语句; while (条件判断语句) { 循环体语句; 条件控制语句; } while循环执行流程： ①执行初始化语句 ②执行条件判断语句，看其结果是true还是false ​ 如果是false，循环结束 ​ 如果是true，继续执行 ③执行循环体语句 ④执行条件控制语句 ⑤回到②继续 示例代码： public class WhileDemo { public static void main(String[] args) { //需求：在控制台输出5次\"HelloWorld\" //for循环实现 for(int i=1; i 1.3.2. 3.2 while循环案例-珠穆朗玛峰 需求：世界最高山峰是珠穆朗玛峰(8844.43米=8844430毫米)，假如我有一张足够大的纸，它的厚度是0.1毫米。请问，我折叠多少次，可以折成珠穆朗玛峰的高度? 示例代码： public class WhileTest { public static void main(String[] args) { //定义一个计数器，初始值为0 int count = 0; //定义纸张厚度 double paper = 0.1; //定义珠穆朗玛峰的高度 int zf = 8844430; //因为要反复折叠，所以要使用循环，但是不知道折叠多少次，这种情况下更适合使用while循环 //折叠的过程中当纸张厚度大于珠峰就停止了，因此继续执行的要求是纸张厚度小于珠峰高度 while(paper 1.4. 4. 循环细节 1.4.1. 4.1 循环语句-dowhile循环 完整格式： 初始化语句; do { 循环体语句; 条件控制语句; }while(条件判断语句); 执行流程： ① 执行初始化语句 ② 执行循环体语句 ③ 执行条件控制语句 ④ 执行条件判断语句，看其结果是true还是false 如果是false，循环结束 如果是true，继续执行 ⑤ 回到②继续 示例代码： public class DoWhileDemo { public static void main(String[] args) { //需求：在控制台输出5次\"HelloWorld\" //for循环实现 for(int i=1; i 1.4.2. 4.2 三种循环的区别 三种循环的区别 for循环和while循环先判断条件是否成立，然后决定是否执行循环体（先判断后执行） do...while循环先执行一次循环体，然后判断条件是否成立，是否继续执行循环体（先执行后判断） for循环和while的区别 条件控制语句所控制的自增变量，因为归属for循环的语法结构中，在for循环结束后，就不能再次被访问到了 条件控制语句所控制的自增变量，对于while循环来说不归属其语法结构中，在while循环结束后，该变量还可以继续使用 死循环（无限循环）的三种格式 for(;;){} while(true){} do {} while(true); 1.4.3. 4.3 死循环 死循环格式 for死循环格式 : for(;;){ } while死循环格式 : while(true){ } do..while死循环格式 : do{ }while(true); 死循环案例 /* 问题: 死循环有应用场景吗? 例如: 键盘录入一个1-100之间的整数 顾虑: 键盘录入是用户操作的, 用户就可能会出现一些误操作的现象 */ public static void main(String[] args) { /* for(;;){ System.out.println(\"我停不下来了~\"); } */ /* while(true){ System.out.println(\"我停不下来了~\"); } */ do{ System.out.println(\"我停不下来了~\"); }while(true); System.out.println(\"看看我能被执行吗?~\"); // 无法访问的语句 } } 1.4.4. 4.4 跳转控制语句 跳转控制语句（break） 跳出循环，结束循环 跳转控制语句（continue） 跳过本次循环，继续下次循环 注意： continue只能在循环中进行使用！ public class Demo1Continue { /* continue : 跳过某次循环体内容的执行 注意：使用是基于条件控制, 在循环内部使用. 需求: 模拟电梯上行的过程 1-24层, 4层不停. */ public static void main(String[] args){ for(int i = 1; i public class Demo2Break { /* break : 终止循环体内容的执行 注意：使用是基于条件控制的 break语句只能在循环和switch中进行使用. 需求: 模拟20岁工作到80岁, 60岁退休. */ public static void main(String[] args){ for(int i = 20; i import java.util.Scanner; public class Test { /* 需求：程序运行后，用户可多次查询星期对应的减肥计划，直到输入0，程序结束 步骤: 1. 不明确用户操作几次, 使用死循环包裹业务逻辑 2. 匹配到0的时候，使用break结束循环死循环 */ public static void main (String[] args){ lo:while(true){ System.out.println(\"请输入您要查看的星期数:\"); System.out.println(\"(如无需继续查看,请输入0退出程序)\"); // 1. 键盘录入星期数据，使用变量接收 Scanner sc = new Scanner(System.in); int week = sc.nextInt(); // 2. 多情况判断，采用switch语句实现 switch(week){ // 3. 在不同的case中，输出对应的减肥计划 case 0: System.out.println(\"感谢您的使用\"); break lo; case 1: System.out.println(\"跑步\"); break; case 2: System.out.println(\"游泳\"); break; case 3: System.out.println(\"慢走\"); break; case 4: System.out.println(\"动感单车\"); break; case 5: System.out.println(\"拳击\"); break; case 6: System.out.println(\"爬山\"); break; case 7: System.out.println(\"好好吃一顿\"); break; default: System.out.println(\"您的输入有误\"); break; } } } } 1.5. 5. Random 1.5.1. 5.1 Random产生随机数（掌握） 概述： Random类似Scanner，也是Java提供好的API，内部提供了产生随机数的功能 API后续课程详细讲解，现在可以简单理解为Java已经写好的代码 使用步骤： 导入包 import java.util.Random; 创建对象 Random r = new Random(); 产生随机数 int num = r.nextInt(10); 解释： 10代表的是一个范围，如果括号写10，产生的随机数就是0-9，括号写20，参数的随机数则是0-19 示例代码： import java.util.Random; public class Demo1Random { /* Random : 产生随机数 1. 导包 : import java.util.Random; 导包的动作必须出现在类定义的上面 2. 创建对象 : Random r = new Random(); 上面这个格式里面，r 是变量名，可以变，其他的都不允许变 3. 获取随机数 : int number = r.nextInt(10); //获取数据的范围：[0,10) 包括0,不包括10 上面这个格式里面，number是变量名，可以变，数字10可以变。其他的都不允许变 需求: 产生随机数1-10之间的 */ public static void main(String[] args){ // 2. 创建对象 Random r = new Random(); for(int i = 1; i 1.5.2. 5.3 Random练习-猜数字（应用） 需求： 程序自动生成一个1-100之间的数字，使用程序实现猜出这个数字是多少？ 当猜错的时候根据不同情况给出相应的提示 A. 如果猜的数字比真实数字大，提示你猜的数据大了 B. 如果猜的数字比真实数字小，提示你猜的数据小了 C. 如果猜的数字与真实数字相等，提示恭喜你猜中了 示例代码： import java.util.Scanner; import java.util.Random; public class Test { /* 需求：程序自动生成一个1-100之间的数字，使用程序实现猜出这个数字是多少？ 当猜错的时候根据不同情况给出相应的提示 如果猜的数字比真实数字大，提示你猜的数据大了 如果猜的数字比真实数字小，提示你猜的数据小了 如果猜的数字与真实数字相等，提示恭喜你猜中了 1. 准备Random和Scanner对象, 分别用于产生随机数和键盘录入 2. 使用Random产生一个1-100之间的数, 作为要猜的数 3. 键盘录入用户猜的的数据 4. 使用录入的数据(用户猜的数据)和随机数(要猜的数据)进行比较, 并给出提示 5. 以上内容需要多次进行, 但无法预估用户输入几次可以猜测正确, 使用while(true)死循环包裹 6. 猜对之后, break结束. */ public static void main(String[] args){ // 1. 准备Random和Scanner对象, 分别用于产生随机数和键盘录入 Random r = new Random(); Scanner sc = new Scanner(System.in); // 2. 使用Random产生一个1-100之间的数, 作为要猜的数 int randomNum = r.nextInt(100) + 1; // 5. 以上内容需要多次进行, 但无法预估用户输入几次可以猜测正确, 使用while(true)死循环包裹 while(true){ // 3. 键盘录入用户猜的的数据 System.out.println(\"请输入您猜的数据:\"); int num = sc.nextInt(); // 4. 使用录入的数据(用户猜的数据)和随机数(要猜的数据)进行比较, 并给出提示 if(num > randomNum){ System.out.println(\"猜大了\"); }else if(num Copyright © MISIN 2022 | 豫ICP备2021006345号-1 all right reserved，powered by Gitbook该文件修订时间： 2020-06-15 17:53:24 "},"1.JAVA基础/day04 IDEA&数组.html":{"url":"1.JAVA基础/day04 IDEA&数组.html","title":"day04 IDEA&数组","keywords":"","body":"1.1. 第一部分 : IDEA开发工具1.2. 1.数组1.2.1. 1.1 数组介绍1.2.2. 1.2 数组的定义格式1.2.3. 1.3 数组的动态初始化1.2.4. 1.4 数组元素访问1.2.5. 1.5 内存分配1.2.6. 1.6 Java内存分配-一个数组内存图1.2.7. 1.7 两个数组内存图1.2.8. 1.8 多个数组指向相同内存图1.2.9. 1.9 数组的静态初始化1.2.10. 1.10 数组操作的两个常见问题1.2.11. 1.11 数组遍历1.2.12. 1.12 数组获取最大值1.2.13. 1.13 数组元素求和1.2.14. 1.14 数组基本查找【应用】1.2.15. 1.15 评委打分【应用】1.1. 第一部分 : IDEA开发工具 参见 ：IEDA的安装请参考文件夹PPT中的 04_IDEA.ppt 1.2. 1.数组 1.2.1. 1.1 数组介绍 ​ 数组就是存储数据长度固定的容器，存储多个数据的数据类型要一致。 1.2.2. 1.2 数组的定义格式 1.2.1 第一种格式 ​ 数据类型[] 数组名 ​ 示例： int[] arr; double[] arr; char[] arr; 1.2.2 第二种格式 ​ 数据类型 数组名[] ​ 示例： int arr[]; double arr[]; char arr[]; 1.2.3. 1.3 数组的动态初始化 1.3.1 什么是动态初始化 ​ 数组动态初始化就是只给定数组的长度，由系统给出默认初始化值 1.3.2 动态初始化格式 数据类型[] 数组名 = new 数据类型[数组长度]; int[] arr = new int[3]; 1.3.3 动态初始化格式详解 等号左边： int:数组的数据类型 []:代表这是一个数组 arr:代表数组的名称 等号右边： new:为数组开辟内存空间 int:数组的数据类型 []:代表这是一个数组 5:代表数组的长度 代码 : package com.itheima.array; public class Demo2Array { /* 数组的动态初始化: 在初始化的时候, 需要手动指定数组的长度, 系统会为数组容器分配初始值. 动态初始化格式: 数据类型[] 数组名 = new 数据类型[数组的长度]; 注意: 打印数组变量的时候, 会打印出数组的内存地址 [I@10f87f48 : @ : 分隔符 [ : 当前的空间是一个数组类型 I : 当前数组容器中所存储的数据类型 10f87f48 : 十六进制内存地址 0 1 2 3 4 5 6 7 8 9 a b c d e f */ public static void main(String[] args) { // 数据类型[] 数组名 = new 数据类型[数组的长度]; // 通过new关键字创建了一个int类型的数组容器, 该容器可以存储5个int类型的整数, 该容器被arr数组变量所记录 int[] arr = new int[5]; // [I@10f87f48 System.out.println(arr); byte[] bArr = new byte[3]; // [B@b4c966a System.out.println(bArr); } } 1.2.4. 1.4 数组元素访问 1.4.1 什么是索引 ​ 每一个存储到数组的元素，都会自动的拥有一个编号，从0开始。 ​ 这个自动编号称为数组索引(index)，可以通过数组的索引访问到数组中的元素。 1.4.2访问数组元素格式 数组名[索引]; 1.4.3示例代码 package com.itheima.array; public class Demo3ArrayIndex { /* 数组动态初始化: 初始化的时候, 手动指定数组长度, 系统会为数组容器分配初始值. 数组的元素访问格式: 数组名[索引] 索引: 数组中数据的编号方式, 编号从0开始 作用: 访问数组容器中的空间位置 注意: 数组在创建完毕后, 即使没有赋值, 也可以取出, 但取出的元素都是默认初始化值. */ public static void main(String[] args) { int[] arr = new int[3]; // 0 1 2 System.out.println(arr); // 数组的内存地址 [I@10f87f48 // 数组名[索引] 访问数组容器中的空间位置 System.out.println(arr[0]); // 0 系统自动分配的默认初始化值 System.out.println(arr[1]); System.out.println(arr[2]); System.out.println(“—————“); // 数组名[索引] arr[0] = 11; arr[1] = 22; arr[2] = 33; System.out.println(arr[0]); System.out.println(arr[1]); System.out.println(arr[2]); } } 1.2.5. 1.5 内存分配 1.5.1 内存概述 ​ 内存是计算机中的重要原件，临时存储区域，作用是运行程序。 ​ 我们编写的程序是存放在硬盘中的，在硬盘中的程序是不会运行的。 ​ 必须放进内存中才能运行，运行完毕后会清空内存。 ​ Java虚拟机要运行程序，必须要对内存进行空间的分配和管理。 1.5.2 java中的内存分配 目前我们只需要记住两个内存，分别是：栈内存和堆内存 | 区域名称 | 作用 | | -——— | -——————————————————— | | 寄存器 | 给CPU使用，和我们开发无关。 | | 本地方法栈 | JVM在使用操作系统功能的时候使用，和我们开发无关。 | | 方法区 | 存储可以运行的class文件。 | | 堆内存 | 存储对象或者数组，new来创建的，都存储在堆内存。 | | 方法栈 | 方法运行时使用的内存，比如main方法运行，进入方法栈中执行。 | 1.2.6. 1.6 Java内存分配-一个数组内存图 1.2.7. 1.7 两个数组内存图 1.2.8. 1.8 多个数组指向相同内存图 1.2.9. 1.9 数组的静态初始化 1.9.1 什么是静态初始化 ​ 在创建数组时，直接将元素确定 1.9.2 静态初始化格式 完整版格式 数据类型[] 数组名 = new 数据类型[]{元素1,元素2,...}; 简化版格式 数据类型[] 数组名 = {元素1,元素2,...}; 1.9.3示例代码 package com.itheima.array2; public class Demo1Array { /* 数组静态初始化 : 初始化时指定每个数组元素的初始值，由系统决定数组长度 完整格式: 数据类型[] 数组名 = new 数据类型[]{数据1,数据2,数据3...}; 简化格式: 数据类型[] 数组名 = {数据1,数据2,数据3...}; */ public static void main(String[] args) { // 数据类型[] 数组名 = new 数据类型[]{数据1,数据2,数据3...}; int[] arr = new int[]{11,22,33}; System.out.println(arr[0]); System.out.println(arr[1]); System.out.println(arr[2]); // 数据类型[] 数组名 = {数据1,数据2,数据3...}; int[] arr2 = {44,55,66}; System.out.println(arr2); System.out.println(arr2[0]); System.out.println(arr2[1]); System.out.println(arr2[2]); } } 1.2.10. 1.10 数组操作的两个常见问题 1.10.1 索引越界异常 出现原因 public class ArrayDemo { public static void main(String[] args) { int[] arr = new int[3]; System.out.println(arr[3]); } } 数组长度为3，索引范围是0~2，但是我们却访问了一个3的索引。 程序运行后，将会抛出ArrayIndexOutOfBoundsException 数组越界异常。在开发中，数组的越界异常是不能出现的，一旦出现了，就必须要修改我们编写的代码。 解决方案 将错误的索引修改为正确的索引范围即可！ 1.10.2 空指针异常 出现原因 public class ArrayDemo { public static void main(String[] args) { int[] arr = new int[3]; //把null赋值给数组 arr = null; System.out.println(arr[0]); } } arr = null 这行代码，意味着变量arr将不会在保存数组的内存地址，也就不允许再操作数组了，因此运行的时候会抛出 NullPointerException 空指针异常。在开发中，空指针异常是不能出现的，一旦出现了，就必须要修改我们编写的代码。 解决方案 给数组一个真正的堆内存空间引用即可！ 1.2.11. 1.11 数组遍历 数组遍历：就是将数组中的每个元素分别获取出来，就是遍历。遍历也是数组操作中的基石。 public class ArrayTest01 { public static void main(String[] args) { int[] arr = { 1, 2, 3, 4, 5 }; System.out.println(arr[0]); System.out.println(arr[1]); System.out.println(arr[2]); System.out.println(arr[3]); System.out.println(arr[4]); } } 以上代码是可以将数组中每个元素全部遍历出来，但是如果数组元素非常多，这种写法肯定不行，因此我们需要改造成循环的写法。数组的索引是 0 到 lenght-1 ，可以作为循环的条件出现。 public class ArrayTest01 { public static void main(String[] args) { //定义数组 int[] arr = {11, 22, 33, 44, 55}; //使用通用的遍历格式 for(int x=0; x 1.2.12. 1.12 数组获取最大值 最大值获取：从数组的所有元素中找出最大值。 实现思路： 定义变量，保存数组0索引上的元素 遍历数组，获取出数组中的每个元素 将遍历到的元素和保存数组0索引上值的变量进行比较 如果数组元素的值大于了变量的值，变量记录住新的值 数组循环遍历结束，变量保存的就是数组中的最大值 代码实现： package com.itheima.test; import java.util.Scanner; public class Test2Array { /* 需求: 从数组中查找最大值 int[] arr = {12,45,98,73,60}; 实现步骤: 1. 假设数组中的第一个元素为最大值 2. 遍历数组, 获取每一个元素, 准备进行比较 3. 如果比较的过程中, 出现了比max更大的, 让max记录更大的值 4. 循环结束后, 打印最大值. */ public static void main(String[] args) { int[] arr = {12,45,98,73,60}; // 1. 假设数组中的第一个元素为最大值 int max = arr[0]; // 2. 遍历数组, 获取每一个元素, 准备进行比较 for(int i = 1; i max){ max = arr[i]; } } // 4. 循环结束后, 打印最大值. System.out.println(\"max:\" + max); } } 1.2.13. 1.13 数组元素求和 需求：键盘录入5个整数，存储到数组中，并对数组求和 思路： 1.创建键盘录入对象，准备键盘录入 2.定义一个求和变量，准备记录累加后的结果 3.动态初始化一个长度为5的int数组，准备存储键盘录入的数值 4.将键盘录入的数值存储到数组中 5.遍历数组，取出每一个元素，并求和 6.输出总和 代码实现： package com.itheima.test; import java.util.Scanner; public class Test3Array { /* 需求：键盘录入5个整数，存储到数组中，并对数组求和 思路： 1.创建键盘录入对象，准备键盘录入 2.定义一个求和变量，准备记录累加后的结果 3.动态初始化一个长度为5的int数组，准备存储键盘录入的数值 4.将键盘录入的数值存储到数组中 5.遍历数组，取出每一个元素，并求和 6.输出总和 */ public static void main(String[] args) { // 1.创建键盘录入对象，准备键盘录入 Scanner sc = new Scanner(System.in); // 2.定义一个求和变量，准备记录累加后的结果 int sum = 0; // 3.动态初始化一个长度为5的int数组，准备存储键盘录入的数值 int[] arr = new int[5]; // 4.将键盘录入的数值存储到数组中 for(int i = 0; i 1.2.14. 1.14 数组基本查找【应用】 需求： 已知一个数组 arr = {19, 28, 37, 46, 50}; 键盘录入一个数据，查找该数据在数组中的索引，并在控 制台输出找到的索引值。 思路： 1.定义一个数组，用静态初始化完成数组元素的初始化 2.键盘录入要查找的数据，用一个变量接收 3.定义一个索引变量，初始值为-1 4.遍历数组，获取到数组中的每一个元素 5.拿键盘录入的数据和数组中的每一个元素进行比较，如果值相同，就把该值对应的索引赋值给索引变量，并结束循环 6.输出索引变量 代码实现： public static void main(String[] args) { // 1.定义一个数组，用静态初始化完成数组元素的初始化 int[] arr = {19, 28, 37, 46, 50}; // 2.键盘录入要查找的数据，用一个变量接收 Scanner sc = new Scanner(System.in); System.out.println(\"请输入您要查找的元素:\"); int num = sc.nextInt(); // 3.定义一个索引变量，初始值为-1 // 假设要查找的数据, 在数组中就是不存在的 int index = -1; // 4.遍历数组，获取到数组中的每一个元素 for (int i = 0; i 1.2.15. 1.15 评委打分【应用】 需求：在编程竞赛中，有6个评委为参赛的选手打分，分数为0-100的整数分。 选手的最后得分为：去掉一个最高分和一个最低分后 的4个评委平均值 (不考虑小数部分)。 思路： 1.定义一个数组，用动态初始化完成数组元素的初始化，长度为6 2.键盘录入评委分数 3.由于是6个评委打分，所以，接收评委分数的操作，用循环 4.求出数组最大值 5.求出数组最小值 6.求出数组总和 7.按照计算规则进行计算得到平均分 8.输出平均分 代码实现： public static void main(String[] args) { // 1.定义一个数组，用动态初始化完成数组元素的初始化，长度为6 int[] arr = new int[6]; // 2.键盘录入评委分数 Scanner sc = new Scanner(System.in); // 3.由于是6个评委打分，所以，接收评委分数的操作，用循环 for (int i = 0; i = 0 && score arr[i]){ min = arr[i]; } } // 6.求出数组总和 int sum = 0; for (int i = 0; i Copyright © MISIN 2022 | 豫ICP备2021006345号-1 all right reserved，powered by Gitbook该文件修订时间： 2022-11-10 13:44:31 "},"1.JAVA基础/day05 方法.html":{"url":"1.JAVA基础/day05 方法.html","title":"day05 方法","keywords":"","body":"1.1. 1. 方法概述1.1.1. 1.1 方法的概念1.2. 2. 方法的定义和调用1.2.1. 2.1 无参数方法定义和调用1.2.2. 2.2 方法的调用过程1.2.3. 2.3 方法练习-奇偶数判断1.3. 3. 带参数方法的定义和调用1.3.1. 3.1 带参数方法定义和调用1.3.2. 3.2 形参和实参1.3.3. 3.3 带参数方法的练习-打印n-m之间所有的奇数1.4. 4. 带返回值方法的定义和调用1.4.1. 4.1 带返回值方法定义和调用（掌握）1.4.2. 4.2 带返回值方法的练习-求两个数的最大值(应用)1.5. 5. 方法的注意事项1.5.1. 5.1 方法的通用格式（掌握）1.5.2. 5.2 方法的注意事项1.6. 6. 方法重载1.6.1. 6.1 方法重载1.6.2. 6.2 方法重载练习1.7. 7. 方法的参数传递1.7.1. 7.1 方法参数传递基本类型（理解）1.7.2. 7.3 数组遍历1.7.3. 7.5 方法同时获取数组最大值和最小值1.1. 1. 方法概述 1.1.1. 1.1 方法的概念 ​ 方法（method）是将具有独立功能的代码块组织成为一个整体，使其具有特殊功能的代码集 注意： 方法必须先创建才可以使用，该过程成为方法定义 方法创建后并不是直接可以运行的，需要手动使用后，才执行，该过程成为方法调用 1.2. 2. 方法的定义和调用 1.2.1. 2.1 无参数方法定义和调用 定义格式： public static void 方法名 ( ) { // 方法体; } 范例： public static void method ( ) { // 方法体; } 调用格式： 方法名(); 范例： method(); 注意： ​ 方法必须先定义，后调用，否则程序将报错 1.2.2. 2.2 方法的调用过程 总结：每个方法在被调用执行的时候，都会进入栈内存，并且拥有自己独立的内存空间，方法内部代码调用完毕之后，会从栈内存中弹栈消失。 1.2.3. 2.3 方法练习-奇偶数判断 需求：判断一个数是奇数还是偶数 代码： public class Demo1Method { /* 带参数方法的定义格式: public static void 方法名 ( 参数 ) { … … } public static void 方法名 ( 数据类型 变量名 ) { … … } 带参数方法的调用格式: 方法名 ( 参数 ) ; 方法名 ( 变量名/常量值 ) ; tips: 参数可以是一个, 也可以是多个. 需求: 判断一个数是奇数还是偶数 */ public static void main(String[] args) { isEvenNumber(10); } public static void isEvenNumber(int num){ if(num % 2 == 0){ System.out.println(\"偶数\"); }else{ System.out.println(\"奇数\"); } } } 1.3. 3. 带参数方法的定义和调用 1.3.1. 3.1 带参数方法定义和调用 定义格式： 参数：由数据类型和变量名组成 - 数据类型 变量名 参数范例：int a public static void 方法名 (参数1) { 方法体; } public static void 方法名 (参数1, 参数2, 参数3...) { 方法体; } 范例： public static void isEvenNumber(int number){ ... } public static void getMax(int num1, int num2){ ... } 注意： 方法定义时，参数中的数据类型与变量名都不能缺少，缺少任意一个程序将报错 方法定义时，多个参数之间使用逗号( ，)分隔 调用格式： 方法名(参数)； 方法名(参数1,参数2); 范例： isEvenNumber(10); getMax(10,20); 方法调用时，参数的数量与类型必须与方法定义中的设置相匹配，否则程序将报错 1.3.2. 3.2 形参和实参 形参：方法定义中的参数 ​ 等同于变量定义格式，例如：int number 实参：方法调用中的参数 ​ 等同于使用变量或常量，例如： 10 number 1.3.3. 3.3 带参数方法的练习-打印n-m之间所有的奇数 需求：设计一个方法（print） 用于打印 n 到 m 之间所有的奇数 思路： ​ 1：定义方法，名称为print 2：为方法添加两个int类型的形参，准备接受调用者传递过来的实参 3：方法中设计for循环，循环从n开始，到m结束 4：循环中加入if判断，是奇数，则打印 5：main方法中调用print方法，传入两个实际参数 代码： package com.itheima.method2; public class Demo2Method { public static void main(String[] args) { // 5：main方法中调用print方法，传入两个实际参数 print(20,10); } //1：定义方法，名称为print // 2：为方法添加两个int类型的形参，准备接受调用者传递过来的实参 public static void print(int n, int m){ System.out.println(n + \"到\" + m + \"之间的奇数为:\"); // 3：方法中设计for循环，循环从n开始，到m结束 for(int i = 20; i 1.4. 4. 带返回值方法的定义和调用 1.4.1. 4.1 带返回值方法定义和调用（掌握） 定义格式 public static 数据类型 方法名 ( 参数 ) { return 数据 ; } 范例 public static boolean isEvenNumber( int number ) { return true ; } public static int getMax( int a, int b ) { return 100 ; } 注意： 方法定义时return后面的返回值与方法定义上的数据类型要匹配，否则程序将报错 调用格式 方法名 ( 参数 ) ; 数据类型 变量名 = 方法名 ( 参数 ) ; 范例 isEvenNumber ( 5 ) ; boolean flag = isEvenNumber ( 5 ); 注意： 方法的返回值通常会使用变量接收，否则该返回值将无意义 1.4.2. 4.2 带返回值方法的练习-求两个数的最大值(应用) 需求：设计一个方法可以获取两个数的较大值，数据来自于参数 思路： 定义一个方法，声明两个形参接收计算的数值，求出结果并返回 使用 if 语句 得出 a 和 b 之间的最大值，根据情况return具体结果 在main()方法中调用定义好的方法并使用 【 变量保存 】 代码： /* 需求：设计一个方法可以获取两个数的较大值，数据来自于参数 1. 定义一个方法，声明两个形参接收计算的数值，求出结果并返回 2. 使用 if 语句 得出 a 和 b 之间的最大值，根据情况return具体结果 3. 在main()方法中调用定义好的方法并使用 【 变量保存 】 */ public static void main(String[] args) { // 3. 在main()方法中调用定义好的方法并使用 【 变量保存 】 System.out.println(getMax(10,20)); // 输出调用 int result = getMax(10,20); System.out.println(result); for(int i = 1; i b){ return a; }else{ return b; } } } 1.5. 5. 方法的注意事项 1.5.1. 5.1 方法的通用格式（掌握） 格式： public static 返回值类型 方法名(参数) { 方法体; return 数据 ; } 解释： public static 修饰符，目前先记住这个格式 返回值类型 方法操作完毕之后返回的数据的数据类型 ​ 如果方法操作完毕，没有数据返回，这里写void，而且方法体中一般不写return 方法名 调用方法时候使用的标识 参数 由数据类型和变量名组成，多个参数之间用逗号隔开 方法体 完成功能的代码块 return 如果方法操作完毕，有数据返回，用于把数据返回给调用者 定义方法时，要做到两个明确 明确返回值类型：主要是明确方法操作完毕之后是否有数据返回，如果没有，写void；如果有，写对应的数据类型 明确参数：主要是明确参数的类型和数量 调用方法时的注意： void类型的方法，直接调用即可 非void类型的方法，推荐用变量接收调用 1.5.2. 5.2 方法的注意事项 方法不能嵌套定义 示例代码： public class MethodDemo { public static void main(String[] args) { } public static void methodOne() { public static void methodTwo() { // 这里会引发编译错误!!! } } } void表示无返回值，可以省略return，也可以单独的书写return，后面不加数据 示例代码： public class MethodDemo { public static void main(String[] args) { } public static void methodTwo() { //return 100; 编译错误，因为没有具体返回值类型 return; //System.out.println(100); return语句后面不能跟数据或代码 } } 1.6. 6. 方法重载 1.6.1. 6.1 方法重载 方法重载概念 方法重载指同一个类中定义的多个方法之间的关系，满足下列条件的多个方法相互构成重载 多个方法在同一个类中 多个方法具有相同的方法名 多个方法的参数不相同，类型不同或者数量不同 注意： 重载仅对应方法的定义，与方法的调用无关，调用方式参照标准格式 重载仅针对同一个类中方法的名称与参数进行识别，与返回值无关，换句话说不能通过返回值来判定两个方法是否相互构成重载 正确范例： public class MethodDemo { public static void fn(int a) { //方法体 } public static int fn(double a) { //方法体 } } public class MethodDemo { public static float fn(int a) { //方法体 } public static int fn(int a , int b) { //方法体 } } 错误范例： public class MethodDemo { public static void fn(int a) { //方法体 } public static int fn(int a) { /*错误原因：重载与返回值无关*/ //方法体 } } public class MethodDemo01 { public static void fn(int a) { //方法体 } } public class MethodDemo02 { public static int fn(double a) { /*错误原因：这是两个类的两个fn方法*/ //方法体 } } 1.6.2. 6.2 方法重载练习 需求：使用方法重载的思想，设计比较两个整数是否相同的方法，兼容全整数类型（byte,short,int,long） 思路： ​ ①定义比较两个数字的是否相同的方法compare()方法，参数选择两个int型参数 ​ ②定义对应的重载方法，变更对应的参数类型，参数变更为两个long型参数 ​ ③定义所有的重载方法，两个byte类型与两个short类型参数 ​ ④完成方法的调用，测试运行结果 代码： public class MethodTest { public static void main(String[] args) { //调用方法 System.out.println(compare(10, 20)); System.out.println(compare((byte) 10, (byte) 20)); System.out.println(compare((short) 10, (short) 20)); System.out.println(compare(10L, 20L)); } //int public static boolean compare(int a, int b) { System.out.println(\"int\"); return a == b; } //byte public static boolean compare(byte a, byte b) { System.out.println(\"byte\"); return a == b; } //short public static boolean compare(short a, short b) { System.out.println(\"short\"); return a == b; } //long public static boolean compare(long a, long b) { System.out.println(\"long\"); return a == b; } } 1.7. 7. 方法的参数传递 1.7.1. 7.1 方法参数传递基本类型（理解） 测试代码： ```java package com.itheima.param; public class Test1 { /* 方法参数传递为基本数据类型 : 传入方法中的, 是具体的数值. */ public static void main(String[] args) { int number = 100; System.out.println(\"调用change方法前:\" + number); change(number); System.out.println(\"调用change方法后:\" + number); } public static void change(int number) { number = 200; } } * 结论： * 基本数据类型的参数，形式参数的改变，不影响实际参数 * 结论依据： * 每个方法在栈内存中，都会有独立的栈空间，方法运行结束后就会弹栈消失 ### 7.2 方法参数传递引用类型 * 测试代码： ```java package com.itheima.param; public class Test2 { /* 方法参数传递为引用数据类型 : 传入方法中的, 是内存地址. */ public static void main(String[] args) { int[] arr = {10, 20, 30}; System.out.println(\"调用change方法前:\" + arr[1]); change(arr); System.out.println(\"调用change方法后:\" + arr[1]); } public static void change(int[] arr) { arr[1] = 200; } } 结论： 对于引用类型的参数，形式参数的改变，影响实际参数的值 结论依据： 引用数据类型的传参，传入的是地址值，内存中会造成两个引用指向同一个内存的效果，所以即使方法弹栈，堆内存中的数据也已经是改变后的结果 1.7.2. 7.3 数组遍历 需求：设计一个方法用于数组遍历，要求遍历的结果是在一行上的。例如：[11, 22, 33, 44, 55] 思路： 因为要求结果在一行上输出，所以这里需要在学习一个新的输出语句System.out.print(“内容”); System.out.println(“内容”); 输出内容并换行 System.out.print(“内容”); 输出内容不换行 System.out.println(); 起到换行的作用 定义一个数组，用静态初始化完成数组元素初始化 定义一个方法，用数组遍历通用格式对数组进行遍历 用新的输出语句修改遍历操作 调用遍历方法 代码： ```java package com.itheima.test; public class Test1 { /* 需求：设计一个方法用于数组遍历，要求遍历的结果是在一行上的。例如：[11, 22, 33, 44, 55] 思路： 1.定义一个数组，用静态初始化完成数组元素初始化 2.定义一个方法，对数组进行遍历 3.遍历打印的时候，数据不换行 4.调用遍历方法 */ public static void main(String[] args) { // 1.定义一个数组，用静态初始化完成数组元素初始化 int[] arr = {11, 22, 33, 44, 55}; // 4.调用遍历方法 printArray(arr); System.out.println(\"另外一段代码逻辑 \"); } /* 2.定义一个方法，对数组进行遍历 1, 参数 int[] arr 2, 返回值类型 void */ public static void printArray(int[] arr){ System.out.print(\"[\"); for (int i = 0; i } } } ### 7.4 数组最大值 * 需求：设计一个方法用于获取数组中元素的最大值 * 思路： * ①定义一个数组，用静态初始化完成数组元素初始化 * ②定义一个方法，用来获取数组中的最大值，最值的认知和讲解我们在数组中已经讲解过了 * ③调用获取最大值方法，用变量接收返回结果 * ④把结果输出在控制台 * 代码： ```java package com.itheima.test; public class Test2 { /* 需求：设计一个方法用于获取数组中元素的最大值 思路： 1.定义一个数组，用静态初始化完成数组元素初始化 2.定义一个方法，用来获取数组中的最大值 3.调用获取最大值方法，用变量接收返回结果 4.把结果输出在控制台 */ public static void main(String[] args) { // 1.定义一个数组，用静态初始化完成数组元素初始化 int[] arr = {11, 55, 22, 44, 33}; // 3.调用获取最大值方法，用变量接收返回结果 int max = getMax(arr); // 4.把结果输出在控制台 System.out.println(max); } /* 2.定义一个方法，用来获取数组中的最大值 1, 参数 int[] arr 2, 返回值类型 int */ public static int getMax(int[] arr){ int max = arr[0]; for (int i = 1; i 1.7.3. 7.5 方法同时获取数组最大值和最小值 需求：设计一个方法，该方法能够同时获取数组的最大值，和最小值 注意: return语句, 只能带回一个结果. 代码： public class Test3 { /* 需求：设计一个方法，该方法能够同时获取数组的最大值，和最小值 注意: return语句, 只能带回一个结果. */ public static void main(String[] args) { int[] arr = {11,55,33,22,44}; int[] maxAndMin = getMaxAndMin(arr); System.out.println(maxAndMin[0]); System.out.println(maxAndMin[1]); } public static int[] getMaxAndMin(int[] arr){ int max = arr[0]; for (int i = 1; i arr[i]){ min = arr[i]; } } int[] maxAndMin = {min, max}; return maxAndMin; } } Copyright © MISIN 2022 | 豫ICP备2021006345号-1 all right reserved，powered by Gitbook该文件修订时间： 2020-06-15 17:53:54 "},"1.JAVA基础/day06 Debug&基础练习.html":{"url":"1.JAVA基础/day06 Debug&基础练习.html","title":"day06 Debug&基础练习","keywords":"","body":"1.1. 1.Debug模式1.1.1. 1.1 什么是Debug模式1.1.2. 1.2 Debug介绍与操作流程1.2. 2. 进制的介绍与书写格式1.2.1. 2.1 进制的介绍与书写格式1.2.2. 2.2 任意进制到十进制的转换1.2.3. 2.3 进制转换-十进制到任意进制转换1.2.4. 2.4 快速进制转换法1.2.5. 2.5 原码反码补码1.2.6. 2.6 位运算-基本位运算符1.2.7. 2.7 位运算-位移运算符1.3. 3.基础练习1.3.1. 3.1 数据交换1.3.2. 3.2 数组反转【应用】1.3.3. 3.3 二维数组概述1.3.4. 3.4 二维数组动态初始化1.3.5. 3.5 二维数组访问元素的细节问题1.3.6. 3.6 二维数组静态初始化1.3.7. 3.7 二维数组遍历1.3.8. 3.8 二维数组求和1.1. 1.Debug模式 1.1.1. 1.1 什么是Debug模式 是供程序员使用的程序调试工具，它可以用于查看程序的执行流程，也可以用于追踪程序执行过程来调试程序。 1.1.2. 1.2 Debug介绍与操作流程 如何加断点 选择要设置断点的代码行，在行号的区域后面单击鼠标左键即可 如何运行加了断点的程序 在代码区域右键Debug执行 看哪里 看Debugger窗口 看Console窗口 点哪里 点Step Into (F7)这个箭头，也可以直接按F7 如何删除断点 选择要删除的断点，单击鼠标左键即可 如果是多个断点，可以每一个再点击一次。也可以一次性全部删除 1.2. 2. 进制的介绍与书写格式 1.2.1. 2.1 进制的介绍与书写格式 代码 : public class Demo1 { /* 十进制：Java中，数值默认都是10进制，不需要加任何修饰。 二进制：数值前面以0b开头，b大小写都可以。 八进制：数值前面以0开头。 十六进制：数值前面以0x开头，x大小写都可以。 注意: 书写的时候, 虽然加入了进制的标识, 但打印在控制台展示的都是十进制数据. */ public static void main(String[] args) { System.out.println(10); System.out.println(“二进制数据0b10的十进制表示为:” + 0b10); System.out.println(“八进制数据010的十进制表示为:” + 010); System.out.println(“十六进制数据0x10的十进制表示为:” + 0x10); } } 1.2.2. 2.2 任意进制到十进制的转换 1.2.3. 2.3 进制转换-十进制到任意进制转换 ​ 2.3.1 : 十进制到二进制的转换 ​ 公式：除基取余使用源数据，不断的除以基数（几进制，基数就是几）得到余数，直到商为0，再将余数倒着拼起来即可。 ​ 需求：将十进制数字11，转换为2进制。 ​ 实现方式：源数据为11，使用11不断的除以基数，也就是2，直到商为0。 ​ 2.3.2 : 十进制到十六进制的转换 ​ 公式：除基取余使用源数据，不断的除以基数（几进制，基数就是几）得到余数，直到商为0，再将余数倒着拼起来即可。 ​ 需求：将十进制数字60，转换为16进制。 ​ 实现方式：源数据为60，使用60不断的除以基数，也就是16，直到商为0。 ​ 结论：十进制到任意进制的转换 ​ 公式：除基取余使用源数据，不断的除以基数（几进制，基数就是几）得到余数，直到商为0，再将余数倒着 拼起来即可 1.2.4. 2.4 快速进制转换法 ​ 8421码： ​ 8421码又称BCD码，是BCD代码中最常用的一种BCD： (Binary-Coded Decimal‎) 二进制码十进制数在这种编码方式中，每一位二进制值的1都是代表一个固定数值，把每一位的1代表的十进制数加起来得到的结果就是它所代表的十进制数。 ​ 1.2.5. 2.5 原码反码补码 前言 : 计算机中的数据，都是以二进制补码的形式在运算，而补码则是通过反码和原码推算出来的 原码 :（可直观看出数据大小） 就是二进制定点表示法，即最高位为符号位，【0】表示正，【1】表示负，其余位表示数值的大小。 通过一个字节表示+7和-7，代码：byte b1 = 7; byte b2 = -7;一个字节等于8个比特位，也就是8个二进制位 0(符号位) 0000111 1(符号位) 0000111 反码 : 正数的反码与其原码相同；负数的反码是对其原码逐位取反，但符号位除外。 补码 : （数据以该状态进行运算）正数的补码与其原码相同；负数的补码是在其反码的末位加1。 1.2.6. 2.6 位运算-基本位运算符 package com.itheima.demo; public class Demo2 { /* 位运算: 位运算符指的是二进制位的运算，先将十进制数转成二进制后再进行运算。 在二进制位运算中，1表示true，0表示false。 & 位与 : 遇false则false, 遇0则0 00000000 00000000 00000000 00000110 // 6的二进制 & 00000000 00000000 00000000 00000010 // 2的二进制 —————————————— 00000000 00000000 00000000 00000010 // 结果: 2 | 位或 : 遇true则true, 遇1则1 ^ 位异或 : 相同为false, 不同为true ~ 取反 : 全部取反, 0变1, 1变0 (也包括符号位) 00000000 00000000 00000000 00000110 // 6的二进制补码 ~ 11111111 11111111 11111111 11111001 - 1 // -1求反码 ———————————— 11111111 11111111 11111111 11111000 // 反码推原码 10000000 00000000 00000000 00000111 // -7 */ public static void main(String[] args) { System.out.println(6 & 2); System.out.println(~6); } } 1.2.7. 2.7 位运算-位移运算符 位运算概述 : 位运算符指的是二进制位的运算，先将十进制数转成二进制后再进行运算。在二进制位运算中，1表示true，0表示false。 位运算符介绍 : 代码 : package com.itheima.demo; public class Demo3 { /* 位移运算符: > 有符号右移运算，二进制位向右移动, 使用符号位进行补位 运算规律: 向右移动几位, 就是除以2的几次幂 000000000 00000000 00000000 0000001(1) // 3的二进制 ----------------------------------------------------------------------------- >>> 无符号右移运算符, 无论符号位是0还是1，都补0 010000000 00000000 00000000 00000110 // -6的二进制 */ public static void main(String[] args) { System.out.println(12 package com.itheima.demo; public class Demo4 { /* ^ 运算符的特点 一个数, 被另外一个数, 异或两次, 该数本身不变 */ public static void main(String[] args) { System.out.println(10 ^ 5 ^ 10); } } 1.3. 3.基础练习 1.3.1. 3.1 数据交换 案例需求 ​ 已知两个整数变量a = 10，b = 20，使用程序实现这两个变量的数据交换 ​ 最终输出a = 20，b = 10; 代码实现 package com.itheima.test; public class Test1 { /* 需求：已知两个整数变量a = 10，b = 20，使用程序实现这两个变量的数据交换 最终输出a = 20，b = 10; 思路： 1. 定义一个三方变量temp，将a原本记录的值，交给temp记录 （a的值，不会丢了） 2. 使用 a 变量记录 b 的值，（第一步交换完毕，b的值也丢不了了） 3. 使用 b 变量记录 temp的值，也就是a原本的值 （交换完毕） 4. 输出 a 和 b 变量即可 */ /* 动态初始化格式： 数据类型[][] 变量名 = new 数据类型[m][n]; m表示这个二维数组，可以存放多少个一维数组 n表示每一个一维数组，可以存放多少个元素 */ public static void main(String[] args) { int a = 10; int b = 20; // 将a原本记录的值，交给temp记录 （a的值，不会丢了） int temp = a; // 用 a 变量记录 b 的值，（第一步交换完毕，b的值也丢不了了） a = b; // 使用 b 变量记录 temp的值，也就是a原本的值 （交换完毕） b = temp; // 输出 a 和 b 变量即可 System.out.println(\"a=\" + a); System.out.println(\"b=\" + b); } } 1.3.2. 3.2 数组反转【应用】 案例需求 : ​ 已知一个数组 arr = {19, 28, 37, 46, 50}; 用程序实现把数组中的元素值交换， ​ 交换后的数组 arr = {50, 46, 37, 28, 19}; 并在控制台输出交换后的数组元素 实现步骤 : 1. 定义两个变量, start和end来表示开始和结束的指针. 确定交换条件, start 循环中编写交换逻辑代码 每一次交换完成, 改变两个指针所指向的索引 start++, end-- 循环结束后, 遍历数组并打印, 查看反转后的数组 代码实现 : package com.itheima.test; public class Test2 { /* 需求：已知一个数组 arr = {19, 28, 37, 46, 50}; 用程序实现把数组中的元素值交换， 交换后的数组 arr = {50, 46, 37, 28, 19}; 并在控制台输出交换后的数组元素。 步骤: 1. 定义两个变量, start和end来表示开始和结束的指针. 2. 确定交换条件, start 1.3.3. 3.3 二维数组概述 ​ 概述 : 二维数组也是一种容器，不同于一维数组，该容器存储的都是一维数组容器 1.3.4. 3.4 二维数组动态初始化 动态初始化格式： 数据类型[][] 变量名 = new 数据类型[m][n]; m表示这个二维数组，可以存放多少个一维数组 n表示每一个一维数组，可以存放多少个元素 package com.itheima.demo; public class Demo1Array { /* 动态初始化格式： 数据类型[][] 变量名 = new 数据类型[m][n]; m表示这个二维数组，可以存放多少个一维数组 n表示每一个一维数组，可以存放多少个元素 */ public static void main(String[] args) { // 数据类型[][] 变量名 = new 数据类型[m][n]; int[][] arr = new int[3][3]; /* [[I@10f87f48 @ : 分隔符 10f87f48 : 十六进制内存地址 I : 数组中存储的数据类型 [[ : 几个中括号就代表的是几维数组 */ System.out.println(arr); /* 二维数组存储一维数组的时候, 存储的是一维数组的内存地址 */ System.out.println(arr[0]); System.out.println(arr[1]); System.out.println(arr[2]); System.out.println(arr[0][0]); System.out.println(arr[1][1]); System.out.println(arr[2][2]); // 向二维数组中存储元素 arr[0][0] = 11; arr[0][1] = 22; arr[0][2] = 33; arr[1][0] = 11; arr[1][1] = 22; arr[1][2] = 33; arr[2][0] = 11; arr[2][1] = 22; arr[2][2] = 33; // 从二维数组中取出元素并打印 System.out.println(arr[0][0]); System.out.println(arr[0][1]); System.out.println(arr[0][2]); System.out.println(arr[1][0]); System.out.println(arr[1][1]); System.out.println(arr[1][2]); System.out.println(arr[2][0]); System.out.println(arr[2][1]); System.out.println(arr[2][2]); } } 1.3.5. 3.5 二维数组访问元素的细节问题 问题 : 二维数组中存储的是一维数组, 那能不能存入 [提前创建好的一维数组] 呢 ? 答 : 可以的 代码实现 package com.itheima.demo; public class Demo2Array { /* 问题: 二维数组中存储的是一维数组, 那能不能存入 [提前创建好的一维数组] 呢 ? 答 : 可以的 */ public static void main(String[] args) { int[] arr1 = {11,22,33}; int[] arr2 = {44,55,66}; int[] arr3 = {77,88,99,100}; int[][] arr = new int[3][3]; arr[2][3] = 100; arr[0] = arr1; arr[1] = arr2; arr[2] = arr3; System.out.println(arr[1][2]); System.out.println(arr[2][3]); } } 1.3.6. 3.6 二维数组静态初始化 **完整格式 :** 数据类型[][] 变量名 = new 数据类型[][]{ {元素1, 元素2...} , {元素1, 元素2...} **简化格式 :** 数据类型[][] 变量名 = { {元素1, 元素2...} , {元素1, 元素2...} ...}; 代码实现 : package com.itheima.demo; public class Demo3Array { /* 完整格式：数据类型[][] 变量名 = new 数据类型[][]{ {元素1, 元素2...} , {元素1, 元素2...} ...}; 简化格式: 数据类型[][] 变量名 = { {元素1, 元素2...} , {元素1, 元素2...} ...}; */ public static void main(String[] args) { int[] arr1 = {11,22,33}; int[] arr2 = {44,55,66}; int[][] arr = { {11,22,33}, {44,55,66} }; System.out.println(arr[0][2]); int[][] array = {arr1,arr2}; System.out.println(array[0][2]); } } 1.3.7. 3.7 二维数组遍历 需求 : ​ 已知一个二维数组 arr = { {11, 22, 33}, {33, 44, 55} }; ​ 遍历该数组，取出所有元素并打印 步骤 : 1. 遍历二维数组，取出里面每一个一维数组 2. 在遍历的过程中，对每一个一维数组继续完成遍历，获取内部存储的每一个元素 代码实现 : package com.itheima.test; public class Test1 { /* 需求: 已知一个二维数组 arr = { {11, 22, 33}, {33, 44, 55} }; 遍历该数组，取出所有元素并打印 步骤: 1. 遍历二维数组，取出里面每一个一维数组 2. 在遍历的过程中，对每一个一维数组继续完成遍历，获取内部存储的每一个元素 */ public static void main(String[] args) { int[][] arr = { {11, 22, 33}, {33, 44, 55} }; // 1. 遍历二维数组，取出里面每一个一维数组 for (int i = 0; i 1.3.8. 3.8 二维数组求和 需求 : 某公司季度和月份统计的数据如下：单位(万元) 第一季度：22,66,44 第二季度：77,33,88 第三季度：25,45,65 第四季度：11,66,99 步骤 : 定义求和变量，准备记录最终累加结果 使用二维数组来存储数据，每个季度是一个一维数组，再将4个一维数组装起来 遍历二维数组，获取所有元素，累加求和 输出最终结果 代码实现 : package com.itheima.test; public class Test2 { /* 需求: 某公司季度和月份统计的数据如下：单位(万元) 第一季度：22,66,44 第二季度：77,33,88 第三季度：25,45,65 第四季度：11,66,99 步骤: 1. 定义求和变量，准备记录最终累加结果 2. 使用二维数组来存储数据，每个季度是一个一维数组，再将4个一维数组装起来 3. 遍历二维数组，获取所有元素，累加求和 4. 输出最终结果 */ public static void main(String[] args) { // 1. 定义求和变量，准备记录最终累加结果 int sum = 0; // 2. 使用二维数组来存储数据，每个季度是一个一维数组，再将4个一维数组装起来 int[][] arr = { {22,66,44} , {77,33,88} , {25,45,65} , {11,66,99} }; // 3. 遍历二维数组，获取所有元素，累加求和 for (int i = 0; i Copyright © MISIN 2022 | 豫ICP备2021006345号-1 all right reserved，powered by Gitbook该文件修订时间： 2022-12-04 20:47:33 "},"1.JAVA基础/day07 面向对象.html":{"url":"1.JAVA基础/day07 面向对象.html","title":"day07 面向对象","keywords":"","body":"1.1. 1. 类和对象1.1.1. 1.1 类和对象的关系1.1.2. 1.2 类的定义【应用】1.1.3. 1.3 对象的创建和使用1.1.4. 1.4 案例-手机类的创建和使用1.2. 2. 对象内存图1.2.1. 2.1 单个对象内存图【理解】1.2.2. 2.2 多个对象内存图【理解】1.2.3. 2.3 多个对象指向相同内存图【理解】1.3. 3. 成员变量和局部变量1.3.1. 3.1 成员变量和局部变量的区别1.4. 4. 封装1.4.1. 4.1 private关键字1.4.2. 4.2 private关键字的使用1.4.3. 4.3 this关键字【应用】1.4.4. 4.4 this内存原理【理解】1.4.5. 4.5 封装思想1.5. 5. 构造方法1.5.1. 5.1 构造方法的格式和执行时机1.5.2. 5.2 构造方法的作用1.5.3. 5.3 构造方法的注意事项1.5.4. 5.4 标准类的代码编写和使用1.1. 1. 类和对象 面向对象和面向过程的思想对比 : ​ 面向过程 ：是一种以过程为中心的编程思想，实现功能的每一步，都是自己实现的 ​ 面向对象 ：是一种以对象为中心的编程思想，通过指挥对象实现具体的功能 1.1.1. 1.1 类和对象的关系 客观存在的事物皆为对象 ，所以我们也常常说万物皆对象。 类 类的理解 类是对现实生活中一类具有共同属性和行为的事物的抽象 类是对象的数据类型，类是具有相同属性和行为的一组对象的集合 简单理解：类就是对现实事物的一种描述 类的组成 属性：指事物的特征，例如：手机事物（品牌，价格，尺寸） 行为：指事物能执行的操作，例如：手机事物（打电话，发短信） 类和对象的关系 类：类是对现实生活中一类具有共同属性和行为的事物的抽象 对象：是能够看得到摸的着的真实存在的实体 简单理解：类是对事物的一种描述，对象则为具体存在的事物 1.1.2. 1.2 类的定义【应用】 类的组成是由属性和行为两部分组成 属性：在类中通过成员变量来体现（类中方法外的变量） 行为：在类中通过成员方法来体现（和前面的方法相比去掉static关键字即可） 类的定义步骤： ​ ① 定义类 ​ ② 编写类的成员变量 ​ ③ 编写类的成员方法 public class Student { // 属性 : 姓名, 年龄 // 成员变量: 跟之前定义变量的格式一样, 只不过位置发生了改变, 类中方法外 String name; int age; // 行为 : 学习 // 成员方法: 跟之前定义方法的格式一样, 只不过去掉了static关键字. public void study(){ System.out.println(“学习”); } } 1.1.3. 1.3 对象的创建和使用 创建对象的格式： 类名 对象名 = new 类名(); 调用成员的格式： 对象名.成员变量 对象名.成员方法(); 示例代码 : package com.itheima.object1; public class TestStudent { /* 创建对象的格式: 类名 对象名 = new 类名(); 调用成员变量的格式: 对象名.变量名 调用成员方法的格式: 对象名.方法名(); */ public static void main(String[] args) { // 类名 对象名 = new 类名(); Student stu = new Student(); // 对象名.变量名 // 默认初始化值 System.out.println(stu.name); // null System.out.println(stu.age); // 0 stu.name = “张三”; stu.age = 23; System.out.println(stu.name); // 张三 System.out.println(stu.age); // 23 // 对象名.方法名(); stu.study(); // com.itheima.object1.Student@b4c966a // 全类名(包名 + 类名) System.out.println(stu); } } 1.1.4. 1.4 案例-手机类的创建和使用 需求 ：首先定义一个手机类，然后定义一个手机测试类，在手机测试类中通过对象完成成员变量和成员方法的使用 分析 ： 成员变量：品牌, 价格 成员方法：打电话, 发短信 示例代码： package com.itheima.test1; public class Phone { // 品牌, 价格 String brand; int price; // 打电话, 发短信 public void call(String name){ System.out.println(“给”+name+”打电话”); } public void sendMessage(){ System.out.println(“群发短信”); } } package com.itheima.test1; public class TestPhone { public static void main(String[] args) { // 1. 创建对象 Phone p = new Phone(); // 2. 给成员变量进行赋值 p.brand = “大米”; p.price = 2999; // 3. 打印赋值后的成员变量 System.out.println(p.brand + “...” + p.price); // 4. 调用成员方法 p.call(“阿强”); p.sendMessage(); } } 1.2. 2. 对象内存图 1.2.1. 2.1 单个对象内存图【理解】 1.2.2. 2.2 多个对象内存图【理解】 总结： 多个对象在堆内存中，都有不同的内存划分，成员变量存储在各自的内存区域中，成员方法多个对象共用的一份 1.2.3. 2.3 多个对象指向相同内存图【理解】 总结 : 当多个对象的引用指向同一个内存空间（变量所记录的地址值是一样的） 只要有任何一个对象修改了内存中的数据，随后，无论使用哪一个对象进行数据获取，都是修改后的数据。 1.3. 3. 成员变量和局部变量 1.3.1. 3.1 成员变量和局部变量的区别 类中位置不同：成员变量（类中方法外）局部变量（方法内部或方法声明上） 内存中位置不同：成员变量（堆内存）局部变量（栈内存） 生命周期不同：成员变量（随着对象的存在而存在，随着对象的消失而消失）局部变量（随着方法的调用而存在，醉着方法的调用完毕而消失） 初始化值不同：成员变量（有默认初始化值）局部变量（没有默认初始化值，必须先定义，赋值才能使用） 1.4. 4. 封装 1.4.1. 4.1 private关键字 ​ 概述 : private是一个修饰符，可以用来修饰成员（成员变量，成员方法） ​ 特点 : 被private修饰的成员，只能在本类进行访问，针对private修饰的成员变量，如果需要被其他类使用， 提供相应的操作 ​ 提供“get变量名()”方法，用于获取成员变量的值，方法用public修饰 ​ 提供“set变量名(参数)”方法，用于设置成员变量的值，方法用public修饰 ​ 示例代码： /* 学生类 */ class Student { //成员变量 String name; private int age; //提供get/set方法 public void setAge(int a) { if(a120) { System.out.println(“你给的年龄有误”); } else { age = a; } } public int getAge() { return age; } //成员方法 public void show() { System.out.println(name + “,” + age); } } /* 学生测试类 */ public class StudentDemo { public static void main(String[] args) { //创建对象 Student s = new Student(); //给成员变量赋值 s.name = “林青霞”; s.setAge(30); //调用show方法 s.show(); } } 1.4.2. 4.2 private关键字的使用 需求： 定义标准的学生类，要求name和age使用private修饰 并提供set和get方法以及便于显示数据的show方法 测试类中创建对象并使用，最终控制台输出 林青霞，30 示例代码： /* 学生类 */ class Student { //成员变量 private String name; private int age; //get/set方法 public void setName(String n) { name = n; } public String getName() { return name; } public void setAge(int a) { age = a; } public int getAge() { return age; } public void show() { System.out.println(name + “,” + age); } } /* 学生测试类 */ public class StudentDemo { public static void main(String[] args) { //创建对象 Student s = new Student(); //使用set方法给成员变量赋值 s.setName(“林青霞”); s.setAge(30); s.show(); //使用get方法获取成员变量的值 System.out.println(s.getName() + “—“ + s.getAge()); System.out.println(s.getName() + “,” + s.getAge()); } } 1.4.3. 4.3 this关键字【应用】 概述 : this修饰的变量用于指代成员变量，其主要作用是（区分局部变量和成员变量的重名问题） 方法的形参如果与成员变量同名，不带this修饰的变量指的是形参，而不是成员变量 方法的形参没有与成员变量同名，不带this修饰的变量指的是成员变量 代码实现 : public class Student { private String name; private int age; public void setName(String name) { this.name = name; } public String getName() { return name; } public void setAge(int age) { this.age = age; } public int getAge() { return age; } public void show() { System.out.println(name + “,” + age); } } 1.4.4. 4.4 this内存原理【理解】 注意 : this代表当前调用方法的引用，哪个对象调用的方法，this就代表哪一个对象 图解 ： 1.4.5. 4.5 封装思想 封装概述 是面向对象三大特征之一（封装，继承，多态） 是面向对象编程语言对客观世界的模拟，客观世界里成员变量都是隐藏在对象内部的，外界是无法直接操作的 封装原则 将类的某些信息隐藏在类内部，不允许外部程序直接访问，而是通过该类提供的方法来实现对隐藏信息的操作和访问 成员变量private，提供对应的getXxx()/setXxx()方法 封装好处 通过方法来控制成员变量的操作，提高了代码的安全性 把代码用方法进行封装，提高了代码的复用性 1.5. 5. 构造方法 1.5.1. 5.1 构造方法的格式和执行时机 格式注意 : 方法名与类名相同，大小写也要一致 没有返回值类型，连void都没有 没有具体的返回值（不能由retrun带回结果数据） 执行时机 ： 创建对象的时候调用，每创建一次对象，就会执行一次构造方法 不能手动调用构造方法 示例代码： class Student { private String name; private int age; //构造方法 public Student() { System.out.println(\"无参构造方法\"); } public void show() { System.out.println(name + \",\" + age); } } /* 测试类 */ public class StudentDemo { public static void main(String[] args) { //创建对象 Student s = new Student(); s.show(); } } 1.5.2. 5.2 构造方法的作用 用于给对象的数据（属性）进行初始化 package com.itheima.constructor; public class Student { /* 格式: 1. 方法名需要跟类名相同, 大小写也要一致 2. 没有返回值类型, 连void都没有 3. 没有具体的返回值(不能由return带回具体的结果) */ private String name; private int age; // 1. 如果一个类中没有编写任何构造方法, 系统将会提供一个默认的无参数构造方法 public Student(){} // 2. 如果手动编写了构造方法, 系统就不会再提供默认的无参数构造方法了 public Student(String name, int age){ this.name = name; this.age = age; System.out.println(\"我是Student类的构造方法\"); } public void show(){ System.out.println(name + \"...\" + age); } } package com.itheima.constructor; public class TestStudent { public static void main(String[] args) { Student stu1 = new Student(\"张三\",23); stu1.show(); Student stu2 = new Student(); } } 1.5.3. 5.3 构造方法的注意事项 构造方法的创建 : ​ 如果没有定义构造方法，系统将给出一个默认的无参数构造方法 ​ 如果定义了构造方法，系统将不再提供默认的构造方法 构造方法的创建 : ​ 如果没有定义构造方法，系统将给出一个默认的无参数构造方法如果定义了构造方法，系统将不再提供默认的构造方法 推荐的使用方式 : ​ 无论是否使用，都手动书写无参数构造方法，和带参数构造方法 1.5.4. 5.4 标准类的代码编写和使用 代码 : package com.itheima.test3; /* JavaBean类: 封装数据 */ public class Student { private String name; private int age; public Student() { } public Student(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public void show(){ System.out.println(name + \"...\" + age); } } package com.itheima.test3; public class TestStudent { public static void main(String[] args) { // 1. 无参数构造方法创建对象, 通过setXxx方法给成员变量进行赋值 Student stu1 = new Student(); stu1.setName(\"张三\"); stu1.setAge(23); stu1.show(); // 2. 通过带参数构造方法, 直接给属性进行赋值 Student stu2 = new Student(\"李四\",24); stu2.show(); } } Copyright © MISIN 2022 | 豫ICP备2021006345号-1 all right reserved，powered by Gitbook该文件修订时间： 2022-11-10 13:40:38 "},"1.JAVA基础/day08 常用API.html":{"url":"1.JAVA基础/day08 常用API.html","title":"day08 常用API","keywords":"","body":"1.1. 1.API1.1.1. 1.1 API概述-帮助文档的使用1.1.2. 1.2 键盘录入字符串1.2. 2. String类1.2.1. 2.1 String概述1.2.2. 2.2 String类的构造方法1.2.3. 2.4 创建字符串对象的区别对比1.2.4. 2.5 字符串的比较1.2.5. 2.6 用户登录案例【应用】1.2.6. 2.7 遍历字符串案例【应用】1.2.7. 2.8 统计字符次数案例【应用】1.2.8. 2.9 手机号屏蔽-字符串截取1.2.9. 2.10 敏感词替换-字符串替换1.2.10. 2.11 切割字符串1.2.11. 2.12 String方法小结1.3. 3 StringBuilder类1.3.1. 3.1 StringBuilder类概述1.3.2. 3.2 StringBuilder类和String类的区别1.3.3. 3.3StringBuilder类的构造方法1.3.4. 3.4 StringBuilder常用的成员方法1.3.5. 3.5StringBuilder和String相互转换【应用】1.3.6. 3.6 StringBuilder拼接字符串案例1.1. 1.API 1.1.1. 1.1 API概述-帮助文档的使用 什么是API ​ API (Application Programming Interface) ：应用程序编程接口 java中的API ​ 指的就是 JDK 中提供的各种功能的 Java类，这些类将底层的实现封装了起来，我们不需要关心这些类是如何实现的，只需要学习这些类如何使用即可，我们可以通过帮助文档来学习这些API如何使用。 如何使用API帮助文档 : 打开帮助文档 找到索引选项卡中的输入框 在输入框中输入Random 看类在哪个包下 看类的描述 看构造方法 看成员方法 1.1.2. 1.2 键盘录入字符串 Scanner类 : ​ next() : 遇到了空格, 就不再录入数据了 , 结束标记: 空格, tab键 ​ nextLine() : 可以将数据完整的接收过来 , 结束标记: 回车换行符 代码实现 : package com.itheima.api; import java.util.Scanner; public class Demo1Scanner { /* next() : 遇到了空格, 就不再录入数据了 结束标记: 空格, tab键 nextLine() : 可以将数据完整的接收过来 结束标记: 回车换行符 */ public static void main(String[] args) { // 1. 创建Scanner对象 Scanner sc = new Scanner(System.in); System.out.println(\"请输入:\"); // 2. 调用nextLine方法接收字符串 // ctrl + alt + v : 快速生成方法的返回值 String s = sc.nextLine(); System.out.println(s); } } package com.itheima.api; import java.util.Scanner; public class Demo2Scanner { /* nextInt和nextLine方法配合使用的时候, nextLine方法就没有键盘录入的机会了 建议: 今后键盘录入数据的时候, 如果是字符串和整数一起接受, 建议使用next方法接受字符串. */ public static void main(String[] args) { Scanner sc = new Scanner(System.in); System.out.println(\"请输入整数:\"); int num = sc.nextInt(); // 10 + 回车换行 System.out.println(\"请输入字符串:\"); String s = sc.nextLine(); System.out.println(num); System.out.println(s); } } 1.2. 2. String类 1.2.1. 2.1 String概述 ​ 1 String 类在 java.lang 包下，所以使用的时候不需要导包 ​ 2 String 类代表字符串，Java 程序中的所有字符串文字（例如“abc”）都被实现为此类的实例也就是说，Java 程序中所有的双引号字符串，都是 String 类的对象 ​ 3 字符串不可变，它们的值在创建后不能被更改 1.2.2. 2.2 String类的构造方法 常用的构造方法 示例代码 package com.itheima.string; public class Demo2StringConstructor { /* String类常见构造方法: public String() : 创建一个空白字符串对象，不含有任何内容 public String(char[] chs) : 根据字符数组的内容，来创建字符串对象 public String(String original) : 根据传入的字符串内容，来创建字符串对象 String s = “abc”; 直接赋值的方式创建字符串对象，内容就是abc 注意: String这个类比较特殊, 打印其对象名的时候, 不会出现内存地址 而是该对象所记录的真实内容. 面向对象-继承, Object类 */ public static void main(String[] args) { // public String() : 创建一个空白字符串对象，不含有任何内容 String s1 = new String(); System.out.println(s1); // public String(char[] chs) : 根据字符数组的内容，来创建字符串对象 char[] chs = {'a','b','c'}; String s2 = new String(chs); System.out.println(s2); // public String(String original) : 根据传入的字符串内容，来创建字符串对象 String s3 = new String(\"123\"); System.out.println(s3); } } 1.2.3. 2.4 创建字符串对象的区别对比 通过构造方法创建 ​ 通过 new 创建的字符串对象，每一次 new 都会申请一个内存空间，虽然内容相同，但是地址值不同 直接赋值方式创建 ​ 以“”方式给出的字符串，只要字符序列相同(顺序和大小写)，无论在程序代码中出现几次，JVM 都只会建立一个 String 对象，并在字符串池中维护 1.2.4. 2.5 字符串的比较 2.5.1 字符串的比较 == 比较基本数据类型：比较的是具体的值 == 比较引用数据类型：比较的是对象地址值 String类 : public boolean equals(String s) 比较两个字符串内容是否相同、区分大小写 代码 : package com.itheima.stringmethod; public class Demo1Equals { public static void main(String[] args) { String s1 = \"abc\"; String s2 = \"ABC\"; String s3 = \"abc\"; // equals : 比较字符串内容, 区分大小写 System.out.println(s1.equals(s2)); System.out.println(s1.equals(s3)); // equalsIgnoreCase : 比较字符串内容, 忽略大小写 System.out.println(s1.equalsIgnoreCase(s2)); } } 1.2.5. 2.6 用户登录案例【应用】 案例需求 : ​ 已知用户名和密码，请用程序实现模拟用户登录。总共给三次机会，登录之后，给出相应的提示 实现步骤 : 已知用户名和密码，定义两个字符串表示即可 键盘录入要登录的用户名和密码，用 Scanner 实现 拿键盘录入的用户名、密码和已知的用户名、密码进行比较，给出相应的提示。 字符串的内容比较，用equals() 方法实现 用循环实现多次机会，这里的次数明确，采用for循环实现，并在登录成功的时候，使用break结束循 代码实现 : package com.itheima.test; import java.util.Scanner; public class Test1 { /* 需求：已知用户名和密码，请用程序实现模拟用户登录。 总共给三次机会，登录之后，给出相应的提示 思路： 1. 已知用户名和密码，定义两个字符串表示即可 2. 键盘录入要登录的用户名和密码，用 Scanner 实现 3. 拿键盘录入的用户名、密码和已知的用户名、密码进行比较，给出相应的提示。 字符串的内容比较，用equals() 方法实现 4. 用循环实现多次机会，这里的次数明确，采用for循环实现，并在登录成功的时候，使用break结束循环 */ public static void main(String[] args) { // 1. 已知用户名和密码，定义两个字符串表示即可 String username = \"admin\"; String password = \"123456\"; // 2. 键盘录入要登录的用户名和密码，用 Scanner 实现 Scanner sc = new Scanner(System.in); // 4. 用循环实现多次机会，这里的次数明确，采用for循环实现 for(int i = 1; i 1.2.6. 2.7 遍历字符串案例【应用】 案例需求 : ​ 键盘录入一个字符串，使用程序实现在控制台遍历该字符串 实现步骤 : 键盘录入一个字符串，用 Scanner 实现 遍历字符串，首先要能够获取到字符串中的每一个字符, public char charAt(int index)：返回指定索引处的char值，字符串的索引也是从0开始的 遍历字符串，其次要能够获取到字符串的长度, public int length()：返回此字符串的长度 遍历打印 代码实现 : package com.itheima.test; import java.util.Scanner; public class Test2 { /* 需求：键盘录入一个字符串，使用程序实现在控制台遍历该字符串 思路： 1. 键盘录入一个字符串，用 Scanner 实现 2. 遍历字符串，首先要能够获取到字符串中的每一个字符 public char charAt(int index)：返回指定索引处的char值，字符串的索引也是从0开始的 3. 遍历字符串，其次要能够获取到字符串的长度 public int length()：返回此字符串的长度 4. 遍历打印 9 */ public static void main(String[] args) { // 1. 键盘录入一个字符串，用 Scanner 实现 Scanner sc = new Scanner(System.in); System.out.println(\"请输入:\"); String s = sc.nextLine(); // 2. 遍历字符串，首先要能够获取到字符串中的每一个字符 for(int i = 0; i 1.2.7. 2.8 统计字符次数案例【应用】 案例需求 : ​ 键盘录入一个字符串，使用程序实现在控制台遍历该字符串 实现步骤 : 键盘录入一个字符串，用 Scanner 实现 将字符串拆分为字符数组 , public char[] toCharArray( )：将当前字符串拆分为字符数组并返回 遍历字符数 代码实现 : package com.itheima.test; import java.util.Scanner; public class Test3 { /* 需求：键盘录入一个字符串，使用程序实现在控制台遍历该字符串 思路： 1. 键盘录入一个字符串，用 Scanner 实现 2. 将字符串拆分为字符数组 public char[] toCharArray( )：将当前字符串拆分为字符数组并返回 3. 遍历字符数组 */ public static void main(String[] args) { // 1. 键盘录入一个字符串，用 Scanner 实现 Scanner sc = new Scanner(System.in); System.out.println(\"请输入:\"); String s = sc.nextLine(); // 2. 将字符串拆分为字符数组 char[] chars = s.toCharArray(); // 3. 遍历字符数组 for (int i = 0; i 1.2.8. 2.9 手机号屏蔽-字符串截取 案例需求 : ​ 以字符串的形式从键盘接受一个手机号，将中间四位号码屏蔽 ​ 最终效果为：156**1234 实现步骤 : 键盘录入一个字符串，用 Scanner 实现 截取字符串前三位 截取字符串后四位 将截取后的两个字符串，中间加上**进行拼接，输出结果 代码实现 : package com.itheima.test; import java.util.Scanner; public class Test5 { /* 需求：以字符串的形式从键盘接受一个手机号，将中间四位号码屏蔽 最终效果为：156****1234 思路： 1. 键盘录入一个字符串，用 Scanner 实现 2. 截取字符串前三位 3. 截取字符串后四位 4. 将截取后的两个字符串，中间加上****进行拼接，输出结果 */ public static void main(String[] args) { // 1. 键盘录入一个字符串，用 Scanner 实现 Scanner sc = new Scanner(System.in); System.out.println(\"请输入手机号:\"); String telString = sc.nextLine(); // 2. 截取字符串前三位 String start = telString.substring(0,3); // 3. 截取字符串后四位 String end = telString.substring(7); // 4. 将截取后的两个字符串，中间加上****进行拼接，输出结果 System.out.println(start + \"****\" + end); } } 1.2.9. 2.10 敏感词替换-字符串替换 案例需求 : ​ 键盘录入一个 字符串，如果字符串中包含（TMD），则使用*替换 实现步骤 : 键盘录入一个字符串，用 Scanner 实现 替换敏感词 String replace(CharSequence target, CharSequence replacement) 将当前字符串中的target内容，使用replacement进行替换，返回新的字符串 输出结果 代码实现 : package com.itheima.test; import java.util.Scanner; public class Test6 { /* 需求：键盘录入一个 字符串，如果字符串中包含（TMD），则使用***替换 思路： 1. 键盘录入一个字符串，用 Scanner 实现 2. 替换敏感词 String replace(CharSequence target, CharSequence replacement) 将当前字符串中的target内容，使用replacement进行替换，返回新的字符串 3. 输出结果 */ public static void main(String[] args) { // 1. 键盘录入一个字符串，用 Scanner 实现 Scanner sc = new Scanner(System.in); System.out.println(\"请输入:\"); String s = sc.nextLine(); // 2. 替换敏感词 String result = s.replace(\"TMD\",\"***\"); // 3. 输出结果 System.out.println(result); } } 1.2.10. 2.11 切割字符串 案例需求 : ​ 以字符串的形式从键盘录入学生信息，例如：“张三 , 23” ​ 从该字符串中切割出有效数据,封装为Student学生对象 实现步骤 : 编写Student类，用于封装数据 键盘录入一个字符串，用 Scanner 实现 根据逗号切割字符串，得到（张三）（23） String[] split(String regex) ：根据传入的字符串作为规则进行切割 将切割后的内容存入字符串数组中，并将字符串数组返回 从得到的字符串数组中取出元素内容，通过Student类的有参构造方法封装为对象 调用对象getXxx方法，取出数据并打印。 代码实现 : package com.itheima.test; import com.itheima.domain.Student; import java.util.Scanner; public class Test7 { /* 需求：以字符串的形式从键盘录入学生信息，例如：“张三 , 23” 从该字符串中切割出有效数据,封装为Student学生对象 思路： 1. 编写Student类，用于封装数据 2. 键盘录入一个字符串，用 Scanner 实现 3. 根据逗号切割字符串，得到（张三）（23） String[] split(String regex) ：根据传入的字符串作为规则进行切割 将切割后的内容存入字符串数组中，并将字符串数组返回 4. 从得到的字符串数组中取出元素内容，通过Student类的有参构造方法封装为对象 5. 调用对象getXxx方法，取出数据并打印。 */ public static void main(String[] args) { // 2. 键盘录入一个字符串，用 Scanner 实现 Scanner sc = new Scanner(System.in); System.out.println(\"请输入学生信息:\"); String stuInfo = sc.nextLine(); // stuInfo = \"张三,23\"; // 3. 根据逗号切割字符串，得到（张三）（23） String[] sArr = stuInfo.split(\",\"); // System.out.println(sArr[0]); // System.out.println(sArr[1]); // 4. 从得到的字符串数组中取出元素内容，通过Student类的有参构造方法封装为对象 Student stu = new Student(sArr[0],sArr[1]); // 5. 调用对象getXxx方法，取出数据并打印。 System.out.println(stu.getName() + \"...\" + stu.getAge()); } } 1.2.11. 2.12 String方法小结 String类的常用方法 : ​ public boolean equals(Object anObject) 比较字符串的内容，严格区分大小写 ​ public boolean equalsIgnoreCase(String anotherString) 比较字符串的内容，忽略大小写 ​ public int length() 返回此字符串的长度 ​ public char charAt(int index) 返回指定索引处的 char 值 ​ public char[] toCharArray() 将字符串拆分为字符数组后返回 ​ public String substring(int beginIndex, int endIndex) 根据开始和结束索引进行截取，得到新的字符串（包含头，不包含尾） ​ public String substring(int beginIndex) 从传入的索引处截取，截取到末尾，得到新的字符串 ​ public String replace(CharSequence target, CharSequence replacement) 使用新值，将字符串中的旧值替换，得到新的字符串 ​ public String[] split(String regex) 根据传入的规则切割字符串，得到字符串数组 1.3. 3 StringBuilder类 1.3.1. 3.1 StringBuilder类概述 ​ 概述 : StringBuilder 是一个可变的字符串类，我们可以把它看成是一个容器，这里的可变指的是 StringBuilder 对象中的内容是可变的 1.3.2. 3.2 StringBuilder类和String类的区别 String类：内容是不可变的 StringBuilder类：内容是可变的 1.3.3. 3.3StringBuilder类的构造方法 常用的构造方法 方法名 说明 public StringBuilder() 创建一个空白可变字符串对象，不含有任何内容 public StringBuilder(String str) 根据字符串的内容，来创建可变字符串对象 示例代码 public class StringBuilderDemo01 { public static void main(String[] args) { //public StringBuilder()：创建一个空白可变字符串对象，不含有任何内容 StringBuilder sb = new StringBuilder(); System.out.println(\"sb:\" + sb); System.out.println(\"sb.length():\" + sb.length()); //public StringBuilder(String str)：根据字符串的内容，来创建可变字符串对象 StringBuilder sb2 = new StringBuilder(\"hello\"); System.out.println(\"sb2:\" + sb2); System.out.println(\"sb2.length():\" + sb2.length()); } } 1.3.4. 3.4 StringBuilder常用的成员方法 添加和反转方法 | 方法名 | 说明 | | --------------------------------------- | ------------------------ | | public StringBuilder append(任意类型) | 添加数据，并返回对象本身 | | public StringBuilder reverse() | 返回相反的字符序列 | 示例代码 public class StringBuilderDemo01 { public static void main(String[] args) { //创建对象 StringBuilder sb = new StringBuilder(); //public StringBuilder append(任意类型)：添加数据，并返回对象本身 // StringBuilder sb2 = sb.append(\"hello\"); // // System.out.println(\"sb:\" + sb); // System.out.println(\"sb2:\" + sb2); // System.out.println(sb == sb2); // sb.append(\"hello\"); // sb.append(\"world\"); // sb.append(\"java\"); // sb.append(100); //链式编程 sb.append(\"hello\").append(\"world\").append(\"java\").append(100); System.out.println(\"sb:\" + sb); //public StringBuilder reverse()：返回相反的字符序列 sb.reverse(); System.out.println(\"sb:\" + sb); } } 1.3.5. 3.5StringBuilder和String相互转换【应用】 StringBuilder转换为String ​ public String toString()：通过 toString() 就可以实现把 StringBuilder 转换为 String String转换为StringBuilder ​ public StringBuilder(String s)：通过构造方法就可以实现把 String 转换为 StringBuilder 示例代码 public class StringBuilderDemo02 { public static void main(String[] args) { /* //StringBuilder 转换为 String StringBuilder sb = new StringBuilder(); sb.append(\"hello\"); //String s = sb; //这个是错误的做法 //public String toString()：通过 toString() 就可以实现把 StringBuilder 转换为 String String s = sb.toString(); System.out.println(s); */ //String 转换为 StringBuilder String s = \"hello\"; //StringBuilder sb = s; //这个是错误的做法 //public StringBuilder(String s)：通过构造方法就可以实现把 String 转换为 StringBuilder StringBuilder sb = new StringBuilder(s); System.out.println(sb); } } 1.3.6. 3.6 StringBuilder拼接字符串案例 案例需求 : ​ 定义一个方法，把 int 数组中的数据按照指定的格式拼接成一个字符串返回，调用该方法， ​ 并在控制台输出结果。例如，数组为int[] arr = {1,2,3}; ，执行方法后的输出结果为：[1, 2, 3] 实现步骤 : 定义一个 int 类型的数组，用静态初始化完成数组元素的初始化 定义一个方法，用于把 int 数组中的数据按照指定格式拼接成一个字符串返回。 返回值类型 String，参数列表 int[] arr 在方法中用 StringBuilder 按照要求进行拼接，并把结果转成 String 返回 调用方法，用一个变量接收结果 输出结果 代码实现 : /* 思路： 1:定义一个 int 类型的数组，用静态初始化完成数组元素的初始化 2:定义一个方法，用于把 int 数组中的数据按照指定格式拼接成一个字符串返回。 返回值类型 String，参数列表 int[] arr 3:在方法中用 StringBuilder 按照要求进行拼接，并把结果转成 String 返回 4:调用方法，用一个变量接收结果 5:输出结果 */ public class StringBuilderTest01 { public static void main(String[] args) { //定义一个 int 类型的数组，用静态初始化完成数组元素的初始化 int[] arr = {1, 2, 3}; //调用方法，用一个变量接收结果 String s = arrayToString(arr); //输出结果 System.out.println(\"s:\" + s); } //定义一个方法，用于把 int 数组中的数据按照指定格式拼接成一个字符串返回 /* 两个明确： 返回值类型：String 参数：int[] arr */ public static String arrayToString(int[] arr) { //在方法中用 StringBuilder 按照要求进行拼接，并把结果转成 String 返回 StringBuilder sb = new StringBuilder(); sb.append(\"[\"); for(int i=0; i Copyright © MISIN 2022 | 豫ICP备2021006345号-1 all right reserved，powered by Gitbook该文件修订时间： 2022-11-10 13:40:01 "},"1.JAVA基础/day09 ArrayList集合&学生管理系统.html":{"url":"1.JAVA基础/day09 ArrayList集合&学生管理系统.html","title":"day09 ArrayList集合&学生管理系统","keywords":"","body":"1.1. 1.ArrayList1.1.1. 1.1 -ArrayList的构造方法和添加方法1.1.2. 1.2ArrayList类常用方法【应用】1.1.3. 1.3 ArrayList存储字符串并遍历1.1.4. 1.4 ArrayList存储学生对象并遍历1.1.5. 1.5 键盘录入学生信息到集合1.2. 2. 学生管理系统1.2.1. 2.1 学生管理系统实现步骤1.2.2. 2.2 学生类的定义1.2.3. 2.3 测试类的定义1.1. 1.ArrayList 集合和数组的区别 : ​ 共同点：都是存储数据的容器 ​ 不同点：数组的容量是固定的，集合的容量是可变的 1.1.1. 1.1 -ArrayList的构造方法和添加方法 public ArrayList() 创建一个空的集合对象 public boolean add(E e) 将指定的元素追加到此集合的末尾 public void add(int index,E element) 在此集合中的指定位置插入指定的元素 ArrayList ： ​ 可调整大小的数组实现 ​ : 是一种特殊的数据类型，泛型。 怎么用呢 ? ​ 在出现E的地方我们使用引用数据类型替换即可 ​ 举例：ArrayList, ArrayList 1.1.2. 1.2ArrayList类常用方法【应用】 成员方法 : public boolean remove(Object o) 删除指定的元素，返回删除是否成功 public E remove(int index) 删除指定索引处的元素，返回被删除的元素 public E set(int index,E element) 修改指定索引处的元素，返回被修改的元素 public E get(int index) 返回指定索引处的元素 public int size() 返回集合中的元素的个数 示例代码 : public class ArrayListDemo02 { public static void main(String[] args) { //创建集合 ArrayList array = new ArrayList(); //添加元素 array.add(\"hello\"); array.add(\"world\"); array.add(\"java\"); //public boolean remove(Object o)：删除指定的元素，返回删除是否成功 // System.out.println(array.remove(\"world\")); // System.out.println(array.remove(\"javaee\")); //public E remove(int index)：删除指定索引处的元素，返回被删除的元素 // System.out.println(array.remove(1)); //IndexOutOfBoundsException // System.out.println(array.remove(3)); //public E set(int index,E element)：修改指定索引处的元素，返回被修改的元素 // System.out.println(array.set(1,\"javaee\")); //IndexOutOfBoundsException // System.out.println(array.set(3,\"javaee\")); //public E get(int index)：返回指定索引处的元素 // System.out.println(array.get(0)); // System.out.println(array.get(1)); // System.out.println(array.get(2)); //System.out.println(array.get(3)); //？？？？？？ 自己测试 //public int size()：返回集合中的元素的个数 System.out.println(array.size()); //输出集合 System.out.println(\"array:\" + array); } } 1.1.3. 1.3 ArrayList存储字符串并遍历 案例需求 : ​ 创建一个存储字符串的集合，存储3个字符串元素，使用程序实现在控制台遍历该集合 实现步骤 : 1:创建集合对象 2:往集合中添加字符串对象 3:遍历集合，首先要能够获取到集合中的每一个元素，这个通过get(int index)方法实现 4:遍历集合，其次要能够获取到集合的长度，这个通过size()方法实现 5:遍历集合的通用格式 代码实现 : /* 思路： 1:创建集合对象 2:往集合中添加字符串对象 3:遍历集合，首先要能够获取到集合中的每一个元素，这个通过get(int index)方法实现 4:遍历集合，其次要能够获取到集合的长度，这个通过size()方法实现 5:遍历集合的通用格式 */ public class ArrayListTest01 { public static void main(String[] args) { //创建集合对象 ArrayList array = new ArrayList(); //往集合中添加字符串对象 array.add(\"刘正风\"); array.add(\"左冷禅\"); array.add(\"风清扬\"); //遍历集合，其次要能够获取到集合的长度，这个通过size()方法实现 // System.out.println(array.size()); //遍历集合的通用格式 for(int i=0; i 1.1.4. 1.4 ArrayList存储学生对象并遍历 案例需求 : ​ 创建一个存储学生对象的集合，存储3个学生对象，使用程序实现在控制台遍历该集合 实现步骤 : ​ 1:定义学生类 ​ 2:创建集合对象 ​ 3:创建学生对象 ​ 4:添加学生对象到集合中 ​ 5:遍历集合，采用通用遍历格式实现 代码实现 : /* 思路： 1:定义学生类 2:创建集合对象 3:创建学生对象 4:添加学生对象到集合中 5:遍历集合，采用通用遍历格式实现 */ public class ArrayListTest02 { public static void main(String[] args) { //创建集合对象 ArrayList array = new ArrayList<>(); //创建学生对象 Student s1 = new Student(\"林青霞\", 30); Student s2 = new Student(\"风清扬\", 33); Student s3 = new Student(\"张曼玉\", 18); //添加学生对象到集合中 array.add(s1); array.add(s2); array.add(s3); //遍历集合，采用通用遍历格式实现 for (int i = 0; i 1.1.5. 1.5 键盘录入学生信息到集合 案例需求 : ​ 创建一个存储学生对象的集合，存储3个学生对象，使用程序实现在控制台遍历该集合 ​ 学生的姓名和年龄来自于键盘录入 实现步骤 : ​ 1:定义学生类，为了键盘录入数据方便，把学生类中的成员变量都定义为String类型 ​ 2:创建集合对象 ​ 3:键盘录入学生对象所需要的数据 ​ 4:创建学生对象，把键盘录入的数据赋值给学生对象的成员变量 ​ 5:往集合中添加学生对象 ​ 6:遍历集合，采用通用遍历格式实现 代码实现 : /* 思路： 1:定义学生类，为了键盘录入数据方便，把学生类中的成员变量都定义为String类型 2:创建集合对象 3:键盘录入学生对象所需要的数据 4:创建学生对象，把键盘录入的数据赋值给学生对象的成员变量 5:往集合中添加学生对象 6:遍历集合，采用通用遍历格式实现 */ public class ArrayListTest { public static void main(String[] args) { //创建集合对象 ArrayList array = new ArrayList(); //为了提高代码的复用性，我们用方法来改进程序 addStudent(array); addStudent(array); addStudent(array); //遍历集合，采用通用遍历格式实现 for (int i = 0; i array */ public static void addStudent(ArrayList array) { //键盘录入学生对象所需要的数据 Scanner sc = new Scanner(System.in); System.out.println(\"请输入学生姓名:\"); String name = sc.nextLine(); System.out.println(\"请输入学生年龄:\"); String age = sc.nextLine(); //创建学生对象，把键盘录入的数据赋值给学生对象的成员变量 Student s = new Student(); s.setName(name); s.setAge(age); //往集合中添加学生对象 array.add(s); } } 1.2. 2. 学生管理系统 1.2.1. 2.1 学生管理系统实现步骤 案例需求 ​ 针对目前我们的所学内容，完成一个综合案例：学生管理系统！该系统主要功能如下： ​ 添加学生：通过键盘录入学生信息，添加到集合中 ​ 删除学生：通过键盘录入要删除学生的学号，将该学生对象从集合中删除 ​ 修改学生：通过键盘录入要修改学生的学号，将该学生对象其他信息进行修改 ​ 查看学生：将集合中的学生对象信息进行展示 ​ 退出系统：结束程序 实现步骤 定义学生类，包含以下成员变量 学生类： Student成员变量： ​ 学号：sid ​ 姓名：name ​ 年龄：age ​ 生日：birthday ​ 构造方法： ​ 无参构造 ​ 带四个参数的构造成员方法： ​ 每个成员变量对应给出get/set方法 学生管理系统主界面的搭建步骤 2.1 用输出语句完成主界面的编写 2.2 用Scanner实现键盘录入数据 2.3 用switch语句完成操作的选择 2.4 用循环完成再次回到主界面 学生管理系统的添加学生功能实现步骤 3.1 用键盘录入选择添加学生 3.2 定义一个方法，用于添加学生 ​ 显示提示信息，提示要输入何种信息 ​ 键盘录入学生对象所需要的数据 ​ 创建学生对象，把键盘录入的数据赋值给学生对象的成员变量 ​ 将学生对象添加到集合中（保存） ​ 给出添加成功提示 3.3 调用方法 学生管理系统的查看学生功能实现步骤 4.1 用键盘录入选择查看所有学生信息 4.2 定义一个方法，用于查看学生信息 ​ 显示表头信息 ​ 将集合中数据取出按照对应格式显示学生信息，年龄显示补充“岁” 4.3 调用方法 学生管理系统的删除学生功能实现步骤 5.1 用键盘录入选择删除学生信息 5.2 定义一个方法，用于删除学生信息 ​ 显示提示信息 ​ 键盘录入要删除的学生学号 ​ 调用getIndex方法，查找该学号在集合的索引 ​ 如果索引为-1，提示信息不存在 ​ 如果索引不是-1，调用remove方法删除并提示删除成功 5.3 调用方法 学生管理系统的修改学生功能实现步骤 6.1 用键盘录入选择修改学生信息 6.2 定义一个方法，用于修改学生信息 ​ 显示提示信息 ​ 键盘录入要修改的学生学号 ​ 调用getIndex方法，查找该学号在集合的索引 ​ 如果索引为-1，提示信息不存在 ​ 如果索引不是-1，键盘录入要修改的学生信息 ​ 集合修改对应的学生信息 ​ 给出修改成功提示 6.3 调用方法 退出系统 使用System.exit(0);退出JVM 1.2.2. 2.2 学生类的定义 package com.itheima.domain; public class Student { private String sid; // 学号 private String name; // 姓名 private int age; // 年龄 private String birthday; // 生日 public Student() { } public Student(String sid, String name, int age, String birthday) { this.sid = sid; this.name = name; this.age = age; this.birthday = birthday; } public String getSid() { return sid; } public void setSid(String sid) { this.sid = sid; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public String getBirthday() { return birthday; } public void setBirthday(String birthday) { this.birthday = birthday; } } 1.2.3. 2.3 测试类的定义 package com.itheima.test; import com.itheima.domain.Student; import java.util.ArrayList; import java.util.Scanner; public class StudentManager { public static void main(String[] args) { Scanner sc = new Scanner(System.in); // 创建集合容器对象 ArrayList list = new ArrayList<>(); lo: while (true) { // 1. 搭建主界面菜单 System.out.println(\"--------欢迎来到学生管理系统--------\"); System.out.println(\"1 添加学生\"); System.out.println(\"2 删除学生\"); System.out.println(\"3 修改学生\"); System.out.println(\"4 查看学生\"); System.out.println(\"5 退出\"); System.out.println(\"请输入您的选择:\"); String choice = sc.next(); switch (choice) { case \"1\": //System.out.println(\"添加学生\"); addStudent(list); break; case \"2\": //System.out.println(\"删除学生\"); deleteStudent(list); break; case \"3\": //System.out.println(\"修改学生\"); updateStudent(list); break; case \"4\": // System.out.println(\"查看学生\"); queryStudents(list); break; case \"5\": System.out.println(\"感谢您的使用\"); break lo; default: System.out.println(\"您的输入有误\"); break; } } } // 修改学生的方法 public static void updateStudent(ArrayList list) { System.out.println(\"请输入您要修改的学生学号:\"); Scanner sc = new Scanner(System.in); String updateSid = sc.next(); // 3. 调用getIndex方法, 查找该学号在集合中出现的索引位置 int index = getIndex(list,updateSid); // 4. 根据索引判断, 学号在集合中是否存在 if(index == -1){ // 不存在: 给出提示 System.out.println(\"查无信息, 请重新输入\"); }else{ // 存在: 接收新的学生信息 System.out.println(\"请输入新的学生姓名:\"); String name = sc.next(); System.out.println(\"请输入新的学生年龄:\"); int age = sc.nextInt(); System.out.println(\"请输入新的学生生日:\"); String birthday = sc.next(); // 封装为新的学生对象 Student stu = new Student(updateSid, name, age, birthday); // 调用集合的set方法, 完成修改 list.set(index, stu); System.out.println(\"修改成功!\"); } } // 删除学生的方法 public static void deleteStudent(ArrayList list) { // 1. 给出提示信息 (请输入您要删除的学号) System.out.println(\"请输入您要删除的学生学号:\"); // 2. 键盘接收要删除的学号 Scanner sc = new Scanner(System.in); String deleteSid = sc.next(); // 3. 调用getIndex方法, 查找该学号在集合中出现的索引位置 int index = getIndex(list,deleteSid); // 4. 根据索引判断, 学号在集合中是否存在 if(index == -1){ // 不存在: 给出提示 System.out.println(\"查无信息, 请重新输入\"); }else{ // 存在:删除 list.remove(index); System.out.println(\"删除成功!\"); } } // 查看学生的方法 public static void queryStudents(ArrayList list) { // 1. 判断集合中是否存在数据, 如果不存在直接给出提示 if(list.size() == 0){ System.out.println(\"无信息, 请添加后重新查询\"); return; } // 2. 存在: 展示表头数据 System.out.println(\"学号\\t\\t姓名\\t年龄\\t生日\"); // 3. 遍历集合, 获取每一个学生对象的信息, 打印在控制台 for (int i = 0; i list) { Scanner sc = new Scanner(System.in); // 1. 给出录入的提示信息 String sid; while(true){ System.out.println(\"请输入学号:\"); sid = sc.next(); int index = getIndex(list, sid); if(index == -1){ // sid不存在, 学号可以使用 break; } } System.out.println(\"请输入姓名:\"); String name = sc.next(); System.out.println(\"请输入年龄:\"); int age = sc.nextInt(); System.out.println(\"请输入生日:\"); String birthday = sc.next(); // 2. 将键盘录入的信息封装为学生对象 Student stu = new Student(sid,name,age,birthday); // 3. 将封装好的学生对象, 添加到集合容器当中 list.add(stu); // 4. 给出添加成功的提示信息 System.out.println(\"添加成功!\"); } /* getIndex : 接收一个集合对象, 接收一个学生学号 查找这个学号, 在集合中出现的索引位置 */ public static int getIndex(ArrayList list, String sid){ // 1. 假设传入的学号, 在集合中不存在 int index = -1; // 2. 遍历集合, 获取每一个学生对象, 准备进行查找 for (int i = 0; i Copyright © MISIN 2022 | 豫ICP备2021006345号-1 all right reserved，powered by Gitbook该文件修订时间： 2020-06-15 17:54:16 "},"1.JAVA基础/day10Git.html":{"url":"1.JAVA基础/day10Git.html","title":"Day 10 Git","keywords":"","body":"1.1. 1.Git介绍1.1.1. 1.1版本控制(理解)1.1.2. 1.2开发中存在的问题(理解)1.1.3. 1.3SVN版本控制(理解)1.1.4. 1.4Git版本控制(理解)1.2. 2.Git下载和安装1.2.1. 2.1Git的下载(应用)1.2.2. 2.2Git的安装(应用)1.2.3. 2.3TortoiseGit的安装(应用)1.3. 3.Git操作入门1.3.1. 3.1Git基本工作流程(理解)1.3.2. 3.2Git命令行操作(应用)1.3.3. 3.3Git图形化工具操作(理解)1.4. 4.Git版本管理1.4.1. 4.1历史版本切换(理解)1.4.2. 4.2分支管理介绍(理解)1.4.3. 4.3分支管理操作(应用)1.5. 5.远程仓库1.5.1. 5.1远程仓库工作流程(理解)1.5.2. 5.2远程仓库平台介绍(理解)1.5.3. 5.3码云的注册(应用)1.5.4. 5.4先有本地项目,远程为空(应用)1.5.5. 5.5先有远程仓库,本地为空(应用)1.5.6. 5.6代码冲突(应用)1.6. 6.IDEA集成Git1.6.1. 6.1IDEA中配置Git(应用)1.6.2. 6.2创建本地仓库(应用)1.6.3. 6.3版本切换(应用)1.6.4. 6.4分支管理(应用)1.6.5. 6.5本地仓库推送到远程仓库(应用)1.6.6. 6.6远程仓库克隆到本地仓库(应用)1.1. 1.Git介绍 1.1.1. 1.1版本控制(理解) 无论是代码编写，还是文档编写，我们都会遇到对文档内容反复修改的情况 1.1.2. 1.2开发中存在的问题(理解) 程序员小明负责的模块就要完成了，就在即将提交发布之前的一瞬间，电脑突然蓝屏，硬盘光荣下岗！ 几个月来的努力付之东流 ​ 老王需要在项目中加入一个很复杂的功能，一边尝试，一边修改代码，就这样摸索了一个星期。 可是这被改得面目全非的代码已经回不到从前了。 小明和老王先后从文件服务器上下载了同一个文件 因项目中Bug过多，导致项目进度拖延，项目经理老徐因此被骂，但不清楚Bug是手下哪一个程序员写的 开发中要解决的问题 代码备份 版本控制 协同工作 责任追溯 1.1.3. 1.3SVN版本控制(理解) SVN是集中式版本控制系统，版本库是集中放在中央服务器的，而开发人员工作的时候，用的都是自己的电脑， 所以首先要从中央服务器下载最新的版本，然后开发，开发完后，需要把自己开发的代码提交到中央服务器。 服务器单点故障 将会导致所有人员无法工作 而服务器硬盘损坏 这意味着，你可能失去了该项目的所有历史记录，这是毁灭性的。 1.1.4. 1.4Git版本控制(理解) Git是在2005年，Linux系统的创建者Linus Torvalds,为了帮助全球的开发者，维护Linux系统内核的开发 而开发了自己的开源分布式版本控制工具,分为两种类型的仓库：本地仓库和远程仓库。 每一个客户端都保存了完整的历史记录 服务器的故障，都可以通过客户端的记录得以恢复。 1.2. 2.Git下载和安装 1.2.1. 2.1Git的下载(应用) 官网下载地址：https://git-scm.com/downloads 1.2.2. 2.2Git的安装(应用) 双击安装包，进入安装向导界面 指定安装目录 一路next下一步 等待安装 安装完成 安装完成后在电脑桌面（也可以是其他目录）点击右键，如果能够看到如下两个菜单则说明Git安装成功。 运行Git命令客户端，使用git —version 命令，可以查看git版本 1.2.3. 2.3TortoiseGit的安装(应用) 双击安装包，进入安装向导界面 一路next下一步 指定安装目录 安装 配置 安装TortoiseGit中文语言包,一路next即可 配置TortoiseGit中文语言 1.3. 3.Git操作入门 1.3.1. 3.1Git基本工作流程(理解) 本地仓库 1.3.2. 3.2Git命令行操作(应用) git常用命令 | 命令 | 作用 | | ——————— | ————————— | | git init | 初始化，创建 git 仓库 | | git status | 查看 git 状态 （文件是否进行了添加、提交操作） | | git add 文件名 | 添加，将指定文件添加到暂存区 | | git commit -m ‘提交信息’ | 提交，将暂存区文件提交到历史仓库 | | git log | 查看日志（ git 提交的历史日志） | 操作步骤 创建工作目录、初始化本地 git 仓库 新建一个 test.txt 文件（暂不执行添加操作） 使用 status 命令，查看状态 使用 add 命令添加，并查看状态 使用 commit 命令，提交到本地历史仓库 使用 log 命令，查看日志 修改 test.txt 文件 添加并提交，查看日志 1.3.3. 3.3Git图形化工具操作(理解) 创建工作目录、初始化本地 git 仓库 新建一个 test.txt 文件（暂不执行添加操作） 选中文件右键，选择TortoiseGit，之后选择添加 空白处右键,Git提交,提交到本地历史仓库 空白处右键,TortoiseGit,显示日志,可以产看日志信息 修改 test.txt 文件 添加并提交，查看日志 1.4. 4.Git版本管理 1.4.1. 4.1历史版本切换(理解) 准备动作 查看 my_project 的 log 日志 git reflog ：可以查看所有分支的所有操作记录（包括已经被删除的 commit 记录的操作） 增加一次新的修改记录 需求: 将代码切换到第二次修改的版本 指令：git reset —hard 版本唯一索引值 1.4.2. 4.2分支管理介绍(理解) 分支 由每次提交的代码，串成的一条时间线 使用分支意味着你可以把你的工作从开发主线上分离开来,以免影响开发主线 分支的使用场景 周期较长的模块开发 假设你准备开发一个新功能，但是需要一个月才能完成 第一周写了20%的代码，突然发现原来已经写好的功能出现了一个严重的Bug 那现在就需要放下手中的新功能，去修复Bug 但这20%的代码不能舍弃，并且也担心丢失，这就需要开启一个新的版本控制。 尝试性的模块开发 业务人员给我们提出了一个需求，经过我们的思考和分析 该需求应该可以使用技术手段进行实现。 但是我们还不敢确定，我们就可以去创建一个分支基于分支进行尝试性开发。 分支工作流程 Master: 指向提交的代码版本 Header: 指向当前所使用的的分支 1.4.3. 4.3分支管理操作(应用) 创建和切换 创建命令：git branch 分支名 切换命令：git checkout 分支名 新分支添加文件 查看文件命令：ls 总结：不同分支之间的关系是平行的关系，不会相互影响 合并分支 合并命令：git merge 分支名 删除分支 删除命令：git branch -d 分支名 查看分支列表 查看命令：git branch 1.5. 5.远程仓库 1.5.1. 5.1远程仓库工作流程(理解) 1.5.2. 5.2远程仓库平台介绍(理解) GitHub 域名：https://github.com 介绍：GitHub是全球最大的开源项目托管平台，俗称大型程序员社区化交友网站 ​ 各类好玩有趣的开源项目，只有想不到，没有找不到。 码云 域名：https://gitee.com 介绍：码云是全国最大的开源项目托管平台，良心平台，速度快，提供免费私有库 1.5.3. 5.3码云的注册(应用) 1.5.4. 5.4先有本地项目,远程为空(应用) 步骤 创建本地仓库 创建或修改文件，添加（add）文件到暂存区，提交（commit）到本地仓库 创建远程仓库 推送到远程仓库 创建远程仓库 生成SSH公钥 推送代码之前，需要先配置SSH公钥 生成SSH公钥步骤 设置Git账户 git config user.name（查看git账户） git config user.email（查看git邮箱） git config —global user.name “账户名”（设置全局账户名） git config —global user.email “邮箱”（设置全局邮箱） cd ~/.ssh（查看是否生成过SSH公钥） 生成SSH公钥 生成命令: ssh-keygen –t rsa –C “邮箱” ( 注意：这里需要敲3次回车) 查看命令: cat ~/.ssh/id-rsa.pub 设置账户公钥 公钥测试 命令: ssh -T git@gitee.com 推送到远程仓库 步骤 为远程仓库的URL（网址），自定义仓库名称 推送 命令 git remote add 远程名称 远程仓库URL git push -u 仓库名称 分支名 1.5.5. 5.5先有远程仓库,本地为空(应用) 步骤 将远程仓库的代码，克隆到本地仓库 克隆命令：git clone 仓库地址 创建新文件，添加并提交到本地仓库 推送至远程仓库 项目拉取更新 拉取命令：git pull 远程仓库名 分支名 1.5.6. 5.6代码冲突(应用) 产生原因: 两个程序员操作同一个文件,其中一个程序员在修改文件后,push到远程仓库,另一个程序员应该先pull将最新的代码更新到本地仓库后,在修改代码,之后push到远程仓库,结果他没有先pull将最新的代码更新到本地仓库,而是直接将自己的代码push到远程仓库,这样就可能会导致代码冲突 如何解决冲突 >>>>>>中间的内容,就是冲突部分 修改冲突行，保存，即可解决冲突。 重新add冲突文件并commit到本地仓库，重新push到远程 1.6. 6.IDEA集成Git 1.6.1. 6.1IDEA中配置Git(应用) File -> Settings Version Control -> Git -> 指定git.exe存放目录 点击Test测试 1.6.2. 6.2创建本地仓库(应用) VCS->Import into Version Control->Create Git Repository 选择工程所在的目录,这样就创建好本地仓库了 点击git后边的对勾,将当前项目代码提交到本地仓库 注意: 项目中的配置文件不需要提交到本地仓库中,提交时,忽略掉即可 1.6.3. 6.3版本切换(应用) 方式一: 控制台Version Control->Log->Reset Current Branch...->Reset 这种切换的特点是会抛弃原来的提交记录 方式二:控制台Version Control->Log->Revert Commit->Merge->处理代码->commit 这种切换的特点是会当成一个新的提交记录,之前的提交记录也都保留 ​ 1.6.4. 6.4分支管理(应用) 创建分支 VCS->Git->Branches->New Branch->给分支起名字->ok 切换分支 idea右下角Git->选择要切换的分支->checkout 合并分支 VCS->Git->Merge changes->选择要合并的分支->merge 处理分支中的代码 删除分支 idea右下角->选中要删除的分支->Delete 1.6.5. 6.5本地仓库推送到远程仓库(应用) VCS->Git->Push->点击master Define remote 将远程仓库的路径复制过来->Push 1.6.6. 6.6远程仓库克隆到本地仓库(应用) File->Close Project->Checkout from Version Control->Git->指定远程仓库的路径->指定本地存放的路径->clone Copyright © MISIN 2022 | 豫ICP备2021006345号-1 all right reserved，powered by Gitbook该文件修订时间： 2022-11-10 13:39:18 "},"1.JAVA基础/day11-分类和static.html":{"url":"1.JAVA基础/day11-分类和static.html","title":"day11-分类和static","keywords":"","body":"1.1. 1.案例驱动模式1.1.1. 1.1案例驱动模式概述 (理解)1.1.2. 1.2案例驱动模式的好处 (理解)1.2. 2.分类思想1.2.1. 2.1分类思想概述 (理解)1.2.2. 2.2黑马信息管理系统 (理解)1.3. 3.分包思想1.3.1. 3.1分包思想概述 (理解)1.3.2. 3.2包的概述 (记忆)1.3.3. 3.3包的注意事项 (理解)1.3.4. 3.4类与类之间的访问 (理解)1.4. 4.黑马信息管理系统1.4.1. 4.1系统介绍 (理解)1.4.2. 4.2学生管理系统 (应用)1.4.3. 4.3老师管理系统 (应用)1.5. 5.static关键字1.5.1. 5.1static关键字概述 (理解)1.5.2. 5.2static修饰的特点 (记忆)1.5.3. 5.3static关键字注意事项 (理解)1.1. 1.案例驱动模式 1.1.1. 1.1案例驱动模式概述 (理解) 通过我们已掌握的知识点,先实现一个案例,然后找出这个案例中,存在的一些问题,在通过新知识点解决问题 1.1.2. 1.2案例驱动模式的好处 (理解) 解决重复代码过多的冗余,提高代码的复用性 解决业务逻辑聚集紧密导致的可读性差,提高代码的可读性 解决代码可维护性差,提高代码的维护性 1.2. 2.分类思想 1.2.1. 2.1分类思想概述 (理解) 分工协作,专人干专事 1.2.2. 2.2黑马信息管理系统 (理解) Student类 标准学生类,封装键盘录入的学生信息(id , name , age , birthday) StudentDao类 Dao : (Data Access Object 缩写) 用于访问存储数据的数组或集合 StudentService类 用来进行业务逻辑的处理(例如: 判断录入的id是否存在) StudentController类 和用户打交道(接收用户需求,采集用户信息,打印数据到控制台) 1.3. 3.分包思想 1.3.1. 3.1分包思想概述 (理解) 如果将所有的类文件都放在同一个包下,不利于管理和后期维护,所以,对于不同功能的类文件,可以放在不同的包下进行管理 1.3.2. 3.2包的概述 (记忆) 包 本质上就是文件夹 创建包 多级包之间使用 “ . “ 进行分割 多级包的定义规范：公司的网站地址翻转(去掉www) 比如：黑马程序员的网站址为www.itheima.com 后期我们所定义的包的结构就是：com.itheima.其他的包名 包的命名规则 字母都是小写 1.3.3. 3.3包的注意事项 (理解) package语句必须是程序的第一条可执行的代码 package语句在一个java文件中只能有一个 如果没有package,默认表示无包名 1.3.4. 3.4类与类之间的访问 (理解) 同一个包下的访问 不需要导包，直接使用即可 不同包下的访问 1.import 导包后访问 2.通过全类名（包名 + 类名）访问 注意：import 、package 、class 三个关键字的摆放位置存在顺序关系 package 必须是程序的第一条可执行的代码 import 需要写在 package 下面 class 需要在 import 下面 1.4. 4.黑马信息管理系统 1.4.1. 4.1系统介绍 (理解) 1.4.2. 4.2学生管理系统 (应用) 4.2.1需求说明 添加学生: 键盘录入学生信息(id，name，age，birthday) 使用数组存储学生信息,要求学生的id不能重复 删除学生: 键盘录入要删除学生的id值,将该学生从数组中移除,如果录入的id在数组中不存在,需要重新录入 修改学生: 键盘录入要修改学生的id值和修改后的学生信息 将数组中该学生的信息修改,如果录入的id在数组中不存在,需要重新录入 查询学生: 将数组中存储的所有学生的信息输出到控制台 4.2.2实现步骤 环境搭建实现步骤 | 包 | 存储的类 | 作用 | | ————————————— | -——————— | ——————— | | com.itheima.edu.info.manager.domain | Student.java | 封装学生信息 | | com.itheima.edu.info.manager.dao | StudentDao.java | 访问存储数据的数组，进行赠删改查（库管） | | com.itheima.edu.info.manager.service | StudentService.java | 业务的逻辑处理（业务员） | | com.itheima.edu.info.manager.controller | StudentController.java | 和用户打交道（客服接待） | | com.itheima.edu.info.manager.entry | InfoManagerEntry.java | 程序的入口类，提供一个main方法 | 菜单搭建实现步骤 需求 黑马管理系统菜单搭建 学生管理系统菜单搭建 实现步骤 展示欢迎页面,用输出语句完成主界面的编写 获取用户的选择,用Scanner实现键盘录入数据 根据用户的选择执行对应的操作,用switch语句完成操作的选择 添加功能实现步骤 添加功能优化:判断id是否存在 查询功能实现步骤 删除功能实现步骤 修改功能实现步骤 系统优化 把updateStudent和deleteStudentById中录入学生id代码抽取到一个方法(inputStudentId)中 该方法的主要作用就是录入学生的id，方法的返回值为String类型 把addStudent和updateStudent中录入学生信息的代码抽取到一个方法(inputStudentInfo)中 该方法的主要作用就是录入学生的信息，并封装为学生对象，方法的返回值为Student类型 4.2.3代码实现 学生类 public class Student { private String id; private String name; private String age; private String birthday; String address; public Student() { } public Student(String id, String name, String age, String birthday) { this.id = id; this.name = name; this.age = age; this.birthday = birthday; } public String getId() { return id; } public void setId(String id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getAge() { return age; } public void setAge(String age) { this.age = age; } public String getBirthday() { return birthday; } public void setBirthday(String birthday) { this.birthday = birthday; } } 程序入口InfoManagerEntry类 public class InfoManagerEntry { public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (true) { // 主菜单搭建 System.out.println(“———欢迎来到黑马信息管理系统———“); System.out.println(“请输入您的选择: 1.学生管理 2.老师管理 3.退出”); String choice = sc.next(); switch (choice) { case “1”: // System.out.println(“学生管理”); // 开启学生管理系统 StudentController studentController = new StudentController(); studentController.start(); break; case “2”: System.out.println(“老师管理”); TeacherController teacherController = new TeacherController(); teacherController.start(); break; case “3”: System.out.println(“感谢您的使用”); // 退出当前正在运行的JVM虚拟机 System.exit(0); break; default: System.out.println(“您的输入有误, 请重新输入”); break; } } } } StudentController类 public class StudentController { // 业务员对象 private StudentService studentService = new StudentService(); private Scanner sc = new Scanner(System.in); // 开启学生管理系统, 并展示学生管理系统菜单 public void start() { //Scanner sc = new Scanner(System.in); studentLoop: while (true) { System.out.println(“———欢迎来到 管理系统———“); System.out.println(“请输入您的选择: 1.添加学生 2.删除学生 3.修改学生 4.查看学生 5.退出”); String choice = sc.next(); switch (choice) { case “1”: // System.out.println(“添加”); addStudent(); break; case “2”: // System.out.println(“删除”); deleteStudentById(); break; case “3”: // System.out.println(“修改”); updateStudent(); break; case “4”: // System.out.println(“查询”); findAllStudent(); break; case “5”: System.out.println(“感谢您使用学生管理系统, 再见!”); break studentLoop; default: System.out.println(“您的输入有误, 请重新输入”); break; } } } // 修改学生方法 public void updateStudent() { String updateId = inputStudentId(); Student newStu = inputStudentInfo(updateId); studentService.updateStudent(updateId, newStu); System.out.println(“修改成功!”); } // 删除学生方法 public void deleteStudentById() { String delId = inputStudentId(); // 3. 调用业务员中的deleteStudentById根据id, 删除学生 studentService.deleteStudentById(delId); // 4. 提示删除成功 System.out.println(“删除成功!”); } // 查看学生方法 public void findAllStudent() { // 1. 调用业务员中的获取方法, 得到学生的对象数组 Student[] stus = studentService.findAllStudent(); // 2. 判断数组的内存地址, 是否为null if (stus == null) { System.out.println(“查无信息, 请添加后重试”); return; } // 3. 遍历数组, 获取学生信息并打印在控制台 System.out.println(“学号\\t\\t姓名\\t年龄\\t生日”); for (int i = 0; i StudentService类 public class StudentService { // 创建StudentDao (库管) private StudentDao studentDao = new StudentDao(); // 添加学生方法 public boolean addStudent(Student stu) { // 2. 将学生对象, 传递给StudentDao 库管中的addStudent方法 // 3. 将返回的boolean类型结果, 返还给StudentController return studentDao.addStudent(stu); } // 判断学号是否存在方法 public boolean isExists(String id) { Student[] stus = studentDao.findAllStudent(); // 假设id在数组中不存在 boolean exists = false; // 遍历数组, 获取每一个学生对象, 准备进行判断 for (int i = 0; i StudentDao类 public class StudentDao { // 创建学生对象数组 private static Student[] stus = new Student[5]; // 添加学生方法 public boolean addStudent(Student stu) { // 2. 添加学生到数组 //2.1 定义变量index为-1，假设数组已经全部存满，没有null的元素 int index = -1; //2.2 遍历数组取出每一个元素，判断是否是null for (int i = 0; i 1.4.3. 4.3老师管理系统 (应用) 4.3.1需求说明 添加老师: 通过键盘录入老师信息(id，name，age，birthday) 使用数组存储老师信息,要求老师的id不能重复 删除老师: 通过键盘录入要删除老师的id值,将该老师从数组中移除,如果录入的id在数组中不存在,需要重新录入 修改老师: 通过键盘录入要修改老师的id值和修改后的老师信息 将数组中该老师的信息修改,如果录入的id在数组中不存在,需要重新录入 查询老师: 将数组中存储的所有老师的信息输出到控制台 4.3.2实现步骤 环境搭建实现步骤 | 包 | 存储的类 | 作用 | | ————————————— | -————————————— | ——————— | | com.itheima.edu.info.manager.domain | Student.java Teacher.java | 封装学生信息 封装老师信息 | | com.itheima.edu.info.manager.dao | StudentDao.java TeacherDao.java | 访问存储数据的数组,进行赠删改查（库管） | | com.itheima.edu.info.manager.service | StudentService.java TeacherService.java | 业务的逻辑处理（业务员） | | com.itheima.edu.info.manager.controller | StudentController.java TeacherController.java | 和用户打交道（客服接待） | | com.itheima.edu.info.manager.entry | InfoManagerEntry.java | 程序的入口类,提供一个main方法 | 菜单搭建实现步骤 展示欢迎页面,用输出语句完成主界面的编写 获取用户的选择,用Scanner实现键盘录入数据 根据用户的选择执行对应的操作,用switch语句完成操作的选择 添加功能实现步骤 查询功能实现步骤 删除功能实现步骤 修改功能实现步骤 系统优化 把updateTeacher和deleteTeacherById中录入老师id代码抽取到一个方法(inputTeacherId)中 该方法的主要作用就是录入老师的id,方法的返回值为String类型 把addTeacher和updateTeacher中录入老师信息的代码抽取到一个方法(inputTeacherInfo)中 该方法的主要作用就是录入老师的信息,并封装为老师对象,方法的返回值为Teacher类型 4.3.3代码实现 老师类 public class Teacher extends Person{ private String id; private String name; private String age; private String birthday; String address; public Teacher() { } public Teacher(String id, String name, String age, String birthday) { this.id = id; this.name = name; this.age = age; this.birthday = birthday; } public String getId() { return id; } public void setId(String id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getAge() { return age; } public void setAge(String age) { this.age = age; } public String getBirthday() { return birthday; } public void setBirthday(String birthday) { this.birthday = birthday; } } TeacherController类 public class TeacherController { private Scanner sc = new Scanner(System.in); private TeacherService teacherService = new TeacherService(); public void start() { teacherLoop: while (true) { System.out.println(\"--------欢迎来到 管理系统--------\"); System.out.println(\"请输入您的选择: 1.添加老师 2.删除老师 3.修改老师 4.查看老师 5.退出\"); String choice = sc.next(); switch (choice) { case \"1\": // System.out.println(\"添加老师\"); addTeacher(); break; case \"2\": // System.out.println(\"删除老师\"); deleteTeacherById(); break; case \"3\": // System.out.println(\"修改老师\"); updateTeacher(); break; case \"4\": // System.out.println(\"查看老师\"); findAllTeacher(); break; case \"5\": System.out.println(\"感谢您使用老师管理系统, 再见!\"); break teacherLoop; default: System.out.println(\"您的输入有误, 请重新输入\"); break; } } } public void updateTeacher() { String id = inputTeacherId(); Teacher newTeacher = inputTeacherInfo(id); // 调用业务员的修改方法 teacherService.updateTeacher(id,newTeacher); System.out.println(\"修改成功\"); } public void deleteTeacherById() { String id = inputTeacherId(); // 2. 调用业务员中的删除方法, 根据id, 删除老师 teacherService.deleteTeacherById(id); // 3. 提示删除成功 System.out.println(\"删除成功\"); } public void findAllTeacher() { // 1. 从业务员中, 获取老师对象数组 Teacher[] teachers = teacherService.findAllTeacher(); // 2. 判断数组中是否有元素 if (teachers == null) { System.out.println(\"查无信息, 请添加后重试\"); return; } // 3. 遍历数组, 取出元素, 并打印在控制台 System.out.println(\"学号\\t\\t姓名\\t年龄\\t生日\"); for (int i = 0; i TeacherService类 public class TeacherService { private TeacherDao teacherDao = new TeacherDao(); public boolean addTeacher(Teacher t) { return teacherDao.addTeacher(t); } public boolean isExists(String id) { // 1. 获取库管对象中的数组 Teacher[] teachers = teacherDao.findAllTeacher(); boolean exists = false; // 2. 遍历数组, 取出每一个元素, 进行判断 for (int i = 0; i TeacherDao类 public class TeacherDao { private static Teacher[] teachers = new Teacher[5]; public boolean addTeacher(Teacher t) { int index = -1; for (int i = 0; i 1.5. 5.static关键字 1.5.1. 5.1static关键字概述 (理解) static 关键字是静态的意思,是Java中的一个修饰符,可以修饰成员方法,成员变量 1.5.2. 5.2static修饰的特点 (记忆) 被类的所有对象共享 是我们判断是否使用静态关键字的条件 随着类的加载而加载，优先于对象存在 对象需要类被加载后，才能创建 可以通过类名调用 也可以通过对象名调用 1.5.3. 5.3static关键字注意事项 (理解) 静态方法只能访问静态的成员 非静态方法可以访问静态的成员，也可以访问非静态的成员 静态方法中是没有this关键字 Copyright © MISIN 2022 | 豫ICP备2021006345号-1 all right reserved，powered by Gitbook该文件修订时间： 2022-11-10 13:37:58 "},"1.JAVA基础/day12-继承.html":{"url":"1.JAVA基础/day12-继承.html","title":"day12-继承","keywords":"","body":"1.1. 1. 继承1.1.1. 1.1 继承的实现（掌握）1.1.2. 1.2 继承的好处和弊端（理解）1.1.3. 1.3. Java中继承的特点（掌握）1.2. 2. 继承中的成员访问特点1.2.1. 2.1 继承中变量的访问特点（掌握）1.2.2. 2.2 super（掌握）1.2.3. 2.3 继承中构造方法的访问特点（理解）1.2.4. 2.4 继承中成员方法的访问特点（掌握）1.2.5. 2.5 super内存图（理解）1.2.6. 2.6 方法重写（掌握）1.2.7. 2.7 方法重写的注意事项（掌握）1.2.8. 2.8 权限修饰符 (理解)1.2.9. 2.9 黑马信息管理系统使用继承改进 (掌握)1.3. 3.抽象类1.3.1. 3.1抽象类的概述（理解）1.3.2. 3.2抽象类的特点（记忆）1.3.3. 3.3抽象类的案例（应用）1.3.4. 3.4模板设计模式1.3.5. 3.5final（应用）1.3.6. 3.6黑马信息管理系统使用抽象类改进 (应用)1.4. 4.代码块1.4.1. 4.1代码块概述 (理解)1.4.2. 4.2代码块分类 (理解)1.4.3. 4.3黑马信息管理系统使用代码块改进 (应用)1.1. 1. 继承 1.1.1. 1.1 继承的实现（掌握） 继承的概念 继承是面向对象三大特征之一，可以使得子类具有父类的属性和方法，还可以在子类中重新定义，以及追加属性和方法 实现继承的格式 继承通过extends实现 格式：class 子类 extends 父类 { } 举例：class Dog extends Animal { } 继承带来的好处 继承可以让类与类之间产生关系，子父类关系，产生子父类后，子类则可以使用父类中非私有的成员。 示例代码 public class Fu { public void show() { System.out.println(“show方法被调用”); } } public class Zi extends Fu { public void method() { System.out.println(“method方法被调用”); } } public class Demo { public static void main(String[] args) { //创建对象，调用方法 Fu f = new Fu(); f.show(); Zi z = new Zi(); z.method(); z.show(); } } 1.1.2. 1.2 继承的好处和弊端（理解） 继承好处 提高了代码的复用性(多个类相同的成员可以放到同一个类中) 提高了代码的维护性(如果方法的代码需要修改，修改一处即可) 继承弊端 继承让类与类之间产生了关系，类的耦合性增强了，当父类发生变化时子类实现也不得不跟着变化，削弱了子类的独立性 继承的应用场景： 使用继承，需要考虑类与类之间是否存在is..a的关系，不能盲目使用继承 is..a的关系：谁是谁的一种，例如：老师和学生是人的一种，那人就是父类，学生和老师就是子类 1.1.3. 1.3. Java中继承的特点（掌握） Java中继承的特点 Java中类只支持单继承，不支持多继承 错误范例：class A extends B, C { } Java中类支持多层继承 多层继承示例代码： public class Granddad { public void drink() { System.out.println(“爷爷爱喝酒”); } } public class Father extends Granddad { public void smoke() { System.out.println(“爸爸爱抽烟”); } } public class Mother { public void dance() { System.out.println(“妈妈爱跳舞”); } } public class Son extends Father { // 此时，Son类中就同时拥有drink方法以及smoke方法 } 1.2. 2. 继承中的成员访问特点 1.2.1. 2.1 继承中变量的访问特点（掌握） 在子类方法中访问一个变量，采用的是就近原则。 子类局部范围找 子类成员范围找 父类成员范围找 如果都没有就报错(不考虑父亲的父亲…) 示例代码 class Fu { int num = 10; } class Zi { int num = 20; public void show(){ int num = 30; System.out.println(num); } } public class Demo1 { public static void main(String[] args) { Zi z = new Zi(); z.show(); // 输出show方法中的局部变量30 } } 1.2.2. 2.2 super（掌握） this&super关键字： this：代表本类对象的引用 super：代表父类存储空间的标识(可以理解为父类对象引用) this和super的使用分别 成员变量： this.成员变量 - 访问本类成员变量 super.成员变量 - 访问父类成员变量 成员方法： this.成员方法 - 访问本类成员方法 super.成员方法 - 访问父类成员方法 构造方法： this(…) - 访问本类构造方法 super(…) - 访问父类构造方法 1.2.3. 2.3 继承中构造方法的访问特点（理解） 注意：子类中所有的构造方法默认都会访问父类中无参的构造方法 ​ 子类会继承父类中的数据，可能还会使用父类的数据。所以，子类初始化之前，一定要先完成父类数据的初始化，原因在于，每一个子类构造方法的第一条语句默认都是：super() 问题：如果父类中没有无参构造方法，只有带参构造方法，该怎么办呢？ 1. 通过使用super关键字去显示的调用父类的带参构造方法 2. 子类通过this去调用本类的其他构造方法,本类其他构造方法再通过super去手动调用父类的带参的构造方法 注意: this(…)super(…) 必须放在构造方法的第一行有效语句，并且二者不能共存 1.2.4. 2.4 继承中成员方法的访问特点（掌握） 通过子类对象访问一个方法 子类成员范围找 父类成员范围找 如果都没有就报错(不考虑父亲的父亲…) 1.2.5. 2.5 super内存图（理解） 对象在堆内存中，会单独存在一块super区域，用来存放父类的数据 1.2.6. 2.6 方法重写（掌握） 1、方法重写概念 子类出现了和父类中一模一样的方法声明（方法名一样，参数列表也必须一样） 2、方法重写的应用场景 当子类需要父类的功能，而功能主体子类有自己特有内容时，可以重写父类中的方法，这样，即沿袭了父类的功能，又定义了子类特有的内容 3、Override注解 用来检测当前的方法，是否是重写的方法，起到【校验】的作用 1.2.7. 2.7 方法重写的注意事项（掌握） 方法重写的注意事项 私有方法不能被重写(父类私有成员子类是不能继承的) 子类方法访问权限不能更低(public > 默认 > 私有) 静态方法不能被重写,如果子类也有相同的方法,并不是重写的父类的方法 示例代码 public class Fu { private void show() { System.out.println(“Fu中show()方法被调用”); } void method() { System.out.println(“Fu中method()方法被调用”); } } public class Zi extends Fu { /* 编译【出错】，子类不能重写父类私有的方法*/ @Override private void show() { System.out.println(“Zi中show()方法被调用”); } /* 编译【出错】，子类重写父类方法的时候，访问权限需要大于等于父类 */ @Override private void method() { System.out.println(“Zi中method()方法被调用”); } /* 编译【通过】，子类重写父类方法的时候，访问权限需要大于等于父类 */ @Override public void method() { System.out.println(“Zi中method()方法被调用”); } } 1.2.8. 2.8 权限修饰符 (理解) 1.2.9. 2.9 黑马信息管理系统使用继承改进 (掌握) 需求 把学生类和老师类共性的内容向上抽取,抽取到出一个 Person 父类,让学生类和老师类继承 Person 类 实现步骤 抽取Person类 优化StudentController类中，inputStudentInfo方法，将setXxx赋值方式，改进为构造方法初始化 注意：直接修改这种操作方式，不符合我们开发中的一个原则 ​ 开闭原则 ( 对扩展开放对修改关闭 ) : 尽量在不更改原有代码的前提下以完成需求 解决：重新创建一个OtherStudentController类 编写新的inputStudentInfo方法 根据StudentController类、OtherStudentController类，向上抽取出BaseStudentController类 再让StudentController类、OtherStudentController类，继承BaseStudentController类 代码实现 Person类及学生类和老师类 public class Person { private String id; private String name; private String age; private String birthday; public Person() { } public Person(String id, String name, String age, String birthday) { this.id = id; this.name = name; this.age = age; this.birthday = birthday; } public String getId() { return id; } public void setId(String id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getAge() { return age; } public void setAge(String age) { this.age = age; } public String getBirthday() { return birthday; } public void setBirthday(String birthday) { this.birthday = birthday; } } // Student类 public class Student extends Person { public Student() { } public Student(String id, String name, String age, String birthday) { super(id, name, age, birthday); } } // Teacher类 public class Teacher extends Person { public Teacher() { } public Teacher(String id, String name, String age, String birthday) { super(id, name, age, birthday); } } BaseStudentController类 public abstract class BaseStudentController { // 业务员对象 private StudentService studentService = new StudentService(); private Scanner sc = new Scanner(System.in); // 开启学生管理系统, 并展示学生管理系统菜单 public void start() { //Scanner sc = new Scanner(System.in); studentLoop: while (true) { System.out.println(\"--------欢迎来到 管理系统--------\"); System.out.println(\"请输入您的选择: 1.添加学生 2.删除学生 3.修改学生 4.查看学生 5.退出\"); String choice = sc.next(); switch (choice) { case \"1\": // System.out.println(\"添加\"); addStudent(); break; case \"2\": // System.out.println(\"删除\"); deleteStudentById(); break; case \"3\": // System.out.println(\"修改\"); updateStudent(); break; case \"4\": // System.out.println(\"查询\"); findAllStudent(); break; case \"5\": System.out.println(\"感谢您使用学生管理系统, 再见!\"); break studentLoop; default: System.out.println(\"您的输入有误, 请重新输入\"); break; } } } // 修改学生方法 public void updateStudent() { String updateId = inputStudentId(); Student newStu = inputStudentInfo(updateId); studentService.updateStudent(updateId, newStu); System.out.println(\"修改成功!\"); } // 删除学生方法 public void deleteStudentById() { String delId = inputStudentId(); // 3. 调用业务员中的deleteStudentById根据id, 删除学生 studentService.deleteStudentById(delId); // 4. 提示删除成功 System.out.println(\"删除成功!\"); } // 查看学生方法 public void findAllStudent() { // 1. 调用业务员中的获取方法, 得到学生的对象数组 Student[] stus = studentService.findAllStudent(); // 2. 判断数组的内存地址, 是否为null if (stus == null) { System.out.println(\"查无信息, 请添加后重试\"); return; } // 3. 遍历数组, 获取学生信息并打印在控制台 System.out.println(\"学号\\t\\t姓名\\t年龄\\t生日\"); for (int i = 0; i StudentController类 public class StudentController extends BaseStudentController { private Scanner sc = new Scanner(System.in); // 键盘录入学生信息 // 开闭原则: 对扩展内容开放, 对修改内容关闭 @Override public Student inputStudentInfo(String id) { System.out.println(\"请输入学生姓名:\"); String name = sc.next(); System.out.println(\"请输入学生年龄:\"); String age = sc.next(); System.out.println(\"请输入学生生日:\"); String birthday = sc.next(); Student stu = new Student(); stu.setId(id); stu.setName(name); stu.setAge(age); stu.setBirthday(birthday); return stu; } } OtherStudentController类 public class OtherStudentController extends BaseStudentController { private Scanner sc = new Scanner(System.in); // 键盘录入学生信息 // 开闭原则: 对扩展内容开放, 对修改内容关闭 @Override public Student inputStudentInfo(String id) { System.out.println(\"请输入学生姓名:\"); String name = sc.next(); System.out.println(\"请输入学生年龄:\"); String age = sc.next(); System.out.println(\"请输入学生生日:\"); String birthday = sc.next(); Student stu = new Student(id,name,age,birthday); return stu; } } 1.3. 3.抽象类 1.3.1. 3.1抽象类的概述（理解） ​ 当我们在做子类共性功能抽取时，有些方法在父类中并没有具体的体现，这个时候就需要抽象类了！ ​ 在Java中，一个没有方法体的方法应该定义为抽象方法，而类中如果有抽象方法，该类必须定义为抽象类！ 1.3.2. 3.2抽象类的特点（记忆） 抽象类和抽象方法必须使用 abstract 关键字修饰 //抽象类的定义 public abstract class 类名 {} //抽象方法的定义 public abstract void eat(); 抽象类中不一定有抽象方法，有抽象方法的类一定是抽象类 抽象类不能实例化 抽象类可以有构造方法 抽象类的子类 ​ 要么重写抽象类中的所有抽象方法 ​ 要么是抽象类 1.3.3. 3.3抽象类的案例（应用） 案例需求 ​ 定义猫类(Cat)和狗类(Dog) ​ 猫类成员方法：eat（猫吃鱼）drink（喝水…） ​ 狗类成员方法：eat（狗吃肉）drink（喝水…） 实现步骤 猫类和狗类中存在共性内容，应向上抽取出一个动物类（Animal） 父类Animal中，无法将 eat 方法具体实现描述清楚，所以定义为抽象方法 抽象方法需要存活在抽象类中，将Animal定义为抽象类 让 Cat 和 Dog 分别继承 Animal，重写eat方法 测试类中创建 Cat 和 Dog 对象，调用方法测试 代码实现 动物类 public abstract class Animal { public void drink(){ System.out.println(\"喝水\"); } public Animal(){ } public abstract void eat(); } 猫类 public class Cat extends Animal { @Override public void eat() { System.out.println(\"猫吃鱼\"); } } 狗类 public class Dog extends Animal { @Override public void eat() { System.out.println(\"狗吃肉\"); } } 测试类 public static void main(String[] args) { Dog d = new Dog(); d.eat(); d.drink(); Cat c = new Cat(); c.drink(); c.eat(); //Animal a = new Animal(); //a.eat(); } 1.3.4. 3.4模板设计模式 设计模式 设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。 使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性、程序的重用性。 模板设计模式 把抽象类整体就可以看做成一个模板，模板中不能决定的东西定义成抽象方法 让使用模板的类（继承抽象类的类）去重写抽象方法实现需求 模板设计模式的优势 模板已经定义了通用结构，使用者只需要关心自己需要实现的功能即可 示例代码 模板类 /* 作文模板类 */ public abstract class CompositionTemplate { public final void write(){ System.out.println(\">\"); body(); System.out.println(\"啊~ 这就是我的爸爸\"); } public abstract void body(); } 实现类A public class Tom extends CompositionTemplate { @Override public void body() { System.out.println(\"那是一个秋天, 风儿那么缠绵,记忆中, \" + \"那天爸爸骑车接我放学回家,我的脚卡在了自行车链当中, 爸爸蹬不动,他就站起来蹬...\"); } } 实现类B public class Tony extends CompositionTemplate { @Override public void body() { } /*public void write(){ }*/ } 测试类 public class Test { public static void main(String[] args) { Tom t = new Tom(); t.write(); } } 1.3.5. 3.5final（应用） fianl关键字的作用 final代表最终的意思，可以修饰成员方法，成员变量，类 final修饰类、方法、变量的效果 fianl修饰类：该类不能被继承（不能有子类，但是可以有父类） final修饰方法：该方法不能被重写 final修饰变量：表明该变量是一个常量，不能再次赋值 变量是基本类型,不能改变的是值 变量是引用类型,不能改变的是地址值,但地址里面的内容是可以改变的 举例 public static void main(String[] args){ final Student s = new Student(23); s = new Student(24); // 错误 s.setAge(24); // 正确 } 1.3.6. 3.6黑马信息管理系统使用抽象类改进 (应用) 需求 使用抽象类的思想，将BaseStudentController 中的 inputStudentInfo 方法，定义为抽象方法 将不希望子类重写的方法，使用 final 进行修饰 代码实现 BaseStudentController类 public abstract class BaseStudentController { // 业务员对象 private StudentService studentService = new StudentService(); private Scanner sc = new Scanner(System.in); // 开启学生管理系统, 并展示学生管理系统菜单 public final void start() { //Scanner sc = new Scanner(System.in); studentLoop: while (true) { System.out.println(\"--------欢迎来到 管理系统--------\"); System.out.println(\"请输入您的选择: 1.添加学生 2.删除学生 3.修改学生 4.查看学生 5.退出\"); String choice = sc.next(); switch (choice) { case \"1\": // System.out.println(\"添加\"); addStudent(); break; case \"2\": // System.out.println(\"删除\"); deleteStudentById(); break; case \"3\": // System.out.println(\"修改\"); updateStudent(); break; case \"4\": // System.out.println(\"查询\"); findAllStudent(); break; case \"5\": System.out.println(\"感谢您使用学生管理系统, 再见!\"); break studentLoop; default: System.out.println(\"您的输入有误, 请重新输入\"); break; } } } // 修改学生方法 public final void updateStudent() { String updateId = inputStudentId(); Student newStu = inputStudentInfo(updateId); studentService.updateStudent(updateId, newStu); System.out.println(\"修改成功!\"); } // 删除学生方法 public final void deleteStudentById() { String delId = inputStudentId(); // 3. 调用业务员中的deleteStudentById根据id, 删除学生 studentService.deleteStudentById(delId); // 4. 提示删除成功 System.out.println(\"删除成功!\"); } // 查看学生方法 public final void findAllStudent() { // 1. 调用业务员中的获取方法, 得到学生的对象数组 Student[] stus = studentService.findAllStudent(); // 2. 判断数组的内存地址, 是否为null if (stus == null) { System.out.println(\"查无信息, 请添加后重试\"); return; } // 3. 遍历数组, 获取学生信息并打印在控制台 System.out.println(\"学号\\t\\t姓名\\t年龄\\t生日\"); for (int i = 0; i 1.4. 4.代码块 1.4.1. 4.1代码块概述 (理解) 在Java中，使用 { } 括起来的代码被称为代码块 1.4.2. 4.2代码块分类 (理解) 局部代码块 位置: 方法中定义 作用: 限定变量的生命周期，及早释放，提高内存利用率 示例代码 public class Test { /* 局部代码块 位置：方法中定义 作用：限定变量的生命周期，及早释放，提高内存利用率 */ public static void main(String[] args) { { int a = 10; System.out.println(a); } // System.out.println(a); } } 构造代码块 位置: 类中方法外定义 特点: 每次构造方法执行的时，都会执行该代码块中的代码，并且在构造方法执行前执行 作用: 将多个构造方法中相同的代码，抽取到构造代码块中，提高代码的复用性 示例代码 public class Test { /* 构造代码块: 位置：类中方法外定义 特点：每次构造方法执行的时，都会执行该代码块中的代码，并且在构造方法执行前执行 作用：将多个构造方法中相同的代码，抽取到构造代码块中，提高代码的复用性 */ public static void main(String[] args) { Student stu1 = new Student(); Student stu2 = new Student(10); } } class Student { { System.out.println(\"好好学习\"); } public Student(){ System.out.println(\"空参数构造方法\"); } public Student(int a){ System.out.println(\"带参数构造方法...........\"); } } 静态代码块 位置: 类中方法外定义 特点: 需要通过static关键字修饰，随着类的加载而加载，并且只执行一次 作用: 在类加载的时候做一些数据初始化的操作 示例代码 public class Test { /* 静态代码块: 位置：类中方法外定义 特点：需要通过static关键字修饰，随着类的加载而加载，并且只执行一次 作用：在类加载的时候做一些数据初始化的操作 */ public static void main(String[] args) { Person p1 = new Person(); Person p2 = new Person(10); } } class Person { static { System.out.println(\"我是静态代码块, 我执行了\"); } public Person(){ System.out.println(\"我是Person类的空参数构造方法\"); } public Person(int a){ System.out.println(\"我是Person类的带...........参数构造方法\"); } } 1.4.3. 4.3黑马信息管理系统使用代码块改进 (应用) 需求 使用静态代码块，初始化一些学生数据 实现步骤 在StudentDao类中定义一个静态代码块，用来初始化一些学生数据 将初始化好的学生数据存储到学生数组中 示例代码 StudentDao类 public class StudentDao { // 创建学生对象数组 private static Student[] stus = new Student[5]; static { Student stu1 = new Student(\"heima001\",\"张三\",\"23\",\"1999-11-11\"); Student stu2 = new Student(\"heima002\",\"李四\",\"24\",\"2000-11-11\"); stus[0] = stu1; stus[1] = stu2; } // 添加学生方法 public boolean addStudent(Student stu) { // 2. 添加学生到数组 //2.1 定义变量index为-1，假设数组已经全部存满，没有null的元素 int index = -1; //2.2 遍历数组取出每一个元素，判断是否是null for (int i = 0; i Copyright © MISIN 2022 | 豫ICP备2021006345号-1 all right reserved，powered by Gitbook该文件修订时间： 2022-11-10 13:27:21 "},"1.JAVA基础/day13-接口和内部类.html":{"url":"1.JAVA基础/day13-接口和内部类.html","title":"day13-接口和内部类","keywords":"","body":"1.1. 1.接口1.1.1. 1.1黑马信息管理系统集合改进 (应用)1.1.2. 1.2黑马信息管理系统抽取Dao (应用)1.1.3. 1.3接口的概述（理解）1.1.4. 1.4接口的特点（记忆）1.1.5. 1.5接口的成员特点（记忆）1.1.6. 1.6类和接口的关系（记忆）1.1.7. 1.7黑马信息管理系统使用接口改进 (应用)1.1.8. 1.8黑马信息管理系统解耦合改进 (应用)1.2. 2.接口组成更新1.2.1. 2.1接口组成更新概述【理解】1.2.2. 2.2接口中默认方法【应用】1.2.3. 2.3接口中静态方法【应用】1.2.4. 2.4接口中私有方法【应用】1.3. 3.多态1.3.1. 3.1多态的概述（记忆）1.3.2. 3.2多态中的成员访问特点（记忆）1.3.3. 3.3多态的好处和弊端（记忆）1.3.4. 3.4多态中的转型（应用）1.3.5. 3.5多态中转型存在的风险和解决方案 (应用)1.3.6. 3.6黑马信息管理系统多态改进 (应用)1.4. 4.内部类1.4.1. 4.1 内部类的基本使用（理解）1.4.2. 2.2 成员内部类（理解）1.4.3. 2.3 局部内部类（理解）1.4.4. 2.4 匿名内部类（应用）1.4.5. 2.4 匿名内部类在开发中的使用（应用）1.5. 5.Lambda表达式1.5.1. 5.1体验Lambda表达式【理解】1.5.2. 5.2Lambda表达式的标准格式【理解】1.5.3. 5.3Lambda表达式练习1【应用】1.5.4. 5.4Lambda表达式练习2【应用】1.5.5. 5.5Lambda表达式练习3【应用】1.5.6. 5.6Lambda表达式的省略模式【应用】1.5.7. 5.7Lambda表达式的使用前提【理解】1.5.8. 5.8Lambda表达式和匿名内部类的区别【理解】1.1. 1.接口 1.1.1. 1.1黑马信息管理系统集合改进 (应用) 使用数组容器的弊端 容器长度是固定的，不能根据添加功能自动增长 没有提供用于赠删改查的方法 优化步骤 创建新的StudentDao类，OtherStudentDao 创建ArrayList集合容器对象 OtherStudentDao中的方法声明，需要跟StudentDao保持一致 注意：如果不一致，StudentService中的代码就需要进行修改 完善方法（添加、删除、修改、查看） 替换StudentService中的Dao对象 代码实现 OtherStudentDao类 public class OtherStudentDao { // 集合容器 private static ArrayList stus = new ArrayList<>(); static { Student stu1 = new Student(\"heima001\",\"张三\",\"23\",\"1999-11-11\"); Student stu2 = new Student(\"heima002\",\"李四\",\"24\",\"2000-11-11\"); stus.add(stu1); stus.add(stu2); } // 添加学生方法 public boolean addStudent(Student stu) { stus.add(stu); return true; } // 查看学生方法 public Student[] findAllStudent() { Student[] students = new Student[stus.size()]; for (int i = 0; i StudentService类 public class StudentService { // 创建StudentDao (库管) private OtherStudentDao studentDao = new OtherStudentDao(); // 其他方法没有变化,此处省略... } 1.1.2. 1.2黑马信息管理系统抽取Dao (应用) 优化步骤 将方法向上抽取，抽取出一个父类 （ BaseStudentDao ） 方法的功能实现在父类中无法给出具体明确，定义为抽象方法 让两个类分别继承 BaseStudentDao ，重写内部抽象方法 代码实现 BaseStudentDao类 public abstract class BaseStudentDao { // 添加学生方法 public abstract boolean addStudent(Student stu); // 查看学生方法 public abstract Student[] findAllStudent(); // 删除学生方法 public abstract void deleteStudentById(String delId); // 根据id找索引方法 public abstract int getIndex(String id); // 修改学生方法 public abstract void updateStudent(String updateId, Student newStu); } StudentDao类 public class StudentDao extends BaseStudentDao { // 其他内容不变,此处省略 } OtherStudentDao类 public class OtherStudentDao extends BaseStudentDao { // 其他内容不变,此处省略 } 1.1.3. 1.3接口的概述（理解） 接口就是一种公共的规范标准，只要符合规范标准，大家都可以通用。 Java中接口存在的两个意义 用来定义规范 用来做功能的拓展 1.1.4. 1.4接口的特点（记忆） 接口用关键字interface修饰 public interface 接口名 {} 类实现接口用implements表示 public class 类名 implements 接口名 {} 接口不能实例化 ​ 我们可以创建接口的实现类对象使用 接口的子类 ​ 要么重写接口中的所有抽象方法 ​ 要么子类也是抽象类 1.1.5. 1.5接口的成员特点（记忆） 成员特点 成员变量 ​ 只能是常量 ​ 默认修饰符：public static final 构造方法 ​ 没有，因为接口主要是扩展功能的，而没有具体存在 成员方法 ​ 只能是抽象方法 ​ 默认修饰符：public abstract ​ 关于接口中的方法，JDK8和JDK9中有一些新特性，后面再讲解 代码演示 接口 public interface Inter { public static final int NUM = 10; public abstract void show(); } 实现类 class InterImpl implements Inter{ public void method(){ // NUM = 20; System.out.println(NUM); } public void show(){ } } 测试类 public class TestInterface { /* 成员变量: 只能是常量 系统会默认加入三个关键字 public static final 构造方法: 没有 成员方法: 只能是抽象方法, 系统会默认加入两个关键字 public abstract */ public static void main(String[] args) { System.out.println(Inter.NUM); } } 1.1.6. 1.6类和接口的关系（记忆） 类与类的关系 ​ 继承关系，只能单继承，但是可以多层继承 类与接口的关系 ​ 实现关系，可以单实现，也可以多实现，还可以在继承一个类的同时实现多个接口 接口与接口的关系 ​ 继承关系，可以单继承，也可以多继承 1.1.7. 1.7黑马信息管理系统使用接口改进 (应用) 实现步骤 将 BaseStudentDao 改进为一个接口 让 StudentDao 和 OtherStudentDao 去实现这个接口 代码实现 BaseStudentDao接口 public interface BaseStudentDao { // 添加学生方法 public abstract boolean addStudent(Student stu); // 查看学生方法 public abstract Student[] findAllStudent(); // 删除学生方法 public abstract void deleteStudentById(String delId); // 根据id找索引方法 public abstract int getIndex(String id); // 修改学生方法 public abstract void updateStudent(String updateId, Student newStu); } StudentDao类 public class StudentDao implements BaseStudentDao { // 其他内容不变,此处省略 } OtherStudentDao类 public class OtherStudentDao implements BaseStudentDao { // 其他内容不变,此处省略 } 1.1.8. 1.8黑马信息管理系统解耦合改进 (应用) 实现步骤 创建factory包，创建 StudentDaoFactory（工厂类） 提供 static 修改的 getStudentDao 方法，该方法用于创建StudentDao对象并返回 代码实现 StudentDaoFactory类 public class StudentDaoFactory { public static OtherStudentDao getStudentDao(){ return new OtherStudentDao(); } } StudentService类 public class StudentService { // 创建StudentDao (库管) // private OtherStudentDao studentDao = new OtherStudentDao(); // 通过学生库管工厂类, 获取库管对象 private OtherStudentDao studentDao = StudentDaoFactory.getStudentDao(); } 1.2. 2.接口组成更新 1.2.1. 2.1接口组成更新概述【理解】 常量 public static final 抽象方法 public abstract 默认方法(Java 8) 静态方法(Java 8) 私有方法(Java 9) 1.2.2. 2.2接口中默认方法【应用】 格式 public default 返回值类型 方法名(参数列表) { } 作用 解决接口升级的问题 范例 public default void show3() { } 注意事项 默认方法不是抽象方法，所以不强制被重写。但是可以被重写，重写的时候去掉default关键字 public可以省略，default不能省略 如果实现了多个接口，多个接口中存在相同的方法声明，子类就必须对该方法进行重写 1.2.3. 2.3接口中静态方法【应用】 格式 public static 返回值类型 方法名(参数列表) { } 范例 public static void show() { } 注意事项 静态方法只能通过接口名调用，不能通过实现类名或者对象名调用 public可以省略，static不能省略 1.2.4. 2.4接口中私有方法【应用】 私有方法产生原因 Java 9中新增了带方法体的私有方法，这其实在Java 8中就埋下了伏笔：Java 8允许在接口中定义带方法体的默认方法和静态方法。这样可能就会引发一个问题：当两个默认方法或者静态方法中包含一段相同的代码实现时，程序必然考虑将这段实现代码抽取成一个共性方法，而这个共性方法是不需要让别人使用的，因此用私有给隐藏起来，这就是Java 9增加私有方法的必然性 定义格式 格式1 private 返回值类型 方法名(参数列表) { } 范例1 private void show() { } 格式2 private static 返回值类型 方法名(参数列表) { } 范例2 private static void method() { } 注意事项 默认方法可以调用私有的静态方法和非静态方法 静态方法只能调用私有的静态方法 1.3. 3.多态 1.3.1. 3.1多态的概述（记忆） 什么是多态 ​ 同一个对象，在不同时刻表现出来的不同形态 多态的前提 要有继承或实现关系 要有方法的重写 要有父类引用指向子类对象 代码演示 class Animal { public void eat(){ System.out.println(\"动物吃饭\"); } } class Cat extends Animal { @Override public void eat() { System.out.println(\"猫吃鱼\"); } } public class Test1Polymorphic { /* 多态的前提: 1. 要有(继承 \\ 实现)关系 2. 要有方法重写 3. 要有父类引用, 指向子类对象 */ public static void main(String[] args) { // 当前事物, 是一只猫 Cat c = new Cat(); // 当前事物, 是一只动物 Animal a = new Cat(); a.eat(); } } 1.3.2. 3.2多态中的成员访问特点（记忆） 成员访问特点 成员变量 ​ 编译看父类，运行看父类 成员方法 ​ 编译看父类，运行看子类 代码演示 class Fu { int num = 10; public void method(){ System.out.println(\"Fu.. method\"); } } class Zi extends Fu { int num = 20; public void method(){ System.out.println(\"Zi.. method\"); } } public class Test2Polymorpic { /* 多态的成员访问特点: 成员变量: 编译看左边 (父类), 运行看左边 (父类) 成员方法: 编译看左边 (父类), 运行看右边 (子类) */ public static void main(String[] args) { Fu f = new Zi(); System.out.println(f.num); f.method(); } } 1.3.3. 3.3多态的好处和弊端（记忆） 好处 ​ 提高程序的扩展性。定义方法时候，使用父类型作为参数，在使用的时候，使用具体的子类型参与操作 弊端 ​ 不能使用子类的特有成员 1.3.4. 3.4多态中的转型（应用） 向上转型 ​ 父类引用指向子类对象就是向上转型 向下转型 ​ 格式：子类型 对象名 = (子类型)父类引用; 代码演示 class Fu { public void show(){ System.out.println(\"Fu..show...\"); } } class Zi extends Fu { @Override public void show() { System.out.println(\"Zi..show...\"); } public void method(){ System.out.println(\"我是子类特有的方法, method\"); } } public class Test3Polymorpic { public static void main(String[] args) { // 1. 向上转型 : 父类引用指向子类对象 Fu f = new Zi(); f.show(); // 多态的弊端: 不能调用子类特有的成员 // f.method(); // A: 直接创建子类对象 // B: 向下转型 // 2. 向下转型 : 从父类类型, 转换回子类类型 Zi z = (Zi) f; z.method(); } } 1.3.5. 3.5多态中转型存在的风险和解决方案 (应用) 风险 如果被转的引用类型变量,对应的实际类型和目标类型不是同一种类型,那么在转换的时候就会出现ClassCastException 解决方案 关键字 instanceof 使用格式 变量名 instanceof 类型 通俗的理解：判断关键字左边的变量，是否是右边的类型，返回boolean类型结果 代码演示 abstract class Animal { public abstract void eat(); } class Dog extends Animal { public void eat() { System.out.println(\"狗吃肉\"); } public void watchHome(){ System.out.println(\"看家\"); } } class Cat extends Animal { public void eat() { System.out.println(\"猫吃鱼\"); } } public class Test4Polymorpic { public static void main(String[] args) { useAnimal(new Dog()); useAnimal(new Cat()); } public static void useAnimal(Animal a){ // Animal a = new Dog(); // Animal a = new Cat(); a.eat(); //a.watchHome(); // Dog dog = (Dog) a; // dog.watchHome(); // ClassCastException 类型转换异常 // 判断a变量记录的类型, 是否是Dog if(a instanceof Dog){ Dog dog = (Dog) a; dog.watchHome(); } } } 1.3.6. 3.6黑马信息管理系统多态改进 (应用) 实现步骤 StudentDaoFactory类中方法的返回值定义成父类类型BaseStudentDao StudentService中接收方法返回值的类型定义成父类类型BaseStudentDao 代码实现 StudentDaoFactory类 public class StudentDaoFactory { public static BaseStudentDao getStudentDao(){ return new OtherStudentDao(); } } StudentService类 public class StudentService { // 创建StudentDao (库管) // private OtherStudentDao studentDao = new OtherStudentDao(); // 通过学生库管工厂类, 获取库管对象 private BaseStudentDao studentDao = StudentDaoFactory.getStudentDao(); } 1.4. 4.内部类 1.4.1. 4.1 内部类的基本使用（理解） 内部类概念 在一个类中定义一个类。举例：在一个类A的内部定义一个类B，类B就被称为内部类 内部类定义格式 格式&举例： /* 格式： class 外部类名{ 修饰符 class 内部类名{ } } */ class Outer { public class Inner { } } 内部类的访问特点 内部类可以直接访问外部类的成员，包括私有 外部类要访问内部类的成员，必须创建对象 示例代码： /* 内部类访问特点： 内部类可以直接访问外部类的成员，包括私有 外部类要访问内部类的成员，必须创建对象 */ public class Outer { private int num = 10; public class Inner { public void show() { System.out.println(num); } } public void method() { Inner i = new Inner(); i.show(); } } 1.4.2. 2.2 成员内部类（理解） 成员内部类的定义位置 在类中方法，跟成员变量是一个位置 外界创建成员内部类格式 格式：外部类名.内部类名 对象名 = 外部类对象.内部类对象; 举例：Outer.Inner oi = new Outer().new Inner(); 私有成员内部类 将一个类，设计为内部类的目的，大多数都是不想让外界去访问，所以内部类的定义应该私有化，私有化之后，再提供一个可以让外界调用的方法，方法内部创建内部类对象并调用。 示例代码： class Outer { private int num = 10; private class Inner { public void show() { System.out.println(num); } } public void method() { Inner i = new Inner(); i.show(); } } public class InnerDemo { public static void main(String[] args) { //Outer.Inner oi = new Outer().new Inner(); //oi.show(); Outer o = new Outer(); o.method(); } } 静态成员内部类 静态成员内部类访问格式：外部类名.内部类名 对象名 = new 外部类名.内部类名(); 静态成员内部类中的静态方法：外部类名.内部类名.方法名(); 示例代码 class Outer { static class Inner { public void show(){ System.out.println(\"inner..show\"); } public static void method(){ System.out.println(\"inner..method\"); } } } public class Test3Innerclass { /* 静态成员内部类演示 */ public static void main(String[] args) { // 外部类名.内部类名 对象名 = new 外部类名.内部类名(); Outer.Inner oi = new Outer.Inner(); oi.show(); Outer.Inner.method(); } } 1.4.3. 2.3 局部内部类（理解） 局部内部类定义位置 局部内部类是在方法中定义的类 局部内部类方式方式 局部内部类，外界是无法直接使用，需要在方法内部创建对象并使用 该类可以直接访问外部类的成员，也可以访问方法内的局部变量 示例代码 class Outer { private int num = 10; public void method() { int num2 = 20; class Inner { public void show() { System.out.println(num); System.out.println(num2); } } Inner i = new Inner(); i.show(); } } public class OuterDemo { public static void main(String[] args) { Outer o = new Outer(); o.method(); } } 1.4.4. 2.4 匿名内部类（应用） 匿名内部类的前提 存在一个类或者接口，这里的类可以是具体类也可以是抽象类 匿名内部类的格式 格式：new 类名 ( ) { 重写方法 } new 接口名 ( ) { 重写方法 } 举例： new Inter(){ @Override public void method(){} } 匿名内部类的本质 本质：是一个继承了该类或者实现了该接口的子类匿名对象 匿名内部类的细节 匿名内部类可以通过多态的形式接受 Inter i = new Inter(){ @Override public void method(){ } } 匿名内部类直接调用方法 interface Inter{ void method(); } class Test{ public static void main(String[] args){ new Inter(){ @Override public void method(){ System.out.println(\"我是匿名内部类\"); } }.method(); // 直接调用方法 } } 1.4.5. 2.4 匿名内部类在开发中的使用（应用） 匿名内部类在开发中的使用 当发现某个方法需要，接口或抽象类的子类对象，我们就可以传递一个匿名内部类过去，来简化传统的代码 示例代码： /* 游泳接口 */ interface Swimming { void swim(); } public class TestSwimming { public static void main(String[] args) { goSwimming(new Swimming() { @Override public void swim() { System.out.println(\"铁汁, 我们去游泳吧\"); } }); } /** * 使用接口的方法 */ public static void goSwimming(Swimming swimming){ /* Swimming swim = new Swimming() { @Override public void swim() { System.out.println(\"铁汁, 我们去游泳吧\"); } } */ swimming.swim(); } } 1.5. 5.Lambda表达式 1.5.1. 5.1体验Lambda表达式【理解】 代码演示 /* 游泳接口 */ interface Swimming { void swim(); } public class TestSwimming { public static void main(String[] args) { // 通过匿名内部类实现 goSwimming(new Swimming() { @Override public void swim() { System.out.println(\"铁汁, 我们去游泳吧\"); } }); /* 通过Lambda表达式实现 理解: 对于Lambda表达式, 对匿名内部类进行了优化 */ goSwimming(() -> System.out.println(\"铁汁, 我们去游泳吧\")); } /** * 使用接口的方法 */ public static void goSwimming(Swimming swimming) { swimming.swim(); } } 函数式编程思想概述 在数学中，函数就是有输入量、输出量的一套计算方案，也就是“拿数据做操作” 面向对象思想强调“必须通过对象的形式来做事情” 函数式思想则尽量忽略面向对象的复杂语法：“强调做什么，而不是以什么形式去做” 而我们要学习的Lambda表达式就是函数式思想的体现 1.5.2. 5.2Lambda表达式的标准格式【理解】 格式： ​ (形式参数) -> {代码块} 形式参数：如果有多个参数，参数之间用逗号隔开；如果没有参数，留空即可 ->：由英文中画线和大于符号组成，固定写法。代表指向动作 代码块：是我们具体要做的事情，也就是以前我们写的方法体内容 组成Lambda表达式的三要素： 形式参数，箭头，代码块 1.5.3. 5.3Lambda表达式练习1【应用】 Lambda表达式的使用前提 有一个接口 接口中有且仅有一个抽象方法 练习描述 ​ 无参无返回值抽象方法的练习 操作步骤 定义一个接口(Eatable)，里面定义一个抽象方法：void eat(); 定义一个测试类(EatableDemo)，在测试类中提供两个方法 一个方法是：useEatable(Eatable e) 一个方法是主方法，在主方法中调用useEatable方法 示例代码 //接口 public interface Eatable { void eat(); } //实现类 public class EatableImpl implements Eatable { @Override public void eat() { System.out.println(\"一天一苹果，医生远离我\"); } } //测试类 public class EatableDemo { public static void main(String[] args) { //在主方法中调用useEatable方法 Eatable e = new EatableImpl(); useEatable(e); //匿名内部类 useEatable(new Eatable() { @Override public void eat() { System.out.println(\"一天一苹果，医生远离我\"); } }); //Lambda表达式 useEatable(() -> { System.out.println(\"一天一苹果，医生远离我\"); }); } private static void useEatable(Eatable e) { e.eat(); } } 1.5.4. 5.4Lambda表达式练习2【应用】 练习描述 有参无返回值抽象方法的练习 操作步骤 定义一个接口(Flyable)，里面定义一个抽象方法：void fly(String s); 定义一个测试类(FlyableDemo)，在测试类中提供两个方法 一个方法是：useFlyable(Flyable f) 一个方法是主方法，在主方法中调用useFlyable方法 示例代码 public interface Flyable { void fly(String s); } public class FlyableDemo { public static void main(String[] args) { //在主方法中调用useFlyable方法 //匿名内部类 useFlyable(new Flyable() { @Override public void fly(String s) { System.out.println(s); System.out.println(\"飞机自驾游\"); } }); System.out.println(\"--------\"); //Lambda useFlyable((String s) -> { System.out.println(s); System.out.println(\"飞机自驾游\"); }); } private static void useFlyable(Flyable f) { f.fly(\"风和日丽，晴空万里\"); } } 1.5.5. 5.5Lambda表达式练习3【应用】 练习描述 有参有返回值抽象方法的练习 操作步骤 定义一个接口(Addable)，里面定义一个抽象方法：int add(int x,int y); 定义一个测试类(AddableDemo)，在测试类中提供两个方法 一个方法是：useAddable(Addable a) 一个方法是主方法，在主方法中调用useAddable方法 示例代码 public interface Addable { int add(int x,int y); } public class AddableDemo { public static void main(String[] args) { //在主方法中调用useAddable方法 useAddable((int x,int y) -> { return x + y; }); } private static void useAddable(Addable a) { int sum = a.add(10, 20); System.out.println(sum); } } 1.5.6. 5.6Lambda表达式的省略模式【应用】 省略的规则 参数类型可以省略。但是有多个参数的情况下，不能只省略一个 如果参数有且仅有一个，那么小括号可以省略 如果代码块的语句只有一条，可以省略大括号和分号，和return关键字 代码演示 public interface Addable { int add(int x, int y); } public interface Flyable { void fly(String s); } public class LambdaDemo { public static void main(String[] args) { // useAddable((int x,int y) -> { // return x + y; // }); //参数的类型可以省略 useAddable((x, y) -> { return x + y; }); // useFlyable((String s) -> { // System.out.println(s); // }); //如果参数有且仅有一个，那么小括号可以省略 // useFlyable(s -> { // System.out.println(s); // }); //如果代码块的语句只有一条，可以省略大括号和分号 useFlyable(s -> System.out.println(s)); //如果代码块的语句只有一条，可以省略大括号和分号，如果有return，return也要省略掉 useAddable((x, y) -> x + y); } private static void useFlyable(Flyable f) { f.fly(\"风和日丽，晴空万里\"); } private static void useAddable(Addable a) { int sum = a.add(10, 20); System.out.println(sum); } } 1.5.7. 5.7Lambda表达式的使用前提【理解】 使用Lambda必须要有接口 并且要求接口中有且仅有一个抽象方法 1.5.8. 5.8Lambda表达式和匿名内部类的区别【理解】 所需类型不同 匿名内部类：可以是接口，也可以是抽象类，还可以是具体类 Lambda表达式：只能是接口 使用限制不同 如果接口中有且仅有一个抽象方法，可以使用Lambda表达式，也可以使用匿名内部类 如果接口中多于一个抽象方法，只能使用匿名内部类，而不能使用Lambda表达式 实现原理不同 匿名内部类：编译之后，产生一个单独的.class字节码文件 Lambda表达式：编译之后，没有一个单独的.class字节码文件。对应的字节码会在运行的时候动态生成 Copyright © MISIN 2022 | 豫ICP备2021006345号-1 all right reserved，powered by Gitbook该文件修订时间： 2020-06-15 17:46:16 "},"1.JAVA基础/day14-常用API01.html":{"url":"1.JAVA基础/day14-常用API01.html","title":"day14-常用API01","keywords":"","body":"1.1. 1.API1.1.1. 1.1 API概述【理解】1.1.2. 1.2 如何使用API帮助文档【应用】1.2. 2.常用API1.2.1. 2.1 Math（应用）1.2.2. 2.2 System（应用）1.2.3. 2.3 Object类的toString方法（应用）1.2.4. 2.4 Object类的equals方法（应用）1.2.5. 2.5 Objects (应用)1.2.6. 2.6 BigDecimal (应用)1.3. 3.包装类1.3.1. 3.1 基本类型包装类（记忆）1.3.2. 3.2 Integer类（应用）1.3.3. 3.3 自动拆箱和自动装箱（理解）1.3.4. 3.4 int和String类型的相互转换（记忆）1.3.5. 3.5 字符串数据排序案例（应用）1.4. 4.递归1.4.1. 4.1 递归【应用】1.4.2. 4.2 递归求阶乘【应用】1.5. 5.数组的高级操作1.5.1. 5.1 二分查找 (理解)1.5.2. 5.2 冒泡排序 (理解)1.5.3. 5.3 快速排序 (理解)1.5.4. 5.4 Arrays (应用)1.1. 1.API 1.1.1. 1.1 API概述【理解】 什么是API ​ API (Application Programming Interface) ：应用程序编程接口 java中的API ​ 指的就是 JDK 中提供的各种功能的 Java类，这些类将底层的实现封装了起来，我们不需要关心这些类是如何实现的，只需要学习这些类如何使用即可，我们可以通过帮助文档来学习这些API如何使用。 1.1.2. 1.2 如何使用API帮助文档【应用】 打开帮助文档 找到索引选项卡中的输入框 在输入框中输入Random 看类在哪个包下 看类的描述 看构造方法 看成员方法 1.2. 2.常用API 1.2.1. 2.1 Math（应用） 1、Math类概述 Math 包含执行基本数字运算的方法 2、Math中方法的调用方式 Math类中无构造方法，但内部的方法都是静态的，则可以通过 类名.进行调用 3、Math类的常用方法 | 方法名 方法名 | 说明 | | -————————————— | ————————— | | public static int abs(int a) | 返回参数的绝对值 | | public static double ceil(double a) | 返回大于或等于参数的最小double值，等于一个整数 | | public static double floor(double a) | 返回小于或等于参数的最大double值，等于一个整数 | | public static int round(float a) | 按照四舍五入返回最接近参数的int | | public static int max(int a,int b) | 返回两个int值中的较大值 | | public static int min(int a,int b) | 返回两个int值中的较小值 | | public static double pow (double a,double b) | 返回a的b次幂的值 | | public static double random() | 返回值为double的正值，[0.0,1.0) | 1.2.2. 2.2 System（应用） System类的常用方法 | 方法名 | 说明 | | -————————————— | —————————— | | public static void exit(int status) | 终止当前运行的 Java 虚拟机，非零表示异常终止 | | public static long currentTimeMillis() | 返回当前时间(以毫秒为单位) | 示例代码 需求：在控制台输出1-10000，计算这段代码执行了多少毫秒 public class SystemDemo { public static void main(String[] args) { // 获取开始的时间节点 long start = System.currentTimeMillis(); for (int i = 1; i 1.2.3. 2.3 Object类的toString方法（应用） Object类概述 Object 是类层次结构的根，每个类都可以将 Object 作为超类。所有类都直接或者间接的继承自该类，换句话说，该类所具备的方法，所有类都会有一份 查看方法源码的方式 选中方法，按下Ctrl + B 重写toString方法的方式 Alt + Insert 选择toString 在类的空白区域，右键 -> Generate -> 选择toString toString方法的作用： 以良好的格式，更方便的展示对象中的属性值 示例代码： class Student extends Object { private String name; private int age; public Student() { } public Student(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } @Override public String toString() { return “Student{“ + “name=‘” + name + ‘\\’’ + “, age=“ + age + ‘}’; } } public class ObjectDemo { public static void main(String[] args) { Student s = new Student(); s.setName(“林青霞”); s.setAge(30); System.out.println(s); System.out.println(s.toString()); } } 运行结果： Student{name=‘林青霞’, age=30} Student{name=‘林青霞’, age=30} 1.2.4. 2.4 Object类的equals方法（应用） equals方法的作用 用于对象之间的比较，返回true和false的结果 举例：s1.equals(s2); s1和s2是两个对象 重写equals方法的场景 不希望比较对象的地址值，想要结合对象属性进行比较的时候。 重写equals方法的方式 alt + insert 选择equals() and hashCode()，IntelliJ Default，一路next，finish即可 在类的空白区域，右键 -> Generate -> 选择equals() and hashCode()，后面的同上。 示例代码： class Student { private String name; private int age; public Student() { } public Student(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } @Override public boolean equals(Object o) { //this — s1 //o — s2 if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Student student = (Student) o; //student — s2 if (age != student.age) return false; return name != null ? name.equals(student.name) : student.name == null; } } public class ObjectDemo { public static void main(String[] args) { Student s1 = new Student(); s1.setName(“林青霞”); s1.setAge(30); Student s2 = new Student(); s2.setName(“林青霞”); s2.setAge(30); //需求：比较两个对象的内容是否相同 System.out.println(s1.equals(s2)); } } 面试题 // 看程序,分析结果 String s = “abc”; StringBuilder sb = new StringBuilder(“abc”); s.equals(sb); sb.equals(s); public class InterviewTest { public static void main(String[] args) { String s1 = “abc”; StringBuilder sb = new StringBuilder(“abc”); //1.此时调用的是String类中的equals方法. //保证参数也是字符串,否则不会比较属性值而直接返回false //System.out.println(s1.equals(sb)); // false //StringBuilder类中是没有重写equals方法,用的就是Object类中的. System.out.println(sb.equals(s1)); // false } } 1.2.5. 2.5 Objects (应用) 常用方法 | 方法名 | 说明 | | -————————————— | -————— | | public static String toString(对象) | 返回参数中对象的字符串表示形式。 | | public static String toString(对象, 默认字符串) | 返回对象的字符串表示形式。 | | public static Boolean isNull(对象) | 判断对象是否为空 | | public static Boolean nonNull(对象) | 判断对象是否不为空 | 示例代码 学生类 class Student { private String name; private int age; public Student() { } public Student(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } @Override public String toString() { return “Student{“ + “name=‘” + name + ‘\\’’ + “, age=“ + age + ‘}’; } } 测试类 public class MyObjectsDemo { public static void main(String[] args) { // public static String toString(对象): 返回参数中对象的字符串表示形式。 // Student s = new Student(“小罗同学”,50); // String result = Objects.toString(s); // System.out.println(result); // System.out.println(s); // public static String toString(对象, 默认字符串): 返回对象的字符串表示形式。如果对象为空,那么返回第二个参数. //Student s = new Student(“小花同学”,23); // Student s = null; // String result = Objects.toString(s, “随便写一个”); // System.out.println(result); // public static Boolean isNull(对象): 判断对象是否为空 //Student s = null; // Student s = new Student(); // boolean result = Objects.isNull(s); // System.out.println(result); // public static Boolean nonNull(对象): 判断对象是否不为空 //Student s = new Student(); Student s = null; boolean result = Objects.nonNull(s); System.out.println(result); } } 1.2.6. 2.6 BigDecimal (应用) 作用 可以用来进行精确计算 构造方法 | 方法名 | 说明 | | -——————— | ——— | | BigDecimal(double val) | 参数为double | | BigDecimal(String val) | 参数为String | 常用方法 | 方法名 | 说明 | | -————————————— | -— | | public BigDecimal add(另一个BigDecimal对象) | 加法 | | public BigDecimal subtract (另一个BigDecimal对象) | 减法 | | public BigDecimal multiply (另一个BigDecimal对象) | 乘法 | | public BigDecimal divide (另一个BigDecimal对象) | 除法 | | public BigDecimal divide (另一个BigDecimal对象，精确几位，舍入模式) | 除法 | 总结 BigDecimal是用来进行精确计算的 创建BigDecimal的对象，构造方法使用参数类型为字符串的。 四则运算中的除法，如果除不尽请使用divide的三个参数的方法。 代码示例： BigDecimal divide = bd1.divide(参与运算的对象,小数点后精确到多少位,舍入模式); 参数1 ，表示参与运算的BigDecimal 对象。 参数2 ，表示小数点后面精确到多少位 参数3 ，舍入模式 BigDecimal.ROUND_UP 进一法 BigDecimal.ROUND_FLOOR 去尾法 BigDecimal.ROUND_HALF_UP 四舍五入 1.3. 3.包装类 1.3.1. 3.1 基本类型包装类（记忆） 基本类型包装类的作用 将基本数据类型封装成对象的好处在于可以在对象中定义更多的功能方法操作该数据 常用的操作之一：用于基本数据类型与字符串之间的转换 基本类型对应的包装类 | 基本数据类型 | 包装类 | | -—— | ——— | | byte | Byte | | short | Short | | int | Integer | | long | Long | | float | Float | | double | Double | | char | Character | | boolean | Boolean | 1.3.2. 3.2 Integer类（应用） Integer类概述 包装一个对象中的原始类型 int 的值 Integer类构造方法 | 方法名 | 说明 | | ————————————— | -————————— | | public Integer(int value) | 根据 int 值创建 Integer 对象(过时) | | public Integer(String s) | 根据 String 值创建 Integer 对象(过时) | | public static Integer valueOf(int i) | 返回表示指定的 int 值的 Integer 实例 | | public static Integer valueOf(String s) | 返回一个保存指定值的 Integer 对象 String | 示例代码 public class IntegerDemo { public static void main(String[] args) { //public Integer(int value)：根据 int 值创建 Integer 对象(过时) Integer i1 = new Integer(100); System.out.println(i1); //public Integer(String s)：根据 String 值创建 Integer 对象(过时) Integer i2 = new Integer(“100”); // Integer i2 = new Integer(“abc”); //NumberFormatException System.out.println(i2); System.out.println(“———“); //public static Integer valueOf(int i)：返回表示指定的 int 值的 Integer 实例 Integer i3 = Integer.valueOf(100); System.out.println(i3); //public static Integer valueOf(String s)：返回一个保存指定值的Integer对象 String Integer i4 = Integer.valueOf(“100”); System.out.println(i4); } } 1.3.3. 3.3 自动拆箱和自动装箱（理解） 自动装箱 ​ 把基本数据类型转换为对应的包装类类型 自动拆箱 ​ 把包装类类型转换为对应的基本数据类型 示例代码 Integer i = 100; // 自动装箱 i += 200; // i = i + 200; i + 200 自动拆箱；i = i + 200; 是自动装箱 1.3.4. 3.4 int和String类型的相互转换（记忆） int转换为String 转换方式 方式一：直接在数字后加一个空字符串 方式二：通过String类静态方法valueOf() 示例代码 public class IntegerDemo { public static void main(String[] args) { //int — String int number = 100; //方式1 String s1 = number + “”; System.out.println(s1); //方式2 //public static String valueOf(int i) String s2 = String.valueOf(number); System.out.println(s2); System.out.println(“———“); } } String转换为int 转换方式 方式一：先将字符串数字转成Integer，再调用valueOf()方法 方式二：通过Integer静态方法parseInt()进行转换 示例代码 public class IntegerDemo { public static void main(String[] args) { //String — int String s = “100”; //方式1：String — Integer — int Integer i = Integer.valueOf(s); //public int intValue() int x = i.intValue(); System.out.println(x); //方式2 //public static int parseInt(String s) int y = Integer.parseInt(s); System.out.println(y); } } 1.3.5. 3.5 字符串数据排序案例（应用） 案例需求 ​ 有一个字符串：“91 27 46 38 50”，请写程序实现最终输出结果是：27 38 46 50 91 代码实现 public class IntegerTest { public static void main(String[] args) { //定义一个字符串 String s = “91 27 46 38 50”; //把字符串中的数字数据存储到一个int类型的数组中 String[] strArray = s.split(“ “); // for(int i=0; i 1.4. 4.递归 1.4.1. 4.1 递归【应用】 递归的介绍 以编程的角度来看，递归指的是方法定义中调用方法本身的现象 把一个复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解 递归策略只需少量的程序就可描述出解题过程所需要的多次重复计算 递归的基本使用 public class MyFactorialDemo2 { public static void main(String[] args) { int sum = getSum(100); System.out.println(sum); } private static int getSum(int i) { //1- 100之间的和 //100 + (1-99之间的和) // 99 + (1- 98之间的和) //.... //1 //方法的作用: 求 1- i 之间和 if(i == 1){ return 1; }else{ return i + getSum(i -1); } } } 递归的注意事项 递归一定要有出口。否则内存溢出 递归虽然有出口，但是递归的次数也不宜过多。否则内存溢出 1.4.2. 4.2 递归求阶乘【应用】 案例需求 ​ 用递归求5的阶乘，并把结果在控制台输出 代码实现 public class DiGuiDemo01 { public static void main(String[] args) { //调用方法 int result = jc(5); //输出结果 System.out.println(“5的阶乘是：” + result); } //定义一个方法，用于递归求阶乘，参数为一个int类型的变量 public static int jc(int n) { //在方法内部判断该变量的值是否是1 if(n == 1) { //是：返回1 return 1; } else { //不是：返回n*(n-1)! return n*jc(n-1); } } } 内存图 1.5. 5.数组的高级操作 1.5.1. 5.1 二分查找 (理解) 二分查找概述 查找指定元素在数组中的位置时,以前的方式是通过遍历,逐个获取每个元素,看是否是要查找的元素,这种方式当数组元素较多时,查找的效率很低 二分查找也叫折半查找,每次可以去掉一半的查找范围,从而提高查找的效率 需求 在数组{1,2,3,4,5,6,7,8,9,10}中,查找某个元素的位置 实现步骤 定义两个变量，表示要查找的范围。默认min = 0 ，max = 最大索引 循环查找，但是min 计算出mid的值 判断mid位置的元素是否为要查找的元素，如果是直接返回对应索引 如果要查找的值在mid的左半边，那么min值不变，max = mid -1.继续下次循环查找 如果要查找的值在mid的右半边，那么max值不变，min = mid + 1.继续下次循环查找 当min > max 时，表示要查找的元素在数组中不存在，返回-1. 代码实现 public class MyBinarySearchDemo { public static void main(String[] args) { int [] arr = {1,2,3,4,5,6,7,8,9,10}; int number = 11; //1,我现在要干嘛? --- 二分查找 //2.我干这件事情需要什么? --- 数组 元素 //3,我干完了,要不要把结果返回调用者 --- 把索引返回给调用者 int index = binarySearchForIndex(arr,number); System.out.println(index); } private static int binarySearchForIndex(int[] arr, int number) { //1,定义查找的范围 int min = 0; int max = arr.length - 1; //2.循环查找 min > 1; //mid指向的元素 > number if(arr[mid] > number){ //表示要查找的元素在左边. max = mid -1; }else if(arr[mid] 注意事项 有一个前提条件，数组内的元素一定要按照大小顺序排列，如果没有大小顺序，是不能使用二分查找法的 1.5.2. 5.2 冒泡排序 (理解) 冒泡排序概述 一种排序的方式，对要进行排序的数据中相邻的数据进行两两比较，将较大的数据放在后面，依次对所有的数据进行操作，直至所有数据按要求完成排序 如果有n个数据进行排序，总共需要比较n-1次 每一次比较完毕，下一次的比较就会少一个数据参与 代码实现 public class MyBubbleSortDemo2 { public static void main(String[] args) { int[] arr = {3, 5, 2, 1, 4}; //1 2 3 4 5 bubbleSort(arr); } private static void bubbleSort(int[] arr) { //外层循环控制的是次数 比数组的长度少一次. for (int i = 0; i arr[j + 1]) { int temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; } } } printArr(arr); } private static void printArr(int[] arr) { for (int i = 0; i 1.5.3. 5.3 快速排序 (理解) 快速排序概述 冒泡排序算法中,一次循环结束,就相当于确定了当前的最大值,也能确定最大值在数组中应存入的位置 快速排序算法中,每一次递归时以第一个数为基准数,找到数组中所有比基准数小的.再找到所有比基准数大的.小的全部放左边,大的全部放右边,确定基准数的正确位置 核心步骤 从右开始找比基准数小的 从左开始找比基准数大的 交换两个值的位置 红色继续往左找，蓝色继续往右找，直到两个箭头指向同一个索引为止 基准数归位 代码实现 public class MyQuiteSortDemo2 { public static void main(String[] args) { // 1，从右开始找比基准数小的 // 2，从左开始找比基准数大的 // 3，交换两个值的位置 // 4，红色继续往左找，蓝色继续往右找，直到两个箭头指向同一个索引为止 // 5，基准数归位 int[] arr = {6, 1, 2, 7, 9, 3, 4, 5, 10, 8}; quiteSort(arr,0,arr.length-1); for (int i = 0; i = baseNumber && right > left){ right--; } // 2，从左开始找比基准数大的 while(arr[left] left){ left++; } // 3，交换两个值的位置 int temp = arr[left]; arr[left] = arr[right]; arr[right] = temp; } //基准数归位 int temp = arr[left]; arr[left] = arr[left0]; arr[left0] = temp; // 递归调用自己,将左半部分排好序 quiteSort(arr,left0,left-1); // 递归调用自己,将右半部分排好序 quiteSort(arr,left +1,right0); } } 1.5.4. 5.4 Arrays (应用) Arrays的常用方法 | 方法名 | 说明 | | ---------------------------------------- | ----------------- | | public static String toString(int[] a) | 返回指定数组的内容的字符串表示形式 | | public static void sort(int[] a) | 按照数字顺序排列指定的数组 | | public static int binarySearch(int[] a, int key) | 利用二分查找返回指定元素的索引 | 示例代码 public class MyArraysDemo { public static void main(String[] args) { // public static String toString(int[] a) 返回指定数组的内容的字符串表示形式 // int [] arr = {3,2,4,6,7}; // System.out.println(Arrays.toString(arr)); // public static void sort(int[] a) 按照数字顺序排列指定的数组 // int [] arr = {3,2,4,6,7}; // Arrays.sort(arr); // System.out.println(Arrays.toString(arr)); // public static int binarySearch(int[] a, int key) 利用二分查找返回指定元素的索引 int [] arr = {1,2,3,4,5,6,7,8,9,10}; int index = Arrays.binarySearch(arr, 0); System.out.println(index); //1,数组必须有序 //2.如果要查找的元素存在,那么返回的是这个元素实际的索引 //3.如果要查找的元素不存在,那么返回的是 (-插入点-1) //插入点:如果这个元素在数组中,他应该在哪个索引上. } } 工具类设计思想 构造方法用 private 修饰 成员用 public static 修饰 Copyright © MISIN 2022 | 豫ICP备2021006345号-1 all right reserved，powered by Gitbook该文件修订时间： 2022-11-10 13:26:30 "},"1.JAVA基础/day15-常用API02.html":{"url":"1.JAVA基础/day15-常用API02.html","title":"day15-常用API02","keywords":"","body":"1.1. 1.时间日期类1.1.1. 1.1 Date类（应用）1.1.2. 1.2 Date类常用方法（应用）1.1.3. 1.3 SimpleDateFormat类（应用）1.1.4. 1.4 时间日期类练习 (应用)1.2. 2.JDK8时间日期类1.2.1. 2.1 JDK8新增日期类 (理解)1.2.2. 2.2 LocalDateTime创建方法 (应用)1.2.3. 2.3 LocalDateTime获取方法 (应用)1.2.4. 2.4 LocalDateTime转换方法 (应用)1.2.5. 2.5 LocalDateTime格式化和解析 (应用)1.2.6. 2.6 LocalDateTime增加或者减少时间的方法 (应用)1.2.7. 2.7 LocalDateTime减少或者增加时间的方法 (应用)1.2.8. 2.8 LocalDateTime修改方法 (应用)1.2.9. 2.9 Period (应用)1.2.10. 2.10 Duration (应用)1.3. 3.异常1.3.1. 3.1 异常（记忆）1.3.2. 3.2 编译时异常和运行时异常的区别（记忆）1.3.3. 3.3 JVM默认处理异常的方式（理解）1.3.4. 3.4 查看异常信息 (理解)1.3.5. 3.5 throws方式处理异常（应用）1.3.6. 3.6 throw抛出异常 (应用)1.3.7. 3.7 try-catch方式处理异常（应用）1.3.8. 3.8 Throwable成员方法（应用）1.3.9. 3.9 异常的练习 (应用)1.3.10. 3.10 自定义异常（应用）1.4. 4.Optional1.4.1. 4.1获取对象(应用)1.4.2. 4.2常用方法(应用)1.4.3. 4.3处理空指针的方法(应用)1.1. 1.时间日期类 1.1.1. 1.1 Date类（应用） 计算机中时间原点 1970年1月1日 00:00:00 时间换算单位 1秒 = 1000毫秒 Date类概述 Date 代表了一个特定的时间，精确到毫秒 Date类构造方法 | 方法名 | 说明 | | -——————— | ———————————— | | public Date() | 分配一个 Date对象，并初始化，以便它代表它被分配的时间，精确到毫秒 | | public Date(long date) | 分配一个 Date对象，并将其初始化为表示从标准基准时间起指定的毫秒数 | 示例代码 public class DateDemo01 { public static void main(String[] args) { //public Date()：分配一个 Date对象，并初始化，以便它代表它被分配的时间，精确到毫秒 Date d1 = new Date(); System.out.println(d1); //public Date(long date)：分配一个 Date对象，并将其初始化为表示从标准基准时间起指定的毫秒数 long date = 1000*60*60; Date d2 = new Date(date); System.out.println(d2); } } 1.1.2. 1.2 Date类常用方法（应用） 常用方法 | 方法名 | 说明 | | —————————— | -——————————— | | public long getTime() | 获取的是日期对象从1970年1月1日 00:00:00到现在的毫秒值 | | public void setTime(long time) | 设置时间，给的是毫秒值 | 示例代码 public class DateDemo02 { public static void main(String[] args) { //创建日期对象 Date d = new Date(); //public long getTime():获取的是日期对象从1970年1月1日 00:00:00到现在的毫秒值 // System.out.println(d.getTime()); // System.out.println(d.getTime() * 1.0 / 1000 / 60 / 60 / 24 / 365 + “年”); //public void setTime(long time):设置时间，给的是毫秒值 // long time = 1000*60*60; long time = System.currentTimeMillis(); d.setTime(time); System.out.println(d); } } 1.1.3. 1.3 SimpleDateFormat类（应用） SimpleDateFormat类概述 ​ SimpleDateFormat是一个具体的类，用于以区域设置敏感的方式格式化和解析日期。 ​ 我们重点学习日期格式化和解析 SimpleDateFormat类构造方法 | 方法名 | 说明 | | ————————————— | ———————————— | | public SimpleDateFormat() | 构造一个SimpleDateFormat，使用默认模式和日期格式 | | public SimpleDateFormat(String pattern) | 构造一个SimpleDateFormat使用给定的模式和默认的日期格式 | SimpleDateFormat类的常用方法 格式化(从Date到String) public final String format(Date date)：将日期格式化成日期/时间字符串 解析(从String到Date) public Date parse(String source)：从给定字符串的开始解析文本以生成日期 示例代码 public class SimpleDateFormatDemo { public static void main(String[] args) throws ParseException { //格式化：从 Date 到 String Date d = new Date(); // SimpleDateFormat sdf = new SimpleDateFormat(); SimpleDateFormat sdf = new SimpleDateFormat(“yyyy年MM月dd日 HH:mm:ss”); String s = sdf.format(d); System.out.println(s); System.out.println(“———“); //从 String 到 Date String ss = “2048-08-09 11:11:11”; //ParseException SimpleDateFormat sdf2 = new SimpleDateFormat(“yyyy-MM-dd HH:mm:ss”); Date dd = sdf2.parse(ss); System.out.println(dd); } } 1.1.4. 1.4 时间日期类练习 (应用) 需求 秒杀开始时间是2020年11月11日 00:00:00,结束时间是2020年11月11日 00:10:00,用户小贾下单时间是2020年11月11日 00:03:47,用户小皮下单时间是2020年11月11日 00:10:11,判断用户有没有成功参与秒杀活动 实现步骤 判断下单时间是否在开始到结束的范围内 把字符串形式的时间变成毫秒值 代码实现 public class DateDemo5 { public static void main(String[] args) throws ParseException { //开始时间：2020年11月11日 0:0:0 //结束时间：2020年11月11日 0:10:0 //小贾2020年11月11日 0:03:47 //小皮2020年11月11日 0:10:11 //1.判断两位同学的下单时间是否在范围之内就可以了。 //2.要把每一个时间都换算成毫秒值。 String start = “2020年11月11日 0:0:0”; String end = “2020年11月11日 0:10:0”; String jia = “2020年11月11日 0:03:47”; String pi = “2020年11月11日 0:10:11”; SimpleDateFormat sdf = new SimpleDateFormat(“yyyy年MM月dd日 HH:mm:ss”); long startTime = sdf.parse(start).getTime(); long endTime = sdf.parse(end).getTime(); // System.out.println(startTime); // System.out.println(endTime); long jiaTime = sdf.parse(jia).getTime(); long piTime = sdf.parse(pi).getTime(); if(jiaTime >= startTime && jiaTime = startTime && piTime 1.2. 2.JDK8时间日期类 1.2.1. 2.1 JDK8新增日期类 (理解) LocalDate 表示日期（年月日） LocalTime 表示时间（时分秒） LocalDateTime 表示时间+ 日期 （年月日时分秒） 1.2.2. 2.2 LocalDateTime创建方法 (应用) 方法说明 | 方法名 | 说明 | | -————————————— | -—————————— | | public static LocalDateTime now() | 获取当前系统时间 | | public static LocalDateTime of (年, 月 , 日, 时, 分, 秒) | 使用指定年月日和时分秒初始化一个LocalDateTime对象 | 示例代码 public class JDK8DateDemo2 { public static void main(String[] args) { LocalDateTime now = LocalDateTime.now(); System.out.println(now); LocalDateTime localDateTime = LocalDateTime.of(2020, 11, 11, 11, 11, 11); System.out.println(localDateTime); } } 1.2.3. 2.3 LocalDateTime获取方法 (应用) 方法说明 | 方法名 | 说明 | | -—————————— | -————— | | public int getYear() | 获取年 | | public int getMonthValue() | 获取月份（1-12） | | public int getDayOfMonth() | 获取月份中的第几天（1-31） | | public int getDayOfYear() | 获取一年中的第几天（1-366） | | public DayOfWeek getDayOfWeek() | 获取星期 | | public int getMinute() | 获取分钟 | | public int getHour() | 获取小时 | 示例代码 public class JDK8DateDemo3 { public static void main(String[] args) { LocalDateTime localDateTime = LocalDateTime.of(2020, 11, 11, 11, 11, 20); //public int getYear() 获取年 int year = localDateTime.getYear(); System.out.println(“年为” +year); //public int getMonthValue() 获取月份（1-12） int month = localDateTime.getMonthValue(); System.out.println(“月份为” + month); Month month1 = localDateTime.getMonth(); // System.out.println(month1); //public int getDayOfMonth() 获取月份中的第几天（1-31） int day = localDateTime.getDayOfMonth(); System.out.println(“日期为” + day); //public int getDayOfYear() 获取一年中的第几天（1-366） int dayOfYear = localDateTime.getDayOfYear(); System.out.println(“这是一年中的第” + dayOfYear + “天”); //public DayOfWeek getDayOfWeek()获取星期 DayOfWeek dayOfWeek = localDateTime.getDayOfWeek(); System.out.println(“星期为” + dayOfWeek); //public int getMinute() 获取分钟 int minute = localDateTime.getMinute(); System.out.println(“分钟为” + minute); //public int getHour() 获取小时 int hour = localDateTime.getHour(); System.out.println(“小时为” + hour); } } 1.2.4. 2.4 LocalDateTime转换方法 (应用) 方法说明 | 方法名 | 说明 | | ——————————— | —————— | | public LocalDate toLocalDate () | 转换成为一个LocalDate对象 | | public LocalTime toLocalTime () | 转换成为一个LocalTime对象 | 示例代码 public class JDK8DateDemo4 { public static void main(String[] args) { LocalDateTime localDateTime = LocalDateTime.of(2020, 12, 12, 8, 10, 12); //public LocalDate toLocalDate () 转换成为一个LocalDate对象 LocalDate localDate = localDateTime.toLocalDate(); System.out.println(localDate); //public LocalTime toLocalTime () 转换成为一个LocalTime对象 LocalTime localTime = localDateTime.toLocalTime(); System.out.println(localTime); } } 1.2.5. 2.5 LocalDateTime格式化和解析 (应用) 方法说明 | 方法名 | 说明 | | -————————————— | ————————————— | | public String format (指定格式) | 把一个LocalDateTime格式化成为一个字符串 | | public LocalDateTime parse (准备解析的字符串, 解析格式) | 把一个日期字符串解析成为一个LocalDateTime对象 | | public static DateTimeFormatter ofPattern(String pattern) | 使用指定的日期模板获取一个日期格式化器DateTimeFormatter对象 | 示例代码 public class JDK8DateDemo5 { public static void main(String[] args) { //method1(); //method2(); } private static void method2() { //public static LocalDateTime parse (准备解析的字符串, 解析格式) 把一个日期字符串解析成为一个LocalDateTime对象 String s = “2020年11月12日 13:14:15”; DateTimeFormatter pattern = DateTimeFormatter.ofPattern(“yyyy年MM月dd日 HH:mm:ss”); LocalDateTime parse = LocalDateTime.parse(s, pattern); System.out.println(parse); } private static void method1() { LocalDateTime localDateTime = LocalDateTime.of(2020, 11, 12, 13, 14, 15); System.out.println(localDateTime); //public String format (指定格式) 把一个LocalDateTime格式化成为一个字符串 DateTimeFormatter pattern = DateTimeFormatter.ofPattern(“yyyy年MM月dd日 HH:mm:ss”); String s = localDateTime.format(pattern); System.out.println(s); } } 1.2.6. 2.6 LocalDateTime增加或者减少时间的方法 (应用) 方法说明 | 方法名 | 说明 | | -————————————— | -—— | | public LocalDateTime plusYears (long years) | 添加或者减去年 | | public LocalDateTime plusMonths(long months) | 添加或者减去月 | | public LocalDateTime plusDays(long days) | 添加或者减去日 | | public LocalDateTime plusHours(long hours) | 添加或者减去时 | | public LocalDateTime plusMinutes(long minutes) | 添加或者减去分 | | public LocalDateTime plusSeconds(long seconds) | 添加或者减去秒 | | public LocalDateTime plusWeeks(long weeks) | 添加或者减去周 | 示例代码 /** * JDK8 时间类添加或者减去时间的方法 */ public class JDK8DateDemo6 { public static void main(String[] args) { //public LocalDateTime plusYears (long years) 添加或者减去年 LocalDateTime localDateTime = LocalDateTime.of(2020, 11, 11, 13, 14, 15); //LocalDateTime newLocalDateTime = localDateTime.plusYears(1); //System.out.println(newLocalDateTime); LocalDateTime newLocalDateTime = localDateTime.plusYears(-1); System.out.println(newLocalDateTime); } } 1.2.7. 2.7 LocalDateTime减少或者增加时间的方法 (应用) 方法说明 | 方法名 | 说明 | | -————————————— | -—— | | public LocalDateTime minusYears (long years) | 减去或者添加年 | | public LocalDateTime minusMonths(long months) | 减去或者添加月 | | public LocalDateTime minusDays(long days) | 减去或者添加日 | | public LocalDateTime minusHours(long hours) | 减去或者添加时 | | public LocalDateTime minusMinutes(long minutes) | 减去或者添加分 | | public LocalDateTime minusSeconds(long seconds) | 减去或者添加秒 | | public LocalDateTime minusWeeks(long weeks) | 减去或者添加周 | 示例代码 /** * JDK8 时间类减少或者添加时间的方法 */ public class JDK8DateDemo7 { public static void main(String[] args) { //public LocalDateTime minusYears (long years) 减去或者添加年 LocalDateTime localDateTime = LocalDateTime.of(2020, 11, 11, 13, 14, 15); //LocalDateTime newLocalDateTime = localDateTime.minusYears(1); //System.out.println(newLocalDateTime); LocalDateTime newLocalDateTime = localDateTime.minusYears(-1); System.out.println(newLocalDateTime); } } 1.2.8. 2.8 LocalDateTime修改方法 (应用) 方法说明 | 方法名 | 说明 | | -————————————— | -————— | | public LocalDateTime withYear(int year) | 直接修改年 | | public LocalDateTime withMonth(int month) | 直接修改月 | | public LocalDateTime withDayOfMonth(int dayofmonth) | 直接修改日期(一个月中的第几天) | | public LocalDateTime withDayOfYear(int dayOfYear) | 直接修改日期(一年中的第几天) | | public LocalDateTime withHour(int hour) | 直接修改小时 | | public LocalDateTime withMinute(int minute) | 直接修改分钟 | | public LocalDateTime withSecond(int second) | 直接修改秒 | 示例代码 /** * JDK8 时间类修改时间 */ public class JDK8DateDemo8 { public static void main(String[] args) { //public LocalDateTime withYear(int year) 修改年 LocalDateTime localDateTime = LocalDateTime.of(2020, 11, 11, 13, 14, 15); // LocalDateTime newLocalDateTime = localDateTime.withYear(2048); // System.out.println(newLocalDateTime); LocalDateTime newLocalDateTime = localDateTime.withMonth(20); System.out.println(newLocalDateTime); } } 1.2.9. 2.9 Period (应用) 方法说明 | 方法名 | 说明 | | ————————————— | ———— | | public static Period between(开始时间,结束时间) | 计算两个“时间”的间隔 | | public int getYears() | 获得这段时间的年数 | | public int getMonths() | 获得此期间的总月数 | | public int getDays() | 获得此期间的天数 | | public long toTotalMonths() | 获取此期间的总月数 | 示例代码 /** * 计算两个时间的间隔 */ public class JDK8DateDemo9 { public static void main(String[] args) { //public static Period between(开始时间,结束时间) 计算两个”时间”的间隔 LocalDate localDate1 = LocalDate.of(2020, 1, 1); LocalDate localDate2 = LocalDate.of(2048, 12, 12); Period period = Period.between(localDate1, localDate2); System.out.println(period);//P28Y11M11D //public int getYears() 获得这段时间的年数 System.out.println(period.getYears());//28 //public int getMonths() 获得此期间的月数 System.out.println(period.getMonths());//11 //public int getDays() 获得此期间的天数 System.out.println(period.getDays());//11 //public long toTotalMonths() 获取此期间的总月数 System.out.println(period.toTotalMonths());//347 } } 1.2.10. 2.10 Duration (应用) 方法说明 | 方法名 | 说明 | | -————————————— | ———— | | public static Durationbetween(开始时间,结束时间) | 计算两个“时间”的间隔 | | public long toSeconds() | 获得此时间间隔的秒 | | public int toMillis() | 获得此时间间隔的毫秒 | | public int toNanos() | 获得此时间间隔的纳秒 | 示例代码 /** * 计算两个时间的间隔 */ public class JDK8DateDemo10 { public static void main(String[] args) { //public static Duration between(开始时间,结束时间) 计算两个“时间”的间隔 LocalDateTime localDateTime1 = LocalDateTime.of(2020, 1, 1, 13, 14, 15); LocalDateTime localDateTime2 = LocalDateTime.of(2020, 1, 2, 11, 12, 13); Duration duration = Duration.between(localDateTime1, localDateTime2); System.out.println(duration);//PT21H57M58S //public long toSeconds() 获得此时间间隔的秒 System.out.println(duration.toSeconds());//79078 //public int toMillis() 获得此时间间隔的毫秒 System.out.println(duration.toMillis());//79078000 //public int toNanos() 获得此时间间隔的纳秒 System.out.println(duration.toNanos());//79078000000000 } } 1.3. 3.异常 1.3.1. 3.1 异常（记忆） 异常的概述 ​ 异常就是程序出现了不正常的情况 异常的体系结构 1.3.2. 3.2 编译时异常和运行时异常的区别（记忆） 编译时异常 都是Exception类及其子类 必须显示处理，否则程序就会发生错误，无法通过编译 运行时异常 都是RuntimeException类及其子类 无需显示处理，也可以和编译时异常一样处理 图示 1.3.3. 3.3 JVM默认处理异常的方式（理解） 如果程序出现了问题，我们没有做任何处理，最终JVM 会做默认的处理，处理方式有如下两个步骤： 把异常的名称，错误原因及异常出现的位置等信息输出在了控制台 程序停止执行 1.3.4. 3.4 查看异常信息 (理解) 控制台在打印异常信息时,会打印异常类名,异常出现的原因,异常出现的位置 我们调bug时,可以根据提示,找到异常出现的位置,分析原因,修改异常代码 1.3.5. 3.5 throws方式处理异常（应用） 定义格式 public void 方法() throws 异常类名 { } 示例代码 public class ExceptionDemo { public static void main(String[] args) throws ParseException{ System.out.println(\"开始\"); // method(); method2(); System.out.println(\"结束\"); } //编译时异常 public static void method2() throws ParseException { String s = \"2048-08-09\"; SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd\"); Date d = sdf.parse(s); System.out.println(d); } //运行时异常 public static void method() throws ArrayIndexOutOfBoundsException { int[] arr = {1, 2, 3}; System.out.println(arr[3]); } } 注意事项 这个throws格式是跟在方法的括号后面的 编译时异常必须要进行处理，两种处理方案：try...catch …或者 throws，如果采用 throws 这种方案，在方法上进行显示声明,将来谁调用这个方法谁处理 运行时异常因为在运行时才会发生,所以在方法后面可以不写,运行时出现异常默认交给jvm处理 1.3.6. 3.6 throw抛出异常 (应用) 格式 throw new 异常(); 注意 这个格式是在方法内的，表示当前代码手动抛出一个异常，下面的代码不用再执行了 throws和throw的区别 | throws | throw | | ----------------------- | --------------------- | | 用在方法声明后面，跟的是异常类名 | 用在方法体内，跟的是异常对象名 | | 表示声明异常，调用该方法有可能会出现这样的异常 | 表示手动抛出异常对象，由方法体内的语句处理 | 示例代码 public class ExceptionDemo8 { public static void main(String[] args) { //int [] arr = {1,2,3,4,5}; int [] arr = null; printArr(arr);//就会 接收到一个异常. //我们还需要自己处理一下异常. } private static void printArr(int[] arr) { if(arr == null){ //调用者知道成功打印了吗? //System.out.println(\"参数不能为null\"); throw new NullPointerException(); //当参数为null的时候 //手动创建了一个异常对象,抛给了调用者,产生了一个异常 }else{ for (int i = 0; i 1.3.7. 3.7 try-catch方式处理异常（应用） 定义格式 try { 可能出现异常的代码; } catch(异常类名 变量名) { 异常的处理代码; } 执行流程 程序从 try 里面的代码开始执行 出现异常，就会跳转到对应的 catch 里面去执行 执行完毕之后，程序还可以继续往下执行 示例代码 public class ExceptionDemo01 { public static void main(String[] args) { System.out.println(\"开始\"); method(); System.out.println(\"结束\"); } public static void method() { try { int[] arr = {1, 2, 3}; System.out.println(arr[3]); System.out.println(\"这里能够访问到吗\"); } catch (ArrayIndexOutOfBoundsException e) { System.out.println(\"你访问的数组索引不存在，请回去修改为正确的索引\"); } } } 注意 如果 try 中没有遇到问题，怎么执行？ 会把try中所有的代码全部执行完毕,不会执行catch里面的代码 如果 try 中遇到了问题，那么 try 下面的代码还会执行吗？ 那么直接跳转到对应的catch语句中,try下面的代码就不会再执行了 当catch里面的语句全部执行完毕,表示整个体系全部执行完全,继续执行下面的代码 如果出现的问题没有被捕获，那么程序如何运行？ 那么try...catch就相当于没有写.那么也就是自己没有处理. 默认交给虚拟机处理. 同时有可能出现多个异常怎么处理？ 出现多个异常,那么就写多个catch就可以了. 注意点:如果多个异常之间存在子父类关系.那么父类一定要写在下面 1.3.8. 3.8 Throwable成员方法（应用） 常用方法 | 方法名 | 说明 | | ----------------------------- | ---------------------- | | public String getMessage() | 返回此 throwable 的详细消息字符串 | | public String toString() | 返回此可抛出的简短描述 | | public void printStackTrace() | 把异常的错误信息输出在控制台 | 示例代码 public class ExceptionDemo02 { public static void main(String[] args) { System.out.println(\"开始\"); method(); System.out.println(\"结束\"); } public static void method() { try { int[] arr = {1, 2, 3}; System.out.println(arr[3]); //new ArrayIndexOutOfBoundsException(); System.out.println(\"这里能够访问到吗\"); } catch (ArrayIndexOutOfBoundsException e) { //new ArrayIndexOutOfBoundsException(); // e.printStackTrace(); //public String getMessage():返回此 throwable 的详细消息字符串 // System.out.println(e.getMessage()); //Index 3 out of bounds for length 3 //public String toString():返回此可抛出的简短描述 // System.out.println(e.toString()); //java.lang.ArrayIndexOutOfBoundsException: Index 3 out of bounds for length 3 //public void printStackTrace():把异常的错误信息输出在控制台 e.printStackTrace(); // java.lang.ArrayIndexOutOfBoundsException: Index 3 out of bounds for length 3 // at com.itheima_02.ExceptionDemo02.method(ExceptionDemo02.java:18) // at com.itheima_02.ExceptionDemo02.main(ExceptionDemo02.java:11) } } } 1.3.9. 3.9 异常的练习 (应用) 需求 键盘录入学生的姓名和年龄,其中年龄为18 - 25岁,超出这个范围是异常数据不能赋值.需要重新录入,一直录到正确为止 实现步骤 创建学生对象 键盘录入姓名和年龄，并赋值给学生对象 如果是非法数据就再次录入 代码实现 学生类 public class Student { private String name; private int age; public Student() { } public Student(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { if(age >= 18 && age 测试类 public class ExceptionDemo12 { public static void main(String[] args) { // 键盘录入学生的姓名和年龄,其中年龄为 18 - 25岁, // 超出这个范围是异常数据不能赋值.需要重新录入,一直录到正确为止。 Student s = new Student(); Scanner sc = new Scanner(System.in); System.out.println(\"请输入姓名\"); String name = sc.nextLine(); s.setName(name); while(true){ System.out.println(\"请输入年龄\"); String ageStr = sc.nextLine(); try { int age = Integer.parseInt(ageStr); s.setAge(age); break; } catch (NumberFormatException e) { System.out.println(\"请输入一个整数\"); continue; } catch (AgeOutOfBoundsException e) { System.out.println(e.toString()); System.out.println(\"请输入一个符合范围的年龄\"); continue; } /*if(age >= 18 && age 1.3.10. 3.10 自定义异常（应用） 自定义异常概述 当Java中提供的异常不能满足我们的需求时,我们可以自定义异常 实现步骤 定义异常类 写继承关系 提供空参构造 提供带参构造 代码实现 异常类 public class AgeOutOfBoundsException extends RuntimeException { public AgeOutOfBoundsException() { } public AgeOutOfBoundsException(String message) { super(message); } } 学生类 public class Student { private String name; private int age; public Student() { } public Student(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { if(age >= 18 && age 测试类 public class ExceptionDemo12 { public static void main(String[] args) { // 键盘录入学生的姓名和年龄,其中年龄为 18 - 25岁, // 超出这个范围是异常数据不能赋值.需要重新录入,一直录到正确为止。 Student s = new Student(); Scanner sc = new Scanner(System.in); System.out.println(\"请输入姓名\"); String name = sc.nextLine(); s.setName(name); while(true){ System.out.println(\"请输入年龄\"); String ageStr = sc.nextLine(); try { int age = Integer.parseInt(ageStr); s.setAge(age); break; } catch (NumberFormatException e) { System.out.println(\"请输入一个整数\"); continue; } catch (AgeOutOfBoundsException e) { System.out.println(e.toString()); System.out.println(\"请输入一个符合范围的年龄\"); continue; } /*if(age >= 18 && age 1.4. 4.Optional 1.4.1. 4.1获取对象(应用) Optional概述 可能包含或不包含非null值的容器对象 方法介绍 | 方法名 | 说明 | | ---------------------------------------- | ---------------------------------------- | | static Optional of(T value) | 获取一个Optional对象，封装的是非null值的对象 | | static Optional ofNullable(T value) | 获取一个Optional对象，Optional封装的值对象可以是null也可以不是null | 示例代码 public class OptionalDemo1 { public static void main(String[] args) { //method1(); //public static Optional ofNullable(T value) //获取一个Optional对象，Optional封装的值对象可以是null也可以不是null //Student s = new Student(\"zhangsan\",23); Student s = null; //ofNullable方法，封装的对象可以是null，也可以不是null。 Optional optional = Optional.ofNullable(s); System.out.println(optional); } private static void method1() { //static Optional of(T value) 获取一个Optional对象，封装的是非null值的对象 //Student s = new Student(\"zhangsan\",23); Student s = null; //Optional可以看做是一个容器，里面装了一个引用数据类型的对象。 //返回值就是Optional的对象 //如果使用of方法，封装的对象如果为空，那么还是会抛出空指针异常 Optional optional1 = Optional.of(s); System.out.println(optional1); } } 1.4.2. 4.2常用方法(应用) 方法介绍 | 方法名 | 说明 | | ------------------- | ------------------------------------ | | T get() | 如果存在值,返回值,否则抛出NoSuchElementException | | boolean isPresent() | 如果存在值,则返回true,否则为false | 示例代码 public class OptionalDemo2 { public static void main(String[] args) { //get() 如果存在值，返回值，否则抛出NoSuchElementException //public boolean isPresent() 判断Optional所封装的对象是否不为空，如果不为空返回true , 否则返回false //Student s = new Student(\"zhangsan\",23); Student s = null; Optional optional = Optional.ofNullable(s); //如果封装的是一个null，那么通过get方法再次获取会抛出NoSuchElementException。 if(optional.isPresent()){ Student student = optional.get(); System.out.println(student); }else{ System.out.println(\"Optional封装的对象为空\"); } } } 1.4.3. 4.3处理空指针的方法(应用) 方法介绍 | 方法名 | 说明 | | ---------------------------------------- | -------------------------------- | | T orElse(T other) | 如果不为空,则返回具体的值,否则返回参数中的值 | | T orElseGet(Supplier supplier) | 如果不为空,则返回具体的值,否则返回由括号中函数产生的结果 | | void ifPresent (Consumer action) | 如果不为空,则使用该值执行给定的操作,否则不执行任何操作 | | void ifPresentOrElse(Consumer action, Runnable emptyAction) | 如果不为空,则使用该值执行给定的操作,否则执行给定的基于空的操作 | 示例代码 public class OptionalDemo3 { public static void main(String[] args) { //method1(); //method2(); //method3(); //method4(); } private static void method4() { //Student s = new Student(\"zhangsan\",23); Student s = null; Optional optional = Optional.ofNullable(s); //public void ifPresentOrElse(Consumer action, Runnable emptyAction)、 //如果不为空，则使用该值执行给定的操作，否则执行给定的基于空的操作。 optional.ifPresentOrElse(student -> System.out.println(student), ()->System.out.println(\"为空了\")); } private static void method3() { //Student s = new Student(\"zhangsan\",23); Student s = null; Optional optional = Optional.ofNullable(s); //ifPresent (Consumer action) //如果不为空，则使用该值执行给定的操作，否则不执行任何操作 optional.ifPresent(student -> System.out.println(student)); } private static void method2() { Student s = new Student(\"zhangsan\",23); //Student s = null; Optional optional = Optional.ofNullable(s); //orElseGet(Supplier supplier) //如果不为空，则返回具体的值，否则返回由括号中函数产生的结果 Student student = optional.orElseGet(()-> new Student(\"lisi\" , 24)); System.out.println(student); } private static void method1() { //Student s = new Student(\"zhangsan\",23); Student s = null; Optional optional = Optional.ofNullable(s); //orElse(T other) 如果不为空，则返回具体的值，否则返回参数中的值 Student student = optional.orElse(new Student(\"lisi\", 24)); System.out.println(student); } } Copyright © MISIN 2022 | 豫ICP备2021006345号-1 all right reserved，powered by Gitbook该文件修订时间： 2022-11-10 13:25:36 "},"1.JAVA基础/day16集合01.html":{"url":"1.JAVA基础/day16集合01.html","title":"day16集合01","keywords":"","body":"1.1. 1.Collection集合1.1.1. 1.1数组和集合的区别【理解】1.1.2. 1.2集合类体系结构【理解】1.1.3. 1.3Collection 集合概述和使用【应用】1.1.4. 1.4Collection集合的遍历【应用】1.1.5. 1.5增强for循环【应用】1.2. 2.List集合1.2.1. 2.1List集合的概述和特点【记忆】1.2.2. 2.2List集合的特有方法【应用】1.3. 3.数据结构1.3.1. 3.1数据结构之栈和队列【记忆】1.3.2. 3.2数据结构之数组和链表【记忆】1.4. 4.List集合的实现类1.4.1. 4.1List集合子类的特点【记忆】1.4.2. 4.2LinkedList集合的特有功能【应用】1.5. 5.泛型1.5.1. 5.1泛型概述【理解】1.5.2. 5.2泛型类【应用】1.5.3. 5.3泛型方法【应用】1.5.4. 5.4泛型接口【应用】1.5.5. 5.5类型通配符1.1. 1.Collection集合 1.1.1. 1.1数组和集合的区别【理解】 相同点 都是容器,可以存储多个数据 不同点 数组的长度是不可变的,集合的长度是可变的 数组可以存基本数据类型和引用数据类型 集合只能存引用数据类型,如果要存基本数据类型,需要存对应的包装类 1.1.2. 1.2集合类体系结构【理解】 1.1.3. 1.3Collection 集合概述和使用【应用】 Collection集合概述 是单例集合的顶层接口,它表示一组对象,这些对象也称为Collection的元素 JDK 不提供此接口的任何直接实现.它提供更具体的子接口(如Set和List)实现 创建Collection集合的对象 多态的方式 具体的实现类ArrayList Collection集合常用方法 | 方法名 | 说明 | | :------------------------- | :---------------- | | boolean add(E e) | 添加元素 | | boolean remove(Object o) | 从集合中移除指定的元素 | | boolean removeIf(Object o) | 根据条件进行移除 | | void clear() | 清空集合中的元素 | | boolean contains(Object o) | 判断集合中是否存在指定的元素 | | boolean isEmpty() | 判断集合是否为空 | | int size() | 集合的长度，也就是集合中元素的个数 | 1.1.4. 1.4Collection集合的遍历【应用】 迭代器介绍 迭代器,集合的专用遍历方式 Iterator iterator(): 返回此集合中元素的迭代器,通过集合对象的iterator()方法得到 Iterator中的常用方法 ​ boolean hasNext(): 判断当前位置是否有元素可以被取出 ​ E next(): 获取当前位置的元素,将迭代器对象移向下一个索引位置 Collection集合的遍历 public class IteratorDemo1 { public static void main(String[] args) { //创建集合对象 Collection c = new ArrayList<>(); //添加元素 c.add(\"hello\"); c.add(\"world\"); c.add(\"java\"); c.add(\"javaee\"); //Iterator iterator()：返回此集合中元素的迭代器，通过集合的iterator()方法得到 Iterator it = c.iterator(); //用while循环改进元素的判断和获取 while (it.hasNext()) { String s = it.next(); System.out.println(s); } } } 迭代器中删除的方法 ​ void remove(): 删除迭代器对象当前指向的元素 public class IteratorDemo2 { public static void main(String[] args) { ArrayList list = new ArrayList<>(); list.add(\"a\"); list.add(\"b\"); list.add(\"b\"); list.add(\"c\"); list.add(\"d\"); Iterator it = list.iterator(); while(it.hasNext()){ String s = it.next(); if(\"b\".equals(s)){ //指向谁,那么此时就删除谁. it.remove(); } } System.out.println(list); } } 1.1.5. 1.5增强for循环【应用】 介绍 它是JDK5之后出现的,其内部原理是一个Iterator迭代器 实现Iterable接口的类才可以使用迭代器和增强for 简化数组和Collection集合的遍历 格式 ​ for(集合/数组中元素的数据类型 变量名 : 集合/数组名) { ​ // 已经将当前遍历到的元素封装到变量中了,直接使用变量即可 ​ } 代码 public class MyCollectonDemo1 { public static void main(String[] args) { ArrayList list = new ArrayList<>(); list.add(\"a\"); list.add(\"b\"); list.add(\"c\"); list.add(\"d\"); list.add(\"e\"); list.add(\"f\"); //1,数据类型一定是集合或者数组中元素的类型 //2,str仅仅是一个变量名而已,在循环的过程中,依次表示集合或者数组中的每一个元素 //3,list就是要遍历的集合或者数组 for(String str : list){ System.out.println(str); } } } 1.2. 2.List集合 1.2.1. 2.1List集合的概述和特点【记忆】 List集合的概述 有序集合,这里的有序指的是存取顺序 用户可以精确控制列表中每个元素的插入位置,用户可以通过整数索引访问元素,并搜索列表中的元素 与Set集合不同,列表通常允许重复的元素 List集合的特点 存取有序 可以重复 有索引 1.2.2. 2.2List集合的特有方法【应用】 方法名 描述 void add(int index,E element) 在此集合中的指定位置插入指定的元素 E remove(int index) 删除指定索引处的元素，返回被删除的元素 E set(int index,E element) 修改指定索引处的元素，返回被修改的元素 E get(int index) 返回指定索引处的元素 1.3. 3.数据结构 1.3.1. 3.1数据结构之栈和队列【记忆】 栈结构 ​ 先进后出 队列结构 ​ 先进先出 1.3.2. 3.2数据结构之数组和链表【记忆】 数组结构 ​ 查询快、增删慢 队列结构 ​ 查询慢、增删快 1.4. 4.List集合的实现类 1.4.1. 4.1List集合子类的特点【记忆】 ArrayList集合 ​ 底层是数组结构实现，查询快、增删慢 LinkedList集合 ​ 底层是链表结构实现，查询慢、增删快 1.4.2. 4.2LinkedList集合的特有功能【应用】 特有方法 | 方法名 | 说明 | | ------------------------- | ---------------- | | public void addFirst(E e) | 在该列表开头插入指定的元素 | | public void addLast(E e) | 将指定的元素追加到此列表的末尾 | | public E getFirst() | 返回此列表中的第一个元素 | | public E getLast() | 返回此列表中的最后一个元素 | | public E removeFirst() | 从此列表中删除并返回第一个元素 | | public E removeLast() | 从此列表中删除并返回最后一个元素 | 1.5. 5.泛型 1.5.1. 5.1泛型概述【理解】 泛型的介绍 ​ 泛型是JDK5中引入的特性，它提供了编译时类型安全检测机制 泛型的好处 把运行时期的问题提前到了编译期间 避免了强制类型转换 泛型的定义格式 : 指定一种类型的格式.尖括号里面可以任意书写,一般只写一个字母.例如: : 指定多种类型的格式,多种类型之间用逗号隔开.例如: 1.5.2. 5.2泛型类【应用】 定义格式 修饰符 class 类名 { } 示例代码 泛型类 public class Generic { private T t; public T getT() { return t; } public void setT(T t) { this.t = t; } } 测试类 public class GenericDemo1 { public static void main(String[] args) { Generic g1 = new Generic(); g1.setT(\"杨幂\"); System.out.println(g1.getT()); Generic g2 = new Generic(); g2.setT(30); System.out.println(g2.getT()); Generic g3 = new Generic(); g3.setT(true); System.out.println(g3.getT()); } } 1.5.3. 5.3泛型方法【应用】 定义格式 修饰符 返回值类型 方法名(类型 变量名) { } 示例代码 带有泛型方法的类 public class Generic { public void show(T t) { System.out.println(t); } } 测试类 public class GenericDemo2 { public static void main(String[] args) { Generic g = new Generic(); g.show(\"柳岩\"); g.show(30); g.show(true); g.show(12.34); } } 1.5.4. 5.4泛型接口【应用】 定义格式 修饰符 interface 接口名 { } 示例代码 泛型接口 public interface Generic { void show(T t); } 泛型接口实现类1 ​ 定义实现类时,定义和接口相同泛型,创建实现类对象时明确泛型的具体类型 public class GenericImpl1 implements Generic { @Override public void show(T t) { System.out.println(t); } } 泛型接口实现类2 ​ 定义实现类时,直接明确泛型的具体类型 public class GenericImpl2 implements Generic{ @Override public void show(Integer t) { System.out.println(t); } } 测试类 public class GenericDemo3 { public static void main(String[] args) { GenericImpl1 g1 = new GenericImpl(); g1.show(\"林青霞\"); GenericImpl1 g2 = new GenericImpl(); g2.show(30); GenericImpl2 g3 = new GenericImpl2(); g3.show(10); } } 1.5.5. 5.5类型通配符 类型通配符: ArrayList: 表示元素类型未知的ArrayList,它的元素可以匹配任何的类型 但是并不能把元素添加到ArrayList中了,获取出来的也是父类类型 类型通配符上限: ArrayListList : 它表示的类型是Number或者其子类型 类型通配符下限: ArrayListList : 它表示的类型是Number或者其父类型 泛型通配符的使用 public class GenericDemo4 { public static void main(String[] args) { ArrayList list1 = new ArrayList<>(); ArrayList list2 = new ArrayList<>(); ArrayList list3 = new ArrayList<>(); ArrayList list4 = new ArrayList<>(); method(list1); method(list2); method(list3); method(list4); getElement1(list1); getElement1(list2);//报错 getElement1(list3); getElement1(list4);//报错 getElement2(list1);//报错 getElement2(list2);//报错 getElement2(list3); getElement2(list4); } // 泛型通配符: 此时的泛型?,可以是任意类型 public static void method(ArrayList list){} // 泛型的上限: 此时的泛型?,必须是Number类型或者Number类型的子类 public static void getElement1(ArrayList list){} // 泛型的下限: 此时的泛型?,必须是Number类型或者Number类型的父类 public static void getElement2(ArrayList list){} } Copyright © MISIN 2022 | 豫ICP备2021006345号-1 all right reserved，powered by Gitbook该文件修订时间： 2022-11-10 13:25:00 "},"1.JAVA基础/day17集合02.html":{"url":"1.JAVA基础/day17集合02.html","title":"day17集合02","keywords":"","body":"1.1. 1.Set集合1.1.1. 1.1Set集合概述和特点【应用】1.1.2. 1.2Set集合的使用【应用】1.2. 2.TreeSet集合1.2.1. 2.1TreeSet集合概述和特点【应用】1.2.2. 2.2TreeSet集合基本使用【应用】1.2.3. 2.3自然排序Comparable的使用【应用】1.2.4. 2.4比较器排序Comparator的使用【应用】1.2.5. 2.4两种比较方式总结【理解】1.3. 3.数据结构1.3.1. 3.1二叉树【理解】1.3.2. 3.2二叉查找树【理解】1.3.3. 3.3平衡二叉树【理解】1.3.4. 3.4红黑树【理解】1.3.5. 3.5成绩排序案例【应用】1.4. 4.HashSet集合1.4.1. 4.1HashSet集合概述和特点【应用】1.4.2. 4.2HashSet集合的基本应用【应用】1.4.3. 4.3哈希值【理解】1.4.4. 4.4哈希表结构【理解】1.4.5. 4.5HashSet集合存储学生对象并遍历【应用】1.1. 1.Set集合 1.1.1. 1.1Set集合概述和特点【应用】 不可以存储重复元素 没有索引,不能使用普通for循环遍历 1.1.2. 1.2Set集合的使用【应用】 存储字符串并遍历 public class MySet1 { public static void main(String[] args) { //创建集合对象 Set set = new TreeSet<>(); //添加元素 set.add(\"ccc\"); set.add(\"aaa\"); set.add(\"aaa\"); set.add(\"bbb\"); // for (int i = 0; i it = set.iterator(); while (it.hasNext()){ String s = it.next(); System.out.println(s); } System.out.println(\"-----------------------------------\"); for (String s : set) { System.out.println(s); } } } 1.2. 2.TreeSet集合 1.2.1. 2.1TreeSet集合概述和特点【应用】 不可以存储重复元素 没有索引 可以将元素按照规则进行排序 TreeSet()：根据其元素的自然排序进行排序 TreeSet(Comparator comparator) ：根据指定的比较器进行排序 1.2.2. 2.2TreeSet集合基本使用【应用】 存储Integer类型的整数并遍历 public class TreeSetDemo01 { public static void main(String[] args) { //创建集合对象 TreeSet ts = new TreeSet(); //添加元素 ts.add(10); ts.add(40); ts.add(30); ts.add(50); ts.add(20); ts.add(30); //遍历集合 for(Integer i : ts) { System.out.println(i); } } } 1.2.3. 2.3自然排序Comparable的使用【应用】 案例需求 存储学生对象并遍历，创建TreeSet集合使用无参构造方法 要求：按照年龄从小到大排序，年龄相同时，按照姓名的字母顺序排序 实现步骤 使用空参构造创建TreeSet集合 用TreeSet集合存储自定义对象，无参构造方法使用的是自然排序对元素进行排序的 自定义的Student类实现Comparable接口 自然排序，就是让元素所属的类实现Comparable接口，重写compareTo(T o)方法 重写接口中的compareTo方法 重写方法时，一定要注意排序规则必须按照要求的主要条件和次要条件来写 代码实现 学生类 public class Student implements Comparable{ private String name; private int age; public Student() { } public Student(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } @Override public String toString() { return \"Student{\" + \"name='\" + name + '\\'' + \", age=\" + age + '}'; } @Override public int compareTo(Student o) { //按照对象的年龄进行排序 //主要判断条件: 按照年龄从小到大排序 int result = this.age - o.age; //次要判断条件: 年龄相同时，按照姓名的字母顺序排序 result = result == 0 ? this.name.compareTo(o.getName()) : result; return result; } } 测试类 public class MyTreeSet2 { public static void main(String[] args) { //创建集合对象 TreeSet ts = new TreeSet<>(); //创建学生对象 Student s1 = new Student(\"zhangsan\",28); Student s2 = new Student(\"lisi\",27); Student s3 = new Student(\"wangwu\",29); Student s4 = new Student(\"zhaoliu\",28); Student s5 = new Student(\"qianqi\",30); //把学生添加到集合 ts.add(s1); ts.add(s2); ts.add(s3); ts.add(s4); ts.add(s5); //遍历集合 for (Student student : ts) { System.out.println(student); } } } 1.2.4. 2.4比较器排序Comparator的使用【应用】 案例需求 存储老师对象并遍历，创建TreeSet集合使用带参构造方法 要求：按照年龄从小到大排序，年龄相同时，按照姓名的字母顺序排序 实现步骤 用TreeSet集合存储自定义对象，带参构造方法使用的是比较器排序对元素进行排序的 比较器排序，就是让集合构造方法接收Comparator的实现类对象，重写compare(T o1,T o2)方法 重写方法时，一定要注意排序规则必须按照要求的主要条件和次要条件来写 代码实现 老师类 public class Teacher { private String name; private int age; public Teacher() { } public Teacher(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } @Override public String toString() { return \"Teacher{\" + \"name='\" + name + '\\'' + \", age=\" + age + '}'; } } 测试类 public class MyTreeSet4 { public static void main(String[] args) { //创建集合对象 TreeSet ts = new TreeSet<>(new Comparator() { @Override public int compare(Teacher o1, Teacher o2) { //o1表示现在要存入的那个元素 //o2表示已经存入到集合中的元素 //主要条件 int result = o1.getAge() - o2.getAge(); //次要条件 result = result == 0 ? o1.getName().compareTo(o2.getName()) : result; return result; } }); //创建老师对象 Teacher t1 = new Teacher(\"zhangsan\",23); Teacher t2 = new Teacher(\"lisi\",22); Teacher t3 = new Teacher(\"wangwu\",24); Teacher t4 = new Teacher(\"zhaoliu\",24); //把老师添加到集合 ts.add(t1); ts.add(t2); ts.add(t3); ts.add(t4); //遍历集合 for (Teacher teacher : ts) { System.out.println(teacher); } } } 1.2.5. 2.4两种比较方式总结【理解】 两种比较方式小结 自然排序: 自定义类实现Comparable接口,重写compareTo方法,根据返回值进行排序 比较器排序: 创建TreeSet对象的时候传递Comparator的实现类对象,重写compare方法,根据返回值进行排序 在使用的时候,默认使用自然排序,当自然排序不满足现在的需求时,必须使用比较器排序 两种方式中关于返回值的规则 如果返回值为负数，表示当前存入的元素是较小值，存左边 如果返回值为0，表示当前存入的元素跟集合中元素重复了，不存 如果返回值为正数，表示当前存入的元素是较大值，存右边 1.3. 3.数据结构 1.3.1. 3.1二叉树【理解】 二叉树的特点 二叉树中,任意一个节点的度要小于等于2 节点: 在树结构中,每一个元素称之为节点 度: 每一个节点的子节点数量称之为度 二叉树结构图 1.3.2. 3.2二叉查找树【理解】 二叉查找树的特点 二叉查找树,又称二叉排序树或者二叉搜索树 每一个节点上最多有两个子节点 左子树上所有节点的值都小于根节点的值 右子树上所有节点的值都大于根节点的值 二叉查找树结构图 二叉查找树和二叉树对比结构图 二叉查找树添加节点规则 小的存左边 大的存右边 一样的不存 1.3.3. 3.3平衡二叉树【理解】 平衡二叉树的特点 二叉树左右两个子树的高度差不超过1 任意节点的左右两个子树都是一颗平衡二叉树 平衡二叉树旋转 旋转触发时机 当添加一个节点之后,该树不再是一颗平衡二叉树 左旋 就是将根节点的右侧往左拉,原先的右子节点变成新的父节点,并把多余的左子节点出让,给已经降级的根节点当右子节点 右旋 就是将根节点的左侧往右拉,左子节点变成了新的父节点,并把多余的右子节点出让,给已经降级根节点当左子节点 平衡二叉树和二叉查找树对比结构图 平衡二叉树旋转的四种情况 左左 左左: 当根节点左子树的左子树有节点插入,导致二叉树不平衡 如何旋转: 直接对整体进行右旋即可 左右 左右: 当根节点左子树的右子树有节点插入,导致二叉树不平衡 如何旋转: 先在左子树对应的节点位置进行左旋,在对整体进行右旋 右右 右右: 当根节点右子树的右子树有节点插入,导致二叉树不平衡 如何旋转: 直接对整体进行左旋即可 右左 右左:当根节点右子树的左子树有节点插入,导致二叉树不平衡 如何旋转: 先在右子树对应的节点位置进行右旋,在对整体进行左旋 1.3.4. 3.4红黑树【理解】 红黑树的特点 平衡二叉B树 每一个节点可以是红或者黑 红黑树不是高度平衡的,它的平衡是通过”自己的红黑规则”进行实现的 红黑树的红黑规则有哪些 每一个节点或是红色的,或者是黑色的 根节点必须是黑色 如果一个节点没有子节点或者父节点,则该节点相应的指针属性值为Nil,这些Nil视为叶节点,每个叶节点(Nil)是黑色的 如果某一个节点是红色,那么它的子节点必须是黑色(不能出现两个红色节点相连 的情况) 对每一个节点,从该节点到其所有后代叶节点的简单路径上,均包含相同数目的黑色节点 红黑树添加节点的默认颜色 添加节点时,默认为红色,效率高 红黑树添加节点后如何保持红黑规则 根节点位置 直接变为黑色 非根节点位置 父节点为黑色 不需要任何操作,默认红色即可 父节点为红色 叔叔节点为红色 将”父节点”设为黑色,将”叔叔节点”设为黑色 将”祖父节点”设为红色 如果”祖父节点”为根节点,则将根节点再次变成黑色 叔叔节点为黑色 将”父节点”设为黑色 将”祖父节点”设为红色 以”祖父节点”为支点进行旋转 1.3.5. 3.5成绩排序案例【应用】 案例需求 用TreeSet集合存储多个学生信息(姓名,语文成绩,数学成绩,英语成绩),并遍历该集合 要求: 按照总分从高到低出现 代码实现 学生类 public class Student implements Comparable { private String name; private int chinese; private int math; private int english; public Student() { } public Student(String name, int chinese, int math, int english) { this.name = name; this.chinese = chinese; this.math = math; this.english = english; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getChinese() { return chinese; } public void setChinese(int chinese) { this.chinese = chinese; } public int getMath() { return math; } public void setMath(int math) { this.math = math; } public int getEnglish() { return english; } public void setEnglish(int english) { this.english = english; } public int getSum() { return this.chinese + this.math + this.english; } @Override public int compareTo(Student o) { // 主要条件: 按照总分进行排序 int result = o.getSum() - this.getSum(); // 次要条件: 如果总分一样,就按照语文成绩排序 result = result == 0 ? o.getChinese() - this.getChinese() : result; // 如果语文成绩也一样,就按照数学成绩排序 result = result == 0 ? o.getMath() - this.getMath() : result; // 如果总分一样,各科成绩也都一样,就按照姓名排序 result = result == 0 ? o.getName().compareTo(this.getName()) : result; return result; } } 测试类 public class TreeSetDemo { public static void main(String[] args) { //创建TreeSet集合对象，通过比较器排序进行排序 TreeSet ts = new TreeSet(); //创建学生对象 Student s1 = new Student(“jack”, 98, 100, 95); Student s2 = new Student(“rose”, 95, 95, 95); Student s3 = new Student(“sam”, 100, 93, 98); //把学生对象添加到集合 ts.add(s1); ts.add(s2); ts.add(s3); //遍历集合 for (Student s : ts) { System.out.println(s.getName() + “,” + s.getChinese() + “,” + s.getMath() + “,” + s.getEnglish() + “,” + s.getSum()); } } } 1.4. 4.HashSet集合 1.4.1. 4.1HashSet集合概述和特点【应用】 底层数据结构是哈希表 存取无序 不可以存储重复元素 没有索引,不能使用普通for循环遍历 1.4.2. 4.2HashSet集合的基本应用【应用】 存储字符串并遍历 public class HashSetDemo { public static void main(String[] args) { //创建集合对象 HashSet set = new HashSet(); //添加元素 set.add(“hello”); set.add(“world”); set.add(“java”); //不包含重复元素的集合 set.add(“world”); //遍历 for(String s : set) { System.out.println(s); } } } 1.4.3. 4.3哈希值【理解】 哈希值简介 ​ 是JDK根据对象的地址或者字符串或者数字算出来的int类型的数值 如何获取哈希值 ​ Object类中的public int hashCode()：返回对象的哈希码值 哈希值的特点 同一个对象多次调用hashCode()方法返回的哈希值是相同的 默认情况下，不同对象的哈希值是不同的。而重写hashCode()方法，可以实现让不同对象的哈希值相同 1.4.4. 4.4哈希表结构【理解】 JDK1.8以前 ​ 数组 + 链表 JDK1.8以后 节点个数少于等于8个 ​ 数组 + 链表 节点个数多于8个 ​ 数组 + 红黑树 1.4.5. 4.5HashSet集合存储学生对象并遍历【应用】 案例需求 创建一个存储学生对象的集合，存储多个学生对象，使用程序实现在控制台遍历该集合 要求：学生对象的成员变量值相同，我们就认为是同一个对象 代码实现 学生类 public class Student { private String name; private int age; public Student() { } public Student(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } @Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Student student = (Student) o; if (age != student.age) return false; return name != null ? name.equals(student.name) : student.name == null; } @Override public int hashCode() { int result = name != null ? name.hashCode() : 0; result = 31 * result + age; return result; } } 测试类 public class HashSetDemo02 { public static void main(String[] args) { //创建HashSet集合对象 HashSet hs = new HashSet(); //创建学生对象 Student s1 = new Student(\"林青霞\", 30); Student s2 = new Student(\"张曼玉\", 35); Student s3 = new Student(\"王祖贤\", 33); Student s4 = new Student(\"王祖贤\", 33); //把学生添加到集合 hs.add(s1); hs.add(s2); hs.add(s3); hs.add(s4); //遍历集合(增强for) for (Student s : hs) { System.out.println(s.getName() + \",\" + s.getAge()); } } } 总结 ​ HashSet集合存储自定义类型元素,要想实现元素的唯一,要求必须重写hashCode方法和equals方法 Copyright © MISIN 2022 | 豫ICP备2021006345号-1 all right reserved，powered by Gitbook该文件修订时间： 2022-11-10 13:24:18 "},"1.JAVA基础/day18集合03.html":{"url":"1.JAVA基础/day18集合03.html","title":"day18集合03","keywords":"","body":"1.1. 1.Map集合1.1.1. 1.1Map集合概述和特点【理解】1.1.2. 1.2Map集合的基本功能【应用】1.1.3. 1.3Map集合的获取功能【应用】1.1.4. 1.4Map集合的遍历(方式1)【应用】1.1.5. 1.5Map集合的遍历(方式2)【应用】1.2. 2.HashMap集合1.2.1. 2.1HashMap集合概述和特点【理解】1.2.2. 2.2HashMap集合应用案例【应用】1.3. 3.TreeMap集合1.3.1. 3.1TreeMap集合概述和特点【理解】1.3.2. 3.2TreeMap集合应用案例一【应用】1.3.3. 3.3TreeMap集合应用案例二【应用】1.4. 4.可变参数1.4.1. 4.1可变参数【应用】1.4.2. 4.2创建不可变集合【理解】1.5. 5.Stream流1.5.1. 5.1体验Stream流【理解】1.5.2. 5.2Stream流的常见生成方式【应用】1.5.3. 5.3Stream流中间操作方法【应用】1.5.4. 5.4Stream流终结操作方法【应用】1.5.5. 5.5Stream流的收集操作【应用】1.5.6. 5.6Stream流综合练习【应用】1.1. 1.Map集合 1.1.1. 1.1Map集合概述和特点【理解】 Map集合概述 interface Map K：键的类型；V：值的类型 Map集合的特点 双列集合,一个键对应一个值 键不可以重复,值可以重复 Map集合的基本使用 public class MapDemo01 { public static void main(String[] args) { //创建集合对象 Map map = new HashMap(); //V put(K key, V value) 将指定的值与该映射中的指定键相关联 map.put(\"itheima001\",\"林青霞\"); map.put(\"itheima002\",\"张曼玉\"); map.put(\"itheima003\",\"王祖贤\"); map.put(\"itheima003\",\"柳岩\"); //输出集合对象 System.out.println(map); } } 1.1.2. 1.2Map集合的基本功能【应用】 方法介绍 | 方法名 | 说明 | | ----------------------------------- | ------------------ | | V put(K key,V value) | 添加元素 | | V remove(Object key) | 根据键删除键值对元素 | | void clear() | 移除所有的键值对元素 | | boolean containsKey(Object key) | 判断集合是否包含指定的键 | | boolean containsValue(Object value) | 判断集合是否包含指定的值 | | boolean isEmpty() | 判断集合是否为空 | | int size() | 集合的长度，也就是集合中键值对的个数 | 示例代码 public class MapDemo02 { public static void main(String[] args) { //创建集合对象 Map map = new HashMap(); //V put(K key,V value)：添加元素 map.put(\"张无忌\",\"赵敏\"); map.put(\"郭靖\",\"黄蓉\"); map.put(\"杨过\",\"小龙女\"); //V remove(Object key)：根据键删除键值对元素 // System.out.println(map.remove(\"郭靖\")); // System.out.println(map.remove(\"郭襄\")); //void clear()：移除所有的键值对元素 // map.clear(); //boolean containsKey(Object key)：判断集合是否包含指定的键 // System.out.println(map.containsKey(\"郭靖\")); // System.out.println(map.containsKey(\"郭襄\")); //boolean isEmpty()：判断集合是否为空 // System.out.println(map.isEmpty()); //int size()：集合的长度，也就是集合中键值对的个数 System.out.println(map.size()); //输出集合对象 System.out.println(map); } } 1.1.3. 1.3Map集合的获取功能【应用】 方法介绍 | 方法名 | 说明 | | -------------------------------- | ------------ | | V get(Object key) | 根据键获取值 | | Set keySet() | 获取所有键的集合 | | Collection values() | 获取所有值的集合 | | Set> entrySet() | 获取所有键值对对象的集合 | 示例代码 public class MapDemo03 { public static void main(String[] args) { //创建集合对象 Map map = new HashMap(); //添加元素 map.put(\"张无忌\", \"赵敏\"); map.put(\"郭靖\", \"黄蓉\"); map.put(\"杨过\", \"小龙女\"); //V get(Object key):根据键获取值 // System.out.println(map.get(\"张无忌\")); // System.out.println(map.get(\"张三丰\")); //Set keySet():获取所有键的集合 // Set keySet = map.keySet(); // for(String key : keySet) { // System.out.println(key); // } //Collection values():获取所有值的集合 Collection values = map.values(); for(String value : values) { System.out.println(value); } } } 1.1.4. 1.4Map集合的遍历(方式1)【应用】 遍历思路 我们刚才存储的元素都是成对出现的，所以我们把Map看成是一个夫妻对的集合 把所有的丈夫给集中起来 遍历丈夫的集合，获取到每一个丈夫 根据丈夫去找对应的妻子 步骤分析 获取所有键的集合。用keySet()方法实现 遍历键的集合，获取到每一个键。用增强for实现 根据键去找值。用get(Object key)方法实现 代码实现 public class MapDemo01 { public static void main(String[] args) { //创建集合对象 Map map = new HashMap(); //添加元素 map.put(\"张无忌\", \"赵敏\"); map.put(\"郭靖\", \"黄蓉\"); map.put(\"杨过\", \"小龙女\"); //获取所有键的集合。用keySet()方法实现 Set keySet = map.keySet(); //遍历键的集合，获取到每一个键。用增强for实现 for (String key : keySet) { //根据键去找值。用get(Object key)方法实现 String value = map.get(key); System.out.println(key + \",\" + value); } } } 1.1.5. 1.5Map集合的遍历(方式2)【应用】 遍历思路 我们刚才存储的元素都是成对出现的，所以我们把Map看成是一个夫妻对的集合 获取所有结婚证的集合 遍历结婚证的集合，得到每一个结婚证 根据结婚证获取丈夫和妻子 步骤分析 获取所有键值对对象的集合 Set> entrySet()：获取所有键值对对象的集合 遍历键值对对象的集合，得到每一个键值对对象 用增强for实现，得到每一个Map.Entry 根据键值对对象获取键和值 用getKey()得到键 用getValue()得到值 代码实现 public class MapDemo02 { public static void main(String[] args) { //创建集合对象 Map map = new HashMap(); //添加元素 map.put(\"张无忌\", \"赵敏\"); map.put(\"郭靖\", \"黄蓉\"); map.put(\"杨过\", \"小龙女\"); //获取所有键值对对象的集合 Set> entrySet = map.entrySet(); //遍历键值对对象的集合，得到每一个键值对对象 for (Map.Entry me : entrySet) { //根据键值对对象获取键和值 String key = me.getKey(); String value = me.getValue(); System.out.println(key + \",\" + value); } } } 1.2. 2.HashMap集合 1.2.1. 2.1HashMap集合概述和特点【理解】 HashMap底层是哈希表结构的 依赖hashCode方法和equals方法保证键的唯一 如果键要存储的是自定义对象，需要重写hashCode和equals方法 1.2.2. 2.2HashMap集合应用案例【应用】 案例需求 创建一个HashMap集合，键是学生对象(Student)，值是居住地 (String)。存储多个元素，并遍历。 要求保证键的唯一性：如果学生对象的成员变量值相同，我们就认为是同一个对象 代码实现 学生类 public class Student { private String name; private int age; public Student() { } public Student(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } @Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Student student = (Student) o; if (age != student.age) return false; return name != null ? name.equals(student.name) : student.name == null; } @Override public int hashCode() { int result = name != null ? name.hashCode() : 0; result = 31 * result + age; return result; } } 测试类 public class HashMapDemo { public static void main(String[] args) { //创建HashMap集合对象 HashMap hm = new HashMap(); //创建学生对象 Student s1 = new Student(\"林青霞\", 30); Student s2 = new Student(\"张曼玉\", 35); Student s3 = new Student(\"王祖贤\", 33); Student s4 = new Student(\"王祖贤\", 33); //把学生添加到集合 hm.put(s1, \"西安\"); hm.put(s2, \"武汉\"); hm.put(s3, \"郑州\"); hm.put(s4, \"北京\"); //遍历集合 Set keySet = hm.keySet(); for (Student key : keySet) { String value = hm.get(key); System.out.println(key.getName() + \",\" + key.getAge() + \",\" + value); } } } 1.3. 3.TreeMap集合 1.3.1. 3.1TreeMap集合概述和特点【理解】 TreeMap底层是红黑树结构 依赖自然排序或者比较器排序,对键进行排序 如果键存储的是自定义对象,需要实现Comparable接口或者在创建TreeMap对象时候给出比较器排序规则 1.3.2. 3.2TreeMap集合应用案例一【应用】 案例需求 创建一个TreeMap集合,键是学生对象(Student),值是籍贯(String),学生属性姓名和年龄,按照年龄进行排序并遍历 要求按照学生的年龄进行排序,如果年龄相同则按照姓名进行排序 代码实现 学生类 public class Student implements Comparable{ private String name; private int age; public Student() { } public Student(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } @Override public String toString() { return \"Student{\" + \"name='\" + name + '\\'' + \", age=\" + age + '}'; } @Override public int compareTo(Student o) { //按照年龄进行排序 int result = o.getAge() - this.getAge(); //次要条件，按照姓名排序。 result = result == 0 ? o.getName().compareTo(this.getName()) : result; return result; } } 测试类 public class Test1 { public static void main(String[] args) { // 创建TreeMap集合对象 TreeMap tm = new TreeMap<>(); // 创建学生对象 Student s1 = new Student(\"xiaohei\",23); Student s2 = new Student(\"dapang\",22); Student s3 = new Student(\"xiaomei\",22); // 将学生对象添加到TreeMap集合中 tm.put(s1,\"江苏\"); tm.put(s2,\"北京\"); tm.put(s3,\"天津\"); // 遍历TreeMap集合,打印每个学生的信息 tm.forEach( (Student key, String value)->{ System.out.println(key + \"---\" + value); } ); } } 1.3.3. 3.3TreeMap集合应用案例二【应用】 案例需求 给定一个字符串,要求统计字符串中每个字符出现的次数。 举例: 给定字符串是“aababcabcdabcde”,在控制台输出: “a(5)b(4)c(3)d(2)e(1)” 代码实现 public class Test2 { public static void main(String[] args) { // 给定字符串 String s = \"aababcabcdabcde\"; // 创建TreeMap集合对象,键是Character,值是Integer TreeMap tm = new TreeMap<>(); //遍历字符串，得到每一个字符 for (int i = 0; i { System.out.print(key + \"（\" + value + \"）\"); } ); } } 1.4. 4.可变参数 1.4.1. 4.1可变参数【应用】 可变参数介绍 可变参数又称参数个数可变，用作方法的形参出现，那么方法参数个数就是可变的了 方法的参数类型已经确定,个数不确定,我们可以使用可变参数 可变参数定义格式 修饰符 返回值类型 方法名(数据类型… 变量名) { } 可变参数的注意事项 这里的变量其实是一个数组 如果一个方法有多个参数，包含可变参数，可变参数要放在最后 可变参数的基本使用 public class ArgsDemo01 { public static void main(String[] args) { System.out.println(sum(10, 20)); System.out.println(sum(10, 20, 30)); System.out.println(sum(10, 20, 30, 40)); System.out.println(sum(10,20,30,40,50)); System.out.println(sum(10,20,30,40,50,60)); System.out.println(sum(10,20,30,40,50,60,70)); System.out.println(sum(10,20,30,40,50,60,70,80,90,100)); } // public static int sum(int b,int... a) { // return 0; // } public static int sum(int... a) { int sum = 0; for(int i : a) { sum += i; } return sum; } } 1.4.2. 4.2创建不可变集合【理解】 方法介绍 在List、Set、Map接口中,都存在of方法,可以创建一个不可变的集合 这个集合不能添加,不能删除,不能修改 但是可以结合集合的带参构造,实现集合的批量添加 在Map接口中,还有一个ofEntries方法可以提高代码的阅读性 首先会把键值对封装成一个Entry对象,再把这个Entry对象添加到集合当中 示例代码 public class MyVariableParameter4 { public static void main(String[] args) { // static List of(E…elements) 创建一个具有指定元素的List集合对象 //static Set of(E…elements) 创建一个具有指定元素的Set集合对象 //static Map of(E…elements) 创建一个具有指定元素的Map集合对象 //method1(); //method2(); //method3(); //method4(); } private static void method4() { Map map = Map.ofEntries( Map.entry(\"zhangsan\", \"江苏\"), Map.entry(\"lisi\", \"北京\")); System.out.println(map); } private static void method3() { Map map = Map.of(\"zhangsan\", \"江苏\", \"lisi\", \"北京\", \"wangwu\", \"天津\"); System.out.println(map); } private static void method2() { //传递的参数当中，不能存在重复的元素。 Set set = Set.of(\"a\", \"b\", \"c\", \"d\",\"a\"); System.out.println(set); } private static void method1() { List list = List.of(\"a\", \"b\", \"c\", \"d\"); System.out.println(list); //list.add(\"Q\"); //list.remove(\"a\"); //list.set(0,\"A\"); //System.out.println(list); // ArrayList list2 = new ArrayList<>(); // list2.add(\"aaa\"); // list2.add(\"aaa\"); // list2.add(\"aaa\"); // list2.add(\"aaa\"); //集合的批量添加。 //首先是通过调用List.of方法来创建一个不可变的集合，of方法的形参就是一个可变参数。 //再创建一个ArrayList集合，并把这个不可变的集合中所有的数据，都添加到ArrayList中。 ArrayList list3 = new ArrayList<>(List.of(\"a\", \"b\", \"c\", \"d\")); System.out.println(list3); } } 1.5. 5.Stream流 1.5.1. 5.1体验Stream流【理解】 案例需求 按照下面的要求完成集合的创建和遍历 创建一个集合，存储多个字符串元素 把集合中所有以\"张\"开头的元素存储到一个新的集合 把\"张\"开头的集合中的长度为3的元素存储到一个新的集合 遍历上一步得到的集合 原始方式示例代码 public class StreamDemo { public static void main(String[] args) { //创建一个集合，存储多个字符串元素 ArrayList list = new ArrayList(); list.add(\"林青霞\"); list.add(\"张曼玉\"); list.add(\"王祖贤\"); list.add(\"柳岩\"); list.add(\"张敏\"); list.add(\"张无忌\"); //把集合中所有以\"张\"开头的元素存储到一个新的集合 ArrayList zhangList = new ArrayList(); for(String s : list) { if(s.startsWith(\"张\")) { zhangList.add(s); } } // System.out.println(zhangList); //把\"张\"开头的集合中的长度为3的元素存储到一个新的集合 ArrayList threeList = new ArrayList(); for(String s : zhangList) { if(s.length() == 3) { threeList.add(s); } } // System.out.println(threeList); //遍历上一步得到的集合 for(String s : threeList) { System.out.println(s); } System.out.println(\"--------\"); //Stream流来改进 // list.stream().filter(s -> s.startsWith(\"张\")).filter(s -> s.length() == 3).forEach(s -> System.out.println(s)); list.stream().filter(s -> s.startsWith(\"张\")).filter(s -> s.length() == 3).forEach(System.out::println); } } 使用Stream流示例代码 public class StreamDemo { public static void main(String[] args) { //创建一个集合，存储多个字符串元素 ArrayList list = new ArrayList(); list.add(\"林青霞\"); list.add(\"张曼玉\"); list.add(\"王祖贤\"); list.add(\"柳岩\"); list.add(\"张敏\"); list.add(\"张无忌\"); //Stream流来改进 list.stream().filter(s -> s.startsWith(\"张\")).filter(s -> s.length() == 3).forEach(System.out::println); } } Stream流的好处 直接阅读代码的字面意思即可完美展示无关逻辑方式的语义：获取流、过滤姓张、过滤长度为3、逐一打印 Stream流把真正的函数式编程风格引入到Java中 代码简洁 1.5.2. 5.2Stream流的常见生成方式【应用】 Stream流的思想 Stream流的三类方法 获取Stream流 创建一条流水线,并把数据放到流水线上准备进行操作 中间方法 流水线上的操作 一次操作完毕之后,还可以继续进行其他操作 终结方法 一个Stream流只能有一个终结方法 是流水线上的最后一个操作 生成Stream流的方式 Collection体系集合 使用默认方法stream()生成流， default Stream stream() Map体系集合 把Map转成Set集合，间接的生成流 数组 通过Arrays中的静态方法stream生成流 同种数据类型的多个数据 通过Stream接口的静态方法of(T... values)生成流 代码演示 public class StreamDemo { public static void main(String[] args) { //Collection体系的集合可以使用默认方法stream()生成流 List list = new ArrayList(); Stream listStream = list.stream(); Set set = new HashSet(); Stream setStream = set.stream(); //Map体系的集合间接的生成流 Map map = new HashMap(); Stream keyStream = map.keySet().stream(); Stream valueStream = map.values().stream(); Stream> entryStream = map.entrySet().stream(); //数组可以通过Arrays中的静态方法stream生成流 String[] strArray = {\"hello\",\"world\",\"java\"}; Stream strArrayStream = Arrays.stream(strArray); //同种数据类型的多个数据可以通过Stream接口的静态方法of(T... values)生成流 Stream strArrayStream2 = Stream.of(\"hello\", \"world\", \"java\"); Stream intStream = Stream.of(10, 20, 30); } } 1.5.3. 5.3Stream流中间操作方法【应用】 概念 中间操作的意思是,执行完此方法之后,Stream流依然可以继续执行其他操作 常见方法 | 方法名 | 说明 | | ---------------------------------------- | ---------------------------------------- | | Stream filter(Predicate predicate) | 用于对流中的数据进行过滤 | | Stream limit(long maxSize) | 返回此流中的元素组成的流，截取前指定参数个数的数据 | | Stream skip(long n) | 跳过指定参数个数的数据，返回由该流的剩余元素组成的流 | | static Stream concat(Stream a, Stream b) | 合并a和b两个流为一个流 | | Stream distinct() | 返回由该流的不同元素（根据Object.equals(Object) ）组成的流 | filter代码演示 public class StreamDemo01 { public static void main(String[] args) { //创建一个集合，存储多个字符串元素 ArrayList list = new ArrayList(); list.add(\"林青霞\"); list.add(\"张曼玉\"); list.add(\"王祖贤\"); list.add(\"柳岩\"); list.add(\"张敏\"); list.add(\"张无忌\"); //需求1：把list集合中以张开头的元素在控制台输出 list.stream().filter(s -> s.startsWith(\"张\")).forEach(System.out::println); System.out.println(\"--------\"); //需求2：把list集合中长度为3的元素在控制台输出 list.stream().filter(s -> s.length() == 3).forEach(System.out::println); System.out.println(\"--------\"); //需求3：把list集合中以张开头的，长度为3的元素在控制台输出 list.stream().filter(s -> s.startsWith(\"张\")).filter(s -> s.length() == 3).forEach(System.out::println); } } limit&skip代码演示 public class StreamDemo02 { public static void main(String[] args) { //创建一个集合，存储多个字符串元素 ArrayList list = new ArrayList(); list.add(\"林青霞\"); list.add(\"张曼玉\"); list.add(\"王祖贤\"); list.add(\"柳岩\"); list.add(\"张敏\"); list.add(\"张无忌\"); //需求1：取前3个数据在控制台输出 list.stream().limit(3).forEach(System.out::println); System.out.println(\"--------\"); //需求2：跳过3个元素，把剩下的元素在控制台输出 list.stream().skip(3).forEach(System.out::println); System.out.println(\"--------\"); //需求3：跳过2个元素，把剩下的元素中前2个在控制台输出 list.stream().skip(2).limit(2).forEach(System.out::println); } } concat&distinct代码演示 public class StreamDemo03 { public static void main(String[] args) { //创建一个集合，存储多个字符串元素 ArrayList list = new ArrayList(); list.add(\"林青霞\"); list.add(\"张曼玉\"); list.add(\"王祖贤\"); list.add(\"柳岩\"); list.add(\"张敏\"); list.add(\"张无忌\"); //需求1：取前4个数据组成一个流 Stream s1 = list.stream().limit(4); //需求2：跳过2个数据组成一个流 Stream s2 = list.stream().skip(2); //需求3：合并需求1和需求2得到的流，并把结果在控制台输出 // Stream.concat(s1,s2).forEach(System.out::println); //需求4：合并需求1和需求2得到的流，并把结果在控制台输出，要求字符串元素不能重复 Stream.concat(s1,s2).distinct().forEach(System.out::println); } } 1.5.4. 5.4Stream流终结操作方法【应用】 概念 终结操作的意思是,执行完此方法之后,Stream流将不能再执行其他操作 常见方法 | 方法名 | 说明 | | ----------------------------- | ------------ | | void forEach(Consumer action) | 对此流的每个元素执行操作 | | long count() | 返回此流中的元素数 | 代码演示 public class StreamDemo { public static void main(String[] args) { //创建一个集合，存储多个字符串元素 ArrayList list = new ArrayList(); list.add(\"林青霞\"); list.add(\"张曼玉\"); list.add(\"王祖贤\"); list.add(\"柳岩\"); list.add(\"张敏\"); list.add(\"张无忌\"); //需求1：把集合中的元素在控制台输出 // list.stream().forEach(System.out::println); //需求2：统计集合中有几个以张开头的元素，并把统计结果在控制台输出 long count = list.stream().filter(s -> s.startsWith(\"张\")).count(); System.out.println(count); } } 1.5.5. 5.5Stream流的收集操作【应用】 概念 对数据使用Stream流的方式操作完毕后,可以把流中的数据收集到集合中 常用方法 | 方法名 | 说明 | | ------------------------------ | --------- | | R collect(Collector collector) | 把结果收集到集合中 | 工具类Collectors提供了具体的收集方式 | 方法名 | 说明 | | ---------------------------------------- | ------------- | | public static Collector toList() | 把元素收集到List集合中 | | public static Collector toSet() | 把元素收集到Set集合中 | | public static Collector toMap(Function keyMapper,Function valueMapper) | 把元素收集到Map集合中 | 代码演示 public class CollectDemo { public static void main(String[] args) { //创建List集合对象 List list = new ArrayList(); list.add(\"林青霞\"); list.add(\"张曼玉\"); list.add(\"王祖贤\"); list.add(\"柳岩\"); /* //需求1：得到名字为3个字的流 Stream listStream = list.stream().filter(s -> s.length() == 3); //需求2：把使用Stream流操作完毕的数据收集到List集合中并遍历 List names = listStream.collect(Collectors.toList()); for(String name : names) { System.out.println(name); } */ //创建Set集合对象 Set set = new HashSet(); set.add(10); set.add(20); set.add(30); set.add(33); set.add(35); /* //需求3：得到年龄大于25的流 Stream setStream = set.stream().filter(age -> age > 25); //需求4：把使用Stream流操作完毕的数据收集到Set集合中并遍历 Set ages = setStream.collect(Collectors.toSet()); for(Integer age : ages) { System.out.println(age); } */ //定义一个字符串数组，每一个字符串数据由姓名数据和年龄数据组合而成 String[] strArray = {\"林青霞,30\", \"张曼玉,35\", \"王祖贤,33\", \"柳岩,25\"}; //需求5：得到字符串中年龄数据大于28的流 Stream arrayStream = Stream.of(strArray).filter(s -> Integer.parseInt(s.split(\",\")[1]) > 28); //需求6：把使用Stream流操作完毕的数据收集到Map集合中并遍历，字符串中的姓名作键，年龄作值 Map map = arrayStream.collect(Collectors.toMap(s -> s.split(\",\")[0], s -> Integer.parseInt(s.split(\",\")[1]))); Set keySet = map.keySet(); for (String key : keySet) { Integer value = map.get(key); System.out.println(key + \",\" + value); } } } 1.5.6. 5.6Stream流综合练习【应用】 案例需求 现在有两个ArrayList集合，分别存储6名男演员名称和6名女演员名称，要求完成如下的操作 男演员只要名字为3个字的前三人 女演员只要姓林的，并且不要第一个 把过滤后的男演员姓名和女演员姓名合并到一起 把上一步操作后的元素作为构造方法的参数创建演员对象,遍历数据 演员类Actor已经提供，里面有一个成员变量，一个带参构造方法，以及成员变量对应的get/set方法 代码实现 演员类 public class Actor { private String name; public Actor(String name) { this.name = name; } public String getName() { return name; } public void setName(String name) { this.name = name; } } 测试类 public class StreamTest { public static void main(String[] args) { //创建集合 ArrayList manList = new ArrayList(); manList.add(\"周润发\"); manList.add(\"成龙\"); manList.add(\"刘德华\"); manList.add(\"吴京\"); manList.add(\"周星驰\"); manList.add(\"李连杰\"); ArrayList womanList = new ArrayList(); womanList.add(\"林心如\"); womanList.add(\"张曼玉\"); womanList.add(\"林青霞\"); womanList.add(\"柳岩\"); womanList.add(\"林志玲\"); womanList.add(\"王祖贤\"); /* //男演员只要名字为3个字的前三人 Stream manStream = manList.stream().filter(s -> s.length() == 3).limit(3); //女演员只要姓林的，并且不要第一个 Stream womanStream = womanList.stream().filter(s -> s.startsWith(\"林\")).skip(1); //把过滤后的男演员姓名和女演员姓名合并到一起 Stream stream = Stream.concat(manStream, womanStream); //把上一步操作后的元素作为构造方法的参数创建演员对象,遍历数据 // stream.map(Actor::new).forEach(System.out::println); stream.map(Actor::new).forEach(p -> System.out.println(p.getName())); */ Stream.concat(manList.stream().filter(s -> s.length() == 3).limit(3), womanList.stream().filter(s -> s.startsWith(\"林\")).skip(1)).map(Actor::new). forEach(p -> System.out.println(p.getName())); } } Copyright © MISIN 2022 | 豫ICP备2021006345号-1 all right reserved，powered by Gitbook该文件修订时间： 2022-11-10 13:22:26 "},"1.JAVA基础/day19IO流01.html":{"url":"1.JAVA基础/day19IO流01.html","title":"day19IO流01","keywords":"","body":"1.1. 1.File类1.1.1. 1.1File类概述和构造方法【应用】1.1.2. 1.2绝对路径和相对路径【理解】1.1.3. 1.3File类创建功能【应用】1.1.4. 1.4File类删除功能【应用】1.1.5. 1.5File类判断和获取功能【应用】1.1.6. 1.6File类练习一【应用】1.1.7. 1.7File类练习二【应用】1.1.8. 1.8File类练习三【应用】1.2. 2.字节流1.2.1. 2.1 IO流概述和分类【理解】1.2.2. 2.2字节流写数据【应用】1.2.3. 2.3字节流写数据的三种方式【应用】1.2.4. 2.4字节流写数据的两个小问题【应用】1.2.5. 2.5字节流写数据加异常处理【应用】1.2.6. 2.6字节流读数据(一次读一个字节数据)【应用】1.2.7. 2.7字节流复制文件【应用】1.2.8. 2.8字节流读数据(一次读一个字节数组数据)【应用】1.2.9. 2.9字节流复制文件【应用】1.3. 3.字节缓冲流1.3.1. 3.1字节缓冲流构造方法【应用】1.1. 1.File类 1.1.1. 1.1File类概述和构造方法【应用】 File类介绍 它是文件和目录路径名的抽象表示 文件和目录是可以通过File封装成对象的 对于File而言,其封装的并不是一个真正存在的文件,仅仅是一个路径名而已.它可以是存在的,也可以是不存在的.将来是要通过具体的操作把这个路径的内容转换为具体存在的 File类的构造方法 | 方法名 | 说明 | | ----------------------------------- | -------------------------------- | | File(String pathname) | 通过将给定的路径名字符串转换为抽象路径名来创建新的 File实例 | | File(String parent, String child) | 从父路径名字符串和子路径名字符串创建新的 File实例 | | File(File parent, String child) | 从父抽象路径名和子路径名字符串创建新的 File实例 | 示例代码 public class FileDemo01 { public static void main(String[] args) { //File(String pathname): 通过将给定的路径名字符串转换为抽象路径名来创建新的 File实例 File f1 = new File(\"E:\\\\itcast\\\\java.txt\"); System.out.println(f1); //File(String parent, String child): 从父路径名字符串和子路径名字符串创建新的 File实例 File f2 = new File(\"E:\\\\itcast\",\"java.txt\"); System.out.println(f2); //File(File parent, String child): 从父抽象路径名和子路径名字符串创建新的 File实例 File f3 = new File(\"E:\\\\itcast\"); File f4 = new File(f3,\"java.txt\"); System.out.println(f4); } } 1.1.2. 1.2绝对路径和相对路径【理解】 绝对路径 是一个完整的路径,从盘符开始 相对路径 是一个简化的路径,相对当前项目下的路径 示例代码 public class FileDemo02 { public static void main(String[] args) { // 是一个完整的路径,从盘符开始 File file1 = new File(\"D:\\\\itheima\\\\a.txt\"); // 是一个简化的路径,从当前项目根目录开始 File file2 = new File(\"a.txt\"); File file3 = new File(\"模块名\\\\a.txt\"); } } 1.1.3. 1.3File类创建功能【应用】 方法分类 | 方法名 | 说明 | | ------------------------------ | -------------------------------- | | public boolean createNewFile() | 当具有该名称的文件不存在时，创建一个由该抽象路径名命名的新空文件 | | public boolean mkdir() | 创建由此抽象路径名命名的目录 | | public boolean mkdirs() | 创建由此抽象路径名命名的目录，包括任何必需但不存在的父目录 | 示例代码 public class FileDemo02 { public static void main(String[] args) throws IOException { //需求1：我要在E:\\\\itcast目录下创建一个文件java.txt File f1 = new File(\"E:\\\\itcast\\\\java.txt\"); System.out.println(f1.createNewFile()); System.out.println(\"--------\"); //需求2：我要在E:\\\\itcast目录下创建一个目录JavaSE File f2 = new File(\"E:\\\\itcast\\\\JavaSE\"); System.out.println(f2.mkdir()); System.out.println(\"--------\"); //需求3：我要在E:\\\\itcast目录下创建一个多级目录JavaWEB\\\\HTML File f3 = new File(\"E:\\\\itcast\\\\JavaWEB\\\\HTML\"); // System.out.println(f3.mkdir()); System.out.println(f3.mkdirs()); System.out.println(\"--------\"); //需求4：我要在E:\\\\itcast目录下创建一个文件javase.txt File f4 = new File(\"E:\\\\itcast\\\\javase.txt\"); // System.out.println(f4.mkdir()); System.out.println(f4.createNewFile()); } } 1.1.4. 1.4File类删除功能【应用】 方法分类 | 方法名 | 说明 | | ------------------------- | ----------------- | | public boolean delete() | 删除由此抽象路径名表示的文件或目录 | 示例代码 public class FileDemo03 { public static void main(String[] args) throws IOException { // File f1 = new File(\"E:\\\\itcast\\\\java.txt\"); //需求1：在当前模块目录下创建java.txt文件 File f1 = new File(\"myFile\\\\java.txt\"); // System.out.println(f1.createNewFile()); //需求2：删除当前模块目录下的java.txt文件 System.out.println(f1.delete()); System.out.println(\"--------\"); //需求3：在当前模块目录下创建itcast目录 File f2 = new File(\"myFile\\\\itcast\"); // System.out.println(f2.mkdir()); //需求4：删除当前模块目录下的itcast目录 System.out.println(f2.delete()); System.out.println(\"--------\"); //需求5：在当前模块下创建一个目录itcast,然后在该目录下创建一个文件java.txt File f3 = new File(\"myFile\\\\itcast\"); // System.out.println(f3.mkdir()); File f4 = new File(\"myFile\\\\itcast\\\\java.txt\"); // System.out.println(f4.createNewFile()); //需求6：删除当前模块下的目录itcast System.out.println(f4.delete()); System.out.println(f3.delete()); } } 1.1.5. 1.5File类判断和获取功能【应用】 判断功能 | 方法名 | 说明 | | ------------------------------ | -------------------- | | public boolean isDirectory() | 测试此抽象路径名表示的File是否为目录 | | public boolean isFile() | 测试此抽象路径名表示的File是否为文件 | | public boolean exists() | 测试此抽象路径名表示的File是否存在 | 获取功能 | 方法名 | 说明 | | --------------------------------- | ----------------------------- | | public String getAbsolutePath() | 返回此抽象路径名的绝对路径名字符串 | | public String getPath() | 将此抽象路径名转换为路径名字符串 | | public String getName() | 返回由此抽象路径名表示的文件或目录的名称 | | public File[] listFiles() | 返回此抽象路径名表示的目录中的文件和目录的File对象数组 | 示例代码 public class FileDemo04 { public static void main(String[] args) { //创建一个File对象 File f = new File(\"myFile\\\\java.txt\"); // public boolean isDirectory()：测试此抽象路径名表示的File是否为目录 // public boolean isFile()：测试此抽象路径名表示的File是否为文件 // public boolean exists()：测试此抽象路径名表示的File是否存在 System.out.println(f.isDirectory()); System.out.println(f.isFile()); System.out.println(f.exists()); // public String getAbsolutePath()：返回此抽象路径名的绝对路径名字符串 // public String getPath()：将此抽象路径名转换为路径名字符串 // public String getName()：返回由此抽象路径名表示的文件或目录的名称 System.out.println(f.getAbsolutePath()); System.out.println(f.getPath()); System.out.println(f.getName()); System.out.println(\"--------\"); // public File[] listFiles()：返回此抽象路径名表示的目录中的文件和目录的File对象数组 File f2 = new File(\"E:\\\\itcast\"); File[] fileArray = f2.listFiles(); for(File file : fileArray) { // System.out.println(file); // System.out.println(file.getName()); if(file.isFile()) { System.out.println(file.getName()); } } } } 1.1.6. 1.6File类练习一【应用】 案例需求 在当前模块下的aaa文件夹中创建一个a.txt文件 实现步骤 创建File对象,指向aaa文件夹 判断aaa文件夹是否存在,如果不存在则创建 创建File对象,指向aaa文件夹下的a.txt文件 创建这个文件 代码实现 public class Test1 { public static void main(String[] args) throws IOException { //练习一：在当前模块下的aaa文件夹中创建一个a.txt文件 /* File file = new File(\"filemodule\\\\aaa\\\\a.txt\"); file.createNewFile();*/ //注意点:文件所在的文件夹必须要存在. //1.创建File对象,指向aaa文件夹 File file = new File(\"filemodule\\\\aaa\"); //2.判断aaa文件夹是否存在,如果不存在则创建 if(!file.exists()){ //如果文件夹不存在,就创建出来 file.mkdirs(); } //3.创建File对象,指向aaa文件夹下的a.txt文件 File newFile = new File(file,\"a.txt\"); //4.创建这个文件 newFile.createNewFile(); } } 1.1.7. 1.7File类练习二【应用】 案例需求 删除一个多级文件夹 实现步骤 定义一个方法,接收一个File对象 遍历这个File对象,获取它下边的每个文件和文件夹对象 判断当前遍历到的File对象是文件还是文件夹 如果是文件,直接删除 如果是文件夹,递归调用自己,将当前遍历到的File对象当做参数传递 参数传递过来的文件夹File对象已经处理完成,最后直接删除这个空文件夹 代码实现 public class Test2 { public static void main(String[] args) { //练习二：删除一个多级文件夹 //delete方法 //只能删除文件和空文件夹. //如果现在要删除一个有内容的文件夹? //先删掉这个文件夹里面所有的内容. //最后再删除这个文件夹 File src = new File(\"C:\\\\Users\\\\apple\\\\Desktop\\\\src\"); deleteDir(src); } //1.定义一个方法,接收一个File对象 private static void deleteDir(File src) { //先删掉这个文件夹里面所有的内容. //递归 方法在方法体中自己调用自己. //注意: 可以解决所有文件夹和递归相结合的题目 //2.遍历这个File对象,获取它下边的每个文件和文件夹对象 File[] files = src.listFiles(); //3.判断当前遍历到的File对象是文件还是文件夹 for (File file : files) { //4.如果是文件,直接删除 if(file.isFile()){ file.delete(); }else{ //5.如果是文件夹,递归调用自己,将当前遍历到的File对象当做参数传递 deleteDir(file);//参数一定要是src文件夹里面的文件夹File对象 } } //6.参数传递过来的文件夹File对象已经处理完成,最后直接删除这个空文件夹 src.delete(); } } 1.1.8. 1.8File类练习三【应用】 案例需求 统计一个文件夹中每种文件的个数并打印 打印格式如下： txt:3个 doc:4个 jpg:6个 … 实现步骤 定义一个方法,参数是HashMap集合用来统计次数和File对象要统计的文件夹 遍历File对象,获取它下边的每一个文件和文件夹对象 判断当前File对象是文件还是文件夹 如果是文件,判断这种类型文件后缀名在HashMap集合中是否出现过 没出现过,将这种类型文件的后缀名存入集合中,次数存1 出现过,获取这种类型文件的后缀名出现的次数,对其+1,在存回集合中 如果是文件夹,递归调用自己,HashMap集合就是参数集合,File对象是当前文件夹对象 代码实现 public class Test3 { public static void main(String[] args) { //统计一个文件夹中,每种文件出现的次数. //统计 --- 定义一个变量用来统计. ---- 弊端:同时只能统计一种文件 //利用map集合进行数据统计,键 --- 文件后缀名 值 ---- 次数 File file = new File(\"filemodule\"); HashMap hm = new HashMap<>(); getCount(hm, file); System.out.println(hm); } //1.定义一个方法,参数是HashMap集合用来统计次数和File对象要统计的文件夹 private static void getCount(HashMap hm, File file) { //2.遍历File对象,获取它下边的每一个文件和文件夹对象 File[] files = file.listFiles(); for (File f : files) { //3.判断当前File对象是文件还是文件夹 if(f.isFile()){ //如果是文件,判断这种类型文件后缀名在HashMap集合中是否出现过 String fileName = f.getName(); String[] fileNameArr = fileName.split(\"\\\\.\"); if(fileNameArr.length == 2){ String fileEndName = fileNameArr[1]; if(hm.containsKey(fileEndName)){ //出现过,获取这种类型文件的后缀名出现的次数,对其+1,在存回集合中 Integer count = hm.get(fileEndName); //这种文件又出现了一次. count++; //把已经出现的次数给覆盖掉. hm.put(fileEndName,count); }else{ // 没出现过,将这种类型文件的后缀名存入集合中,次数存1 hm.put(fileEndName,1); } } }else{ //如果是文件夹,递归调用自己,HashMap集合就是参数集合,File对象是当前文件夹对象代码实现 getCount(hm,f); } } } } 1.2. 2.字节流 1.2.1. 2.1 IO流概述和分类【理解】 IO流介绍 IO：输入/输出(Input/Output) 流：是一种抽象概念,是对数据传输的总称.也就是说数据在设备间的传输称为流,流的本质是数据传输 IO流就是用来处理设备间数据传输问题的.常见的应用: 文件复制; 文件上传; 文件下载 IO流的分类 按照数据的流向 输入流：读数据 输出流：写数据 按照数据类型来分 字节流 字节输入流 字节输出流 字符流 字符输入流 字符输出流 IO流的使用场景 如果操作的是纯文本文件,优先使用字符流 如果操作的是图片、视频、音频等二进制文件,优先使用字节流 如果不确定文件类型,优先使用字节流.字节流是万能的流 1.2.2. 2.2字节流写数据【应用】 字节流抽象基类 InputStream：这个抽象类是表示字节输入流的所有类的超类 OutputStream：这个抽象类是表示字节输出流的所有类的超类 子类名特点：子类名称都是以其父类名作为子类名的后缀 字节输出流 FileOutputStream(String name)：创建文件输出流以指定的名称写入文件 使用字节输出流写数据的步骤 创建字节输出流对象(调用系统功能创建了文件,创建字节输出流对象,让字节输出流对象指向文件) 调用字节输出流对象的写数据方法 释放资源(关闭此文件输出流并释放与此流相关联的任何系统资源) 示例代码 public class FileOutputStreamDemo01 { public static void main(String[] args) throws IOException { //创建字节输出流对象 /* 注意点: 1.如果文件不存在,会帮我们创建 2.如果文件存在,会把文件清空 */ //FileOutputStream(String name)：创建文件输出流以指定的名称写入文件 FileOutputStream fos = new FileOutputStream(\"myByteStream\\\\fos.txt\"); //void write(int b)：将指定的字节写入此文件输出流 fos.write(97); // fos.write(57); // fos.write(55); //最后都要释放资源 //void close()：关闭此文件输出流并释放与此流相关联的任何系统资源。 fos.close(); } } 1.2.3. 2.3字节流写数据的三种方式【应用】 写数据的方法分类 | 方法名 | 说明 | | ---------------------------------------- | ---------------------------------------- | | void write(int b) | 将指定的字节写入此文件输出流 一次写一个字节数据 | | void write(byte[] b) | 将 b.length字节从指定的字节数组写入此文件输出流 一次写一个字节数组数据 | | void write(byte[] b, int off, int len) | 将 len字节从指定的字节数组开始，从偏移量off开始写入此文件输出流 一次写一个字节数组的部分数据 | 示例代码 public class FileOutputStreamDemo02 { public static void main(String[] args) throws IOException { //FileOutputStream(String name)：创建文件输出流以指定的名称写入文件 FileOutputStream fos = new FileOutputStream(\"myByteStream\\\\fos.txt\"); //FileOutputStream(File file)：创建文件输出流以写入由指定的 File对象表示的文件 // FileOutputStream fos = new FileOutputStream(new File(\"myByteStream\\\\fos.txt\")); //void write(int b)：将指定的字节写入此文件输出流 // fos.write(97); // fos.write(98); // fos.write(99); // fos.write(100); // fos.write(101); // void write(byte[] b)：将 b.length字节从指定的字节数组写入此文件输出流 // byte[] bys = {97, 98, 99, 100, 101}; //byte[] getBytes()：返回字符串对应的字节数组 byte[] bys = \"abcde\".getBytes(); // fos.write(bys); //void write(byte[] b, int off, int len)：将 len字节从指定的字节数组开始，从偏移量off开始写入此文件输出流 // fos.write(bys,0,bys.length); fos.write(bys,1,3); //释放资源 fos.close(); } } 1.2.4. 2.4字节流写数据的两个小问题【应用】 字节流写数据如何实现换行 windows:\\r\\n linux:\\n mac:\\r 字节流写数据如何实现追加写入 public FileOutputStream(String name,boolean append) 创建文件输出流以指定的名称写入文件。如果第二个参数为true ，则字节将写入文件的末尾而不是开头 示例代码 public class FileOutputStreamDemo03 { public static void main(String[] args) throws IOException { //创建字节输出流对象 // FileOutputStream fos = new FileOutputStream(\"myByteStream\\\\fos.txt\"); FileOutputStream fos = new FileOutputStream(\"myByteStream\\\\fos.txt\",true); //写数据 for (int i = 0; i 1.2.5. 2.5字节流写数据加异常处理【应用】 异常处理格式 try-catch-finally try{ 可能出现异常的代码; }catch(异常类名 变量名){ 异常的处理代码; }finally{ 执行所有清除操作; } finally特点 被finally控制的语句一定会执行，除非JVM退出 示例代码 public class FileOutputStreamDemo04 { public static void main(String[] args) { //加入finally来实现释放资源 FileOutputStream fos = null; try { fos = new FileOutputStream(\"myByteStream\\\\fos.txt\"); fos.write(\"hello\".getBytes()); } catch (IOException e) { e.printStackTrace(); } finally { if(fos != null) { try { fos.close(); } catch (IOException e) { e.printStackTrace(); } } } } } 1.2.6. 2.6字节流读数据(一次读一个字节数据)【应用】 字节输入流 FileInputStream(String name)：通过打开与实际文件的连接来创建一个FileInputStream,该文件由文件系统中的路径名name命名 字节输入流读取数据的步骤 创建字节输入流对象 调用字节输入流对象的读数据方法 释放资源 示例代码 public class FileInputStreamDemo01 { public static void main(String[] args) throws IOException { //创建字节输入流对象 //FileInputStream(String name) FileInputStream fis = new FileInputStream(\"myByteStream\\\\fos.txt\"); int by; /* fis.read()：读数据 by=fis.read()：把读取到的数据赋值给by by != -1：判断读取到的数据是否是-1 */ while ((by=fis.read())!=-1) { System.out.print((char)by); } //释放资源 fis.close(); } } 1.2.7. 2.7字节流复制文件【应用】 案例需求 ​ 把“E:\\itcast\\窗里窗外.txt”复制到模块目录下的“窗里窗外.txt” (文件可以是任意文件) 实现步骤 复制文本文件，其实就把文本文件的内容从一个文件中读取出来(数据源)，然后写入到另一个文件中(目的地) 数据源： ​ E:\\itcast\\窗里窗外.txt --- 读数据 --- InputStream --- FileInputStream 目的地： ​ myByteStream\\窗里窗外.txt --- 写数据 --- OutputStream --- FileOutputStream 代码实现 public class CopyTxtDemo { public static void main(String[] args) throws IOException { //根据数据源创建字节输入流对象 FileInputStream fis = new FileInputStream(\"E:\\\\itcast\\\\窗里窗外.txt\"); //根据目的地创建字节输出流对象 FileOutputStream fos = new FileOutputStream(\"myByteStream\\\\窗里窗外.txt\"); //读写数据，复制文本文件(一次读取一个字节，一次写入一个字节) int by; while ((by=fis.read())!=-1) { fos.write(by); } //释放资源 fos.close(); fis.close(); } } 1.2.8. 2.8字节流读数据(一次读一个字节数组数据)【应用】 一次读一个字节数组的方法 public int read(byte[] b)：从输入流读取最多b.length个字节的数据 返回的是读入缓冲区的总字节数,也就是实际的读取字节个数 示例代码 public class FileInputStreamDemo02 { public static void main(String[] args) throws IOException { //创建字节输入流对象 FileInputStream fis = new FileInputStream(\"myByteStream\\\\fos.txt\"); byte[] bys = new byte[1024]; //1024及其整数倍 int len; //循环读取 while ((len=fis.read(bys))!=-1) { System.out.print(new String(bys,0,len)); } //释放资源 fis.close(); } } 1.2.9. 2.9字节流复制文件【应用】 案例需求 ​ 把“E:\\itcast\\mn.jpg”复制到模块目录下的“mn.jpg” (文件可以是任意文件去) 实现步骤 根据数据源创建字节输入流对象 根据目的地创建字节输出流对象 读写数据，复制图片(一次读取一个字节数组，一次写入一个字节数组) 释放资源 代码实现 public class CopyJpgDemo { public static void main(String[] args) throws IOException { //根据数据源创建字节输入流对象 FileInputStream fis = new FileInputStream(\"E:\\\\itcast\\\\mn.jpg\"); //根据目的地创建字节输出流对象 FileOutputStream fos = new FileOutputStream(\"myByteStream\\\\mn.jpg\"); //读写数据，复制图片(一次读取一个字节数组，一次写入一个字节数组) byte[] bys = new byte[1024]; int len; while ((len=fis.read(bys))!=-1) { fos.write(bys,0,len); } //释放资源 fos.close(); fis.close(); } } 1.3. 3.字节缓冲流 1.3.1. 3.1字节缓冲流构造方法【应用】 字节缓冲流介绍 lBufferOutputStream：该类实现缓冲输出流.通过设置这样的输出流,应用程序可以向底层输出流写入字节,而不必为写入的每个字节导致底层系统的调用 lBufferedInputStream：创建BufferedInputStream将创建一个内部缓冲区数组.当从流中读取或跳过字节时,内部缓冲区将根据需要从所包含的输入流中重新填充,一次很多字节 构造方法： | 方法名 | 说明 | | -------------------------------------- | ----------- | | BufferedOutputStream(OutputStream out) | 创建字节缓冲输出流对象 | | BufferedInputStream(InputStream in) | 创建字节缓冲输入流对象 | 示例代码 ```java public class BufferStreamDemo { public static void main(String[] args) throws IOException { //字节缓冲输出流：BufferedOutputStream(OutputStream out) BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(\"myByteStream\\\\bos.txt\")); //写数据 bos.write(\"hello\\r\\n\".getBytes()); bos.write(\"world\\r\\n\".getBytes()); //释放资源 bos.close(); //字节缓冲输入流：BufferedInputStream(InputStream in) BufferedInputStream bis = new BufferedInputStream(new FileInputStream(\"myByteStream\\\\bos.txt\")); //一次读取一个字节数据 // int by; // while ((by=bis.read())!=-1) { // System.out.print((char)by); // } //一次读取一个字节数组数据 byte[] bys = new byte[1024]; int len; while ((len=bis.read(bys))!=-1) { System.out.print(new String(bys,0,len)); } //释放资源 bis.close(); } } ### 3.2字节缓冲流复制视频【应用】 - 案例需求 把“E:\\\\itcast\\\\字节流复制图片.avi”复制到模块目录下的“字节流复制图片.avi” - 实现步骤 - 根据数据源创建字节输入流对象 - 根据目的地创建字节输出流对象 - 读写数据，复制视频 - 释放资源 - 代码实现 ```java public class CopyAviDemo { public static void main(String[] args) throws IOException { //复制视频 // method1(); method2(); } //字节缓冲流一次读写一个字节数组 public static void method2() throws IOException { BufferedInputStream bis = new BufferedInputStream(new FileInputStream(\"E:\\\\itcast\\\\字节流复制图片.avi\")); BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(\"myByteStream\\\\字节流复制图片.avi\")); byte[] bys = new byte[1024]; int len; while ((len=bis.read(bys))!=-1) { bos.write(bys,0,len); } bos.close(); bis.close(); } //字节缓冲流一次读写一个字节 public static void method1() throws IOException { BufferedInputStream bis = new BufferedInputStream(new FileInputStream(\"E:\\\\itcast\\\\字节流复制图片.avi\")); BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(\"myByteStream\\\\字节流复制图片.avi\")); int by; while ((by=bis.read())!=-1) { bos.write(by); } bos.close(); bis.close(); } } Copyright © MISIN 2022 | 豫ICP备2021006345号-1 all right reserved，powered by Gitbook该文件修订时间： 2020-06-15 17:46:22 "},"1.JAVA基础/day20IO流02.html":{"url":"1.JAVA基础/day20IO流02.html","title":"day20IO流02","keywords":"","body":"1.1. 1.字符流1.1.1. 1.1为什么会出现字符流【理解】1.1.2. 1.2编码表【理解】1.1.3. 1.3字符串中的编码解码问题【应用】1.1.4. 1.4字符流写数据【应用】1.1.5. 1.5字符流读数据【应用】1.1.6. 1.6字符流用户注册案例【应用】1.1.7. 1.7字符缓冲流【应用】1.1.8. 1.8字符缓冲流特有功能【应用】1.1.9. 1.9字符缓冲流操作文件中数据排序案例【应用】1.1.10. 1.10IO流小结【理解】1.2. 2.转换流1.2.1. 2.1字符流中和编码解码问题相关的两个类【理解】1.2.2. 2.2转换流读写数据【应用】1.3. 3.对象操作流1.3.1. 3.1对象序列化流【应用】1.3.2. 3.2对象反序列化流【应用】1.3.3. 3.3serialVersionUID&transient【应用】1.3.4. 3.4对象操作流练习【应用】1.4. 4.Properties集合1.4.1. 4.1Properties作为Map集合的使用【应用】1.4.2. 4.2Properties作为Map集合的特有方法【应用】1.4.3. 4.3Properties和IO流相结合的方法【应用】1.4.4. 4.4Properties集合练习【应用】1.1. 1.字符流 1.1.1. 1.1为什么会出现字符流【理解】 字符流的介绍 由于字节流操作中文不是特别的方便，所以Java就提供字符流 字符流 = 字节流 + 编码表 中文的字节存储方式 用字节流复制文本文件时，文本文件也会有中文，但是没有问题，原因是最终底层操作会自动进行字节拼接成中文，如何识别是中文的呢？ 汉字在存储的时候，无论选择哪种编码存储，第一个字节都是负数 1.1.2. 1.2编码表【理解】 什么是字符集 是一个系统支持的所有字符的集合，包括各国家文字、标点符号、图形符号、数字等 l计算机要准确的存储和识别各种字符集符号，就需要进行字符编码，一套字符集必然至少有一套字符编码。常见字符集有ASCII字符集、GBXXX字符集、Unicode字符集等 常见的字符集 ASCII字符集： lASCII：是基于拉丁字母的一套电脑编码系统，用于显示现代英语，主要包括控制字符(回车键、退格、换行键等)和可显示字符(英文大小写字符、阿拉伯数字和西文符号) 基本的ASCII字符集，使用7位表示一个字符，共128字符。ASCII的扩展字符集使用8位表示一个字符，共256字符，方便支持欧洲常用字符。是一个系统支持的所有字符的集合，包括各国家文字、标点符号、图形符号、数字等 GBXXX字符集： GBK：最常用的中文码表。是在GB2312标准基础上的扩展规范，使用了双字节编码方案，共收录了21003个汉字，完全兼容GB2312标准，同时支持繁体汉字以及日韩汉字等 Unicode字符集： UTF-8编码：可以用来表示Unicode标准中任意字符，它是电子邮件、网页及其他存储或传送文字的应用 中，优先采用的编码。互联网工程工作小组（IETF）要求所有互联网协议都必须支持UTF-8编码。它使用一至四个字节为每个字符编码 编码规则： 128个US-ASCII字符，只需一个字节编码 拉丁文等字符，需要二个字节编码 大部分常用字（含中文），使用三个字节编码 其他极少使用的Unicode辅助字符，使用四字节编码 1.1.3. 1.3字符串中的编码解码问题【应用】 相关方法 | 方法名 | 说明 | | ---------------------------------------- | --------------------------- | | byte[] getBytes() | 使用平台的默认字符集将该 String编码为一系列字节 | | byte[] getBytes(String charsetName) | 使用指定的字符集将该 String编码为一系列字节 | | String(byte[] bytes) | 使用平台的默认字符集解码指定的字节数组来创建字符串 | | String(byte[] bytes, String charsetName) | 通过指定的字符集解码指定的字节数组来创建字符串 | 代码演示 public class StringDemo { public static void main(String[] args) throws UnsupportedEncodingException { //定义一个字符串 String s = \"中国\"; //byte[] bys = s.getBytes(); //[-28, -72, -83, -27, -101, -67] //byte[] bys = s.getBytes(\"UTF-8\"); //[-28, -72, -83, -27, -101, -67] byte[] bys = s.getBytes(\"GBK\"); //[-42, -48, -71, -6] System.out.println(Arrays.toString(bys)); //String ss = new String(bys); //String ss = new String(bys,\"UTF-8\"); String ss = new String(bys,\"GBK\"); System.out.println(ss); } } 1.1.4. 1.4字符流写数据【应用】 介绍 Writer: 用于写入字符流的抽象父类 FileWriter: 用于写入字符流的常用子类 构造方法 | 方法名 | 说明 | | ---------------------------------------- | ---------------------------------------- | | FileWriter(File file) | 根据给定的 File 对象构造一个 FileWriter 对象 | | FileWriter(File file, boolean append) | 根据给定的 File 对象构造一个 FileWriter 对象 | | FileWriter(String fileName) | 根据给定的文件名构造一个 FileWriter 对象 | | FileWriter(String fileName, boolean append) | 根据给定的文件名以及指示是否附加写入数据的 boolean 值来构造 FileWriter 对象 | 成员方法 | 方法名 | 说明 | | ---------------------------------------- | ---------- | | void write(int c) | 写一个字符 | | void write(char[] cbuf) | 写入一个字符数组 | | void write(char[] cbuf, int off, int len) | 写入字符数组的一部分 | | void write(String str) | 写一个字符串 | | void write(String str, int off, int len) | 写一个字符串的一部分 | 刷新和关闭的方法 | 方法名 | 说明 | | ------- | ---------------------------------- | | flush() | 刷新流，之后还可以继续写数据 | | close() | 关闭流，释放资源，但是在关闭之前会先刷新流。一旦关闭，就不能再写数据 | 代码演示 public class OutputStreamWriterDemo { public static void main(String[] args) throws IOException { FileWriter fw = new FileWriter(\"myCharStream\\\\a.txt\"); //void write(int c)：写一个字符 // fw.write(97); // fw.write(98); // fw.write(99); //void writ(char[] cbuf)：写入一个字符数组 char[] chs = {'a', 'b', 'c', 'd', 'e'}; // fw.write(chs); //void write(char[] cbuf, int off, int len)：写入字符数组的一部分 // fw.write(chs, 0, chs.length); // fw.write(chs, 1, 3); //void write(String str)：写一个字符串 // fw.write(\"abcde\"); //void write(String str, int off, int len)：写一个字符串的一部分 // fw.write(\"abcde\", 0, \"abcde\".length()); fw.write(\"abcde\", 1, 3); //释放资源 fw.close(); } } 1.1.5. 1.5字符流读数据【应用】 介绍 Reader: 用于读取字符流的抽象父类 FileReader: 用于读取字符流的常用子类 构造方法 | 方法名 | 说明 | | --------------------------- | ------------------------------------ | | FileReader(File file) | 在给定从中读取数据的 File 的情况下创建一个新 FileReader | | FileReader(String fileName) | 在给定从中读取数据的文件名的情况下创建一个新 FileReader | 成员方法 | 方法名 | 说明 | | --------------------- | ----------- | | int read() | 一次读一个字符数据 | | int read(char[] cbuf) | 一次读一个字符数组数据 | 代码演示 public class InputStreamReaderDemo { public static void main(String[] args) throws IOException { FileReader fr = new FileReader(\"myCharStream\\\\b.txt\"); //int read()：一次读一个字符数据 // int ch; // while ((ch=fr.read())!=-1) { // System.out.print((char)ch); // } //int read(char[] cbuf)：一次读一个字符数组数据 char[] chs = new char[1024]; int len; while ((len = fr.read(chs)) != -1) { System.out.print(new String(chs, 0, len)); } //释放资源 fr.close(); } } 1.1.6. 1.6字符流用户注册案例【应用】 案例需求 将键盘录入的用户名和密码保存到本地实现永久化存储 实现步骤 获取用户输入的用户名和密码 将用户输入的用户名和密码写入到本地文件中 关流,释放资源 代码实现 public class CharStreamDemo8 { public static void main(String[] args) throws IOException { //需求: 将键盘录入的用户名和密码保存到本地实现永久化存储 //要求：用户名独占一行，密码独占一行 //分析： //1，实现键盘录入，把用户名和密码录入进来 Scanner sc = new Scanner(System.in); System.out.println(\"请录入用户名\"); String username = sc.next(); System.out.println(\"请录入密码\"); String password = sc.next(); //2.分别把用户名和密码写到本地文件。 FileWriter fw = new FileWriter(\"charstream\\\\a.txt\"); //将用户名和密码写到文件中 fw.write(username); //表示写出一个回车换行符 windows \\r\\n MacOS \\r Linux \\n fw.write(\"\\r\\n\"); fw.write(password); //刷新流 fw.flush(); //3.关流,释放资源 fw.close(); } } 1.1.7. 1.7字符缓冲流【应用】 字符缓冲流介绍 BufferedWriter：将文本写入字符输出流，缓冲字符，以提供单个字符，数组和字符串的高效写入，可以指定缓冲区大小，或者可以接受默认大小。默认值足够大，可用于大多数用途 BufferedReader：从字符输入流读取文本，缓冲字符，以提供字符，数组和行的高效读取，可以指定缓冲区大小，或者可以使用默认大小。 默认值足够大，可用于大多数用途 构造方法 | 方法名 | 说明 | | -------------------------- | ----------- | | BufferedWriter(Writer out) | 创建字符缓冲输出流对象 | | BufferedReader(Reader in) | 创建字符缓冲输入流对象 | 代码演示 public class BufferedStreamDemo01 { public static void main(String[] args) throws IOException { //BufferedWriter(Writer out) BufferedWriter bw = new BufferedWriter(new FileWriter(\"myCharStream\\\\bw.txt\")); bw.write(\"hello\\r\\n\"); bw.write(\"world\\r\\n\"); bw.close(); //BufferedReader(Reader in) BufferedReader br = new BufferedReader(new FileReader(\"myCharStream\\\\bw.txt\")); //一次读取一个字符数据 // int ch; // while ((ch=br.read())!=-1) { // System.out.print((char)ch); // } //一次读取一个字符数组数据 char[] chs = new char[1024]; int len; while ((len=br.read(chs))!=-1) { System.out.print(new String(chs,0,len)); } br.close(); } } 1.1.8. 1.8字符缓冲流特有功能【应用】 方法介绍 BufferedWriter： | 方法名 | 说明 | | -------------- | ---------------------- | | void newLine() | 写一行行分隔符，行分隔符字符串由系统属性定义 | BufferedReader: | 方法名 | 说明 | | ----------------- | ---------------------------------------- | | String readLine() | 读一行文字。 结果包含行的内容的字符串，不包括任何行终止字符如果流的结尾已经到达，则为null | 代码演示 public class BufferedStreamDemo02 { public static void main(String[] args) throws IOException { //创建字符缓冲输出流 BufferedWriter bw = new BufferedWriter(new FileWriter(\"myCharStream\\\\bw.txt\")); //写数据 for (int i = 0; i 1.1.9. 1.9字符缓冲流操作文件中数据排序案例【应用】 案例需求 使用字符缓冲流读取文件中的数据，排序后再次写到本地文件 实现步骤 将文件中的数据读取到程序中 对读取到的数据进行处理 将处理后的数据添加到集合中 对集合中的数据进行排序 将排序后的集合中的数据写入到文件中 代码实现 public class CharStreamDemo14 { public static void main(String[] args) throws IOException { //需求：读取文件中的数据，排序后再次写到本地文件 //分析： //1.要把文件中的数据读取进来。 BufferedReader br = new BufferedReader(new FileReader(\"charstream\\\\sort.txt\")); //输出流一定不能写在这里，因为会清空文件中的内容 //BufferedWriter bw = new BufferedWriter(new FileWriter(\"charstream\\\\sort.txt\")); String line = br.readLine(); System.out.println(\"读取到的数据为\" + line); br.close(); //2.按照空格进行切割 String[] split = line.split(\" \");//9 1 2 5 3 10 4 6 7 8 //3.把字符串类型的数组变成int类型 int [] arr = new int[split.length]; //遍历split数组，可以进行类型转换。 for (int i = 0; i 1.1.10. 1.10IO流小结【理解】 IO流小结 1.2. 2.转换流 1.2.1. 2.1字符流中和编码解码问题相关的两个类【理解】 InputStreamReader：是从字节流到字符流的桥梁,父类是Reader ​ 它读取字节，并使用指定的编码将其解码为字符 ​ 它使用的字符集可以由名称指定，也可以被明确指定，或者可以接受平台的默认字符集 OutputStreamWriter：是从字符流到字节流的桥梁,父类是Writer ​ 是从字符流到字节流的桥梁，使用指定的编码将写入的字符编码为字节 ​ 它使用的字符集可以由名称指定，也可以被明确指定，或者可以接受平台的默认字符集 1.2.2. 2.2转换流读写数据【应用】 构造方法 | 方法名 | 说明 | | ---------------------------------------- | ------------------------------- | | InputStreamReader(InputStream in) | 使用默认字符编码创建InputStreamReader对象 | | InputStreamReader(InputStream in,String chatset) | 使用指定的字符编码创建InputStreamReader对象 | | OutputStreamWriter(OutputStream out) | 使用默认字符编码创建OutputStreamWriter对象 | | OutputStreamWriter(OutputStream out,String charset) | 使用指定的字符编码创建OutputStreamWriter对象 | 代码演示 public class ConversionStreamDemo { public static void main(String[] args) throws IOException { //OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(\"myCharStream\\\\osw.txt\")); OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(\"myCharStream\\\\osw.txt\"),\"GBK\"); osw.write(\"中国\"); osw.close(); //InputStreamReader isr = new InputStreamReader(new FileInputStream(\"myCharStream\\\\osw.txt\")); InputStreamReader isr = new InputStreamReader(new FileInputStream(\"myCharStream\\\\osw.txt\"),\"GBK\"); //一次读取一个字符数据 int ch; while ((ch=isr.read())!=-1) { System.out.print((char)ch); } isr.close(); } } 1.3. 3.对象操作流 1.3.1. 3.1对象序列化流【应用】 对象序列化介绍 对象序列化：就是将对象保存到磁盘中，或者在网络中传输对象 这种机制就是使用一个字节序列表示一个对象，该字节序列包含：对象的类型、对象的数据和对象中存储的属性等信息 字节序列写到文件之后，相当于文件中持久保存了一个对象的信息 反之，该字节序列还可以从文件中读取回来，重构对象，对它进行反序列化 对象序列化流： ObjectOutputStream 将Java对象的原始数据类型和图形写入OutputStream。 可以使用ObjectInputStream读取（重构）对象。 可以通过使用流的文件来实现对象的持久存储。 如果流是网络套接字流，则可以在另一个主机上或另一个进程中重构对象 构造方法 | 方法名 | 说明 | | ------------------------------------ | ---------------------------------------- | | ObjectOutputStream(OutputStream out) | 创建一个写入指定的OutputStream的ObjectOutputStream | 序列化对象的方法 | 方法名 | 说明 | | ---------------------------- | -------------------------- | | void writeObject(Object obj) | 将指定的对象写入ObjectOutputStream | 示例代码 学生类 public class Student implements Serializable { private String name; private int age; public Student() { } public Student(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } @Override public String toString() { return \"Student{\" + \"name='\" + name + '\\'' + \", age=\" + age + '}'; } } 测试类 public class ObjectOutputStreamDemo { public static void main(String[] args) throws IOException { //ObjectOutputStream(OutputStream out)：创建一个写入指定的OutputStream的ObjectOutputStream ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"myOtherStream\\\\oos.txt\")); //创建对象 Student s = new Student(\"佟丽娅\",30); //void writeObject(Object obj)：将指定的对象写入ObjectOutputStream oos.writeObject(s); //释放资源 oos.close(); } } 注意事项 一个对象要想被序列化，该对象所属的类必须必须实现Serializable 接口 Serializable是一个标记接口，实现该接口，不需要重写任何方法 1.3.2. 3.2对象反序列化流【应用】 对象反序列化流： ObjectInputStream ObjectInputStream反序列化先前使用ObjectOutputStream编写的原始数据和对象 构造方法 | 方法名 | 说明 | | --------------------------------- | ------------------------------------- | | ObjectInputStream(InputStream in) | 创建从指定的InputStream读取的ObjectInputStream | 反序列化对象的方法 | 方法名 | 说明 | | ------------------- | ------------------------ | | Object readObject() | 从ObjectInputStream读取一个对象 | 示例代码 public class ObjectInputStreamDemo { public static void main(String[] args) throws IOException, ClassNotFoundException { //ObjectInputStream(InputStream in)：创建从指定的InputStream读取的ObjectInputStream ObjectInputStream ois = new ObjectInputStream(new FileInputStream(\"myOtherStream\\\\oos.txt\")); //Object readObject()：从ObjectInputStream读取一个对象 Object obj = ois.readObject(); Student s = (Student) obj; System.out.println(s.getName() + \",\" + s.getAge()); ois.close(); } } 1.3.3. 3.3serialVersionUID&transient【应用】 serialVersionUID 用对象序列化流序列化了一个对象后，假如我们修改了对象所属的类文件，读取数据会不会出问题呢？ 会出问题，会抛出InvalidClassException异常 如果出问题了，如何解决呢？ 重新序列化 给对象所属的类加一个serialVersionUID private static final long serialVersionUID = 42L; transient 如果一个对象中的某个成员变量的值不想被序列化，又该如何实现呢？ 给该成员变量加transient关键字修饰，该关键字标记的成员变量不参与序列化过程 示例代码 学生类 public class Student implements Serializable { private static final long serialVersionUID = 42L; private String name; // private int age; private transient int age; public Student() { } public Student(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } // @Override // public String toString() { // return \"Student{\" + // \"name='\" + name + '\\'' + // \", age=\" + age + // '}'; // } } 测试类 public class ObjectStreamDemo { public static void main(String[] args) throws IOException, ClassNotFoundException { // write(); read(); } //反序列化 private static void read() throws IOException, ClassNotFoundException { ObjectInputStream ois = new ObjectInputStream(new FileInputStream(\"myOtherStream\\\\oos.txt\")); Object obj = ois.readObject(); Student s = (Student) obj; System.out.println(s.getName() + \",\" + s.getAge()); ois.close(); } //序列化 private static void write() throws IOException { ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"myOtherStream\\\\oos.txt\")); Student s = new Student(\"佟丽娅\", 30); oos.writeObject(s); oos.close(); } } 1.3.4. 3.4对象操作流练习【应用】 案例需求 创建多个学生类对象写到文件中,再次读取到内存中 实现步骤 创建序列化流对象 创建多个学生对象 将学生对象添加到集合中 将集合对象序列化到文件中 创建反序列化流对象 将文件中的对象数据,读取到内存中 代码实现 学生类 public class Student implements Serializable{ private static final long serialVersionUID = 2L; private String name; private int age; public Student() { } public Student(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } } 测试类 public class Demo03 { /** * read(): * 读取到文件末尾返回值是 -1 * readLine(): * 读取到文件的末尾返回值 null * readObject(): * 读取到文件的末尾 直接抛出异常 * 如果要序列化的对象有多个,不建议直接将多个对象序列化到文件中,因为反序列化时容易出异常 * 建议: 将要序列化的多个对象存储到集合中,然后将集合序列化到文件中 */ public static void main(String[] args) throws Exception { /*// 序列化 //1.创建序列化流对象 ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"myCode\\\\oos.txt\")); ArrayList arrayList = new ArrayList<>(); //2.创建多个学生对象 Student s = new Student(\"佟丽娅\",30); Student s01 = new Student(\"佟丽娅\",30); //3.将学生对象添加到集合中 arrayList.add(s); arrayList.add(s01); //4.将集合对象序列化到文件中 oos.writeObject(arrayList); oos.close();*/ // 反序列化 //5.创建反序列化流对象 ObjectInputStream ois = new ObjectInputStream(new FileInputStream(\"myCode\\\\oos.txt\")); //6.将文件中的对象数据,读取到内存中 Object obj = ois.readObject(); ArrayList arrayList = (ArrayList)obj; ois.close(); for (Student s : arrayList) { System.out.println(s.getName() + \",\" + s.getAge()); } } } 1.4. 4.Properties集合 1.4.1. 4.1Properties作为Map集合的使用【应用】 Properties介绍 是一个Map体系的集合类 Properties可以保存到流中或从流中加载 属性列表中的每个键及其对应的值都是一个字符串 Properties基本使用 public class PropertiesDemo01 { public static void main(String[] args) { //创建集合对象 // Properties prop = new Properties(); //错误 Properties prop = new Properties(); //存储元素 prop.put(\"itheima001\", \"佟丽娅\"); prop.put(\"itheima002\", \"赵丽颖\"); prop.put(\"itheima003\", \"刘诗诗\"); //遍历集合 Set keySet = prop.keySet(); for (Object key : keySet) { Object value = prop.get(key); System.out.println(key + \",\" + value); } } } 1.4.2. 4.2Properties作为Map集合的特有方法【应用】 特有方法 | 方法名 | 说明 | | ---------------------------------------- | ---------------------------------------- | | Object setProperty(String key, String value) | 设置集合的键和值，都是String类型，底层调用 Hashtable方法 put | | String getProperty(String key) | 使用此属性列表中指定的键搜索属性 | | Set stringPropertyNames() | 从该属性列表中返回一个不可修改的键集，其中键及其对应的值是字符串 | 示例代码 public class PropertiesDemo02 { public static void main(String[] args) { //创建集合对象 Properties prop = new Properties(); //Object setProperty(String key, String value)：设置集合的键和值，都是String类型 prop.setProperty(\"itheima001\", \"佟丽娅\"); prop.setProperty(\"itheima002\", \"赵丽颖\"); prop.setProperty(\"itheima003\", \"刘诗诗\"); //String getProperty(String key)：使用此属性列表中指定的键搜索属性 // System.out.println(prop.getProperty(\"itheima001\")); // System.out.println(prop.getProperty(\"itheima0011\")); // System.out.println(prop); //Set stringPropertyNames()：从该属性列表中返回一个不可修改的键集，其中键及其对应的值是字符串 Set names = prop.stringPropertyNames(); for (String key : names) { // System.out.println(key); String value = prop.getProperty(key); System.out.println(key + \",\" + value); } } } 1.4.3. 4.3Properties和IO流相结合的方法【应用】 和IO流结合的方法 | 方法名 | 说明 | | ---------------------------------------- | ---------------------------------------- | | void load(Reader reader) | 从输入字符流读取属性列表（键和元素对） | | void store(Writer writer, String comments) | 将此属性列表（键和元素对）写入此 Properties表中，以适合使用 load(Reader)方法的格式写入输出字符流 | 示例代码 public class PropertiesDemo03 { public static void main(String[] args) throws IOException { //把集合中的数据保存到文件 // myStore(); //把文件中的数据加载到集合 myLoad(); } private static void myLoad() throws IOException { Properties prop = new Properties(); //void load(Reader reader)： FileReader fr = new FileReader(\"myOtherStream\\\\fw.txt\"); prop.load(fr); fr.close(); System.out.println(prop); } private static void myStore() throws IOException { Properties prop = new Properties(); prop.setProperty(\"itheima001\",\"佟丽娅\"); prop.setProperty(\"itheima002\",\"赵丽颖\"); prop.setProperty(\"itheima003\",\"刘诗诗\"); //void store(Writer writer, String comments)： FileWriter fw = new FileWriter(\"myOtherStream\\\\fw.txt\"); prop.store(fw,null); fw.close(); } } 1.4.4. 4.4Properties集合练习【应用】 案例需求 在Properties文件中手动写上姓名和年龄,读取到集合中,将该数据封装成学生对象,写到本地文件 实现步骤 创建Properties集合,将本地文件中的数据加载到集合中 获取集合中的键值对数据,封装到学生对象中 创建序列化流对象,将学生对象序列化到本地文件中 代码实现 学生类 public class Student implements Serializable { private static final long serialVersionUID = 1L; private String name; private int age; public Student() { } public Student(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } @Override public String toString() { return \"Student{\" + \"name='\" + name + '\\'' + \", age=\" + age + '}'; } } 测试类 public class Test { public static void main(String[] args) throws IOException { //1.创建Properties集合,将本地文件中的数据加载到集合中 Properties prop = new Properties(); FileReader fr = new FileReader(\"prop.properties\"); prop.load(fr); fr.close(); //2.获取集合中的键值对数据,封装到学生对象中 String name = prop.getProperty(\"name\"); int age = Integer.parseInt(prop.getProperty(\"age\")); Student s = new Student(name,age); //3.创建序列化流对象,将学生对象序列化到本地文件中 ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"a.txt\")); oos.writeObject(s); oos.close(); } } Copyright © MISIN 2022 | 豫ICP备2021006345号-1 all right reserved，powered by Gitbook该文件修订时间： 2022-11-10 13:20:18 "},"1.JAVA基础/day21-多线程01.html":{"url":"1.JAVA基础/day21-多线程01.html","title":"day21-多线程01","keywords":"","body":"1.1. 1.实现多线程1.1.1. 1.1简单了解多线程【理解】1.1.2. 1.2并发和并行【理解】1.1.3. 1.3进程和线程【理解】1.1.4. 1.4实现多线程方式一：继承Thread类【应用】1.1.5. 1.5实现多线程方式二：实现Runnable接口【应用】1.1.6. 1.6实现多线程方式三: 实现Callable接口【应用】1.1.7. 1.7设置和获取线程名称【应用】1.1.8. 1.8线程休眠【应用】1.1.9. 1.9线程优先级【应用】1.1.10. 1.10守护线程【应用】1.2. 2.线程同步1.2.1. 2.1卖票【应用】1.2.2. 2.2卖票案例的问题【理解】1.2.3. 2.3同步代码块解决数据安全问题【应用】1.2.4. 2.4同步方法解决数据安全问题【应用】1.2.5. 2.6死锁【理解】1.3. 3.生产者消费者1.3.1. 3.1生产者和消费者模式概述【应用】1.3.2. 3.2生产者和消费者案例【应用】1.3.3. 3.3生产者和消费者案例优化【应用】1.3.4. 3.4阻塞队列基本使用【理解】1.3.5. 3.5阻塞队列实现等待唤醒机制【理解】1.1. 1.实现多线程 1.1.1. 1.1简单了解多线程【理解】 是指从软件或者硬件上实现多个线程并发执行的技术。 具有多线程能力的计算机因有硬件支持而能够在同一时间执行多个线程，提升性能。 1.1.2. 1.2并发和并行【理解】 并行：在同一时刻，有多个指令在多个CPU上同时执行。 并发：在同一时刻，有多个指令在单个CPU上交替执行。 1.1.3. 1.3进程和线程【理解】 进程：是正在运行的程序 独立性：进程是一个能独立运行的基本单位，同时也是系统分配资源和调度的独立单位 动态性：进程的实质是程序的一次执行过程，进程是动态产生，动态消亡的 并发性：任何进程都可以同其他进程一起并发执行 线程：是进程中的单个顺序控制流，是一条执行路径 ​ 单线程：一个进程如果只有一条执行路径，则称为单线程程序 ​ 多线程：一个进程如果有多条执行路径，则称为多线程程序 ​ 1.1.4. 1.4实现多线程方式一：继承Thread类【应用】 方法介绍 | 方法名 | 说明 | | ———— | ————————— | | void run() | 在线程开启后，此方法将被调用执行 | | void start() | 使此线程开始执行，Java虚拟机会调用run方法() | 实现步骤 定义一个类MyThread继承Thread类 在MyThread类中重写run()方法 创建MyThread类的对象 启动线程 代码演示 public class MyThread extends Thread { @Override public void run() { for(int i=0; i 两个小问题 为什么要重写run()方法？ 因为run()是用来封装被线程执行的代码 run()方法和start()方法的区别？ run()：封装线程执行的代码，直接调用，相当于普通方法的调用 start()：启动线程；然后由JVM调用此线程的run()方法 1.1.5. 1.5实现多线程方式二：实现Runnable接口【应用】 Thread构造方法 | 方法名 | 说明 | | ———————————— | ————— | | Thread(Runnable target) | 分配一个新的Thread对象 | | Thread(Runnable target, String name) | 分配一个新的Thread对象 | 实现步骤 定义一个类MyRunnable实现Runnable接口 在MyRunnable类中重写run()方法 创建MyRunnable类的对象 创建Thread类的对象，把MyRunnable对象作为构造方法的参数 启动线程 代码演示 public class MyRunnable implements Runnable { @Override public void run() { for(int i=0; i 1.1.6. 1.6实现多线程方式三: 实现Callable接口【应用】 方法介绍 | 方法名 | 说明 | | ——————————— | ———————————— | | V call() | 计算结果，如果无法计算结果，则抛出一个异常 | | FutureTask(Callable callable) | 创建一个 FutureTask，一旦运行就执行给定的 Callable | | V get() | 如有必要，等待计算完成，然后获取其结果 | 实现步骤 定义一个类MyCallable实现Callable接口 在MyCallable类中重写call()方法 创建MyCallable类的对象 创建Future的实现类FutureTask对象，把MyCallable对象作为构造方法的参数 创建Thread类的对象，把FutureTask对象作为构造方法的参数 启动线程 再调用get方法，就可以获取线程结束之后的结果。 代码演示 public class MyCallable implements Callable { @Override public String call() throws Exception { for (int i = 0; i ft = new FutureTask<>(mc); //创建线程对象 Thread t1 = new Thread(ft); String s = ft.get(); //开启线程 t1.start(); //String s = ft.get(); System.out.println(s); } } 三种实现方式的对比 实现Runnable、Callable接口 好处: 扩展性强，实现该接口的同时还可以继承其他的类 缺点: 编程相对复杂，不能直接使用Thread类中的方法 继承Thread类 好处: 编程比较简单，可以直接使用Thread类中的方法 缺点: 可以扩展性较差，不能再继承其他的类 1.1.7. 1.7设置和获取线程名称【应用】 方法介绍 | 方法名 | 说明 | | ————————— | —————— | | void setName(String name) | 将此线程的名称更改为等于参数name | | String getName() | 返回此线程的名称 | | Thread currentThread() | 返回对当前正在执行的线程对象的引用 | 代码演示 public class MyThread extends Thread { public MyThread() {} public MyThread(String name) { super(name); } @Override public void run() { for (int i = 0; i 1.1.8. 1.8线程休眠【应用】 相关方法 | 方法名 | 说明 | | —————————— | ———————— | | static void sleep(long millis) | 使当前正在执行的线程停留（暂停执行）指定的毫秒数 | 代码演示 public class MyRunnable implements Runnable { @Override public void run() { for (int i = 0; i 1.1.9. 1.9线程优先级【应用】 线程调度 两种调度方式 分时调度模型：所有线程轮流使用 CPU 的使用权，平均分配每个线程占用 CPU 的时间片 抢占式调度模型：优先让优先级高的线程使用 CPU，如果线程的优先级相同，那么会随机选择一个，优先级高的线程获取的 CPU 时间片相对多一些 Java使用的是抢占式调度模型 随机性 假如计算机只有一个 CPU，那么 CPU 在某一个时刻只能执行一条指令，线程只有得到CPU时间片，也就是使用权，才可以执行指令。所以说多线程程序的执行是有随机性，因为谁抢到CPU的使用权是不一定的 优先级相关方法 | 方法名 | 说明 | | --------------------------------------- | -------------——————— | | final int getPriority() | 返回此线程的优先级 | | final void setPriority(int newPriority) | 更改此线程的优先级线程默认优先级是5；线程优先级的范围是：1-10 | 代码演示 public class MyCallable implements Callable { @Override public String call() throws Exception { for (int i = 0; i ft = new FutureTask<>(mc); Thread t1 = new Thread(ft); t1.setName(“飞机”); t1.setPriority(10); //System.out.println(t1.getPriority());//5 t1.start(); MyCallable mc2 = new MyCallable(); FutureTask ft2 = new FutureTask<>(mc2); Thread t2 = new Thread(ft2); t2.setName(“坦克”); t2.setPriority(1); //System.out.println(t2.getPriority());//5 t2.start(); } } 1.1.10. 1.10守护线程【应用】 相关方法 | 方法名 | 说明 | | ————————— | ———————————— | | void setDaemon(boolean on) | 将此线程标记为守护线程，当运行的线程都是守护线程时，Java虚拟机将退出 | 代码演示 public class MyThread1 extends Thread { @Override public void run() { for (int i = 0; i 1.2. 2.线程同步 1.2.1. 2.1卖票【应用】 案例需求 某电影院目前正在上映国产大片，共有100张票，而它有3个窗口卖票，请设计一个程序模拟该电影院卖票 实现步骤 定义一个类SellTicket实现Runnable接口，里面定义一个成员变量：private int tickets = 100; 在SellTicket类中重写run()方法实现卖票，代码步骤如下 判断票数大于0，就卖票，并告知是哪个窗口卖的 卖了票之后，总票数要减1 票卖没了，线程停止 定义一个测试类SellTicketDemo，里面有main方法，代码步骤如下 创建SellTicket类的对象 创建三个Thread类的对象，把SellTicket对象作为构造方法的参数，并给出对应的窗口名称 启动线程 代码实现 public class SellTicket implements Runnable { private int tickets = 100; //在SellTicket类中重写run()方法实现卖票，代码步骤如下 @Override public void run() { while (true) { if(ticket 1.2.2. 2.2卖票案例的问题【理解】 卖票出现了问题 相同的票出现了多次 出现了负数的票 问题产生原因 线程执行的随机性导致的,可能在卖票过程中丢失cpu的执行权,导致出现问题 1.2.3. 2.3同步代码块解决数据安全问题【应用】 安全问题出现的条件 是多线程环境 有共享数据 有多条语句操作共享数据 如何解决多线程安全问题呢? 基本思想：让程序没有安全问题的环境 怎么实现呢? 把多条语句操作共享数据的代码给锁起来，让任意时刻只能有一个线程执行即可 Java提供了同步代码块的方式来解决 同步代码块格式： synchronized(任意对象) { 多条语句操作共享数据的代码 } synchronized(任意对象)：就相当于给代码加锁了，任意对象就可以看成是一把锁 同步的好处和弊端 好处：解决了多线程的数据安全问题 弊端：当线程很多时，因为每个线程都会去判断同步上的锁，这是很耗费资源的，无形中会降低程序的运行效率 代码演示 public class SellTicket implements Runnable { private int tickets = 100; private Object obj = new Object(); @Override public void run() { while (true) { synchronized (obj) { // 对可能有安全问题的代码加锁,多个线程必须使用同一把锁 //t1进来后，就会把这段代码给锁起来 if (tickets > 0) { try { Thread.sleep(100); //t1休息100毫秒 } catch (InterruptedException e) { e.printStackTrace(); } //窗口1正在出售第100张票 System.out.println(Thread.currentThread().getName() + “正在出售第” + tickets + “张票”); tickets—; //tickets = 99; } } //t1出来了，这段代码的锁就被释放了 } } } public class SellTicketDemo { public static void main(String[] args) { SellTicket st = new SellTicket(); Thread t1 = new Thread(st, “窗口1”); Thread t2 = new Thread(st, “窗口2”); Thread t3 = new Thread(st, “窗口3”); t1.start(); t2.start(); t3.start(); } } 1.2.4. 2.4同步方法解决数据安全问题【应用】 同步方法的格式 同步方法：就是把synchronized关键字加到方法上 修饰符 synchronized 返回值类型 方法名(方法参数) { 方法体； } 同步方法的锁对象是什么呢? ​ this 静态同步方法 同步静态方法：就是把synchronized关键字加到静态方法上 修饰符 static synchronized 返回值类型 方法名(方法参数) { 方法体； } 同步静态方法的锁对象是什么呢? ​ 类名.class 代码演示 public class MyRunnable implements Runnable { private static int ticketCount = 100; @Override public void run() { while(true){ if(“窗口一”.equals(Thread.currentThread().getName())){ //同步方法 boolean result = synchronizedMthod(); if(result){ break; } } if(“窗口二”.equals(Thread.currentThread().getName())){ //同步代码块 synchronized (MyRunnable.class){ if(ticketCount == 0){ break; }else{ try { Thread.sleep(10); } catch (InterruptedException e) { e.printStackTrace(); } ticketCount—; System.out.println(Thread.currentThread().getName() + “在卖票,还剩下” + ticketCount + “张票”); } } } } } private static synchronized boolean synchronizedMthod() { if(ticketCount == 0){ return true; }else{ try { Thread.sleep(10); } catch (InterruptedException e) { e.printStackTrace(); } ticketCount—; System.out.println(Thread.currentThread().getName() + “在卖票,还剩下” + ticketCount + “张票”); return false; } } } public class Demo { public static void main(String[] args) { MyRunnable mr = new MyRunnable(); Thread t1 = new Thread(mr); Thread t2 = new Thread(mr); t1.setName(“窗口一”); t2.setName(“窗口二”); t1.start(); t2.start(); } } ### 2.5Lock锁【应用】 虽然我们可以理解同步代码块和同步方法的锁对象问题，但是我们并没有直接看到在哪里加上了锁，在哪里释放了锁，为了更清晰的表达如何加锁和释放锁，JDK5以后提供了一个新的锁对象Lock Lock是接口不能直接实例化，这里采用它的实现类ReentrantLock来实例化 - ReentrantLock构造方法 | 方法名 | 说明 | | ————— | ——————— | | ReentrantLock() | 创建一个ReentrantLock的实例 | - 加锁解锁方法 | 方法名 | 说明 | | -———— | -— | | void lock() | 获得锁 | | void unlock() | 释放锁 | - 代码演示 ```java public class Ticket implements Runnable { //票的数量 private int ticket = 100; private Object obj = new Object(); private ReentrantLock lock = new ReentrantLock(); @Override public void run() { while (true) { //synchronized (obj){//多个线程必须使用同一把锁. try { lock.lock(); if (ticket 1.2.5. 2.6死锁【理解】 概述 线程死锁是指由于两个或者多个线程互相持有对方所需要的资源，导致这些线程处于等待状态，无法前往执行 什么情况下会产生死锁 资源有限 同步嵌套 代码演示 public class Demo { public static void main(String[] args) { Object objA = new Object(); Object objB = new Object(); new Thread(()->{ while(true){ synchronized (objA){ //线程一 synchronized (objB){ System.out.println(“小康同学正在走路”); } } } }).start(); new Thread(()->{ while(true){ synchronized (objB){ //线程二 synchronized (objA){ System.out.println(“小薇同学正在走路”); } } } }).start(); } } 1.3. 3.生产者消费者 1.3.1. 3.1生产者和消费者模式概述【应用】 概述 生产者消费者模式是一个十分经典的多线程协作的模式，弄懂生产者消费者问题能够让我们对多线程编程的理解更加深刻。 所谓生产者消费者问题，实际上主要是包含了两类线程： ​ 一类是生产者线程用于生产数据 ​ 一类是消费者线程用于消费数据 为了解耦生产者和消费者的关系，通常会采用共享的数据区域，就像是一个仓库 生产者生产数据之后直接放置在共享数据区中，并不需要关心消费者的行为 消费者只需要从共享数据区中去获取数据，并不需要关心生产者的行为 Object类的等待和唤醒方法 | 方法名 | 说明 | | -————— | -————————————— | | void wait() | 导致当前线程等待，直到另一个线程调用该对象的 notify()方法或 notifyAll()方法 | | void notify() | 唤醒正在等待对象监视器的单个线程 | | void notifyAll() | 唤醒正在等待对象监视器的所有线程 | 1.3.2. 3.2生产者和消费者案例【应用】 案例需求 桌子类(Desk)：定义表示包子数量的变量,定义锁对象变量,定义标记桌子上有无包子的变量 生产者类(Cooker)：实现Runnable接口，重写run()方法，设置线程任务 1.判断是否有包子,决定当前线程是否执行 2.如果有包子,就进入等待状态,如果没有包子,继续执行,生产包子 3.生产包子之后,更新桌子上包子状态,唤醒消费者消费包子 消费者类(Foodie)：实现Runnable接口，重写run()方法，设置线程任务 1.判断是否有包子,决定当前线程是否执行 2.如果没有包子,就进入等待状态,如果有包子,就消费包子 3.消费包子后,更新桌子上包子状态,唤醒生产者生产包子 测试类(Demo)：里面有main方法，main方法中的代码步骤如下 创建生产者线程和消费者线程对象 分别开启两个线程 代码实现 public class Desk { //定义一个标记 //true 就表示桌子上有汉堡包的,此时允许吃货执行 //false 就表示桌子上没有汉堡包的,此时允许厨师执行 public static boolean flag = false; //汉堡包的总数量 public static int count = 10; //锁对象 public static final Object lock = new Object(); } public class Cooker extends Thread { // 生产者步骤： // 1，判断桌子上是否有汉堡包 // 如果有就等待，如果没有才生产。 // 2，把汉堡包放在桌子上。 // 3，叫醒等待的消费者开吃。 @Override public void run() { while(true){ synchronized (Desk.lock){ if(Desk.count == 0){ break; }else{ if(!Desk.flag){ //生产 System.out.println(“厨师正在生产汉堡包”); Desk.flag = true; Desk.lock.notifyAll(); }else{ try { Desk.lock.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } } } } } } public class Foodie extends Thread { @Override public void run() { // 1，判断桌子上是否有汉堡包。 // 2，如果没有就等待。 // 3，如果有就开吃 // 4，吃完之后，桌子上的汉堡包就没有了 // 叫醒等待的生产者继续生产 // 汉堡包的总数量减一 //套路: //1. while(true)死循环 //2. synchronized 锁,锁对象要唯一 //3. 判断,共享数据是否结束. 结束 //4. 判断,共享数据是否结束. 没有结束 while(true){ synchronized (Desk.lock){ if(Desk.count == 0){ break; }else{ if(Desk.flag){ //有 System.out.println(“吃货在吃汉堡包”); Desk.flag = false; Desk.lock.notifyAll(); Desk.count—; }else{ //没有就等待 //使用什么对象当做锁,那么就必须用这个对象去调用等待和唤醒的方法. try { Desk.lock.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } } } } } } public class Demo { public static void main(String[] args) { /*消费者步骤： 1，判断桌子上是否有汉堡包。 2，如果没有就等待。 3，如果有就开吃 4，吃完之后，桌子上的汉堡包就没有了 叫醒等待的生产者继续生产 汉堡包的总数量减一*/ /*生产者步骤： 1，判断桌子上是否有汉堡包 如果有就等待，如果没有才生产。 2，把汉堡包放在桌子上。 3，叫醒等待的消费者开吃。*/ Foodie f = new Foodie(); Cooker c = new Cooker(); f.start(); c.start(); } } 1.3.3. 3.3生产者和消费者案例优化【应用】 需求 将Desk类中的变量,采用面向对象的方式封装起来 生产者和消费者类中构造方法接收Desk类对象,之后在run方法中进行使用 创建生产者和消费者线程对象,构造方法中传入Desk类对象 开启两个线程 代码实现 public class Desk { //定义一个标记 //true 就表示桌子上有汉堡包的,此时允许吃货执行 //false 就表示桌子上没有汉堡包的,此时允许厨师执行 //public static boolean flag = false; private boolean flag; //汉堡包的总数量 //public static int count = 10; //以后我们在使用这种必须有默认值的变量 // private int count = 10; private int count; //锁对象 //public static final Object lock = new Object(); private final Object lock = new Object(); public Desk() { this(false,10); // 在空参内部调用带参,对成员变量进行赋值,之后就可以直接使用成员变量了 } public Desk(boolean flag, int count) { this.flag = flag; this.count = count; } public boolean isFlag() { return flag; } public void setFlag(boolean flag) { this.flag = flag; } public int getCount() { return count; } public void setCount(int count) { this.count = count; } public Object getLock() { return lock; } @Override public String toString() { return “Desk{“ + “flag=“ + flag + “, count=“ + count + “, lock=“ + lock + ‘}’; } } public class Cooker extends Thread { private Desk desk; public Cooker(Desk desk) { this.desk = desk; } // 生产者步骤： // 1，判断桌子上是否有汉堡包 // 如果有就等待，如果没有才生产。 // 2，把汉堡包放在桌子上。 // 3，叫醒等待的消费者开吃。 @Override public void run() { while(true){ synchronized (desk.getLock()){ if(desk.getCount() == 0){ break; }else{ //System.out.println(“验证一下是否执行了”); if(!desk.isFlag()){ //生产 System.out.println(“厨师正在生产汉堡包”); desk.setFlag(true); desk.getLock().notifyAll(); }else{ try { desk.getLock().wait(); } catch (InterruptedException e) { e.printStackTrace(); } } } } } } } public class Foodie extends Thread { private Desk desk; public Foodie(Desk desk) { this.desk = desk; } @Override public void run() { // 1，判断桌子上是否有汉堡包。 // 2，如果没有就等待。 // 3，如果有就开吃 // 4，吃完之后，桌子上的汉堡包就没有了 // 叫醒等待的生产者继续生产 // 汉堡包的总数量减一 //套路: //1. while(true)死循环 //2. synchronized 锁,锁对象要唯一 //3. 判断,共享数据是否结束. 结束 //4. 判断,共享数据是否结束. 没有结束 while(true){ synchronized (desk.getLock()){ if(desk.getCount() == 0){ break; }else{ //System.out.println(“验证一下是否执行了”); if(desk.isFlag()){ //有 System.out.println(“吃货在吃汉堡包”); desk.setFlag(false); desk.getLock().notifyAll(); desk.setCount(desk.getCount() - 1); }else{ //没有就等待 //使用什么对象当做锁,那么就必须用这个对象去调用等待和唤醒的方法. try { desk.getLock().wait(); } catch (InterruptedException e) { e.printStackTrace(); } } } } } } } public class Demo { public static void main(String[] args) { /*消费者步骤： 1，判断桌子上是否有汉堡包。 2，如果没有就等待。 3，如果有就开吃 4，吃完之后，桌子上的汉堡包就没有了 叫醒等待的生产者继续生产 汉堡包的总数量减一*/ /*生产者步骤： 1，判断桌子上是否有汉堡包 如果有就等待，如果没有才生产。 2，把汉堡包放在桌子上。 3，叫醒等待的消费者开吃。*/ Desk desk = new Desk(); Foodie f = new Foodie(desk); Cooker c = new Cooker(desk); f.start(); c.start(); } } 1.3.4. 3.4阻塞队列基本使用【理解】 阻塞队列继承结构 常见BlockingQueue: ArrayBlockingQueue: 底层是数组,有界 LinkedBlockingQueue: 底层是链表,无界.但不是真正的无界,最大为int的最大值 BlockingQueue的核心方法: put(anObject): 将参数放入队列,如果放不进去会阻塞 take(): 取出第一个数据,取不到会阻塞 代码示例 public class Demo02 { public static void main(String[] args) throws Exception { // 创建阻塞队列的对象,容量为 1 ArrayBlockingQueue arrayBlockingQueue = new ArrayBlockingQueue<>(1); // 存储元素 arrayBlockingQueue.put(\"汉堡包\"); // 取元素 System.out.println(arrayBlockingQueue.take()); System.out.println(arrayBlockingQueue.take()); // 取不到会阻塞 System.out.println(\"程序结束了\"); } } 1.3.5. 3.5阻塞队列实现等待唤醒机制【理解】 案例需求 生产者类(Cooker)：实现Runnable接口，重写run()方法，设置线程任务 1.构造方法中接收一个阻塞队列对象 2.在run方法中循环向阻塞队列中添加包子 3.打印添加结果 消费者类(Foodie)：实现Runnable接口，重写run()方法，设置线程任务 1.构造方法中接收一个阻塞队列对象 2.在run方法中循环获取阻塞队列中的包子 3.打印获取结果 测试类(Demo)：里面有main方法，main方法中的代码步骤如下 创建阻塞队列对象 创建生产者线程和消费者线程对象,构造方法中传入阻塞队列对象 分别开启两个线程 代码实现 public class Cooker extends Thread { private ArrayBlockingQueue bd; public Cooker(ArrayBlockingQueue bd) { this.bd = bd; } // 生产者步骤： // 1，判断桌子上是否有汉堡包 // 如果有就等待，如果没有才生产。 // 2，把汉堡包放在桌子上。 // 3，叫醒等待的消费者开吃。 @Override public void run() { while (true) { try { bd.put(\"汉堡包\"); System.out.println(\"厨师放入一个汉堡包\"); } catch (InterruptedException e) { e.printStackTrace(); } } } } public class Foodie extends Thread { private ArrayBlockingQueue bd; public Foodie(ArrayBlockingQueue bd) { this.bd = bd; } @Override public void run() { // 1，判断桌子上是否有汉堡包。 // 2，如果没有就等待。 // 3，如果有就开吃 // 4，吃完之后，桌子上的汉堡包就没有了 // 叫醒等待的生产者继续生产 // 汉堡包的总数量减一 //套路: //1. while(true)死循环 //2. synchronized 锁,锁对象要唯一 //3. 判断,共享数据是否结束. 结束 //4. 判断,共享数据是否结束. 没有结束 while (true) { try { String take = bd.take(); System.out.println(\"吃货将\" + take + \"拿出来吃了\"); } catch (InterruptedException e) { e.printStackTrace(); } } } } public class Demo { public static void main(String[] args) { ArrayBlockingQueue bd = new ArrayBlockingQueue<>(1); Foodie f = new Foodie(bd); Cooker c = new Cooker(bd); f.start(); c.start(); } } Copyright © MISIN 2022 | 豫ICP备2021006345号-1 all right reserved，powered by Gitbook该文件修订时间： 2022-11-10 13:18:30 "},"1.JAVA基础/day22 多线程02.html":{"url":"1.JAVA基础/day22 多线程02.html","title":"day22 多线程02","keywords":"","body":"1.1. 1.线程池1.1.1. 1.1 线程状态介绍1.1.2. 1.2 线程的状态-练习11.1.3. 1.3 线程的状态-练习21.1.4. 1.1.5. 1.4 线程的状态-练习31.1.6. 1.5 线程池-基本原理1.1.7. 1.6 线程池-Executors默认线程池1.1.8. 1.7 线程池-Executors创建指定上限的线程池1.1.9. 1.8 线程池-ThreadPoolExecutor1.1.10. 1.9 线程池-参数详解1.1.11. 1.10 线程池-非默认任务拒绝策略1.2. 2. 原子性1.2.1. 2.1 volatile-问题1.2.2. 2.2 volatile解决1.2.3. 2.3 synchronized解决1.2.4. 2.4 原子性1.2.5. 2.5 volatile关键字不能保证原子性1.2.6. 2.6 原子性_AtomicInteger1.2.7. 2.7 AtomicInteger-内存解析1.2.8. 2.8 AtomicInteger-源码解析1.2.9. 2.9 悲观锁和乐观锁1.3. 3. 并发工具类1.3.1. 3.1 并发工具类-Hashtable1.3.2. 3.2 并发工具类-ConcurrentHashMap基本使用1.3.3. 3.3 并发工具类-ConcurrentHashMap1.7原理1.3.4. 3.4 并发工具类-ConcurrentHashMap1.8原理1.3.5. 3.5 并发工具类-CountDownLatch1.3.6. 3.6 并发工具类-Semaphore1.1. 1.线程池 1.1.1. 1.1 线程状态介绍 当线程被创建并启动以后，它既不是一启动就进入了执行状态，也不是一直处于执行状态。线程对象在不同的时期有不同的状态。那么Java中的线程存在哪几种状态呢？Java中的线程 状态被定义在了java.lang.Thread.State枚举类中，State枚举类的源码如下： public class Thread { public enum State { /* 新建 */ NEW , /* 可运行状态 */ RUNNABLE , /* 阻塞状态 */ BLOCKED , /* 无限等待状态 */ WAITING , /* 计时等待 */ TIMED_WAITING , /* 终止 */ TERMINATED; } // 获取当前线程的状态 public State getState() { return jdk.internal.misc.VM.toThreadState(threadStatus); } } 通过源码我们可以看到Java中的线程存在6种状态，每种线程状态的含义如下 | 线程状态 | 具体含义 | | -———— | -————————————— | | NEW | 一个尚未启动的线程的状态。也称之为初始状态、开始状态。线程刚被创建，但是并未启动。还没调用start方法。MyThread t = new MyThread()只有线程象，没有线程特征。 | | RUNNABLE | 当我们调用线程对象的start方法，那么此时线程对象进入了RUNNABLE状态。那么此时才是真正的在JVM进程中创建了一个线程，线程一经启动并不是立即得到执行，线程的运行与否要听令与CPU的调度，那么我们把这个中间状态称之为可执行状态(RUNNABLE)也就是说它具备执行的资格，但是并没有真正的执行起来而是在等待CPU的度。 | | BLOCKED | 当一个线程试图获取一个对象锁，而该对象锁被其他的线程持有，则该线程进入Blocked状态；当该线程持有锁时，该线程将变成Runnable状态。 | | WAITING | 一个正在等待的线程的状态。也称之为等待状态。造成线程等待的原因有两种，分别是调用Object.wait()、join()方法。处于等待状态的线程，正在等待其他线程去执行一个特定的操作。例如：因为wait()而等待的线程正在等待另一个线程去调用notify()或notifyAll()；一个因为join()而等待的线程正在等待另一个线程结束。 | | TIMED_WAITING | 一个在限定时间内等待的线程的状态。也称之为限时等待状态。造成线程限时等待状态的原因有三种，分别是：Thread.sleep(long)，Object.wait(long)、join(long)。 | | TERMINATED | 一个完全运行完成的线程的状态。也称之为终止状态、结束状态 | 各个状态的转换，如下图所示： 1.1.2. 1.2 线程的状态-练习1 目的 : 本案例主要演示TIME_WAITING的状态转换。 需求：编写一段代码，依次显示一个线程的这些状态：NEW -> RUNNABLE -> TIME_WAITING -> RUNNABLE -> TERMINATED 为了简化我们的开发，本次我们使用匿名内部类结合lambda表达式的方式使用多线程。 代码实现 public class ThreadStateDemo01 { public static void main(String[] args) throws InterruptedException { //定义一个内部线程 Thread thread = new Thread(() -> { System.out.println(“2.执行thread.start()之后，线程的状态：” + Thread.currentThread().getState()); try { //休眠100毫秒 Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(“4.执行Thread.sleep(long)完成之后，线程的状态：” + Thread.currentThread().getState()); }); //获取start()之前的状态 System.out.println(“1.通过new初始化一个线程，但是还没有start()之前，线程的状态：” + thread.getState()); //启动线程 thread.start(); //休眠50毫秒 Thread.sleep(50); //因为thread1需要休眠100毫秒，所以在第50毫秒，thread处于sleep状态 System.out.println(“3.执行Thread.sleep(long)时，线程的状态：” + thread.getState()); //thread1和main线程主动休眠150毫秒，所以在第150毫秒,thread早已执行完毕 Thread.sleep(100); System.out.println(“5.线程执行完毕之后，线程的状态：” + thread.getState() + “\\n”); } } 控制台输出 1.通过new初始化一个线程，但是还没有start()之前，线程的状态：NEW 2.执行thread.start()之后，线程的状态：RUNNABLE 3.执行Thread.sleep(long)时，线程的状态：TIMED_WAITING 4.执行Thread.sleep(long)完成之后，线程的状态：RUNNABLE 5.线程执行完毕之后，线程的状态：TERMINATED 1.1.3. 1.3 线程的状态-练习2 目的 : 本案例主要演示WAITING的状态转换。 需求 ：编写一段代码，依次显示一个线程的这些状态：NEW -> RUNNABLE -> WAITING -> RUNNABLE -> TERMINATED 代码实现 : public class ThreadStateDemo02 { public static void main(String[] args) throws InterruptedException { //定义一个对象，用来加锁和解锁 Object obj = new Object(); //定义一个内部线程 Thread thread1 = new Thread(() -> { System.out.println(“2.执行thread.start()之后，线程的状态：” + Thread.currentThread().getState()); synchronized (obj) { try { //thread1需要休眠100毫秒 Thread.sleep(100); //thread1100毫秒之后，通过wait()方法释放obj对象是锁 obj.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } System.out.println(“4.被object.notify()方法唤醒之后，线程的状态：” + Thread.currentThread().getState()); }); //获取start()之前的状态 System.out.println(“1.通过new初始化一个线程，但是还没有start()之前，线程的状态：” + thread1.getState()); //启动线程 thread1.start(); //main线程休眠150毫秒 Thread.sleep(150); //因为thread1在第100毫秒进入wait等待状态，所以第150秒肯定可以获取其状态 System.out.println(“3.执行object.wait()时，线程的状态：” + thread1.getState()); //声明另一个线程进行解锁 new Thread(() -> { synchronized (obj) { //唤醒等待的线程 obj.notify(); } }).start(); //main线程休眠10毫秒等待thread1线程能够苏醒 Thread.sleep(10); //获取thread1运行结束之后的状态 System.out.println(“5.线程执行完毕之后，线程的状态：” + thread1.getState() + “\\n”); } } 控制台输出结果 1.通过new初始化一个线程，但是还没有start()之前，线程的状态：NEW 2.执行thread.start()之后，线程的状态：RUNNABLE 3.执行object.wait()时，线程的状态：WAITING 4.被object.notify()方法唤醒之后，线程的状态：RUNNABLE 5.线程执行完毕之后，线程的状态：TERMINATED 1.1.4. 1.1.5. 1.4 线程的状态-练习3 目的 : 本案例主要演示BLOCKED的状态转换。 需求 ：编写一段代码，依次显示一个线程的这些状态：NEW -> RUNNABLE -> BLOCKED -> RUNNABLE -> TERMINATED public class ThreadStateDemo03 { public static void main(String[] args) throws InterruptedException { //定义一个对象，用来加锁和解锁 Object obj2 = new Object(); //定义一个线程，先抢占了obj2对象的锁 new Thread(() -> { synchronized (obj2) { try { Thread.sleep(100); //第一个线程要持有锁100毫秒 obj2.wait(); //然后通过wait()方法进行等待状态，并释放obj2的对象锁 } catch (InterruptedException e) { e.printStackTrace(); } } }).start(); //定义目标线程，获取等待获取obj2的锁 Thread thread = new Thread(() -> { System.out.println(“2.执行thread.start()之后，线程的状态：” + Thread.currentThread().getState()); synchronized (obj2) { try { Thread.sleep(100); //thread3要持有对象锁100毫秒 obj2.notify(); //然后通过notify()方法唤醒所有在ojb2上等待的线程继续执行后续操作 } catch (InterruptedException e) { e.printStackTrace(); } } System.out.println(“4.阻塞结束后，线程的状态：” + Thread.currentThread().getState()); }); //获取start()之前的状态 System.out.println(“1.通过new初始化一个线程，但是还没有thread.start()之前，线程的状态：” + thread.getState()); //启动线程 thread.start(); //先等100毫秒 Thread.sleep(50); //第一个线程释放锁至少需要100毫秒，所以在第50毫秒时，thread正在因等待obj的对象锁而阻塞 System.out.println(“3.因为等待锁而阻塞时，线程的状态：” + thread.getState()); //再等300毫秒 Thread.sleep(300); //两个线程的执行时间加上之前等待的50毫秒总共是250毫秒，所以第300毫秒，所有的线程都已经执行完毕 System.out.println(“5.线程执行完毕之后，线程的状态：” + thread.getState()); } } 控制台输出结果 1.通过new初始化一个线程，但是还没有thread.start()之前，线程的状态：NEW 2.执行thread.start()之后，线程的状态：RUNNABLE 3.因为等待锁而阻塞时，线程的状态：BLOCKED 4.阻塞结束后，线程的状态：RUNNABLE 5.线程执行完毕之后，线程的状态：TERMINATED 1.1.6. 1.5 线程池-基本原理 概述 : ​ 提到池，大家应该能想到的就是水池。水池就是一个容器，在该容器中存储了很多的水。那么什么是线程池呢？线程池也是可以看做成一个池子，在该池子中存储很多个线程。 线程池存在的意义： ​ 系统创建一个线程的成本是比较高的，因为它涉及到与操作系统交互，当程序中需要创建大量生存期很短暂的线程时，频繁的创建和销毁线程对系统的资源消耗有可能大于业务处理是对系 ​ 统资源的消耗，这样就有点”舍本逐末”了。针对这一种情况，为了提高性能，我们就可以采用线程池。线程池在启动的时，会创建大量空闲线程，当我们向线程池提交任务的时，线程池就 ​ 会启动一个线程来执行该任务。等待任务执行完毕以后，线程并不会死亡，而是再次返回到线程池中称为空闲状态。等待下一次任务的执行。 线程池的设计思路 : 准备一个任务容器 一次性启动多个(2个)消费者线程 刚开始任务容器是空的，所以线程都在wait 直到一个外部线程向这个任务容器中扔了一个”任务”，就会有一个消费者线程被唤醒 这个消费者线程取出”任务”，并且执行这个任务，执行完毕后，继续等待下一次任务的到来 1.1.7. 1.6 线程池-Executors默认线程池 概述 : JDK对线程池也进行了相关的实现，在真实企业开发中我们也很少去自定义线程池，而是使用JDK中自带的线程池。 我们可以使用Executors中所提供的静态方法来创建线程池 ​ static ExecutorService newCachedThreadPool() 创建一个默认的线程池 ​ static newFixedThreadPool(int nThreads) 创建一个指定最多线程数量的线程池 代码实现 : package com.itheima.mythreadpool; //static ExecutorService newCachedThreadPool() 创建一个默认的线程池 //static newFixedThreadPool(int nThreads) 创建一个指定最多线程数量的线程池 import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; public class MyThreadPoolDemo { public static void main(String[] args) throws InterruptedException { //1,创建一个默认的线程池对象.池子中默认是空的.默认最多可以容纳int类型的最大值. ExecutorService executorService = Executors.newCachedThreadPool(); //Executors — 可以帮助我们创建线程池对象 //ExecutorService — 可以帮助我们控制线程池 executorService.submit(()->{ System.out.println(Thread.currentThread().getName() + “在执行了”); }); //Thread.sleep(2000); executorService.submit(()->{ System.out.println(Thread.currentThread().getName() + “在执行了”); }); executorService.shutdown(); } } 1.1.8. 1.7 线程池-Executors创建指定上限的线程池 使用Executors中所提供的静态方法来创建线程池 ​ static ExecutorService newFixedThreadPool(int nThreads) : 创建一个指定最多线程数量的线程池 代码实现 : package com.itheima.mythreadpool; //static ExecutorService newFixedThreadPool(int nThreads) //创建一个指定最多线程数量的线程池 import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; import java.util.concurrent.ThreadPoolExecutor; public class MyThreadPoolDemo2 { public static void main(String[] args) { //参数不是初始值而是最大值 ExecutorService executorService = Executors.newFixedThreadPool(10); ThreadPoolExecutor pool = (ThreadPoolExecutor) executorService; System.out.println(pool.getPoolSize());//0 executorService.submit(()->{ System.out.println(Thread.currentThread().getName() + “在执行了”); }); executorService.submit(()->{ System.out.println(Thread.currentThread().getName() + “在执行了”); }); System.out.println(pool.getPoolSize());//2 // executorService.shutdown(); } } 1.1.9. 1.8 线程池-ThreadPoolExecutor 创建线程池对象 : ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(核心线程数量,最大线程数量,空闲线程最大存活时间,任务队列,创建线程工厂,任务的拒绝策略); 代码实现 : package com.itheima.mythreadpool; import java.util.concurrent.ArrayBlockingQueue; import java.util.concurrent.Executors; import java.util.concurrent.ThreadPoolExecutor; import java.util.concurrent.TimeUnit; public class MyThreadPoolDemo3 { // 参数一：核心线程数量 // 参数二：最大线程数 // 参数三：空闲线程最大存活时间 // 参数四：时间单位 // 参数五：任务队列 // 参数六：创建线程工厂 // 参数七：任务的拒绝策略 public static void main(String[] args) { ThreadPoolExecutor pool = new ThreadPoolExecutor(2,5,2,TimeUnit.SECONDS,new ArrayBlockingQueue<>(10), Executors.defaultThreadFactory(),new ThreadPoolExecutor.AbortPolicy()); pool.submit(new MyRunnable()); pool.submit(new MyRunnable()); pool.shutdown(); } } 1.1.10. 1.9 线程池-参数详解 public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) corePoolSize： 核心线程的最大值，不能小于0 maximumPoolSize：最大线程数，不能小于等于0，maximumPoolSize >= corePoolSize keepAliveTime： 空闲线程最大存活时间,不能小于0 unit： 时间单位 workQueue： 任务队列，不能为null threadFactory： 创建线程工厂,不能为null handler： 任务的拒绝策略,不能为null 1.1.11. 1.10 线程池-非默认任务拒绝策略 RejectedExecutionHandler是jdk提供的一个任务拒绝策略接口，它下面存在4个子类。 ThreadPoolExecutor.AbortPolicy: 丢弃任务并抛出RejectedExecutionException异常。是默认的策略。 ThreadPoolExecutor.DiscardPolicy： 丢弃任务，但是不抛出异常 这是不推荐的做法。 ThreadPoolExecutor.DiscardOldestPolicy： 抛弃队列中等待最久的任务 然后把当前任务加入队列中。 ThreadPoolExecutor.CallerRunsPolicy: 调用任务的run()方法绕过线程池直接执行。 注：明确线程池对多可执行的任务数 = 队列容量 + 最大线程数 案例演示1：演示ThreadPoolExecutor.AbortPolicy任务处理策略 public class ThreadPoolExecutorDemo01 { public static void main(String[] args) { /** * 核心线程数量为1 ， 最大线程池数量为3, 任务容器的容量为1 ,空闲线程的最大存在时间为20s */ ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(1 , 3 , 20 , TimeUnit.SECONDS , new ArrayBlockingQueue<>(1) , Executors.defaultThreadFactory() , new ThreadPoolExecutor.AbortPolicy()) ; // 提交5个任务，而该线程池最多可以处理4个任务，当我们使用AbortPolicy这个任务处理策略的时候，就会抛出异常 for(int x = 0 ; x { System.out.println(Thread.currentThread().getName() + “-—>> 执行了任务”); }); } } } 控制台输出结果 pool-1-thread-1-—>> 执行了任务 pool-1-thread-3-—>> 执行了任务 pool-1-thread-2-—>> 执行了任务 pool-1-thread-3-—>> 执行了任务 控制台报错，仅仅执行了4个任务，有一个任务被丢弃了 案例演示2：演示ThreadPoolExecutor.DiscardPolicy任务处理策略 public class ThreadPoolExecutorDemo02 { public static void main(String[] args) { /** * 核心线程数量为1 ， 最大线程池数量为3, 任务容器的容量为1 ,空闲线程的最大存在时间为20s */ ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(1 , 3 , 20 , TimeUnit.SECONDS , new ArrayBlockingQueue<>(1) , Executors.defaultThreadFactory() , new ThreadPoolExecutor.DiscardPolicy()) ; // 提交5个任务，而该线程池最多可以处理4个任务，当我们使用DiscardPolicy这个任务处理策略的时候，控制台不会报错 for(int x = 0 ; x { System.out.println(Thread.currentThread().getName() + “-—>> 执行了任务”); }); } } } 控制台输出结果 pool-1-thread-1-—>> 执行了任务 pool-1-thread-1-—>> 执行了任务 pool-1-thread-3-—>> 执行了任务 pool-1-thread-2-—>> 执行了任务 控制台没有报错，仅仅执行了4个任务，有一个任务被丢弃了 案例演示3：演示ThreadPoolExecutor.DiscardOldestPolicy任务处理策略 public class ThreadPoolExecutorDemo02 { public static void main(String[] args) { /** * 核心线程数量为1 ， 最大线程池数量为3, 任务容器的容量为1 ,空闲线程的最大存在时间为20s */ ThreadPoolExecutor threadPoolExecutor; threadPoolExecutor = new ThreadPoolExecutor(1 , 3 , 20 , TimeUnit.SECONDS , new ArrayBlockingQueue<>(1) , Executors.defaultThreadFactory() , new ThreadPoolExecutor.DiscardOldestPolicy()); // 提交5个任务 for(int x = 0 ; x { System.out.println(Thread.currentThread().getName() + “-—>> 执行了任务” + y); }); } } } 控制台输出结果 pool-1-thread-2-—>> 执行了任务2 pool-1-thread-1-—>> 执行了任务0 pool-1-thread-3-—>> 执行了任务3 pool-1-thread-1-—>> 执行了任务4 由于任务1在线程池中等待时间最长，因此任务1被丢弃。 案例演示4：演示ThreadPoolExecutor.CallerRunsPolicy任务处理策略 public class ThreadPoolExecutorDemo04 { public static void main(String[] args) { /** * 核心线程数量为1 ， 最大线程池数量为3, 任务容器的容量为1 ,空闲线程的最大存在时间为20s */ ThreadPoolExecutor threadPoolExecutor; threadPoolExecutor = new ThreadPoolExecutor(1 , 3 , 20 , TimeUnit.SECONDS , new ArrayBlockingQueue<>(1) , Executors.defaultThreadFactory() , new ThreadPoolExecutor.CallerRunsPolicy()); // 提交5个任务 for(int x = 0 ; x { System.out.println(Thread.currentThread().getName() + “-—>> 执行了任务”); }); } } } 控制台输出结果 pool-1-thread-1-—>> 执行了任务 pool-1-thread-3-—>> 执行了任务 pool-1-thread-2-—>> 执行了任务 pool-1-thread-1-—>> 执行了任务 main-—>> 执行了任务 通过控制台的输出，我们可以看到次策略没有通过线程池中的线程执行任务，而是直接调用任务的run()方法绕过线程池直接执行。 1.2. 2. 原子性 1.2.1. 2.1 volatile-问题 代码分析 : package com.itheima.myvolatile; public class Demo { public static void main(String[] args) { MyThread1 t1 = new MyThread1(); t1.setName(“小路同学”); t1.start(); MyThread2 t2 = new MyThread2(); t2.setName(“小皮同学”); t2.start(); } } package com.itheima.myvolatile; public class Money { public static int money = 100000; } package com.itheima.myvolatile; public class MyThread1 extends Thread { @Override public void run() { while(Money.money == 100000){ } System.out.println(“结婚基金已经不是十万了”); } } package com.itheima.myvolatile; public class MyThread2 extends Thread { @Override public void run() { try { Thread.sleep(10); } catch (InterruptedException e) { e.printStackTrace(); } Money.money = 90000; } } 程序问题 : 女孩虽然知道结婚基金是十万，但是当基金的余额发生变化的时候，女孩无法知道最新的余额。 1.2.2. 2.2 volatile解决 以上案例出现的问题 : ​ 当A线程修改了共享数据时，B线程没有及时获取到最新的值，如果还在使用原先的值，就会出现问题 ​ 1，堆内存是唯一的，每一个线程都有自己的线程栈。 ​ 2 ，每一个线程在使用堆里面变量的时候，都会先拷贝一份到变量的副本中。 ​ 3 ，在线程中，每一次使用是从变量的副本中获取的。 Volatile关键字 : 强制线程每次在使用的时候，都会看一下共享区域最新的值 代码实现 : 使用volatile关键字解决 package com.itheima.myvolatile; public class Demo { public static void main(String[] args) { MyThread1 t1 = new MyThread1(); t1.setName(“小路同学”); t1.start(); MyThread2 t2 = new MyThread2(); t2.setName(“小皮同学”); t2.start(); } } package com.itheima.myvolatile; public class Money { public static volatile int money = 100000; } package com.itheima.myvolatile; public class MyThread1 extends Thread { @Override public void run() { while(Money.money == 100000){ } System.out.println(“结婚基金已经不是十万了”); } } package com.itheima.myvolatile; public class MyThread2 extends Thread { @Override public void run() { try { Thread.sleep(10); } catch (InterruptedException e) { e.printStackTrace(); } Money.money = 90000; } } 1.2.3. 2.3 synchronized解决 synchronized解决 : ​ 1 ，线程获得锁 ​ 2 ，清空变量副本 ​ 3 ，拷贝共享变量最新的值到变量副本中 ​ 4 ，执行代码 ​ 5 ，将修改后变量副本中的值赋值给共享数据 ​ 6 ，释放锁 代码实现 : package com.itheima.myvolatile2; public class Demo { public static void main(String[] args) { MyThread1 t1 = new MyThread1(); t1.setName(“小路同学”); t1.start(); MyThread2 t2 = new MyThread2(); t2.setName(“小皮同学”); t2.start(); } } package com.itheima.myvolatile2; public class Money { public static Object lock = new Object(); public static volatile int money = 100000; } package com.itheima.myvolatile2; public class MyThread1 extends Thread { @Override public void run() { while(true){ synchronized (Money.lock){ if(Money.money != 100000){ System.out.println(“结婚基金已经不是十万了”); break; } } } } } package com.itheima.myvolatile2; public class MyThread2 extends Thread { @Override public void run() { synchronized (Money.lock) { try { Thread.sleep(10); } catch (InterruptedException e) { e.printStackTrace(); } Money.money = 90000; } } } 1.2.4. 2.4 原子性 概述 : 所谓的原子性是指在一次操作或者多次操作中，要么所有的操作全部都得到了执行并且不会受到任何因素的干扰而中断，要么所有的操作都不执行，多个操作是一个不可以分割的整体。 代码实现 : package com.itheima.threadatom; public class AtomDemo { public static void main(String[] args) { MyAtomThread atom = new MyAtomThread(); for (int i = 0; i 代码总结 : count++ 不是一个原子性操作, 他在执行的过程中,有可能被其他线程打断 1.2.5. 2.5 volatile关键字不能保证原子性 解决方案 : 我们可以给count++操作添加锁，那么count++操作就是临界区中的代码，临界区中的代码一次只能被一个线程去执行，所以count++就变成了原子操作。 package com.itheima.threadatom2; public class AtomDemo { public static void main(String[] args) { MyAtomThread atom = new MyAtomThread(); for (int i = 0; i 1.2.6. 2.6 原子性_AtomicInteger 概述：java从JDK1.5开始提供了java.util.concurrent.atomic包(简称Atomic包)，这个包中的原子操作类提供了一种用法简单，性能高效，线程安全地更新一个变量的方式。因为变 量的类型有很多种，所以在Atomic包里一共提供了13个类，属于4种类型的原子更新方式，分别是原子更新基本类型、原子更新数组、原子更新引用和原子更新属性(字段)。本次我们只讲解 使用原子的方式更新基本类型，使用原子的方式更新基本类型Atomic包提供了以下3个类： AtomicBoolean： 原子更新布尔类型 AtomicInteger： 原子更新整型 AtomicLong： 原子更新长整型 以上3个类提供的方法几乎一模一样，所以本节仅以AtomicInteger为例进行讲解，AtomicInteger的常用方法如下： public AtomicInteger()： 初始化一个默认值为0的原子型Integer public AtomicInteger(int initialValue)： 初始化一个指定值的原子型Integer int get(): 获取值 int getAndIncrement(): 以原子方式将当前值加1，注意，这里返回的是自增前的值。 int incrementAndGet(): 以原子方式将当前值加1，注意，这里返回的是自增后的值。 int addAndGet(int data): 以原子方式将输入的数值与实例中的值（AtomicInteger里的value）相加，并返回结果。 int getAndSet(int value): 以原子方式设置为newValue的值，并返回旧值。 代码实现 : package com.itheima.threadatom3; import java.util.concurrent.atomic.AtomicInteger; public class MyAtomIntergerDemo1 { // public AtomicInteger()： 初始化一个默认值为0的原子型Integer // public AtomicInteger(int initialValue)： 初始化一个指定值的原子型Integer public static void main(String[] args) { AtomicInteger ac = new AtomicInteger(); System.out.println(ac); AtomicInteger ac2 = new AtomicInteger(10); System.out.println(ac2); } } package com.itheima.threadatom3; import java.lang.reflect.Field; import java.util.concurrent.atomic.AtomicInteger; public class MyAtomIntergerDemo2 { // int get(): 获取值 // int getAndIncrement(): 以原子方式将当前值加1，注意，这里返回的是自增前的值。 // int incrementAndGet(): 以原子方式将当前值加1，注意，这里返回的是自增后的值。 // int addAndGet(int data): 以原子方式将参数与对象中的值相加，并返回结果。 // int getAndSet(int value): 以原子方式设置为newValue的值，并返回旧值。 public static void main(String[] args) { // AtomicInteger ac1 = new AtomicInteger(10); // System.out.println(ac1.get()); // AtomicInteger ac2 = new AtomicInteger(10); // int andIncrement = ac2.getAndIncrement(); // System.out.println(andIncrement); // System.out.println(ac2.get()); // AtomicInteger ac3 = new AtomicInteger(10); // int i = ac3.incrementAndGet(); // System.out.println(i);//自增后的值 // System.out.println(ac3.get()); // AtomicInteger ac4 = new AtomicInteger(10); // int i = ac4.addAndGet(20); // System.out.println(i); // System.out.println(ac4.get()); AtomicInteger ac5 = new AtomicInteger(100); int andSet = ac5.getAndSet(20); System.out.println(andSet); System.out.println(ac5.get()); } } 1.2.7. 2.7 AtomicInteger-内存解析 AtomicInteger原理 : 自旋锁 + CAS 算法 CAS算法： ​ 有3个操作数（内存值V， 旧的预期值A，要修改的值B） ​ 当旧的预期值A == 内存值 此时修改成功，将V改为B ​ 当旧的预期值A！=内存值 此时修改失败，不做任何操作 ​ 并重新获取现在的最新值（这个重新获取的动作就是自旋） 1.2.8. 2.8 AtomicInteger-源码解析 代码实现 : package com.itheima.threadatom4; public class AtomDemo { public static void main(String[] args) { MyAtomThread atom = new MyAtomThread(); for (int i = 0; i package com.itheima.threadatom4; import java.util.concurrent.atomic.AtomicInteger; public class MyAtomThread implements Runnable { //private volatile int count = 0; //送冰淇淋的数量 //private Object lock = new Object(); AtomicInteger ac = new AtomicInteger(0); @Override public void run() { for (int i = 0; i 源码解析 : //先自增，然后获取自增后的结果 public final int incrementAndGet() { //+ 1 自增后的结果 //this 就表示当前的atomicInteger（值） //1 自增一次 return U.getAndAddInt(this, VALUE, 1) + 1; } public final int getAndAddInt(Object o, long offset, int delta) { //v 旧值 int v; //自旋的过程 do { //不断的获取旧值 v = getIntVolatile(o, offset); //如果这个方法的返回值为false，那么继续自旋 //如果这个方法的返回值为true，那么自旋结束 //o 表示的就是内存值 //v 旧值 //v + delta 修改后的值 } while (!weakCompareAndSetInt(o, offset, v, v + delta)); //作用：比较内存中的值，旧值是否相等，如果相等就把修改后的值写到内存中，返回true。表示修改成功。 // 如果不相等，无法把修改后的值写到内存中，返回false。表示修改失败。 //如果修改失败，那么继续自旋。 return v; } 1.2.9. 2.9 悲观锁和乐观锁 synchronized和CAS的区别 : 相同点：在多线程情况下，都可以保证共享数据的安全性。 不同点：synchronized总是从最坏的角度出发，认为每次获取数据的时候，别人都有可能修改。所以在每 次操作共享数据之前，都会上锁。（悲观锁） ​ cas是从乐观的角度出发，假设每次获取数据别人都不会修改，所以不会上锁。只不过在修改共享数据的时候，会检查一下，别人有没有修改过这个数据。 ​ 如果别人修改过，那么我再次获取现在最新的值。 ​ 如果别人没有修改过，那么我现在直接修改共享数据的值.(乐观锁） 1.3. 3. 并发工具类 1.3.1. 3.1 并发工具类-Hashtable ​ Hashtable出现的原因 : 在集合类中HashMap是比较常用的集合对象，但是HashMap是线程不安全的(多线程环境下可能会存在问题)。为了保证数据的安全性我们可以使用Hashtable，但是Hashtable的效率低下。 代码实现 : package com.itheima.mymap; import java.util.HashMap; import java.util.Hashtable; public class MyHashtableDemo { public static void main(String[] args) throws InterruptedException { Hashtable hm = new Hashtable<>(); Thread t1 = new Thread(() -> { for (int i = 0; i { for (int i = 25; i 1.3.2. 3.2 并发工具类-ConcurrentHashMap基本使用 ​ ConcurrentHashMap出现的原因 : 在集合类中HashMap是比较常用的集合对象，但是HashMap是线程不安全的(多线程环境下可能会存在问题)。为了保证数据的安全性我们可以使用Hashtable，但是Hashtable的效率低下。 基于以上两个原因我们可以使用JDK1.5以后所提供的ConcurrentHashMap。 体系结构 : 总结 : ​ 1 ，HashMap是线程不安全的。多线程环境下会有数据安全问题 ​ 2 ，Hashtable是线程安全的，但是会将整张表锁起来，效率低下 ​ 3，ConcurrentHashMap也是线程安全的，效率较高。 在JDK7和JDK8中，底层原理不一样。 代码实现 : package com.itheima.mymap; import java.util.Hashtable; import java.util.concurrent.ConcurrentHashMap; public class MyConcurrentHashMapDemo { public static void main(String[] args) throws InterruptedException { ConcurrentHashMap hm = new ConcurrentHashMap<>(100); Thread t1 = new Thread(() -> { for (int i = 0; i { for (int i = 25; i 1.3.3. 3.3 并发工具类-ConcurrentHashMap1.7原理 1.3.4. 3.4 并发工具类-ConcurrentHashMap1.8原理 总结 : ​ 1，如果使用空参构造创建ConcurrentHashMap对象，则什么事情都不做。 在第一次添加元素的时候创建哈希表 ​ 2，计算当前元素应存入的索引。 ​ 3，如果该索引位置为null，则利用cas算法，将本结点添加到数组中。 ​ 4，如果该索引位置不为null，则利用volatile关键字获得当前位置最新的结点地址，挂在他下面，变成链表。 ​ 5，当链表的长度大于等于8时，自动转换成红黑树6，以链表或者红黑树头结点为锁对象，配合悲观锁保证多线程操作集合时数据的安全性 1.3.5. 3.5 并发工具类-CountDownLatch CountDownLatch类 : 方法 解释 public CountDownLatch(int count) 参数传递线程数，表示等待线程数量 public void await() 让线程等待 public void countDown() 当前线程执行完毕 使用场景： 让某一条线程等待其他线程执行完毕之后再执行 代码实现 : package com.itheima.mycountdownlatch; import java.util.concurrent.CountDownLatch; public class ChileThread1 extends Thread { private CountDownLatch countDownLatch; public ChileThread1(CountDownLatch countDownLatch) { this.countDownLatch = countDownLatch; } @Override public void run() { //1.吃饺子 for (int i = 1; i package com.itheima.mycountdownlatch; import java.util.concurrent.CountDownLatch; public class ChileThread2 extends Thread { private CountDownLatch countDownLatch; public ChileThread2(CountDownLatch countDownLatch) { this.countDownLatch = countDownLatch; } @Override public void run() { //1.吃饺子 for (int i = 1; i package com.itheima.mycountdownlatch; import java.util.concurrent.CountDownLatch; public class ChileThread3 extends Thread { private CountDownLatch countDownLatch; public ChileThread3(CountDownLatch countDownLatch) { this.countDownLatch = countDownLatch; } @Override public void run() { //1.吃饺子 for (int i = 1; i package com.itheima.mycountdownlatch; import java.util.concurrent.CountDownLatch; public class MotherThread extends Thread { private CountDownLatch countDownLatch; public MotherThread(CountDownLatch countDownLatch) { this.countDownLatch = countDownLatch; } @Override public void run() { //1.等待 try { //当计数器变成0的时候，会自动唤醒这里等待的线程。 countDownLatch.await(); } catch (InterruptedException e) { e.printStackTrace(); } //2.收拾碗筷 System.out.println(\"妈妈在收拾碗筷\"); } } package com.itheima.mycountdownlatch; import java.util.concurrent.CountDownLatch; public class MyCountDownLatchDemo { public static void main(String[] args) { //1.创建CountDownLatch的对象，需要传递给四个线程。 //在底层就定义了一个计数器，此时计数器的值就是3 CountDownLatch countDownLatch = new CountDownLatch(3); //2.创建四个线程对象并开启他们。 MotherThread motherThread = new MotherThread(countDownLatch); motherThread.start(); ChileThread1 t1 = new ChileThread1(countDownLatch); t1.setName(\"小明\"); ChileThread2 t2 = new ChileThread2(countDownLatch); t2.setName(\"小红\"); ChileThread3 t3 = new ChileThread3(countDownLatch); t3.setName(\"小刚\"); t1.start(); t2.start(); t3.start(); } } 总结 : ​ 1. CountDownLatch(int count)：参数写等待线程的数量。并定义了一个计数器。 ​ 2. await()：让线程等待，当计数器为0时，会唤醒等待的线程 ​ 3. countDown()： 线程执行完毕时调用，会将计数器-1。 1.3.6. 3.6 并发工具类-Semaphore 使用场景 : ​ 可以控制访问特定资源的线程数量。 实现步骤 : ​ 1，需要有人管理这个通道 ​ 2，当有车进来了，发通行许可证 ​ 3，当车出去了，收回通行许可证 ​ 4，如果通行许可证发完了，那么其他车辆只能等着 代码实现 : package com.itheima.mysemaphore; import java.util.concurrent.Semaphore; public class MyRunnable implements Runnable { //1.获得管理员对象， private Semaphore semaphore = new Semaphore(2); @Override public void run() { //2.获得通行证 try { semaphore.acquire(); //3.开始行驶 System.out.println(\"获得了通行证开始行驶\"); Thread.sleep(2000); System.out.println(\"归还通行证\"); //4.归还通行证 semaphore.release(); } catch (InterruptedException e) { e.printStackTrace(); } } } package com.itheima.mysemaphore; public class MySemaphoreDemo { public static void main(String[] args) { MyRunnable mr = new MyRunnable(); for (int i = 0; i Copyright © MISIN 2022 | 豫ICP备2021006345号-1 all right reserved，powered by Gitbook该文件修订时间： 2022-11-10 13:16:07 "},"1.JAVA基础/day23-网络编程01.html":{"url":"1.JAVA基础/day23-网络编程01.html","title":"day23-网络编程01","keywords":"","body":"1.1. 1.网络编程入门1.1.1. 1.1 网络编程概述【理解】1.1.2. 1.2 网络编程三要素【理解】1.1.3. 1.3 IP地址【理解】1.1.4. 1.4 InetAddress【应用】1.1.5. 1.5 端口和协议【理解】1.2. 2.UDP通信程序1.2.1. 2.1 UDP发送数据【应用】1.2.2. 2.2UDP接收数据【应用】1.2.3. 2.3UDP通信程序练习【应用】1.2.4. 2.4UDP三种通讯方式【理解】1.2.5. 2.5UDP组播实现【理解】1.2.6. 2.6UDP广播实现【理解】1.3. 3.TCP通信程序1.3.1. 3.1TCP发送数据【应用】1.3.2. 3.2TCP接收数据【应用】1.3.3. 3.3TCP程序练习【应用】1.3.4. 3.4TCP程序文件上传练习【应用】1.3.5. 3.5TCP程序服务器优化【应用】1.4. 4.NIO1.4.1. 4.1概述【理解】1.4.2. 4.2NIO与BIO的区别【理解】1.4.3. 4.3NIO三大模块【理解】1.4.4. 4.4NIO创建缓冲区对象【应用】1.4.5. 4.5NIO缓冲区添加数据【应用】1.4.6. 4.6NIO缓冲区获取数据【应用】1.4.7. 4.7小结【理解】1.1. 1.网络编程入门 1.1.1. 1.1 网络编程概述【理解】 计算机网络 是指将地理位置不同的具有独立功能的多台计算机及其外部设备，通过通信线路连接起来，在网络操作系统，网络管理软件及网络通信协议的管理和协调下，实现资源共享和信息传递的计算机系统 网络编程 在网络通信协议下，不同计算机上运行的程序，可以进行数据传输 1.1.2. 1.2 网络编程三要素【理解】 IP地址 要想让网络中的计算机能够互相通信，必须为每台计算机指定一个标识号，通过这个标识号来指定要接收数据的计算机和识别发送的计算机，而IP地址就是这个标识号。也就是设备的标识 端口 网络的通信，本质上是两个应用程序的通信。每台计算机都有很多的应用程序，那么在网络通信时，如何区分这些应用程序呢？如果说IP地址可以唯一标识网络中的设备，那么端口号就可以唯一标识设备中的应用程序了。也就是应用程序的标识 协议 通过计算机网络可以使多台计算机实现连接，位于同一个网络中的计算机在进行连接和通信时需要遵守一定的规则，这就好比在道路中行驶的汽车一定要遵守交通规则一样。在计算机网络中，这些连接和通信的规则被称为网络通信协议，它对数据的传输格式、传输速率、传输步骤等做了统一规定，通信双方必须同时遵守才能完成数据交换。常见的协议有UDP协议和TCP协议 1.1.3. 1.3 IP地址【理解】 IP地址：是网络中设备的唯一标识 IP地址分为两大类 IPv4：是给每个连接在网络上的主机分配一个32bit地址。按照TCP/IP规定，IP地址用二进制来表示，每个IP地址长32bit，也就是4个字节。例如一个采用二进制形式的IP地址是“11000000 10101000 00000001 01000010”，这么长的地址，处理起来也太费劲了。为了方便使用，IP地址经常被写成十进制的形式，中间使用符号“.”分隔不同的字节。于是，上面的IP地址可以表示为“192.168.1.66”。IP地址的这种表示法叫做“点分十进制表示法”，这显然比1和0容易记忆得多 IPv6：由于互联网的蓬勃发展，IP地址的需求量愈来愈大，但是网络地址资源有限，使得IP的分配越发紧张。为了扩大地址空间，通过IPv6重新定义地址空间，采用128位地址长度，每16个字节一组，分成8组十六进制数，这样就解决了网络地址资源数量不够的问题 DOS常用命令： ipconfig：查看本机IP地址 ping IP地址：检查网络是否连通 特殊IP地址： 127.0.0.1：是回送地址，可以代表本机地址，一般用来测试使用 1.1.4. 1.4 InetAddress【应用】 InetAddress：此类表示Internet协议（IP）地址 相关方法 | 方法名 | 说明 | | -————————————— | ——————————— | | static InetAddress getByName(String host) | 确定主机名称的IP地址。主机名称可以是机器名称，也可以是IP地址 | | String getHostName() | 获取此IP地址的主机名 | | String getHostAddress() | 返回文本显示中的IP地址字符串 | 代码演示 public class InetAddressDemo { public static void main(String[] args) throws UnknownHostException { //InetAddress address = InetAddress.getByName(“itheima”); InetAddress address = InetAddress.getByName(“192.168.1.66”); //public String getHostName()：获取此IP地址的主机名 String name = address.getHostName(); //public String getHostAddress()：返回文本显示中的IP地址字符串 String ip = address.getHostAddress(); System.out.println(“主机名：” + name); System.out.println(“IP地址：” + ip); } } 1.1.5. 1.5 端口和协议【理解】 端口 设备上应用程序的唯一标识 端口号 用两个字节表示的整数，它的取值范围是0~65535。其中，0~1023之间的端口号用于一些知名的网络服务和应用，普通的应用程序需要使用1024以上的端口号。如果端口号被另外一个服务或应用所占用，会导致当前程序启动失败 协议 计算机网络中，连接和通信的规则被称为网络通信协议 UDP协议 用户数据报协议(User Datagram Protocol) UDP是无连接通信协议，即在数据传输时，数据的发送端和接收端不建立逻辑连接。简单来说，当一台计算机向另外一台计算机发送数据时，发送端不会确认接收端是否存在，就会发出数据，同样接收端在收到数据时，也不会向发送端反馈是否收到数据。 由于使用UDP协议消耗系统资源小，通信效率高，所以通常都会用于音频、视频和普通数据的传输 例如视频会议通常采用UDP协议，因为这种情况即使偶尔丢失一两个数据包，也不会对接收结果产生太大影响。但是在使用UDP协议传送数据时，由于UDP的面向无连接性，不能保证数据的完整性，因此在传输重要数据时不建议使用UDP协议 TCP协议 传输控制协议 (Transmission Control Protocol) TCP协议是面向连接的通信协议，即传输数据之前，在发送端和接收端建立逻辑连接，然后再传输数据，它提供了两台计算机之间可靠无差错的数据传输。在TCP连接中必须要明确客户端与服务器端，由客户端向服务端发出连接请求，每次连接的创建都需要经过“三次握手” 三次握手：TCP协议中，在发送数据的准备阶段，客户端与服务器之间的三次交互，以保证连接的可靠 第一次握手，客户端向服务器端发出连接请求，等待服务器确认 第二次握手，服务器端向客户端回送一个响应，通知客户端收到了连接请求 第三次握手，客户端再次向服务器端发送确认信息，确认连接 完成三次握手，连接建立后，客户端和服务器就可以开始进行数据传输了。由于这种面向连接的特性，TCP协议可以保证传输数据的安全，所以应用十分广泛。例如上传文件、下载文件、浏览网页等 1.2. 2.UDP通信程序 1.2.1. 2.1 UDP发送数据【应用】 Java中的UDP通信 UDP协议是一种不可靠的网络协议，它在通信的两端各建立一个Socket对象，但是这两个Socket只是发送，接收数据的对象，因此对于基于UDP协议的通信双方而言，没有所谓的客户端和服务器的概念 Java提供了DatagramSocket类作为基于UDP协议的Socket 构造方法 | 方法名 | 说明 | | -————————————— | -————————— | | DatagramSocket() | 创建数据报套接字并将其绑定到本机地址上的任何可用端口 | | DatagramPacket(byte[] buf,int len,InetAddress add,int port) | 创建数据包,发送长度为len的数据包到指定主机的指定端口 | 相关方法 | 方法名 | 说明 | | —————————— | ———— | | void send(DatagramPacket p) | 发送数据报包 | | void close() | 关闭数据报套接字 | | void receive(DatagramPacket p) | 从此套接字接受数据报包 | 发送数据的步骤 创建发送端的Socket对象(DatagramSocket) 创建数据，并把数据打包 调用DatagramSocket对象的方法发送数据 关闭发送端 代码演示 public class SendDemo { public static void main(String[] args) throws IOException { //创建发送端的Socket对象(DatagramSocket) // DatagramSocket() 构造数据报套接字并将其绑定到本地主机上的任何可用端口 DatagramSocket ds = new DatagramSocket(); //创建数据，并把数据打包 //DatagramPacket(byte[] buf, int length, InetAddress address, int port) //构造一个数据包，发送长度为 length的数据包到指定主机上的指定端口号。 byte[] bys = “hello,udp,我来了”.getBytes(); DatagramPacket dp = new DatagramPacket(bys,bys.length,InetAddress.getByName(“127.0.0.1”),10086); //调用DatagramSocket对象的方法发送数据 //void send(DatagramPacket p) 从此套接字发送数据报包 ds.send(dp); //关闭发送端 //void close() 关闭此数据报套接字 ds.close(); } } 1.2.2. 2.2UDP接收数据【应用】 接收数据的步骤 创建接收端的Socket对象(DatagramSocket) 创建一个数据包，用于接收数据 调用DatagramSocket对象的方法接收数据 解析数据包，并把数据在控制台显示 关闭接收端 构造方法 | 方法名 | 说明 | | ———————————— | ——————————— | | DatagramPacket(byte[] buf, int len) | 创建一个DatagramPacket用于接收长度为len的数据包 | 相关方法 | 方法名 | 说明 | | —————— | ——————— | | byte[] getData() | 返回数据缓冲区 | | int getLength() | 返回要发送的数据的长度或接收的数据的长度 | 示例代码 public class ReceiveDemo { public static void main(String[] args) throws IOException { //创建接收端的Socket对象(DatagramSocket) DatagramSocket ds = new DatagramSocket(12345); //创建一个数据包，用于接收数据 byte[] bys = new byte[1024]; DatagramPacket dp = new DatagramPacket(bys, bys.length); //调用DatagramSocket对象的方法接收数据 ds.receive(dp); //解析数据包，并把数据在控制台显示 System.out.println(“数据是：” + new String(dp.getData(), 0, dp.getLength())); } } } 1.2.3. 2.3UDP通信程序练习【应用】 案例需求 UDP发送数据：数据来自于键盘录入，直到输入的数据是886，发送数据结束 UDP接收数据：因为接收端不知道发送端什么时候停止发送，故采用死循环接收 代码实现 /* UDP发送数据： 数据来自于键盘录入，直到输入的数据是886，发送数据结束 */ public class SendDemo { public static void main(String[] args) throws IOException { //创建发送端的Socket对象(DatagramSocket) DatagramSocket ds = new DatagramSocket(); //键盘录入数据 Scanner sc = new Scanner(System.in); while (true) { String s = sc.nextLine(); //输入的数据是886，发送数据结束 if (“886”.equals(s)) { break; } //创建数据，并把数据打包 byte[] bys = s.getBytes(); DatagramPacket dp = new DatagramPacket(bys, bys.length, InetAddress.getByName(“192.168.1.66”), 12345); //调用DatagramSocket对象的方法发送数据 ds.send(dp); } //关闭发送端 ds.close(); } } /* UDP接收数据： 因为接收端不知道发送端什么时候停止发送，故采用死循环接收 */ public class ReceiveDemo { public static void main(String[] args) throws IOException { //创建接收端的Socket对象(DatagramSocket) DatagramSocket ds = new DatagramSocket(12345); while (true) { //创建一个数据包，用于接收数据 byte[] bys = new byte[1024]; DatagramPacket dp = new DatagramPacket(bys, bys.length); //调用DatagramSocket对象的方法接收数据 ds.receive(dp); //解析数据包，并把数据在控制台显示 System.out.println(“数据是：” + new String(dp.getData(), 0, dp.getLength())); } //关闭接收端 // ds.close(); } } 1.2.4. 2.4UDP三种通讯方式【理解】 单播 单播用于两个主机之间的端对端通信 组播 组播用于对一组特定的主机进行通信 广播 广播用于一个主机对整个局域网上所有主机上的数据通信 1.2.5. 2.5UDP组播实现【理解】 实现步骤 发送端 创建发送端的Socket对象(DatagramSocket) 创建数据，并把数据打包(DatagramPacket) 调用DatagramSocket对象的方法发送数据(在单播中,这里是发给指定IP的电脑但是在组播当中,这里是发给组播地址) 释放资源 接收端 创建接收端Socket对象(MulticastSocket) 创建一个箱子,用于接收数据 把当前计算机绑定一个组播地址 将数据接收到箱子中 解析数据包,并打印数据 释放资源 代码实现 // 发送端 public class ClinetDemo { public static void main(String[] args) throws IOException { // 1. 创建发送端的Socket对象(DatagramSocket) DatagramSocket ds = new DatagramSocket(); String s = “hello 组播”; byte[] bytes = s.getBytes(); InetAddress address = InetAddress.getByName(“224.0.1.0”); int port = 10000; // 2. 创建数据，并把数据打包(DatagramPacket) DatagramPacket dp = new DatagramPacket(bytes,bytes.length,address,port); // 3. 调用DatagramSocket对象的方法发送数据(在单播中,这里是发给指定IP的电脑但是在组播当中,这里是发给组播地址) ds.send(dp); // 4. 释放资源 ds.close(); } } // 接收端 public class ServerDemo { public static void main(String[] args) throws IOException { // 1. 创建接收端Socket对象(MulticastSocket) MulticastSocket ms = new MulticastSocket(10000); // 2. 创建一个箱子,用于接收数据 DatagramPacket dp = new DatagramPacket(new byte[1024],1024); // 3. 把当前计算机绑定一个组播地址,表示添加到这一组中. ms.joinGroup(InetAddress.getByName(“224.0.1.0”)); // 4. 将数据接收到箱子中 ms.receive(dp); // 5. 解析数据包,并打印数据 byte[] data = dp.getData(); int length = dp.getLength(); System.out.println(new String(data,0,length)); // 6. 释放资源 ms.close(); } } 1.2.6. 2.6UDP广播实现【理解】 实现步骤 发送端 创建发送端Socket对象(DatagramSocket) 创建存储数据的箱子,将广播地址封装进去 发送数据 释放资源 接收端 创建接收端的Socket对象(DatagramSocket) 创建一个数据包，用于接收数据 调用DatagramSocket对象的方法接收数据 解析数据包，并把数据在控制台显示 关闭接收端 代码实现 // 发送端 public class ClientDemo { public static void main(String[] args) throws IOException { // 1. 创建发送端Socket对象(DatagramSocket) DatagramSocket ds = new DatagramSocket(); // 2. 创建存储数据的箱子,将广播地址封装进去 String s = “广播 hello”; byte[] bytes = s.getBytes(); InetAddress address = InetAddress.getByName(“255.255.255.255”); int port = 10000; DatagramPacket dp = new DatagramPacket(bytes,bytes.length,address,port); // 3. 发送数据 ds.send(dp); // 4. 释放资源 ds.close(); } } // 接收端 public class ServerDemo { public static void main(String[] args) throws IOException { // 1. 创建接收端的Socket对象(DatagramSocket) DatagramSocket ds = new DatagramSocket(10000); // 2. 创建一个数据包，用于接收数据 DatagramPacket dp = new DatagramPacket(new byte[1024],1024); // 3. 调用DatagramSocket对象的方法接收数据 ds.receive(dp); // 4. 解析数据包，并把数据在控制台显示 byte[] data = dp.getData(); int length = dp.getLength(); System.out.println(new String(data,0,length)); // 5. 关闭接收端 ds.close(); } } 1.3. 3.TCP通信程序 1.3.1. 3.1TCP发送数据【应用】 Java中的TCP通信 Java对基于TCP协议的的网络提供了良好的封装，使用Socket对象来代表两端的通信端口，并通过Socket产生IO流来进行网络通信。 Java为客户端提供了Socket类，为服务器端提供了ServerSocket类 构造方法 | 方法名 | 说明 | | ———————————— | ———————— | | Socket(InetAddress address,int port) | 创建流套接字并将其连接到指定IP指定端口号 | | Socket(String host, int port) | 创建流套接字并将其连接到指定主机上的指定端口号 | 相关方法 | 方法名 | 说明 | | —————————— | -——— | | InputStream getInputStream() | 返回此套接字的输入流 | | OutputStream getOutputStream() | 返回此套接字的输出流 | 示例代码 public class ClientDemo { public static void main(String[] args) throws IOException { //创建客户端的Socket对象(Socket) //Socket(String host, int port) 创建流套接字并将其连接到指定主机上的指定端口号 Socket s = new Socket(“127.0.0.1”,10000); //获取输出流，写数据 //OutputStream getOutputStream() 返回此套接字的输出流 OutputStream os = s.getOutputStream(); os.write(“hello,tcp,我来了”.getBytes()); //释放资源 s.close(); } } 1.3.2. 3.2TCP接收数据【应用】 构造方法 | 方法名 | 说明 | | ———————— | -————— | | ServletSocket(int port) | 创建绑定到指定端口的服务器套接字 | 相关方法 | 方法名 | 说明 | | ————— | ————— | | Socket accept() | 监听要连接到此的套接字并接受它 | 注意事项 accept方法是阻塞的,作用就是等待客户端连接 客户端创建对象并连接服务器,此时是通过三次握手协议,保证跟服务器之间的连接 针对客户端来讲,是往外写的,所以是输出流 针对服务器来讲,是往里读的,所以是输入流 read方法也是阻塞的 客户端在关流的时候,还多了一个往服务器写结束标记的动作 最后一步断开连接,通过四次挥手协议保证连接终止 三次握手和四次挥手 三次握手 四次挥手 示例代码 public class ServerDemo { public static void main(String[] args) throws IOException { //创建服务器端的Socket对象(ServerSocket) //ServerSocket(int port) 创建绑定到指定端口的服务器套接字 ServerSocket ss = new ServerSocket(10000); //Socket accept() 侦听要连接到此套接字并接受它 Socket s = ss.accept(); //获取输入流，读数据，并把数据显示在控制台 InputStream is = s.getInputStream(); byte[] bys = new byte[1024]; int len = is.read(bys); String data = new String(bys,0,len); System.out.println(“数据是：” + data); //释放资源 s.close(); ss.close(); } } 1.3.3. 3.3TCP程序练习【应用】 案例需求 客户端：发送数据，接受服务器反馈 服务器：收到消息后给出反馈 案例分析 客户端创建对象，使用输出流输出数据 服务端创建对象，使用输入流接受数据 服务端使用输出流给出反馈数据 客户端使用输入流接受反馈数据 代码实现 // 客户端 public class ClientDemo { public static void main(String[] args) throws IOException { Socket socket = new Socket(“127.0.0.1”,10000); OutputStream os = socket.getOutputStream(); os.write(“hello”.getBytes()); // os.close();如果在这里关流,会导致整个socket都无法使用 socket.shutdownOutput();//仅仅关闭输出流.并写一个结束标记,对socket没有任何影响 BufferedReader br = new BufferedReader(new InputStreamReader(socket.getInputStream())); String line; while((line = br.readLine())!=null){ System.out.println(line); } br.close(); os.close(); socket.close(); } } // 服务器 public class ServerDemo { public static void main(String[] args) throws IOException { ServerSocket ss = new ServerSocket(10000); Socket accept = ss.accept(); InputStream is = accept.getInputStream(); int b; while((b = is.read())!=-1){ System.out.println((char) b); } System.out.println(“看看我执行了吗?”); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(accept.getOutputStream())); bw.write(“你谁啊?”); bw.newLine(); bw.flush(); bw.close(); is.close(); accept.close(); ss.close(); } } 1.3.4. 3.4TCP程序文件上传练习【应用】 案例需求 客户端：数据来自于本地文件，接收服务器反馈 服务器：接收到的数据写入本地文件，给出反馈 案例分析 创建客户端对象，创建输入流对象指向文件，每读一次数据就给服务器输出一次数据，输出结束后使用shutdownOutput()方法告知服务端传输结束 创建服务器对象，创建输出流对象指向文件，每接受一次数据就使用输出流输出到文件中，传输结束后。使用输出流给客户端反馈信息 客户端接受服务端的回馈信息 相关方法 | 方法名 | 说明 | | ——————— | —————— | | void shutdownInput() | 将此套接字的输入流放置在“流的末尾” | | void shutdownOutput() | 禁止用此套接字的输出流 | 代码实现 // 客户端 public class ClientDemo { public static void main(String[] args) throws IOException { Socket socket = new Socket(“127.0.0.1”,10000); //是本地的流,用来读取本地文件的. BufferedInputStream bis = new BufferedInputStream(new FileInputStream(“socketmodule\\\\ClientDir\\\\1.jpg”)); //写到服务器 — 网络中的流 OutputStream os = socket.getOutputStream(); BufferedOutputStream bos = new BufferedOutputStream(os); int b; while((b = bis.read())!=-1){ bos.write(b);//通过网络写到服务器中 } bos.flush(); //给服务器一个结束标记,告诉服务器文件已经传输完毕 socket.shutdownOutput(); BufferedReader br = new BufferedReader(new InputStreamReader(socket.getInputStream())); String line; while((line = br.readLine()) !=null){ System.out.println(line); } bis.close(); socket.close(); } } // 服务器 public class ServerDemo { public static void main(String[] args) throws IOException { ServerSocket ss = new ServerSocket(10000); Socket accept = ss.accept(); //网络中的流,从客户端读取数据的 BufferedInputStream bis = new BufferedInputStream(accept.getInputStream()); //本地的IO流,把数据写到本地中,实现永久化存储 BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(“socketmodule\\\\ServerDir\\\\copy.jpg”)); int b; while((b = bis.read()) !=-1){ bos.write(b); } BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(accept.getOutputStream())); bw.write(“上传成功”); bw.newLine(); bw.flush(); bos.close(); accept.close(); ss.close(); } } 1.3.5. 3.5TCP程序服务器优化【应用】 优化方案一 需求 服务器只能处理一个客户端请求，接收完一个图片之后，服务器就关闭了。 解决方案 使用循环 代码实现 // 服务器代码如下,客户端代码同上个案例,此处不再给出 public class ServerDemo { public static void main(String[] args) throws IOException { ServerSocket ss = new ServerSocket(10000); while (true) { Socket accept = ss.accept(); //网络中的流,从客户端读取数据的 BufferedInputStream bis = new BufferedInputStream(accept.getInputStream()); //本地的IO流,把数据写到本地中,实现永久化存储 BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(“optimizeserver\\\\ServerDir\\\\copy.jpg”)); int b; while((b = bis.read()) !=-1){ bos.write(b); } BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(accept.getOutputStream())); bw.write(“上传成功”); bw.newLine(); bw.flush(); bos.close(); accept.close(); } //ss.close(); } } 优化方案二 需求 第二次上传文件的时候，会把第一次的文件给覆盖。 解决方案 UUID. randomUUID()方法生成随机的文件名 代码实现 // 服务器代码如下,客户端代码同上个案例,此处不再给出 public class ServerDemo { public static void main(String[] args) throws IOException { ServerSocket ss = new ServerSocket(10000); while (true) { Socket accept = ss.accept(); //网络中的流,从客户端读取数据的 BufferedInputStream bis = new BufferedInputStream(accept.getInputStream()); //本地的IO流,把数据写到本地中,实现永久化存储 BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(“optimizeserver\\\\ServerDir\\\\” + UUID.randomUUID().toString() + “.jpg”)); int b; while((b = bis.read()) !=-1){ bos.write(b); } BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(accept.getOutputStream())); bw.write(“上传成功”); bw.newLine(); bw.flush(); bos.close(); accept.close(); } //ss.close(); } } 优化方案三 需求 使用循环虽然可以让服务器处理多个客户端请求。但是还是无法同时跟多个客户端进行通信。 解决方案 开启多线程处理 代码实现 // 线程任务类 public class ThreadSocket implements Runnable { private Socket acceptSocket; public ThreadSocket(Socket accept) { this.acceptSocket = accept; } @Override public void run() { BufferedOutputStream bos = null; try { //网络中的流,从客户端读取数据的 BufferedInputStream bis = new BufferedInputStream(acceptSocket.getInputStream()); //本地的IO流,把数据写到本地中,实现永久化存储 bos = new BufferedOutputStream(new FileOutputStream(“optimizeserver\\\\ServerDir\\\\” + UUID.randomUUID().toString() + “.jpg”)); int b; while((b = bis.read()) !=-1){ bos.write(b); } BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(acceptSocket.getOutputStream())); bw.write(“上传成功”); bw.newLine(); bw.flush(); } catch (IOException e) { e.printStackTrace(); } finally { if(bos != null){ try { bos.close(); } catch (IOException e) { e.printStackTrace(); } } if (acceptSocket != null){ try { acceptSocket.close(); } catch (IOException e) { e.printStackTrace(); } } } } } // 服务器代码 public class ServerDemo { public static void main(String[] args) throws IOException { ServerSocket ss = new ServerSocket(10000); while (true) { Socket accept = ss.accept(); ThreadSocket ts = new ThreadSocket(accept); new Thread(ts).start(); } //ss.close(); } } 优化方案四 需求 使用多线程虽然可以让服务器同时处理多个客户端请求。但是资源消耗太大。 解决方案 加入线程池 代码实现 // 服务器代码如下,线程任务类代码同上,此处不再给出 public class ServerDemo { public static void main(String[] args) throws IOException { ServerSocket ss = new ServerSocket(10000); ThreadPoolExecutor pool = new ThreadPoolExecutor( 3,//核心线程数量 10, //线程池的总数量 60, //临时线程空闲时间 TimeUnit.SECONDS, //临时线程空闲时间的单位 new ArrayBlockingQueue<>(5),//阻塞队列 Executors.defaultThreadFactory(),//创建线程的方式 new ThreadPoolExecutor.AbortPolicy()//任务拒绝策略 ); while (true) { Socket accept = ss.accept(); ThreadSocket ts = new ThreadSocket(accept); //new Thread(ts).start(); pool.submit(ts); } //ss.close(); } } 1.4. 4.NIO 1.4.1. 4.1概述【理解】 BIO Blocking IO,阻塞型IO NIO No Blocking IO,非阻塞型IO 阻塞IO的弊端 在等待的过程中,什么事也做不了 非阻塞IO的好处 不需要一直等待,当一切就绪了再去做 1.4.2. 4.2NIO与BIO的区别【理解】 区别一 BIO是阻塞的，NIO是非阻塞的 区别二 BIO是面向流的，NIO是面向缓冲区的 BIO中数据传输是单向的，NIO中的缓冲区是双向的 1.4.3. 4.3NIO三大模块【理解】 缓冲区 用来存储数据 通道 用来建立连接和传输数据 选择器 监视通道状态 1.4.4. 4.4NIO创建缓冲区对象【应用】 方法介绍 | 方法名 | 说明 | | ————————————— | —————— | | static ByteBuffer allocate(长度) | 创建byte类型的缓冲区 | | static ByteBuffer wrap(byte[] array) | 创建一个有内容的byte类型缓冲区 | 代码示例 public class CreateByteBufferDemo1 { public static void main(String[] args) { //method1(); //method2(); ByteBuffer wrap = ByteBuffer.wrap(“aaa”.getBytes()); for (int i = 0; i 1.4.5. 4.5NIO缓冲区添加数据【应用】 方法介绍 代码示例 public class ByteBufferDemo2 { public static void main(String[] args) { // int position() 当前要操作的索引 // int limit() 最多能操作到哪个索引 // int capacity() 缓冲区的总长度 ByteBuffer byteBuffer = ByteBuffer.allocate(10); System.out.println(byteBuffer.position());//0 System.out.println(byteBuffer.limit());//10 System.out.println(byteBuffer.capacity());//10 // put(byte b) 一次添加一个字节 // byteBuffer.put((byte) 97); // System.out.println(byteBuffer.position()); // System.out.println(byteBuffer.limit()); // System.out.println(byteBuffer.capacity()); // put(byte[] src) 一次添加一个字节数组 // byteBuffer.put(\"aaa\".getBytes()); // System.out.println(byteBuffer.position());//3 // System.out.println(byteBuffer.limit());//10 // System.out.println(byteBuffer.capacity());//10 // position(int newPosition) 修改position // byteBuffer.position(1); // limit(int newLimit) 修改limit // byteBuffer.limit(5); // System.out.println(byteBuffer.position()); // System.out.println(byteBuffer.limit()); // System.out.println(byteBuffer.capacity()); // int remaining() 还有多少能操作 // boolean hasRemaining() 是否还有能操作的 byteBuffer.put(\"0123456789\".getBytes()); System.out.println(byteBuffer.remaining()); System.out.println(byteBuffer.hasRemaining()); } } 1.4.6. 4.6NIO缓冲区获取数据【应用】 方法介绍 | 方法名 | 介绍 | | ---------------- | ------------------- | | flip() | 切换读写模式（写à读） | | get() | 读一个字节 | | get(byte[] dst) | 读多个字节 | | get(int index) | 读指定索引的字节 | | rewind() | 将position设置为0，可以重复读 | | clear() | 数据读写完毕（读->写） | | array() | 将缓冲区转换成字节数组返回 | 代码示例 public class ByteBufferDemo3 { public static void main(String[] args) { ByteBuffer byteBuffer = ByteBuffer.allocate(10); byteBuffer.put(\"abc\".getBytes()); // flip() 切换读写模式（写读） byteBuffer.flip(); // get() 读一个字节 // while(byteBuffer.limit() != byteBuffer.position()){ // System.out.println((char) byteBuffer.get()); // } for (int i = 0; i 写） byteBuffer.clear(); byteBuffer.put(\"qqq\".getBytes()); // array() 将缓冲区转换成字节数组返回 byte[] bytes = byteBuffer.array(); System.out.println(new String(bytes)); } } 1.4.7. 4.7小结【理解】 需求：我要把数据写到缓冲区中。 数据是从外面进入到缓冲区的，所以缓冲区在做读数据的操作。 需求：我要把数据从缓冲区中读出来。 数据是从缓冲区里面到外面的。所以缓冲区在做写数据的操作。 capacity：容量（长度） limit： 界限（最多能读/写到哪里） posotion：位置（读/写哪个索引） 获取缓冲区里面数据之前，需要调用flip方法 再次写数据之前，需要调用clear方法， 但是数据还未消失，等再次写入数据，被覆盖了才会消失。 Copyright © MISIN 2022 | 豫ICP备2021006345号-1 all right reserved，powered by Gitbook该文件修订时间： 2022-11-10 13:16:46 "},"1.JAVA基础/day24-网络编程02.html":{"url":"1.JAVA基础/day24-网络编程02.html","title":"day24-网络编程02","keywords":"","body":"1.1. 1.NIO1.1.1. 1.1 NIO通道客户端【应用】1.1.2. 1.2 NIO通道服务端【应用】1.1.3. 1.3 NIO通道练习【应用】1.1.4. 1.4 NIO通道练习优化【应用】1.1.5. 1.5NIO选择器【理解】1.1.6. 1.6NIO选择器改写服务端【应用】1.2. 2.HTTP协议1.2.1. 2.1概述【理解】1.2.2. 2.2URL【理解】1.2.3. 2.3抓包工具的使用【应用】1.2.4. 2.4请求信息【理解】1.2.5. 2.5响应信息【理解】1.3. 3.HTTP服务器1.3.1. 3.1需求【理解】1.3.2. 3.2环境搭建【理解】1.3.3. 3.3获取请求信息并解析【理解】1.3.4. 3.4给浏览器响应数据【理解】1.3.5. 3.5代码优化【理解】1.1. 1.NIO 1.1.1. 1.1 NIO通道客户端【应用】 客户端实现步骤 打开通道 指定IP和端口号 写出数据 释放资源 示例代码 public class NIOClient { public static void main(String[] args) throws IOException { //1.打开通道 SocketChannel socketChannel = SocketChannel.open(); //2.指定IP和端口号 socketChannel.connect(new InetSocketAddress(\"127.0.0.1\",10000)); //3.写出数据 ByteBuffer byteBuffer = ByteBuffer.wrap(\"一点寒毛先制\".getBytes()); socketChannel.write(byteBuffer); //4.释放资源 socketChannel.close(); } } 1.1.2. 1.2 NIO通道服务端【应用】 NIO通道 服务端通道 只负责建立建立，不负责传递数据 客户端通道 建立建立并将数据传递给服务端 缓冲区 客户端发送的数据都在缓冲区中 服务端通道内部创建出来的客户端通道 相当于客户端通道的延伸用来传递数据 服务端实现步骤 打开一个服务端通道 绑定对应的端口号 通道默认是阻塞的，需要设置为非阻塞 此时没有门卫大爷，所以需要经常看一下有没有连接发过来没？ 如果有客户端来连接了,则在服务端通道内部,再创建一个客户端通道,相当于是客户端通道的延伸 获取客户端传递过来的数据,并把数据放在byteBuffer1这个缓冲区中 给客户端回写数据 释放资源 示例代码 public class NIOServer { public static void main(String[] args) throws IOException { // 1.打开一个服务端通道 ServerSocketChannel serverSocketChannel = ServerSocketChannel.open(); // 2.绑定对应的端口号 serverSocketChannel.bind(new InetSocketAddress(10000)); // 3.通道默认是阻塞的，需要设置为非阻塞 //如果传递true 表示通道设置为阻塞通道...默认值 //如果传递false 表示通道设置为非阻塞通道 serverSocketChannel.configureBlocking(false); // 4.此时没有门卫大爷，所以需要经常看一下有没有连接发过来没？ while (true) { // 5.如果有客户端来连接了，则在服务端通道内部，再创建一个客户端通道，相当于是客户端通道的延伸 //此时已经设置了通道为非阻塞 //所以在调用方法的时候,如果有客户端来连接,那么会创建一个SocketChannel对象. //如果在调用方法的时候,没有客户端来连接,那么他会返回一个null SocketChannel socketChannel = serverSocketChannel.accept(); //System.out.println(socketChannel); if(socketChannel != null){ // 6.客户端将缓冲区通过通道传递给服务端,就到了这个延伸通道socketChannel里面 // 7.服务端创建一个空的缓冲区装数据并输出 ByteBuffer byteBuffer = ByteBuffer.allocate(1024); //获取传递过来的数据,并把他们放到byteBuffer缓冲区中. //返回值: //正数: 表示本次读到的有效字节个数. //0 : 表示本次没有读到有效字节. //-1 : 表示读到了末尾 int len = socketChannel.read(byteBuffer); System.out.println(new String(byteBuffer.array(),0,len)); //8.释放资源 socketChannel.close(); } } } } 1.1.3. 1.3 NIO通道练习【应用】 客户端 实现步骤 打开通道 指定IP和端口号 写出数据 读取服务器写回的数据 释放资源 示例代码 public class Clinet { public static void main(String[] args) throws IOException { // 1.打开通道 SocketChannel socketChannel = SocketChannel.open(); // 2.指定IP和端口号 socketChannel.connect(new InetSocketAddress(\"127.0.0.1\",10000)); // 3.写出数据 ByteBuffer byteBuffer1 = ByteBuffer.wrap(\"吃俺老孙一棒棒\".getBytes()); socketChannel.write(byteBuffer1); // 手动写入结束标记 socketChannel.shutdownOutput(); System.out.println(\"数据已经写给服务器\"); // 4.读取服务器写回的数据 ByteBuffer byteBuffer2 = ByteBuffer.allocate(1024); int len; while((len = socketChannel.read(byteBuffer2)) != -1){ byteBuffer2.flip(); System.out.println(new String(byteBuffer2.array(),0,len)); byteBuffer2.clear(); } // 5.释放资源 socketChannel.close(); } } 服务端 实现步骤 打开一个服务端通道 绑定对应的端口号 通道默认是阻塞的，需要设置为非阻塞 此时没有门卫大爷，所以需要经常看一下有没有连接发过来没？ 如果有客户端来连接了,则在服务端通道内部,再创建一个客户端通道,相当于是客户端通道的延伸 获取客户端传递过来的数据,并把数据放在byteBuffer1这个缓冲区中 给客户端回写数据 释放资源 示例代码 public class Sever { public static void main(String[] args) throws IOException { // 1，打开一个服务端通道 ServerSocketChannel serverSocketChannel = ServerSocketChannel.open(); // 2，绑定对应的端口号 serverSocketChannel.bind(new InetSocketAddress(10000)); // 3，通道默认是阻塞的，需要设置为非阻塞 serverSocketChannel.configureBlocking(false); // 4，此时没有门卫大爷，所以需要经常看一下有没有连接发过来没？ while(true){ // 5，如果有客户端来连接了，则在服务端通道内部，再创建一个客户端通道，相当于是客户端通道的延伸 SocketChannel socketChannel = serverSocketChannel.accept(); if(socketChannel != null){ System.out.println(\"此时有客户端来连接了\"); // 6,获取客户端传递过来的数据,并把数据放在byteBuffer1这个缓冲区中 ByteBuffer byteBuffer1 = ByteBuffer.allocate(1024); //socketChannel.read(byteBuffer1); int len; //针对于缓冲区来讲 //如果 从添加数据 ----> 获取数据 flip //如果 从获取数据 ----> 添加数据 clear while((len = socketChannel.read(byteBuffer1)) != -1){ byteBuffer1.flip(); System.out.println(new String(byteBuffer1.array(),0,len)); byteBuffer1.clear(); } System.out.println(\"接收数据完毕,准备开始往客户端回写数据\"); // 7,给客户端回写数据 ByteBuffer byteBuffer2 = ByteBuffer.wrap(\"哎哟,真疼啊!!!\".getBytes()); socketChannel.write(byteBuffer2); // 8,释放资源 socketChannel.close(); } } } } 1.1.4. 1.4 NIO通道练习优化【应用】 存在问题 服务端内部获取的客户端通道在读取时,如果读取不到结束标记就会一直阻塞 解决方案 将服务端内部获取的客户端通道设置为非阻塞的 示例代码 // 客户端 public class Clinet { public static void main(String[] args) throws IOException { SocketChannel socketChannel = SocketChannel.open(); socketChannel.connect(new InetSocketAddress(\"127.0.0.1\",10000)); ByteBuffer byteBuffer1 = ByteBuffer.wrap(\"吃俺老孙一棒棒\".getBytes()); socketChannel.write(byteBuffer1); System.out.println(\"数据已经写给服务器\"); ByteBuffer byteBuffer2 = ByteBuffer.allocate(1024); int len; while((len = socketChannel.read(byteBuffer2)) != -1){ System.out.println(\"客户端接收回写数据\"); byteBuffer2.flip(); System.out.println(new String(byteBuffer2.array(),0,len)); byteBuffer2.clear(); } socketChannel.close(); } } // 服务端 public class Sever { public static void main(String[] args) throws IOException { ServerSocketChannel serverSocketChannel = ServerSocketChannel.open(); serverSocketChannel.bind(new InetSocketAddress(10000)); serverSocketChannel.configureBlocking(false); while(true){ SocketChannel socketChannel = serverSocketChannel.accept(); if(socketChannel != null){ System.out.println(\"此时有客户端来连接了\"); // 将服务端内部获取的客户端通道设置为非阻塞的 socketChannel.configureBlocking(false); //获取客户端传递过来的数据,并把数据放在byteBuffer1这个缓冲区中 ByteBuffer byteBuffer1 = ByteBuffer.allocate(1024); //socketChannel.read(byteBuffer1); int len; //针对于缓冲区来讲 //如果 从添加数据 ----> 获取数据 flip //如果 从获取数据 ----> 添加数据 clear while((len = socketChannel.read(byteBuffer1)) > 0){ System.out.println(\"服务端接收发送数据\"); byteBuffer1.flip(); System.out.println(new String(byteBuffer1.array(),0,len)); byteBuffer1.clear(); } System.out.println(\"接收数据完毕,准备开始往客户端回写数据\"); ByteBuffer byteBuffer2 = ByteBuffer.wrap(\"哎哟,真疼啊!!!\".getBytes()); socketChannel.write(byteBuffer2); socketChannel.close(); } } } } 1.1.5. 1.5NIO选择器【理解】 概述 选择器可以监视通道的状态,多路复用 选择器对象 Selector 选择器对象 SelectionKey 绑定的key SelectableChannel 能使用选择器的通道 SocketChannel ServerSocketChannel 1.1.6. 1.6NIO选择器改写服务端【应用】 实现步骤 打开一个服务端通道(open) 绑定对应的端口号 通道默认是阻塞的，需要设置为非阻塞 打开一个选择器（门卫大爷） 将选择器绑定服务端通道，并监视服务端是否准备好 如果有客户端来连接了，大爷会遍历所有的服务端通道，谁准备好了，就让谁来连接 连接后，在服务端通道内部，再创建一个客户端延伸通道 如果客户端把数据传递过来了，大爷会遍历所有的延伸通道，谁准备好了，谁去接收数据 代码实现 // 客户端 public class Clinet { public static void main(String[] args) throws IOException { SocketChannel socketChannel = SocketChannel.open(); socketChannel.connect(new InetSocketAddress(“127.0.0.1”,10000)); ByteBuffer byteBuffer1 = ByteBuffer.wrap(“吃俺老孙一棒棒”.getBytes()); socketChannel.write(byteBuffer1); System.out.println(“数据已经写给服务器”); ByteBuffer byteBuffer2 = ByteBuffer.allocate(1024); int len; while((len = socketChannel.read(byteBuffer2)) != -1){ System.out.println(“客户端接收回写数据”); byteBuffer2.flip(); System.out.println(new String(byteBuffer2.array(),0,len)); byteBuffer2.clear(); } socketChannel.close(); } } // 服务端 public class Server { public static void main(String[] args) throws IOException { //1.打开服务端通道 ServerSocketChannel serverSocketChannel = ServerSocketChannel.open(); //2.让这个通道绑定一个端口 serverSocketChannel.bind(new InetSocketAddress(10000)); //3.设置通道为非阻塞 serverSocketChannel.configureBlocking(false); //4.打开一个选择器 //Selector — 选择器 // SelectionKey — 绑定通道后返回那个令牌 // SelectableChannel — 可以使用选择器的通道 Selector selector = Selector.open(); //5.绑定选择器和服务端通道 serverSocketChannel.register(selector,SelectionKey.OP_ACCEPT); while(true){ System.out.println(“11”); //选择器会监视客户端通道的状态. //6.返回值就表示此时有多少个客户端来连接. int count = selector.select(); System.out.println(“222”); if(count != 0){ System.out.println(“有客户端来连接了”); //7.会遍历所有的服务端通道.看谁准备好了,谁准备好了,就让谁去连接. //获取所有服务端通道的令牌,并将它们都放到一个集合中,将集合返回. Set selectionKeys = selector.selectedKeys(); Iterator iterator = selectionKeys.iterator(); while(iterator.hasNext()){ //selectionKey 依次表示每一个服务端通道的令牌 SelectionKey selectionKey = iterator.next(); if(selectionKey.isAcceptable()){ //可以通过令牌来获取到了一个已经就绪的服务端通道 ServerSocketChannel ssc = (ServerSocketChannel) selectionKey.channel(); //客户端的延伸通道 SocketChannel socketChannel = ssc.accept(); //将客户端延伸通道设置为非阻塞的 socketChannel.configureBlocking(false); socketChannel.register(selector,SelectionKey.OP_READ); //当客户端来连接的时候,所有的步骤已经全部执行完毕. }else if(selectionKey.isReadable()){ //当前通道已经做好了读取的准备(延伸通道) SocketChannel socketChannel = (SocketChannel) selectionKey.channel(); ByteBuffer byteBuffer1 = ByteBuffer.allocate(1024); //socketChannel.read(byteBuffer1); int len; while((len = socketChannel.read(byteBuffer1)) > 0){ byteBuffer1.flip(); System.out.println(new String(byteBuffer1.array(),0,len)); byteBuffer1.clear(); } //给客户端的回写数据 socketChannel.write(ByteBuffer.wrap(“哎哟喂好疼啊!!!”.getBytes())); socketChannel.close(); } iterator.remove(); } } } } } 1.2. 2.HTTP协议 1.2.1. 2.1概述【理解】 超文本传输协议(关于超文本的概念JavaWeb在进行学习)，是建立在TCP/IP协议基础上,是网络应用层的协议。 由请求和响应构成,是一个标准的客户端和服务器模型 1.2.2. 2.2URL【理解】 概述 统一资源定位符,常见的如http://bbs.itheima.com/forum.php 完整的格式为 http://bbs.itheima.com:80/forum.php 详解 1.2.3. 2.3抓包工具的使用【应用】 使用步骤 在谷歌浏览器网页中按F12 或者网页空白处右键,点击检查,可以调出工具 点击network,进入到查看网络相关信息界面 这时在浏览器中发起请求,进行访问,工具中就会显示出请求和响应相关的信息 1.2.4. 2.4请求信息【理解】 组成 请求行 请求头 请求空行 请求体 请求行 格式 请求方式 GET,POST,HEAD,PUT,DELETE,CONNECT,OPTIONS,TRACE,PATCH 其中用的比较多的是GET和POST URI 请求资源路径,统一资源标识符 协议版本 HTTP1.0: 每次请求和响应都需要建立一个单独的连接 HTTP1.1:支持长连接 请求头 格式 请求头名称 Host: 用来指定请求的服务端地址 Connection: 取值为keep-alive表示需要持久连接 User-Agent: 客户端的信息 Accept: 指定客户端能够接收的内容类型 Accept-Encoding: 指定浏览器可以支持的服务器返回内容压缩编码类型 Accept-Language: 浏览器可接受的语言 小结 1.2.5. 2.5响应信息【理解】 组成 响应行 响应头 响应空行 响应体 响应行 格式 协议版本 HTTP1.0: 每次请求和响应都需要建立一个单独的连接 HTTP1.1: 支持长连接 响应状态码 1xx: 指示信息(表示请求已接收，继续处理) 2xx: 成功(表示请求已被成功接收、理解、接受) 3xx: 请求重定向(要完成请求必须进行更进一步的操作) 4xx: 客户端错误(请求有语法错误或请求无法实现) 5xx: 服务器端错误(服务器未能实现合法的请求) 状态信息 200 ok 404 Not Found 500 Internal Server Error 响应头 响应头名称 Content-Type: 告诉客户端实际返回内容的网络媒体类型(互联网媒体类型,也叫做MIME类型) 响应头值 text/html -—> 文本类型 image/png -—> png格式文件 image/jpeg -—> jpg格式文件 小结 1.3. 3.HTTP服务器 1.3.1. 3.1需求【理解】 编写服务器端代码,实现可以解析浏览器的请求,给浏览器响应数据 1.3.2. 3.2环境搭建【理解】 实现步骤 编写HttpServer类,实现可以接收浏览器发出的请求 其中获取连接的代码可以单独抽取到一个类中 代码实现 // 服务端代码 public class HttpServer { public static void main(String[] args) throws IOException { //1.打开服务端通道 ServerSocketChannel serverSocketChannel = ServerSocketChannel.open(); //2.让这个通道绑定一个端口 serverSocketChannel.bind(new InetSocketAddress(10000)); //3.设置通道为非阻塞 serverSocketChannel.configureBlocking(false); //4.打开一个选择器 Selector selector = Selector.open(); //5.绑定选择器和服务端通道 serverSocketChannel.register(selector,SelectionKey.OP_ACCEPT); while(true){ //6.选择器会监视通道的状态. int count = selector.select(); if(count != 0){ //7.会遍历所有的服务端通道.看谁准备好了,谁准备好了,就让谁去连接. //获取所有服务端通道的令牌,并将它们都放到一个集合中,将集合返回. Set selectionKeys = selector.selectedKeys(); Iterator iterator = selectionKeys.iterator(); while(iterator.hasNext()){ //selectionKey 依次表示每一个服务端通道的令牌 SelectionKey selectionKey = iterator.next(); if(selectionKey.isAcceptable()){ //获取连接 AcceptHandler acceptHandler = new AcceptHandler(); acceptHandler.connSocketChannel(selectionKey); }else if(selectionKey.isReadable()){ } //任务处理完毕以后,将SelectionKey从集合中移除 iterator.remove(); } } } } } // 将获取连接的代码抽取到这个类中 public class AcceptHandler { public SocketChannel connSocketChannel(SelectionKey selectionKey){ try { //获取到已经就绪的服务端通道 ServerSocketChannel ssc = (ServerSocketChannel) selectionKey.channel(); SocketChannel socketChannel = ssc.accept(); //设置为非阻塞状态 socketChannel.configureBlocking(false); //把socketChannel注册到选择器上 socketChannel.register(selectionKey.selector(), SelectionKey.OP_READ); return socketChannel; } catch (IOException e) { e.printStackTrace(); } return null; } } 1.3.3. 3.3获取请求信息并解析【理解】 实现步骤 将请求信息封装到HttpRequest类中 在类中定义方法,实现获取请求信息并解析 代码实现 /** * 用来封装请求数据的类 */ public class HttpRequest { private String method; //请求方式 private String requestURI; //请求的uri private String version; //http的协议版本 private HashMap hm = new HashMap<>();//所有的请求头 //parse --- 获取请求数据 并解析 public void parse(SelectionKey selectionKey){ try { SocketChannel socketChannel = (SocketChannel) selectionKey.channel(); StringBuilder sb = new StringBuilder(); //创建一个缓冲区 ByteBuffer byteBuffer = ByteBuffer.allocate(1024); int len; //循环读取 while((len = socketChannel.read(byteBuffer)) > 0){ byteBuffer.flip(); sb.append(new String(byteBuffer.array(),0,len)); //System.out.println(new String(byteBuffer.array(),0,len)); byteBuffer.clear(); } //System.out.println(sb); parseHttpRequest(sb); } catch (IOException e) { e.printStackTrace(); } } //解析http请求协议中的数据 private void parseHttpRequest(StringBuilder sb) { //1.需要把StringBuilder先变成一个字符串 String httpRequestStr = sb.toString(); //2.获取每一行数据 String[] split = httpRequestStr.split(\"\\r\\n\"); //3.获取请求行 String httpRequestLine = split[0];//GET / HTTP/1.1 //4.按照空格进行切割,得到请求行中的三部分 String[] httpRequestInfo = httpRequestLine.split(\" \"); this.method = httpRequestInfo[0]; this.requestURI = httpRequestInfo[1]; this.version = httpRequestInfo[2]; //5.操作每一个请求头 for (int i = 1; i getHm() { return hm; } public void setHm(HashMap hm) { this.hm = hm; } @Override public String toString() { return \"HttpRequest{\" + \"method='\" + method + '\\'' + \", requestURI='\" + requestURI + '\\'' + \", version='\" + version + '\\'' + \", hm=\" + hm + '}'; } } 1.3.4. 3.4给浏览器响应数据【理解】 实现步骤 将响应信息封装HttpResponse类中 定义方法,封装响应信息,给浏览器响应数据 代码实现 public class HttpResponse { private String version; //协议版本 private String status; //响应状态码 private String desc; //状态码的描述信息 //响应头数据 private HashMap hm = new HashMap<>(); private HttpRequest httpRequest; //我们后面要根据请求的数据,来进行一些判断 //给浏览器响应数据的方法 public void sendStaticResource(SelectionKey selectionKey) { //1.给响应行赋值 this.version = \"HTTP/1.1\"; this.status = \"200\"; this.desc = \"ok\"; //2.将响应行拼接成一个单独的字符串 // HTTP/1.1 200 ok String responseLine = this.version + \" \" + this.status + \" \" + this.desc + \"\\r\\n\"; //3.给响应头赋值 hm.put(\"Content-Type\", \"text/html;charset=UTF-8\"); //4.将所有的响应头拼接成一个单独的字符串 StringBuilder sb = new StringBuilder(); Set> entries = hm.entrySet(); for (Map.Entry entry : entries) { sb.append(entry.getKey()).append(\": \").append(entry.getValue()).append(\"\\r\\n\"); } //5.响应空行 String emptyLine = \"\\r\\n\"; //6.响应行,响应头,响应空行拼接成一个大字符串 String responseLineStr = responseLine + sb.toString() + emptyLine; try { //7.将上面三个写给浏览器 SocketChannel socketChannel = (SocketChannel) selectionKey.channel(); ByteBuffer byteBuffer1 = ByteBuffer.wrap(responseLineStr.getBytes()); socketChannel.write(byteBuffer1); //8.单独操作响应体 //因为在以后响应体不一定是一个字符串 //有可能是一个文件,所以单独操作 String s = \"哎哟,妈呀,终于写完了.\"; ByteBuffer byteBuffer2 = ByteBuffer.wrap(s.getBytes()); socketChannel.write(byteBuffer2); //9.释放资源 socketChannel.close(); } catch (IOException e) { e.printStackTrace(); } } public String getVersion() { return version; } public void setVersion(String version) { this.version = version; } public String getStatus() { return status; } public void setStatus(String status) { this.status = status; } public String getDesc() { return desc; } public void setDesc(String desc) { this.desc = desc; } public HashMap getHm() { return hm; } public void setHm(HashMap hm) { this.hm = hm; } public HttpRequest getHttpRequest() { return httpRequest; } public void setHttpRequest(HttpRequest httpRequest) { this.httpRequest = httpRequest; } @Override public String toString() { return \"HttpResponse{\" + \"version='\" + version + '\\'' + \", status='\" + status + '\\'' + \", desc='\" + desc + '\\'' + \", hm=\" + hm + \", httpRequest=\" + httpRequest + '}'; } } 1.3.5. 3.5代码优化【理解】 实现步骤 根据请求资源路径不同,响应不同的数据 服务端健壮性处理 访问不存在的资源处理 代码实现 /** * 接收连接的任务处理类 */ public class AcceptHandler { public SocketChannel connSocketChannel(SelectionKey selectionKey){ try { //获取到已经就绪的服务端通道 ServerSocketChannel ssc = (ServerSocketChannel) selectionKey.channel(); SocketChannel socketChannel = ssc.accept(); //设置为非阻塞状态 socketChannel.configureBlocking(false); //把socketChannel注册到选择器上 socketChannel.register(selectionKey.selector(), SelectionKey.OP_READ); return socketChannel; } catch (IOException e) { e.printStackTrace(); } return null; } } /** * 接收客户端请求的类 */ public class HttpServer { public static void main(String[] args) throws IOException { //1.打开服务端通道 ServerSocketChannel serverSocketChannel = ServerSocketChannel.open(); //2.让这个通道绑定一个端口 serverSocketChannel.bind(new InetSocketAddress(10000)); //3.设置通道为非阻塞 serverSocketChannel.configureBlocking(false); //4.打开一个选择器 Selector selector = Selector.open(); //5.绑定选择器和服务端通道 serverSocketChannel.register(selector,SelectionKey.OP_ACCEPT); while(true){ //6.选择器会监视通道的状态. int count = selector.select(); if(count != 0){ //7.会遍历所有的服务端通道.看谁准备好了,谁准备好了,就让谁去连接. //获取所有服务端通道的令牌,并将它们都放到一个集合中,将集合返回. Set selectionKeys = selector.selectedKeys(); Iterator iterator = selectionKeys.iterator(); while(iterator.hasNext()){ //selectionKey 依次表示每一个服务端通道的令牌 SelectionKey selectionKey = iterator.next(); if(selectionKey.isAcceptable()){ //获取连接 AcceptHandler acceptHandler = new AcceptHandler(); acceptHandler.connSocketChannel(selectionKey); }else if(selectionKey.isReadable()){ //读取数据 HttpRequest httpRequest = new HttpRequest(); httpRequest.parse(selectionKey); System.out.println(\"http请求的数据为 ---->\" + httpRequest); if(httpRequest.getRequestURI() == null || \"\".equals(httpRequest.getRequestURI())){ selectionKey.channel(); continue; } System.out.println(\"...数据解析完毕,准备响应数据....\"); //响应数据 HttpResponse httpResponse = new HttpResponse(); httpResponse.setHttpRequest(httpRequest); httpResponse.sendStaticResource(selectionKey); } //任务处理完毕以后,将SelectionKey从集合中移除 iterator.remove(); } } } } } /** * 用来封装请求数据的类 */ public class HttpRequest { private String method; //请求方式 private String requestURI; //请求的uri private String version; //http的协议版本 private HashMap hm = new HashMap<>();//所有的请求头 //parse --- 获取请求数据 并解析 public void parse(SelectionKey selectionKey){ try { SocketChannel socketChannel = (SocketChannel) selectionKey.channel(); StringBuilder sb = new StringBuilder(); //创建一个缓冲区 ByteBuffer byteBuffer = ByteBuffer.allocate(1024); int len; //循环读取 while((len = socketChannel.read(byteBuffer)) > 0){ byteBuffer.flip(); sb.append(new String(byteBuffer.array(),0,len)); //System.out.println(new String(byteBuffer.array(),0,len)); byteBuffer.clear(); } //System.out.println(sb); parseHttpRequest(sb); } catch (IOException e) { e.printStackTrace(); } } //解析http请求协议中的数据 private void parseHttpRequest(StringBuilder sb) { //1.需要把StringBuilder先变成一个字符串 String httpRequestStr = sb.toString(); if(!(httpRequestStr == null || \"\".equals(httpRequestStr))){ //2.获取每一行数据 String[] split = httpRequestStr.split(\"\\r\\n\"); //3.获取请求行 String httpRequestLine = split[0];//GET / HTTP/1.1 //4.按照空格进行切割,得到请求行中的三部分 String[] httpRequestInfo = httpRequestLine.split(\" \"); this.method = httpRequestInfo[0]; this.requestURI = httpRequestInfo[1]; this.version = httpRequestInfo[2]; //5.操作每一个请求头 for (int i = 1; i getHm() { return hm; } public void setHm(HashMap hm) { this.hm = hm; } @Override public String toString() { return \"HttpRequest{\" + \"method='\" + method + '\\'' + \", requestURI='\" + requestURI + '\\'' + \", version='\" + version + '\\'' + \", hm=\" + hm + '}'; } } /** * 用来封装响应数据的类 */ public class HttpResponse { private String version; //协议版本 private String status; //响应状态码 private String desc; //状态码的描述信息 //响应头数据 private HashMap hm = new HashMap<>(); private HttpRequest httpRequest; //我们后面要根据请求的数据,来进行一些判断 //给浏览器响应数据的方法 public void sendStaticResource(SelectionKey selectionKey) { //1.给响应行赋值 this.version = \"HTTP/1.1\"; this.status = \"200\"; this.desc = \"ok\"; //3.给响应头赋值 //先获取浏览器请求的URI String requestURI = this.getHttpRequest().getRequestURI(); if(requestURI != null){ File file = new File(WEB_APP_PATH + requestURI); //判断这个路径是否存在 if(!file.exists()){ this.status = \"404\"; this.desc = \"NOT FOUNG\"; } if(\"200\".equals(this.status)){ if(\"/\".equals(requestURI)){ hm.put(\"Content-Type\", \"text/html;charset=UTF-8\"); }else if(\"/favicon.ico\".equals(requestURI)){ hm.put(\"Content-Type\", \"image/x-icon\"); }else if(\"/a.txt\".equals(requestURI)){ hm.put(\"Content-Type\", \"text/html;charset=UTF-8\"); }else if(\"/1.jpg\".equals(requestURI)){ hm.put(\"Content-Type\", \"image/jpeg\"); }else if(\"/1.png\".equals(requestURI)){ hm.put(\"Content-Type\", \"image/png\"); } }else{ hm.put(\"Content-Type\", \"text/html;charset=UTF-8\"); } } //2.将响应行拼接成一个单独的字符串 // HTTP/1.1 200 ok String responseLine = this.version + \" \" + this.status + \" \" + this.desc + \"\\r\\n\"; //4.将所有的响应头拼接成一个单独的字符串 StringBuilder sb = new StringBuilder(); Set> entries = hm.entrySet(); for (Map.Entry entry : entries) { sb.append(entry.getKey()).append(\": \").append(entry.getValue()).append(\"\\r\\n\"); } //5.响应空行 String emptyLine = \"\\r\\n\"; //6.响应行,响应头,响应空行拼接成一个大字符串 String responseLineStr = responseLine + sb.toString() + emptyLine; try { //7.将上面三个写给浏览器 SocketChannel socketChannel = (SocketChannel) selectionKey.channel(); ByteBuffer byteBuffer1 = ByteBuffer.wrap(responseLineStr.getBytes()); socketChannel.write(byteBuffer1); //8.单独操作响应体 //因为在以后响应体不一定是一个字符串 //有可能是一个文件,所以单独操作 // String s = \"哎哟,妈呀,终于写完了.\"; byte [] bytes = getContent(); ByteBuffer byteBuffer2 = ByteBuffer.wrap(bytes); socketChannel.write(byteBuffer2); //9.释放资源 socketChannel.close(); } catch (IOException e) { e.printStackTrace(); } } public static final String WEB_APP_PATH = \"mynio\\\\webapp\"; private byte[] getContent() { try { //1.获取浏览器请求的URI String requestURI = this.getHttpRequest().getRequestURI(); if(requestURI != null){ if(\"200\".equals(this.status)){ //2.判断一下请求的URI,根据不同的URI来响应不同的东西 if(\"/\".equals(requestURI)){ String s = \"哎哟,妈呀,终于写完了.\"; return s.getBytes(); }else/* if(\"/favicon.ico\".equals(requestURI))*/{ //获取一个ico文件 FileInputStream fis = new FileInputStream(WEB_APP_PATH + requestURI); //把ico文件变成一个字节数组返回 return IOUtils.toByteArray(fis); } }else{ return \"访问的资源不存在\".getBytes(); } } } catch (IOException e) { e.printStackTrace(); } return new byte[0]; } public String getVersion() { return version; } public void setVersion(String version) { this.version = version; } public String getStatus() { return status; } public void setStatus(String status) { this.status = status; } public String getDesc() { return desc; } public void setDesc(String desc) { this.desc = desc; } public HashMap getHm() { return hm; } public void setHm(HashMap hm) { this.hm = hm; } public HttpRequest getHttpRequest() { return httpRequest; } public void setHttpRequest(HttpRequest httpRequest) { this.httpRequest = httpRequest; } @Override public String toString() { return \"HttpResponse{\" + \"version='\" + version + '\\'' + \", status='\" + status + '\\'' + \", desc='\" + desc + '\\'' + \", hm=\" + hm + \", httpRequest=\" + httpRequest + '}'; } } Copyright © MISIN 2022 | 豫ICP备2021006345号-1 all right reserved，powered by Gitbook该文件修订时间： 2022-11-10 13:14:45 "},"1.JAVA基础/day25-基础加强01.html":{"url":"1.JAVA基础/day25-基础加强01.html","title":"day25-基础加强01","keywords":"","body":"1.1. 1.类加载器1.1.1. 1.1类加载器【理解】1.1.2. 1.2类加载的过程【理解】1.1.3. 1.3类加载的分类【理解】1.1.4. 1.4双亲委派模型【理解】1.1.5. 1.5ClassLoader 中的两个方法【应用】1.2. 2.反射1.2.1. 2.1反射的概述【理解】1.2.2. 2.2获取Class类对象的三种方式【应用】1.2.3. 2.3反射获取构造方法并使用【应用】1.2.4. 2.4反射获取成员变量并使用【应用】1.2.5. 2.5反射获取成员方法并使用【应用】1.3. 3.http服务器改写1.3.1. 3.1静态资源和动态资源【理解】1.3.2. 3.2准备工作【理解】1.3.3. 3.3浏览器请求动态资源【理解】1.3.4. 3.4main方法和Servlet优化【理解】1.3.5. 3.5多个动态资源【理解】1.3.6. 3.6通过反射和配置文件优化【理解】1.3.7. 3.7Servlet忘记实现HttpServlet接口处理【理解】1.3.8. 3.8响应404【理解】1.1. 1.类加载器 1.1.1. 1.1类加载器【理解】 作用 负责将.class文件（存储的物理文件）加载在到内存中 1.1.2. 1.2类加载的过程【理解】 类加载时机 创建类的实例（对象） 调用类的类方法 访问类或者接口的类变量，或者为该类变量赋值 使用反射方式来强制创建某个类或接口对应的java.lang.Class对象 初始化某个类的子类 直接使用java.exe命令来运行某个主类 类加载过程 加载 通过包名 + 类名，获取这个类，准备用流进行传输 在这个类加载到内存中 加载完毕创建一个class对象 链接 验证 确保Class文件字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身安全 (文件中的信息是否符合虚拟机规范有没有安全隐患) 准备 负责为类的类变量（被static修饰的变量）分配内存，并设置默认初始化值 (初始化静态变量) 解析 将类的二进制数据流中的符号引用替换为直接引用 (本类中如果用到了其他类，此时就需要找到对应的类) 初始化 根据程序员通过程序制定的主观计划去初始化类变量和其他资源 (静态变量赋值以及初始化其他资源) 小结 当一个类被使用的时候，才会加载到内存 类加载的过程: 加载、验证、准备、解析、初始化 1.1.3. 1.3类加载的分类【理解】 分类 Bootstrap class loader：虚拟机的内置类加载器，通常表示为null ，并且没有父null Platform class loader：平台类加载器,负责加载JDK中一些特殊的模块 System class loader：系统类加载器,负责加载用户类路径上所指定的类库 类加载器的继承关系 System的父加载器为Platform Platform的父加载器为Bootstrap 代码演示 public class ClassLoaderDemo1 { public static void main(String[] args) { //获取系统类加载器 ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader(); //获取系统类加载器的父加载器 — 平台类加载器 ClassLoader classLoader1 = systemClassLoader.getParent(); //获取平台类加载器的父加载器 — 启动类加载器 ClassLoader classLoader2 = classLoader1.getParent(); System.out.println(”系统类加载器“ + systemClassLoader); System.out.println(”平台类加载器“ + classLoader1); System.out.println(”启动类加载器“ + classLoader2); } } 1.1.4. 1.4双亲委派模型【理解】 介绍 如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式 1.1.5. 1.5ClassLoader 中的两个方法【应用】 方法介绍 | 方法名 | 说明 | | -————————————— | ——— | | public static ClassLoader getSystemClassLoader() | 获取系统类加载器 | | public InputStream getResourceAsStream(String name) | 加载某一个资源文件 | 示例代码 public class ClassLoaderDemo2 { public static void main(String[] args) throws IOException { //static ClassLoader getSystemClassLoader() 获取系统类加载器 //InputStream getResourceAsStream(String name) 加载某一个资源文件 //获取系统类加载器 ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader(); //利用加载器去加载一个指定的文件 //参数：文件的路径（放在src的根目录下，默认去那里加载） //返回值：字节流。 InputStream is = systemClassLoader.getResourceAsStream(”prop.properties“); Properties prop = new Properties(); prop.load(is); System.out.println(prop); is.close(); } } 1.2. 2.反射 1.2.1. 2.1反射的概述【理解】 反射机制 是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法； 对于任意一个对象，都能够调用它的任意属性和方法； 这种动态获取信息以及动态调用对象方法的功能称为Java语言的反射机制。 1.2.2. 2.2获取Class类对象的三种方式【应用】 三种方式分类 类名.class属性 对象名.getClass()方法 Class.forName(全类名)方法 示例代码 public class Student { private String name; private int age; public Student() { } public Student(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public void study(){ System.out.println(”学生在学习“); } @Override public String toString() { return ”Student{“ + ”name=’“ + name + ‘\\’‘ + ”, age=“ + age + ’}‘; } } public class ReflectDemo1 { public static void main(String[] args) throws ClassNotFoundException { //1.Class类中的静态方法forName(”全类名“) //全类名:包名 + 类名 Class clazz = Class.forName(”com.itheima.myreflect2.Student“); System.out.println(clazz); //2.通过class属性来获取 Class clazz2 = Student.class; System.out.println(clazz2); //3.利用对象的getClass方法来获取class对象 //getClass方法是定义在Object类中. Student s = new Student(); Class clazz3 = s.getClass(); System.out.println(clazz3); System.out.println(clazz == clazz2); System.out.println(clazz2 == clazz3); } } 1.2.3. 2.3反射获取构造方法并使用【应用】 2.3.1Class类获取构造方法对象的方法 方法介绍 | 方法名 | 说明 | | -————————————— | ————— | | Constructor[] getConstructors() | 返回所有公共构造方法对象的数组 | | Constructor[] getDeclaredConstructors() | 返回所有构造方法对象的数组 | | Constructor getConstructor(Class... parameterTypes) | 返回单个公共构造方法对象 | | Constructor getDeclaredConstructor(Class... parameterTypes) | 返回单个构造方法对象 | 示例代码 public class Student { private String name; private int age; //私有的有参构造方法 private Student(String name) { System.out.println(”name的值为:“ + name); System.out.println(”private...Student...有参构造方法“); } //公共的无参构造方法 public Student() { System.out.println(”public...Student...无参构造方法“); } //公共的有参构造方法 public Student(String name, int age) { System.out.println(”name的值为:“ + name + ”age的值为:“ + age); System.out.println(”public...Student...有参构造方法“); } } public class ReflectDemo1 { public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException { //method1(); //method2(); //method3(); //method4(); } private static void method4() throws ClassNotFoundException, NoSuchMethodException { // Constructor getDeclaredConstructor(Class... parameterTypes)： // 返回单个构造方法对象 //1.获取Class对象 Class clazz = Class.forName(”com.itheima.myreflect3.Student“); Constructor constructor = clazz.getDeclaredConstructor(String.class); System.out.println(constructor); } private static void method3() throws ClassNotFoundException, NoSuchMethodException { // Constructor getConstructor(Class... parameterTypes)： // 返回单个公共构造方法对象 //1.获取Class对象 Class clazz = Class.forName(”com.itheima.myreflect3.Student“); //小括号中,一定要跟构造方法的形参保持一致. Constructor constructor1 = clazz.getConstructor(); System.out.println(constructor1); Constructor constructor2 = clazz.getConstructor(String.class, int.class); System.out.println(constructor2); //因为Student类中,没有只有一个int的构造,所以这里会报错. Constructor constructor3 = clazz.getConstructor(int.class); System.out.println(constructor3); } private static void method2() throws ClassNotFoundException { // Constructor[] getDeclaredConstructors()： // 返回所有构造方法对象的数组 //1.获取Class对象 Class clazz = Class.forName(”com.itheima.myreflect3.Student“); Constructor[] constructors = clazz.getDeclaredConstructors(); for (Constructor constructor : constructors) { System.out.println(constructor); } } private static void method1() throws ClassNotFoundException { // Constructor[] getConstructors()： // 返回所有公共构造方法对象的数组 //1.获取Class对象 Class clazz = Class.forName(”com.itheima.myreflect3.Student“); Constructor[] constructors = clazz.getConstructors(); for (Constructor constructor : constructors) { System.out.println(constructor); } } } 2.3.2Constructor类用于创建对象的方法 方法介绍 | 方法名 | 说明 | | ——————————— | -————— | | T newInstance(Object...initargs) | 根据指定的构造方法创建对象 | | setAccessible(boolean flag) | 设置为true,表示取消访问检查 | 示例代码 // Student类同上一个示例,这里就不在重复提供了 public class ReflectDemo2 { public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException { //T newInstance(Object... initargs)：根据指定的构造方法创建对象 //method1(); //method2(); //method3(); //method4(); } private static void method4() throws ClassNotFoundException, NoSuchMethodException, InstantiationException, IllegalAccessException, InvocationTargetException { //获取一个私有的构造方法并创建对象 //1.获取class对象 Class clazz = Class.forName(”com.itheima.myreflect3.Student“); //2.获取一个私有化的构造方法. Constructor constructor = clazz.getDeclaredConstructor(String.class); //被private修饰的成员,不能直接使用的 //如果用反射强行获取并使用,需要临时取消访问检查 constructor.setAccessible(true); //3.直接创建对象 Student student = (Student) constructor.newInstance(”zhangsan“); System.out.println(student); } private static void method3() throws ClassNotFoundException, InstantiationException, IllegalAccessException { //简写格式 //1.获取class对象 Class clazz = Class.forName(”com.itheima.myreflect3.Student“); //2.在Class类中,有一个newInstance方法,可以利用空参直接创建一个对象 Student student = (Student) clazz.newInstance();//这个方法现在已经过时了,了解一下 System.out.println(student); } private static void method2() throws ClassNotFoundException, NoSuchMethodException, InstantiationException, IllegalAccessException, InvocationTargetException { //1.获取class对象 Class clazz = Class.forName(”com.itheima.myreflect3.Student“); //2.获取构造方法对象 Constructor constructor = clazz.getConstructor(); //3.利用空参来创建Student的对象 Student student = (Student) constructor.newInstance(); System.out.println(student); } private static void method1() throws ClassNotFoundException, NoSuchMethodException, InstantiationException, IllegalAccessException, InvocationTargetException { //1.获取class对象 Class clazz = Class.forName(”com.itheima.myreflect3.Student“); //2.获取构造方法对象 Constructor constructor = clazz.getConstructor(String.class, int.class); //3.利用newInstance创建Student的对象 Student student = (Student) constructor.newInstance(”zhangsan“, 23); System.out.println(student); } } 2.3.3小结 获取class对象 三种方式: Class.forName(“全类名”), 类名.class, 对象名.getClass() 获取里面的构造方法对象 getConstructor (Class... parameterTypes) getDeclaredConstructor (Class... parameterTypes) 如果是public的，直接创建对象 newInstance(Object... initargs) 如果是非public的，需要临时取消检查，然后再创建对象 setAccessible(boolean) 暴力反射 1.2.4. 2.4反射获取成员变量并使用【应用】 2.4.1Class类获取成员变量对象的方法 方法分类 | 方法名 | 说明 | | ———————————— | ————— | | Field[] getFields() | 返回所有公共成员变量对象的数组 | | Field[] getDeclaredFields() | 返回所有成员变量对象的数组 | | Field getField(String name) | 返回单个公共成员变量对象 | | Field getDeclaredField(String name) | 返回单个成员变量对象 | 示例代码 public class Student { public String name; public int age; public String gender; private int money = 300; @Override public String toString() { return ”Student{“ + ”name=’“ + name + ‘\\’‘ + ”, age=“ + age + ”, gender=’“ + gender + ‘\\’‘ + ”, money=“ + money + ’}‘; } } public class ReflectDemo1 { public static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException { // method1(); //method2(); //method3(); //method4(); } private static void method4() throws ClassNotFoundException, NoSuchFieldException { // Field getDeclaredField(String name)：返回单个成员变量对象 //1.获取class对象 Class clazz = Class.forName(”com.itheima.myreflect4.Student“); //2.获取money成员变量 Field field = clazz.getDeclaredField(”money“); //3.打印一下 System.out.println(field); } private static void method3() throws ClassNotFoundException, NoSuchFieldException { // Field getField(String name)：返回单个公共成员变量对象 //想要获取的成员变量必须是真实存在的 //且必须是public修饰的. //1.获取class对象 Class clazz = Class.forName(”com.itheima.myreflect4.Student“); //2.获取name这个成员变量 //Field field = clazz.getField(”name“); //Field field = clazz.getField(”name1“); Field field = clazz.getField(”money“); //3.打印一下 System.out.println(field); } private static void method2() throws ClassNotFoundException { // Field[] getDeclaredFields()：返回所有成员变量对象的数组 //1.获取class对象 Class clazz = Class.forName(”com.itheima.myreflect4.Student“); //2.获取所有的Field对象 Field[] fields = clazz.getDeclaredFields(); //3.遍历 for (Field field : fields) { System.out.println(field); } } private static void method1() throws ClassNotFoundException { // Field[] getFields()：返回所有公共成员变量对象的数组 //1.获取class对象 Class clazz = Class.forName(”com.itheima.myreflect4.Student“); //2.获取Field对象. Field[] fields = clazz.getFields(); //3.遍历 for (Field field : fields) { System.out.println(field); } } } 2.4.2Field类用于给成员变量赋值的方法 方法介绍 | 方法名 | 说明 | | -——————————— | -— | | void set(Object obj, Object value) | 赋值 | | Object get(Object obj) | 获取值 | 示例代码 // Student类同上一个示例,这里就不在重复提供了 public class ReflectDemo2 { public static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException, IllegalAccessException, InstantiationException { // Object get(Object obj) 返回由该 Field表示的字段在指定对象上的值。 //method1(); //method2(); } private static void method2() throws ClassNotFoundException, NoSuchFieldException, InstantiationException, IllegalAccessException { //1.获取class对象 Class clazz = Class.forName(”com.itheima.myreflect4.Student“); //2.获取成员变量Field的对象 Field field = clazz.getDeclaredField(”money“); //3.取消一下访问检查 field.setAccessible(true); //4.调用get方法来获取值 //4.1创建一个对象 Student student = (Student) clazz.newInstance(); //4.2获取指定对象的money的值 Object o = field.get(student); //5.打印一下 System.out.println(o); } private static void method1() throws ClassNotFoundException, NoSuchFieldException, InstantiationException, IllegalAccessException { // void set(Object obj, Object value)：给obj对象的成员变量赋值为value //1.获取class对象 Class clazz = Class.forName(”com.itheima.myreflect4.Student“); //2.获取name这个Field对象 Field field = clazz.getField(”name“); //3.利用set方法进行赋值. //3.1先创建一个Student对象 Student student = (Student) clazz.newInstance(); //3.2有了对象才可以给指定对象进行赋值 field.set(student,”zhangsan“); System.out.println(student); } } 1.2.5. 2.5反射获取成员方法并使用【应用】 2.5.1Class类获取成员方法对象的方法 方法分类 | 方法名 | 说明 | | -————————————— | ——————— | | Method[] getMethods() | 返回所有公共成员方法对象的数组，包括继承的 | | Method[] getDeclaredMethods() | 返回所有成员方法对象的数组，不包括继承的 | | Method getMethod(String name, Class... parameterTypes) | 返回单个公共成员方法对象 | | Method getDeclaredMethod(String name, Class... parameterTypes) | 返回单个成员方法对象 | 示例代码 public class Student { //私有的，无参无返回值 private void show() { System.out.println(”私有的show方法，无参无返回值“); } //公共的，无参无返回值 public void function1() { System.out.println(”function1方法，无参无返回值“); } //公共的，有参无返回值 public void function2(String name) { System.out.println(”function2方法，有参无返回值,参数为“ + name); } //公共的，无参有返回值 public String function3() { System.out.println(”function3方法，无参有返回值“); return ”aaa“; } //公共的，有参有返回值 public String function4(String name) { System.out.println(”function4方法，有参有返回值,参数为“ + name); return ”aaa“; } } public class ReflectDemo1 { public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException { //method1(); //method2(); //method3(); //method4(); //method5(); } private static void method5() throws ClassNotFoundException, NoSuchMethodException { // Method getDeclaredMethod(String name, Class... parameterTypes)： // 返回单个成员方法对象 //1.获取class对象 Class clazz = Class.forName(”com.itheima.myreflect5.Student“); //2.获取一个成员方法show Method method = clazz.getDeclaredMethod(”show“); //3.打印一下 System.out.println(method); } private static void method4() throws ClassNotFoundException, NoSuchMethodException { //1.获取class对象 Class clazz = Class.forName(”com.itheima.myreflect5.Student“); //2.获取一个有形参的方法function2 Method method = clazz.getMethod(”function2“, String.class); //3.打印一下 System.out.println(method); } private static void method3() throws ClassNotFoundException, NoSuchMethodException { // Method getMethod(String name, Class... parameterTypes) ： // 返回单个公共成员方法对象 //1.获取class对象 Class clazz = Class.forName(”com.itheima.myreflect5.Student“); //2.获取成员方法function1 Method method1 = clazz.getMethod(”function1“); //3.打印一下 System.out.println(method1); } private static void method2() throws ClassNotFoundException { // Method[] getDeclaredMethods()： // 返回所有成员方法对象的数组，不包括继承的 //1.获取class对象 Class clazz = Class.forName(”com.itheima.myreflect5.Student“); //2.获取Method对象 Method[] methods = clazz.getDeclaredMethods(); //3.遍历一下数组 for (Method method : methods) { System.out.println(method); } } private static void method1() throws ClassNotFoundException { // Method[] getMethods()：返回所有公共成员方法对象的数组，包括继承的 //1.获取class对象 Class clazz = Class.forName(”com.itheima.myreflect5.Student“); //2.获取成员方法对象 Method[] methods = clazz.getMethods(); //3.遍历 for (Method method : methods) { System.out.println(method); } } } 2.5.2Method类用于执行方法的方法 方法介绍 | 方法名 | 说明 | | -————————————— | -— | | Object invoke(Object obj, Object... args) | 运行方法 | 参数一: 用obj对象调用该方法 参数二: 调用方法的传递的参数(如果没有就不写) 返回值: 方法的返回值(如果没有就不写) 示例代码 public class ReflectDemo2 { public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InstantiationException, InvocationTargetException { // Object invoke(Object obj, Object... args)：运行方法 // 参数一：用obj对象调用该方法 // 参数二：调用方法的传递的参数（如果没有就不写） // 返回值：方法的返回值（如果没有就不写） //1.获取class对象 Class clazz = Class.forName(”com.itheima.myreflect5.Student“); //2.获取里面的Method对象 function4 Method method = clazz.getMethod(”function4“, String.class); //3.运行function4方法就可以了 //3.1创建一个Student对象,当做方法的调用者 Student student = (Student) clazz.newInstance(); //3.2运行方法 Object result = method.invoke(student, ”zhangsan“); //4.打印一下返回值 System.out.println(result); } } 1.3. 3.http服务器改写 1.3.1. 3.1静态资源和动态资源【理解】 静态资源 在服务器提前准备好的文件。(图片，文本) 动态资源 在图示的案例中，当用户点击了浏览器上的按钮。 本质上访问的就是服务端的某一个类中的某一个方法。 在方法中，可以写一些判断代码和逻辑代码，让响应的内容，有可能不一样了。 那么，服务端所对应的这个类我们常常将其称之为“动态资源” 1.3.2. 3.2准备工作【理解】 修改四个地方 HttpResponse -> 常量WEB_APP_PATH的值与当前模块一致 HttpServer -> main方法中端口改成80 HttpResponse -> 添加一个write方法，添加一个带参数的构造方法 HttpResponse -> 添加一个contentType成员变量，生成对应的set/get方法 示例代码 // 1.HttpResponse -> 常量WEB_APP_PATH的值与当前模块一致 public class HttpResponse { ... public static final String WEB_APP_PATH = ”http-dynamic-server\\\\webapp“; ... } // 2.HttpServer -> main方法中端口改成80 public class HttpServer { public static void main(String[] args) throws IOException { ... //2.让这个通道绑定一个端口 serverSocketChannel.bind(new InetSocketAddress(80)); ... } } // 3.HttpResponse -> 添加一个write方法，添加一个带参数的构造方法 public class HttpResponse { ... // 已经提供了selectionKey，所以之前的方法接收这个参数的可以去掉了，直接使用这个即可 // HttpRequest也按照此方式进行优化，定义成员变量，在构造方法中赋值，其他方法直接使用即可 private SelectionKey selectionKey; public HttpResponse(SelectionKey selectionKey) { this.selectionKey = selectionKey; } //给浏览器响应数据的方法 -— 浏览器在请求动态资源时,响应数据的方法. //content:响应的内容 public void write(String content){ } ... } public class HttpServer { public static void main(String[] args) throws IOException { ... //响应数据 //修改后的构造方法中要传入参数 HttpResponse httpResponse = new HttpResponse(selectionKey); ... } } // 4.HttpResponse -> 添加一个contentType成员变量，生成对应的set/get方法 public class HttpResponse { ... private String contentType;//MIME类型 public String getContentType() { return contentType; } public void setContentTpye(String contentType) { this.contentType = contentType; //添加到map集合中 hm.put(”Content-Type“,contentType); } ... } 1.3.3. 3.3浏览器请求动态资源【理解】 两个小问题 服务器如何判断浏览器请求的是静态资源还是动态资源? 我们可以规定：如果浏览器地址栏中的uri是以”/servlet”开始的，那么就表示请求动态资源 在一个项目中有很多类，很多方法。那么请求过来之后，执行哪个方法呢? 写一个UserServlet类，在类中写service方法 我们可以规定：如果请求动态资源，就创建这个类对象，并调用service方法，表示服务器处理了当前请求 实现步骤 解析http请求 处理浏览器请求 定义一个UserServlet 类，类中定义service方法，处理浏览器请求动态资源 解析完http请求之后，再判断uri是否以/servlet开头 响应 示例代码 public class UserServlet{ public void service(){ //模拟业务处理 -— 就可以对这个手机号进行判断验证 System.out.println(”UserServlet处理了用户的请求...“); } } public class HttpServer { public static void main(String[] args) throws IOException { ... //响应数据 HttpResponse httpResponse = new HttpResponse(selectionKey); httpResponse.setHttpRequest(httpRequest); if(httpRequest.getRequestURI().startsWith(”/servlet“)){ //本次请求动态资源 //处理 UserServlet userServlet = new UserServlet(); userServlet.service(); //响应 httpResponse.setContentTpye(”text/html;charset=UTF-8“); httpResponse.write(”ok,UserServlet处理了本次请求....“); }else{ //本次请求静态资源 httpResponse.sendStaticResource(); } ... } } public class HttpResponse { ... //给浏览器响应数据的方法 -— 浏览器在请求动态资源时,响应数据的方法. //content:响应的内容 public void write(String content){ //准备响应行数据 this.version = ”HTTP/1.1“; this.status = ”200“; this.desc = ”ok“; //把响应行拼接在一起 String responseLine = this.version + ” “ + this.status + ” “ + this.desc + ”\\r\\n“; //准备响应头 StringBuilder sb = new StringBuilder(); Set> entries = hm.entrySet(); for (Map.Entry entry : entries) { //entry依次表示每一个键值对对象 //键 — 响应头的名称 //值 — 响应头的值 sb.append(entry.getKey()).append(”: “).append(entry.getValue()).append(”\\r\\n“); } //处理响应空行 String emptyLine = ”\\r\\n“; //拼接响应行,响应头,响应空行 String result = responseLine + sb.toString() + emptyLine; try { //给浏览器响应 响应行,响应头,响应空行 ByteBuffer byteBuffer1 = ByteBuffer.wrap(result.getBytes()); SocketChannel channel = (SocketChannel) selectionKey.channel(); channel.write(byteBuffer1); //给浏览器响应 响应体 ByteBuffer byteBuffer2 = ByteBuffer.wrap(content.getBytes()); channel.write(byteBuffer2); //释放资源 channel.close(); } catch (IOException e) { System.out.println(”响应数据失败....“); e.printStackTrace(); } } ... } 1.3.4. 3.4main方法和Servlet优化【理解】 main方法优化 需求 将请求动态资源的代码抽取到一个单独的类单独的方法中，简化main中的代码 代码实现 public class DynamicResourceProcess { //执行指定动态资源的service方法 //参数一 //由于后期可能根据用户请求的uri做出相应的处理. //参数二 //要给用户响应数据,那么就需要使用到httpResponse. public void process(HttpRequest httpRequest,HttpResponse httpResponse) { // 创建UserServlet对象,调用service方法,进行处理 UserServlet userServlet = new UserServlet(); userServlet.service(); //给浏览器响应 httpResponse.setContentTpye(”text/html;charset=UTF-8“); httpResponse.write(”ok,UserServlet处理了本次请求....“); } } public class HttpServer { public static void main(String[] args) throws IOException { ... //响应数据 HttpResponse httpResponse = new HttpResponse(selectionKey); httpResponse.setHttpRequest(httpRequest); if(httpRequest.getRequestURI().startsWith(”/servlet“)){ //本次请求动态资源 DynamicResourceProcess drp = new DynamicResourceProcess(); drp.process(httpRequest,httpResponse); }else{ //本次请求静态资源 httpResponse.sendStaticResource(); } ... } } Servlet优化 需求 将给浏览器响应的代码写到Servlet中 代码实现 public class UserServlet implements HttpServlet{ //处理浏览器请求的方法 //参数一 //由于后期可能根据用户请求的uri做出相应的处理. //参数二 //要给用户响应数据,那么就需要使用到httpResponse. public void service(HttpRequest httpRequest, HttpResponse httpResponse){ //模拟业务处理 -— 就可以对这个手机号进行判断验证 System.out.println(”UserServlet处理了用户的请求...“); //给浏览器响应 httpResponse.setContentTpye(”text/html;charset=UTF-8“); httpResponse.write(”ok,UserServlet处理了本次请求....“); } } public class DynamicResourceProcess { //执行指定动态资源的service方法 //参数一 //由于后期可能根据用户请求的uri做出相应的处理. //参数二 //要给用户响应数据,那么就需要使用到httpResponse. public void process(HttpRequest httpRequest,HttpResponse httpResponse) { // 创建UserServlet对象,调用service方法,进行处理 UserServlet userServlet = new UserServlet(); userServlet.service(httpRequest,httpResponse); } } 1.3.5. 3.5多个动态资源【理解】 多个动态资源 针对每一个业务操作，我们都会去定义一个对应的Servlet来完成。 就会在服务端产生很多个Servlet 实现步骤 定义一个接口HttpServlet，接口中定义service方法。 针对于每一种业务，都定义一个servlet类与之对应，该类实现HttpServlet接口 获取请求的uri，进行判断，调用不同的servlet类中的service方法 代码实现 // 1.定义一个接口HttpServlet，接口中定义service方法 public interface HttpServlet { //定义业务处理的方法 public abstract void service(HttpRequest httpRequest, HttpResponse httpResponse); } // 2.针对于每一种业务，都定义一个servlet类与之对应，该类实现HttpServlet接口 public class UserServlet implements HttpServlet{ //处理浏览器请求的方法 //参数一 //由于后期可能根据用户请求的uri做出相应的处理. //参数二 //要给用户响应数据,那么就需要使用到httpResponse. public void service(HttpRequest httpRequest, HttpResponse httpResponse){ //模拟业务处理 -— 就可以对这个手机号进行判断验证 System.out.println(”UserServlet处理了用户的请求...“); //给浏览器响应 httpResponse.setContentTpye(”text/html;charset=UTF-8“); httpResponse.write(”ok,UserServlet处理了本次请求....“); } } public class LoginServlet implements HttpServlet{ @Override public void service(HttpRequest httpRequest, HttpResponse httpResponse) { //处理 System.out.println(”LoginServlet处理了登录请求“); //响应 httpResponse.setContentTpye(”text/html;charset=UTF-8“); httpResponse.write(”登录成功“); } } public class RegisterServlet implements HttpServlet{ @Override public void service(HttpRequest httpRequest, HttpResponse httpResponse) { //处理 System.out.println(”RegisterServlet处理了注册请求“); //响应 httpResponse.setContentTpye(”text/html;charset=UTF-8“); httpResponse.write(”注册成功“); } } public class SearchServlet implements HttpServlet{ @Override public void service(HttpRequest httpRequest, HttpResponse httpResponse) { //处理 System.out.println(”SearchServlet处理了搜索商品请求“); //响应 httpResponse.setContentTpye(”text/html;charset=UTF-8“); httpResponse.write(”响应了一些商品信息“); } } // 3.获取请求的uri，进行判断，调用不同的servlet类中的service方法 public class DynamicResourceProcess { public void process(HttpRequest httpRequest,HttpResponse httpResponse){ //获取请求的uri String requestURI = httpRequest.getRequestURI(); //根据请求的uri进行判断 if(”/servlet/loginservlet“.equals(requestURI)){ //登录请求 LoginServlet loginServlet = new LoginServlet(); loginServlet.service(httpRequest,httpResponse); }else if(”/servlet/registerservlet“.equals(requestURI)){ //注册请求 RegisterServlet registerServlet = new RegisterServlet(); registerServlet.service(httpRequest,httpResponse); }else if(”/servlet/searchservlet“.equals(requestURI)){ //搜索商品请求 SearchServlet searchServlet = new SearchServlet(); searchServlet.service(httpRequest,httpResponse); }else{ //表示默认处理方法 //创建UserServlet对象,调用service方法,进行处理 UserServlet userServlet = new UserServlet(); userServlet.service(httpRequest,httpResponse); } } } 1.3.6. 3.6通过反射和配置文件优化【理解】 优化步骤 把Servlet信息写到properties配置文件中 格式为：servlet-info=/servlet/UserServlet，全类名；/servlet/loginServlet，全类名 定义一个接口ServletConcurrentHashMap，接口中定义ConcurrentHashMap，该集合存储所有的servlet信息 定义一个接口ParseServletConfig，该接口中定义一个方法（parse） 定义ParseServletConfig的实现类，解析配置文件，并把配置文件中Servlet信息存到map集合中 在main方法的第一行，开启一条线程执行解析配置文件的代码 修改处理DynamicResourceProcess中的process方法 代码实现 // 1.把Servlet信息写到properties配置文件中 // 在webapp\\config\\servlet-info.properties文件中，写入如下内容 servlet-info=/servlet/loginservlet,com.itheima.myservlet.LoginServlet;/servlet/registerservlet,com.itheima.myservlet.RegisterServlet;/servlet/searchservlet,com.itheima.myservlet.SearchServlet;/servlet/lostpasswordservlet,com.itheima.myservlet.LostPasswordServlet // 2.定义一个接口ServletConcurrentHashMap，接口中定义ConcurrentHashMap，该集合存储所有的servlet信息 public interface ServletConcurrentHashMap { //存储请求路径和对应的servlet的map集合 //键: 请求的uri //值: 对应的Servlet对象 public static final ConcurrentHashMap map = new ConcurrentHashMap<>(); } // 3.定义一个接口ParseServletConfig，该接口中定义一个方法（parse） public interface ParseServletConfig { //解析数据的方法 public abstract void parse(); } // 4.定义ParseServletConfig的实现类，解析配置文件，并把配置文件中Servlet信息存到map集合中 public class PropertiesParseServletConfig implements ParseServletConfig { @Override public void parse() { try { //1.读取配置文件中的数据 Properties properties = new Properties(); FileReader fr = new FileReader(\"http-dynamic-server/webapp/config/servlet-info.properties\"); properties.load(fr); fr.close(); //2.获取集合中servlet-info的属性值 String properValue = (String) properties.get(\"servlet-info\"); // uri,全类名;uri,全类名 //3.解析 String[] split = properValue.split(\";\"); for (String servletInfo : split) { String[] servletInfoArr = servletInfo.split(\",\"); String uri = servletInfoArr[0]; String servletName = servletInfoArr[1]; //我们需要通过servletName(全类名)来创建他的对象 Class clazz = Class.forName(servletName); HttpServlet httpServlet = (HttpServlet) clazz.newInstance(); //4.将uri和httpServlet添加到map集合中 ServletConcurrentHashMap.map.put(uri,httpServlet); } } catch (Exception e) { System.out.println(\"解析数据异常.....\"); e.printStackTrace(); } } } public class LoaderResourceRunnable implements Runnable { @Override public void run() { //执行parse方法 ParseServletConfig parseServletConfig = new PropertiesParseServletConfig(); parseServletConfig.parse(); } } // 5.在main方法的第一行，开启一条线程执行解析配置文件的代码 public class HttpServer { public static void main(String[] args) throws IOException { //开启一条线程去解析配置文件 new Thread(new LoaderResourceRunnable()).start(); ... } } // 6.修改处理DynamicResourceProcess中的process方法 public class DynamicResourceProcess { public void process(HttpRequest httpRequest,HttpResponse httpResponse){ //获取请求的uri String requestURI = httpRequest.getRequestURI(); //根据请求的uri到map集合中直接找到对应的servlet的对象 HttpServlet httpServlet = ServletConcurrentHashMap.map.get(requestURI); //调用service方法对请求进行处理并响应 httpServlet.service(httpRequest,httpResponse); } } 1.3.7. 3.7Servlet忘记实现HttpServlet接口处理【理解】 出现情况 在写Servlet时，忘记了实现HttpServlet接口 导致结果 在反射创建对象后，强转成HttpServlet时，会报类型转换异常 解决方案 在反射创建对象后，强转成HttpServlet前，进行判断 如果有实现HttpServlet接口，就进行强转 否则抛出一个异常 代码实现 public class PropertiesParseServletConfig implements ParseServletConfig { @Override public void parse() { try { //1.读取配置文件中的数据 Properties properties = new Properties(); FileReader fr = new FileReader(\"http-dynamic-server/webapp/config/servlet-info.properties\"); properties.load(fr); fr.close(); //2.获取集合中servlet-info的属性值 String properValue = (String) properties.get(\"servlet-info\"); // uri,全类名;uri,全类名 //3.解析 String[] split = properValue.split(\";\"); for (String servletInfo : split) { String[] servletInfoArr = servletInfo.split(\",\"); String uri = servletInfoArr[0]; String servletName = servletInfoArr[1]; //我们需要通过servletName(全类名)来创建他的对象 Class clazz = Class.forName(servletName); //获取该类所实现的所有的接口信息,得到的是一个数组 Class[] interfaces = clazz.getInterfaces(); //定义一个boolean类型的变量 boolean flag = false; //遍历数组 for (Class clazzInfo : interfaces) { //判断当前所遍历的接口的字节码对象是否和HttpServlet的字节码文件对象相同 if(clazzInfo == HttpServlet.class){ //如果相同,就需要更改flag值.结束循环 flag = true; break; } } if(flag){ //true就表示当前的类已经实现了HttpServlet接口 HttpServlet httpServlet = (HttpServlet) clazz.newInstance(); //4.将uri和httpServlet添加到map集合中 ServletConcurrentHashMap.map.put(uri,httpServlet); }else{ //false就表示当前的类还没有实现HttpServlet接口 throw new NotImplementsHttpServletException(clazz.getName() + \"Not Implements HttpServlet\"); } } } catch (NotImplementsHttpServletException e) { e.printStackTrace(); }catch (Exception e) { System.out.println(\"解析数据异常.....\"); e.printStackTrace(); } } } 1.3.8. 3.8响应404【理解】 出现情况 客户端浏览器请求了一个服务器中不存在的动态资源 导致结果 服务器中代码出现异常，程序停止 解决方案 如果请求的动态资源不存在，服务器根据请求的uri找到对应的Servlet时为null，继续调用方法会出现异常 增加一个非空的判断，如果不为null，则继续处理请求，调用方法 如果为null，则响应404 代码实现 public class DynamicResourceProcess { //执行指定动态资源的service方法 //参数一 //由于后期可能根据用户请求的uri做出相应的处理. //参数二 //要给用户响应数据,那么就需要使用到httpResponse. public void process(HttpRequest httpRequest,HttpResponse httpResponse){ //获取请求的uri String requestURI = httpRequest.getRequestURI(); //根据请求的uri到map集合中直接找到对应的servlet的对象 HttpServlet httpServlet = ServletConcurrentHashMap.map.get(requestURI); if(httpServlet != null){ //调用service方法对请求进行处理并响应 httpServlet.service(httpRequest,httpResponse); }else{ //浏览器请求的动态资源不存在 //响应404 response404(httpResponse); } } //浏览器请求动态资源不存在,响应404的方法 private void response404(HttpResponse httpResponse) { try { //准备响应行 String responseLine = \"HTTP/1.1 404 NOT FOUND\\r\\n\"; //准备响应头 String responseHeader = \"Content-Type: text/html;charset=UTF-8\\r\\n\"; //准备响应空行 String emptyLine = \"\\r\\n\"; //拼接在一起 String result = responseLine + responseHeader + emptyLine; //把响应行,响应头,响应空行去响应给浏览器 SelectionKey selectionKey = httpResponse.getSelectionKey(); SocketChannel channel = (SocketChannel) selectionKey.channel(); ByteBuffer byteBuffer1 = ByteBuffer.wrap(result.getBytes()); channel.write(byteBuffer1); //给浏览器 响应 响应体内容 ByteBuffer byteBuffer2 = ByteBuffer.wrap(\"404 NOT FOUND....\".getBytes()); channel.write(byteBuffer2); //释放资源 channel.close(); } catch (IOException e) { e.printStackTrace(); } } } Copyright © MISIN 2022 | 豫ICP备2021006345号-1 all right reserved，powered by Gitbook该文件修订时间： 2022-11-10 13:13:03 "},"1.JAVA基础/day26-基础加强02.html":{"url":"1.JAVA基础/day26-基础加强02.html","title":"day26-基础加强02","keywords":"","body":"1.1. 1.xml1.1.1. 1.1概述【理解】1.1.2. 1.2标签的规则【应用】1.1.3. 1.3语法规则【应用】1.1.4. 1.4xml解析【应用】1.1.5. 1.5DTD约束【理解】1.1.6. 1.6schema约束【理解】1.1.7. 1.7服务器改进【应用】1.2. 2.枚举1.2.1. 2.1概述【理解】1.2.2. 2.2定义格式【应用】1.2.3. 2.3枚举的特点【理解】1.2.4. 2.4枚举的方法【应用】1.3. 3.注解1.3.1. 3.1概述【理解】1.3.2. 3.2自定义注解【理解】1.3.3. 3.3元注解【理解】1.3.4. 3.4改写服务器【理解】1.1. 1.xml 1.1.1. 1.1概述【理解】 万维网联盟(W3C) 万维网联盟(W3C)创建于1994年，又称W3C理事会。1994年10月在麻省理工学院计算机科学实验室成立。 建立者： Tim Berners-Lee (蒂姆·伯纳斯·李)。 是Web技术领域最具权威和影响力的国际中立性技术标准机构。 到目前为止，W3C已发布了200多项影响深远的Web技术标准及实施指南， 如广为业界采用的超文本标记语言HTML（标准通用标记语言下的一个应用）、 可扩展标记语言XML（标准通用标记语言下的一个子集） 以及帮助残障人士有效获得Web信息的无障碍指南（WCAG）等 xml概述 XML的全称为(EXtensible Markup Language)，是一种可扩展的标记语言 标记语言: 通过标签来描述数据的一门语言(标签有时我们也将其称之为元素) 可扩展：标签的名字是可以自定义的,XML文件是由很多标签组成的,而标签名是可以自定义的 作用 用于进行存储数据和传输数据 作为软件的配置文件 作为配置文件的优势 可读性好 可维护性高 1.1.2. 1.2标签的规则【应用】 标签由一对尖括号和合法标识符组成 标签必须成对出现 前边的是开始标签，后边的是结束标签 特殊的标签可以不成对,但是必须有结束标记 标签中可以定义属性,属性和标签名空格隔开,属性值必须用引号引起来 标签需要正确的嵌套 这是正确的: 张三 这是错误的: 张三 1.1.3. 1.3语法规则【应用】 语法规则 XML文件的后缀名为：xml 文档声明必须是第一行第一列 version：该属性是必须存在的 encoding：该属性不是必须的 ​ 打开当前xml文件的时候应该是使用什么字符编码表(一般取值都是UTF-8) standalone: 该属性不是必须的，描述XML文件是否依赖其他的xml文件，取值为yes/no 必须存在一个根标签，有且只能有一个 XML文件中可以定义注释信息 XML文件中可以存在以下特殊字符 &lt; 大于 &amp; & 和号 &apos; ‘ 单引号 &quot; “ 引号 XML文件中可以存在CDATA区 示例代码 张三 23 学生&lt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;的信息 >>>>> ]]]> 李四 24 1.1.4. 1.4xml解析【应用】 概述 xml解析就是从xml中获取到数据 常见的解析思想 DOM(Document Object Model)文档对象模型:就是把文档的各个组成部分看做成对应的对象。 会把xml文件全部加载到内存,在内存中形成一个树形结构,再获取对应的值 常见的解析工具 JAXP: SUN公司提供的一套XML的解析的API JDOM: 开源组织提供了一套XML的解析的API-jdom DOM4J: 开源组织提供了一套XML的解析的API-dom4j,全称：Dom For Java pull: 主要应用在Android手机端解析XML 解析的准备工作 我们可以通过网站：https://dom4j.github.io/ 去下载dom4j 今天的资料中已经提供,我们不用再单独下载了,直接使用即可 将提供好的dom4j-1.6.1.zip解压,找到里面的dom4j-1.6.1.jar 在idea中当前模块下新建一个libs文件夹,将jar包复制到文件夹中 选中jar包 -> 右键 -> 选择add as library即可 需求 解析提供好的xml文件 将解析到的数据封装到学生对象中 并将学生对象存储到ArrayList集合中 遍历集合 代码实现 张三 23 李四 24 // 上边是已经准备好的student.xml文件 public class Student { private String id; private String name; private int age; public Student() { } public Student(String id, String name, int age) { this.id = id; this.name = name; this.age = age; } public String getId() { return id; } public void setId(String id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } @Override public String toString() { return “Student{” + “id=’” + id + ‘\\’‘ + “, name=’” + name + ‘\\’‘ + “, age=” + age + ’}‘; } } /** * 利用dom4j解析xml文件 */ public class XmlParse { public static void main(String[] args) throws DocumentException { //1.获取一个解析器对象 SAXReader saxReader = new SAXReader(); //2.利用解析器把xml文件加载到内存中,并返回一个文档对象 Document document = saxReader.read(new File(“myxml\\\\xml\\\\student.xml”)); //3.获取到根标签 Element rootElement = document.getRootElement(); //4.通过根标签来获取student标签 //elements():可以获取调用者所有的子标签.会把这些子标签放到一个集合中返回. //elements(“标签名”):可以获取调用者所有的指定的子标签,会把这些子标签放到一个集合中并返回 //List list = rootElement.elements(); List studentElements = rootElement.elements(“student”); //System.out.println(list.size()); //用来装学生对象 ArrayList list = new ArrayList<>(); //5.遍历集合,得到每一个student标签 for (Element element : studentElements) { //element依次表示每一个student标签 //获取id这个属性 Attribute attribute = element.attribute(“id”); //获取id的属性值 String id = attribute.getValue(); //获取name标签 //element(“标签名”):获取调用者指定的子标签 Element nameElement = element.element(“name”); //获取这个标签的标签体内容 String name = nameElement.getText(); //获取age标签 Element ageElement = element.element(“age”); //获取age标签的标签体内容 String age = ageElement.getText(); // System.out.println(id); // System.out.println(name); // System.out.println(age); Student s = new Student(id,name,Integer.parseInt(age)); list.add(s); } //遍历操作 for (Student student : list) { System.out.println(student); } } } 1.1.5. 1.5DTD约束【理解】 什么是约束 用来限定xml文件中可使用的标签以及属性 约束的分类 DTD schema 编写DTD约束 步骤 创建一个文件，这个文件的后缀名为.dtd 看xml文件中使用了哪些元素 可以定义元素 判断元素是简单元素还是复杂元素 简单元素：没有子元素。 复杂元素：有子元素的元素； 代码实现 ``` ``` 引入DTD约束 引入DTD约束的三种方法 引入本地dtd 在xml文件内部引入 引入网络dtd 代码实现 引入本地DTD约束 // 这是persondtd.dtd文件中的内容,已经提前写好 // 在person1.xml文件中引入persondtd.dtd约束 张三 23 在xml文件内部引入 ]> 张三 23 引入网络dtd 张三 23 DTD语法 定义元素 定义一个元素的格式为： 简单元素： ​ EMPTY: 表示标签体为空 ​ ANY: 表示标签体可以为空也可以不为空 ​ PCDATA: 表示该元素的内容部分为字符串 复杂元素： ​ 直接写子元素名称. 多个子元素可以使用“,”或者“|”隔开； ​ “,”表示定义子元素的顺序 ; “|”: 表示子元素只能出现任意一个 ​ “?”零次或一次, “+”一次或多次, “*”零次或多次;如果不写则表示出现一次 定义属性 格式 定义一个属性的格式为： 属性的类型： ​ CDATA类型：普通的字符串 属性的约束: ​ // #REQUIRED： 必须的 ​ // #IMPLIED： 属性不是必需的 ​ // #FIXED value：属性值是固定的 代码实现 张三 23 张三 23 ​ ``` 1.1.6. 1.6schema约束【理解】 schema和dtd的区别 schema约束文件也是一个xml文件，符合xml的语法，这个文件的后缀名.xsd 一个xml中可以引用多个schema约束文件，多个schema使用名称空间区分（名称空间类似于java包名） dtd里面元素类型的取值比较单一常见的是PCDATA类型，但是在schema里面可以支持很多个数据类型 schema 语法更加的复杂 编写schema约束 步骤 1，创建一个文件，这个文件的后缀名为.xsd。 2，定义文档声明 3，schema文件的根标签为： 4，在中定义属性： ​ xmlns=http://www.w3.org/2001/XMLSchema 5，在中定义属性 ： ​ targetNamespace =唯一的url地址，指定当前这个schema文件的名称空间。 6，在中定义属性 ： ​ elementFormDefault=”qualified“，表示当前schema文件是一个质量良好的文件。 7，通过element定义元素 8，判断当前元素是简单元素还是复杂元素 代码实现 引入schema约束 步骤 1，在根标签上定义属性xmlns=“http://www.w3.org/2001/XMLSchema-instance” 2，通过xmlns引入约束文件的名称空间 3，给某一个xmlns属性添加一个标识，用于区分不同的名称空间 ​ 格式为: xmlns:标识=“名称空间地址” ,标识可以是任意的，但是一般取值都是xsi 4，通过xsi:schemaLocation指定名称空间所对应的约束文件路径 ​ 格式为：xsi:schemaLocation = “名称空间url 文件路径“ 代码实现 张三 23 ​ ``` schema约束定义属性 代码示例 张三 23 ​ ``` 1.1.7. 1.7服务器改进【应用】 准备xml文件 在当前模块下的webapp目录下新建一个文件夹，名字叫WEB-INF 新建一个xml文件，名字叫web.xml 将资料中的web.xml文件中引入约束的代码复制到新建的web.xml文件中 将要解析的数据配置到xml文件中 需求 把uri和servlet信息放到一个concurrentHashMap集合当中 当浏览器请求一个动态资源时，我们会获取uri对应的servlet来处理当前业务 实现步骤 导入dom4j的jar包 定义一个XmlParseServletConfig类实现ParseServletConfig接口 在parse方法里面就可以解析xml文件了 代码实现 // web.xml配置文件中配置的信息 LoginServlet com.itheima.myservlet.LoginServlet LoginServlet /servlet/loginservlet // 定义一个XmlParseServletConfig类实现ParseServletConfig接口 public class XMLParseServletConfig implements ParseServletConfig { //定义web.xml文件的路径 private static final String WEB_XML_PATH = \"http-dynamic-server/webapp/WEB-INF/web.xml\"; //在parse方法里面就可以解析xml文件了 @Override public void parse() { try { //1.创建一个解析器对象(注意:如果解析器对象等不能使用,请检查一下jar包是否导入) SAXReader saxReader = new SAXReader(); //2.利用解析器把xml文件读取到内存中 Document document = saxReader.read(new File(WEB_XML_PATH)); //3.获取根节点元素对象 Element rootElement = document.getRootElement(); //创建一个Map集合，用来存储servlet的配置信息 HashMap servletInfoHashMap = new HashMap<>(); //4.获取根元素对象下所有的servlet元素的对象 List servletInfos = rootElement.elements(\"servlet\"); //5.遍历集合，依次获取到每一个servlet标签对象 for (Element servletInfo : servletInfos) { //servletInfo依次表示每一个servlet标签对象 //获取到servlet下的servlet-name元素对象，并且获取标签体内容 String servletName = servletInfo.element(\"servlet-name\").getText(); //获取到servlet下的servlet-class元素对象，并且获取标签体内容 String servletClass = servletInfo.element(\"servlet-class\").getText(); servletInfoHashMap.put(servletName,servletClass); } //--------------------servlet-mapping-------------------------------------- //获取到所有的servlet-mapping标签 List servletMappingInfos = rootElement.elements(\"servlet-mapping\"); //遍历集合依次得到每一个servlet-mapping标签 for (Element servletMappingInfo : servletMappingInfos) { //servletMappingInfo依次表示每一个servlet-mapping标签 //获取servlet-mapping标签标签中的servlet-name标签的标签体内容 String servletName = servletMappingInfo.element(\"servlet-name\").getText(); //获取servlet-mapping标签标签中的url-pattern标签的标签体内容 String urlPattern = servletMappingInfo.element(\"url-pattern\").getText(); //通过servletName来获取到servlet的全类名 String servletClassName = servletInfoHashMap.get(servletName); //通过反射来创建这个servlet对象 Class clazz = Class.forName(servletClassName); //获取该类所实现的所有的接口信息,得到的是一个数组 Class[] interfaces = clazz.getInterfaces(); //定义一个boolean类型的变量 boolean flag = false; //遍历数组 for (Class clazzInfo : interfaces) { //判断当前所遍历的接口的字节码对象是否和HttpServlet的字节码文件对象相同 if(clazzInfo == HttpServlet.class){ //如果相同,就需要更改flag值.结束循环 flag = true; break; } } if(flag){ //true就表示当前的类已经实现了HttpServlet接口 HttpServlet httpServlet = (HttpServlet) clazz.newInstance(); //4.将uri和httpServlet添加到map集合中 ServletConcurrentHashMap.map.put(urlPattern,httpServlet); }else{ //false就表示当前的类还没有实现HttpServlet接口 throw new NotImplementsHttpServletException(clazz.getName() + \"Not Implements HttpServlet\"); } } } catch (NotImplementsHttpServletException e) { e.printStackTrace(); }catch (Exception e) { e.printStackTrace(); } } } public class LoaderResourceRunnable implements Runnable { @Override public void run() { // //执行parse方法 // ParseServletConfig parseServletConfig = new PropertiesParseServletConfig(); // parseServletConfig.parse(); ParseServletConfig parseServletConfig = new XMLParseServletConfig(); parseServletConfig.parse(); } } 1.2. 2.枚举 1.2.1. 2.1概述【理解】 为了间接的表示一些固定的值，Java就给我们提供了枚举 是指将变量的值一一列出来,变量的值只限于列举出来的值的范围内 1.2.2. 2.2定义格式【应用】 格式 public enum s { 枚举项1,枚举项2,枚举项3; } 注意: 定义枚举类要用关键字enum 示例代码 // 定义一个枚举类，用来表示春，夏，秋，冬这四个固定值 public enum Season { SPRING,SUMMER,AUTUMN,WINTER; } 1.2.3. 2.3枚举的特点【理解】 特点 所有枚举类都是Enum的子类 我们可以通过\"枚举类名.枚举项名称\"去访问指定的枚举项 每一个枚举项其实就是该枚举的一个对象 枚举也是一个类，也可以去定义成员变量 枚举类的第一行上必须是枚举项，最后一个枚举项后的分号是可以省略的，但是如果枚举类有其他的东西，这个分号就不能省略。建议不要省略 枚举类可以有构造器，但必须是private的，它默认的也是private的。 枚举项的用法比较特殊：枚举(\"\"); 枚举类也可以有抽象方法，但是枚举项必须重写该方法 示例代码 public enum Season { SPRING(\"春\"){ //如果枚举类中有抽象方法 //那么在枚举项中必须要全部重写 @Override public void show() { System.out.println(this.name); } }, SUMMER(\"夏\"){ @Override public void show() { System.out.println(this.name); } }, AUTUMN(\"秋\"){ @Override public void show() { System.out.println(this.name); } }, WINTER(\"冬\"){ @Override public void show() { System.out.println(this.name); } }; public String name; //空参构造 //private Season(){} //有参构造 private Season(String name){ this.name = name; } //抽象方法 public abstract void show(); } public class EnumDemo { public static void main(String[] args) { /* 1.所有枚举类都是Enum的子类 2.我们可以通过\"枚举类名.枚举项名称\"去访问指定的枚举项 3.每一个枚举项其实就是该枚举的一个对象 4.枚举也是一个类，也可以去定义成员变量 5.枚举类的第一行上必须是枚举项，最后一个枚举项后的分号是可以省略的， 但是如果枚举类有其他的东西，这个分号就不能省略。建议不要省略 6.枚举类可以有构造器，但必须是private的，它默认的也是private的。 枚举项的用法比较特殊：枚举(\"\"); 7.枚举类也可以有抽象方法，但是枚举项必须重写该方法 */ //第二个特点的演示 //我们可以通过\"枚举类名.枚举项名称\"去访问指定的枚举项 System.out.println(Season.SPRING); System.out.println(Season.SUMMER); System.out.println(Season.AUTUMN); System.out.println(Season.WINTER); //第三个特点的演示 //每一个枚举项其实就是该枚举的一个对象 Season spring = Season.SPRING; } } 1.2.4. 2.4枚举的方法【应用】 方法介绍 | 方法名 | 说明 | | ---------------------------------------- | ------------------ | | String name() | 获取枚举项的名称 | | int ordinal() | 返回枚举项在枚举类中的索引值 | | int compareTo(E o) | 比较两个枚举项，返回的是索引值的差值 | | String toString() | 返回枚举常量的名称 | | static T valueOf(Class type,String name) | 获取指定枚举类中的指定名称的枚举值 | | values() | 获得所有的枚举项 | 示例代码 public enum Season { SPRING,SUMMER,AUTUMN,WINTER; } public class EnumDemo { public static void main(String[] args) { // String name() 获取枚举项的名称 String name = Season.SPRING.name(); System.out.println(name); System.out.println(\"-----------------------------\"); // int ordinal() 返回枚举项在枚举类中的索引值 int index1 = Season.SPRING.ordinal(); int index2 = Season.SUMMER.ordinal(); int index3 = Season.AUTUMN.ordinal(); int index4 = Season.WINTER.ordinal(); System.out.println(index1); System.out.println(index2); System.out.println(index3); System.out.println(index4); System.out.println(\"-----------------------------\"); // int compareTo(E o) 比较两个枚举项，返回的是索引值的差值 int result = Season.SPRING.compareTo(Season.WINTER); System.out.println(result);//-3 System.out.println(\"-----------------------------\"); // String toString() 返回枚举常量的名称 String s = Season.SPRING.toString(); System.out.println(s); System.out.println(\"-----------------------------\"); // static T valueOf(Class type,String name) // 获取指定枚举类中的指定名称的枚举值 Season spring = Enum.valueOf(Season.class, \"SPRING\"); System.out.println(spring); System.out.println(Season.SPRING == spring); System.out.println(\"-----------------------------\"); // values() 获得所有的枚举项 Season[] values = Season.values(); for (Season value : values) { System.out.println(value); } } } 1.3. 3.注解 1.3.1. 3.1概述【理解】 概述 对我们的程序进行标注和解释 注解和注释的区别 注释: 给程序员看的 注解: 给编译器看的 使用注解进行配置配置的优势 代码更加简洁,方便 1.3.2. 3.2自定义注解【理解】 格式 public @interface 注解名称 { ​ public 属性类型 属性名() default 默认值 ; } 属性类型 基本数据类型 String Class 注解 枚举 以上类型的一维数组 代码演示 public @interface Anno2 { } public enum Season { SPRING,SUMMER,AUTUMN,WINTER; } public @interface Anno1 { //定义一个基本类型的属性 int a () default 23; //定义一个String类型的属性 public String name() default \"itheima\"; //定义一个Class类型的属性 public Class clazz() default Anno2.class; //定义一个注解类型的属性 public Anno2 anno() default @Anno2; //定义一个枚举类型的属性 public Season season() default Season.SPRING; //以上类型的一维数组 //int数组 public int[] arr() default {1,2,3,4,5}; //枚举数组 public Season[] seasons() default {Season.SPRING,Season.SUMMER}; //value。后期我们在使用注解的时候，如果我们只需要给注解的value属性赋值。 //那么value就可以省略 public String value(); } //在使用注解的时候如果注解里面的属性没有指定默认值。 //那么我们就需要手动给出注解属性的设置值。 //@Anno1(name = \"itheima\") @Anno1(\"abc\") public class AnnoDemo { } 注意 如果只有一个属性需要赋值，并且属性的名称是value，则value可以省略，直接定义值即可 自定义注解案例 需求 自定义一个注解@Test,用于指定类的方法上,如果某一个类的方法上使用了该注解,就执行该方法 实现步骤 自定义一个注解Test,并在类中的某几个方法上加上注解 在测试类中,获取注解所在的类的Class对象 获取类中所有的方法对象 遍历每一个方法对象,判断是否有对应的注解 代码实现 //表示Test这个注解的存活时间 @Retention(value = RetentionPolicy.RUNTIME) public @interface Test { } public class UseTest { //没有使用Test注解 public void show(){ System.out.println(\"UseTest....show....\"); } //使用Test注解 @Test public void method(){ System.out.println(\"UseTest....method....\"); } //没有使用Test注解 @Test public void function(){ System.out.println(\"UseTest....function....\"); } } public class AnnoDemo { public static void main(String[] args) throws ClassNotFoundException, IllegalAccessException, InstantiationException, InvocationTargetException { //1.通过反射获取UseTest类的字节码文件对象 Class clazz = Class.forName(\"com.itheima.myanno3.UseTest\"); //创建对象 UseTest useTest = (UseTest) clazz.newInstance(); //2.通过反射获取这个类里面所有的方法对象 Method[] methods = clazz.getDeclaredMethods(); //3.遍历数组，得到每一个方法对象 for (Method method : methods) { //method依次表示每一个方法对象。 //isAnnotationPresent(Class annotationClass) //判断当前方法上是否有指定的注解。 //参数：注解的字节码文件对象 //返回值：布尔结果。 true 存在 false 不存在 if(method.isAnnotationPresent(Test.class)){ method.invoke(useTest); } } } } 1.3.3. 3.3元注解【理解】 概述 元注解就是描述注解的注解 元注解介绍 | 元注解名 | 说明 | | ----------- | --------------------- | | @Target | 指定了注解能在哪里使用 | | @Retention | 可以理解为保留时间(生命周期) | | @Inherited | 表示修饰的自定义注解可以被子类继承 | | @Documented | 表示该自定义注解，会出现在API文档里面。 | 示例代码 @Target({ElementType.FIELD,ElementType.TYPE,ElementType.METHOD}) //指定注解使用的位置（成员变量，类，方法） @Retention(RetentionPolicy.RUNTIME) //指定该注解的存活时间 //@Inherited //指定该注解可以被继承 public @interface Anno { } @Anno public class Person { } public class Student extends Person { public void show(){ System.out.println(\"student.......show..........\"); } } public class StudentDemo { public static void main(String[] args) throws ClassNotFoundException { //获取到Student类的字节码文件对象 Class clazz = Class.forName(\"com.itheima.myanno4.Student\"); //获取注解。 boolean result = clazz.isAnnotationPresent(Anno.class); System.out.println(result); } } 1.3.4. 3.4改写服务器【理解】 需求 目前项目中Servlet和url对应关系,是配置在xml文件中的,将其改为在Servlet类上通过注解配置实现 实现步骤 定义一个注解(@WebServlet),注解内有一个属性urlPatterns 在servlet类上去使用该注解,来指定当前Servlet的访问路径 创建一个注解解析类(AnnoParseServletConfig),该类实现ParseServletConfig接口 实现parse方法 代码实现 @Target(ElementType.TYPE) //指定该注解可以使用在类上 @Retention(RetentionPolicy.RUNTIME)//指定该注解的存活时间 --- 为运行期 public @interface WebServlet { //让用户去指定某一个Servlet在进行访问的时候所对应的请求uri public String urlPatterns(); } // 这里只给出了LoginServlet的配置,其他Servlet同理 @WebServlet(urlPatterns = \"/servlet/loginservlet\") public class LoginServlet implements HttpServlet{ @Override public void service(HttpRequest httpRequest, HttpResponse httpResponse) { //处理 System.out.println(\"LoginServlet处理了登录请求\"); //响应 httpResponse.setContentTpye(\"text/html;charset=UTF-8\"); httpResponse.write(\"登录成功\"); } } public class AnnoParseServletConfig implements ParseServletConfig { //定义一个servlet路径所对应的常量 public static final String SERVLET_PATH = \"http-dynamic-server\\\\src\\\\com\\\\itheima\\\\myservlet\"; //定义包名 public static final String SERVLET_PACKAGE_NAME = \"com.itheima.myservlet.\"; @Override public void parse() { //获取类名 // 1.获得servlet所在文件夹的路径，并封装成File对象 File file = new File(SERVLET_PATH); // 2.调用listFiles方法，获取文件夹下所有的File对象 File[] servletFiles = file.listFiles(); // 3.遍历数组，获取每一个File对象 for (File servletFile : servletFiles) { // 4.获取File对象的名字（后缀名） String servletFileName = servletFile.getName().replace(\".java\", \"\"); // 5.根据包名 + 类名 得到每一个类的全类名 String servletFullName = SERVLET_PACKAGE_NAME + servletFileName; try { // 6.通过全类名获取字节码文件对象 Class servletClazz = Class.forName(servletFullName); // 7.判断该类是否有WebServlet注解 if(servletClazz.isAnnotationPresent(WebServlet.class)){ // 8.判断该Servlet类是否实现HttpServlet接口 //获取该类所实现的所有的接口信息,得到的是一个数组 Class[] interfaces = servletClazz.getInterfaces(); //定义一个boolean类型的变量 boolean flag = false; //遍历数组 for (Class clazzInfo : interfaces) { //判断当前所遍历的接口的字节码对象是否和HttpServlet的字节码文件对象相同 if(clazzInfo == HttpServlet.class){ //如果相同,就需要更改flag值.结束循环 flag = true; break; } } if(flag){ // 9.如果满足，则获取注解中的urlPattrens的值， WebServlet annotation = (WebServlet) servletClazz.getAnnotation(WebServlet.class); String uri = annotation.urlPatterns(); // 10.创建当前Servlet类对象存入值位置 HttpServlet httpServlet = (HttpServlet) servletClazz.newInstance(); // 11.存入集合的键位置 ServletConcurrentHashMap.map.put(uri,httpServlet); // }else{ // 12.如果不满足，抛出异常 //false就表示当前的类还没有实现HttpServlet接口 throw new NotImplementsHttpServletException(servletClazz.getName() + \"Not Implements HttpServlet\"); } } } catch (NotImplementsHttpServletException e) { e.printStackTrace(); } catch (Exception e) { e.printStackTrace(); } } } } public class LoaderResourceRunnable implements Runnable { @Override public void run() { // //执行parse方法 // ParseServletConfig parseServletConfig = new PropertiesParseServletConfig(); // parseServletConfig.parse(); // ParseServletConfig parseServletConfig = new XMLParseServletConfig(); // parseServletConfig.parse(); ParseServletConfig parseServletConfig = new AnnoParseServletConfig(); parseServletConfig.parse(); } } Copyright © MISIN 2022 | 豫ICP备2021006345号-1 all right reserved，powered by Gitbook该文件修订时间： 2022-11-10 13:10:59 "},"1.JAVA基础/day27-基础加强03.html":{"url":"1.JAVA基础/day27-基础加强03.html","title":"day27-基础加强03","keywords":"","body":"1.1. 1.管理系统与服务器集成1.1.1. 1.1准备工作【应用】1.1.2. 1.2HttpRequest类代码实现【应用】1.1.3. 1.3DynamicResourceProcess类代码实现【应用】1.1.4. 1.4StudentServlet类代码实现【应用】1.1.5. 1.5查询学生【应用】1.1.6. 1.6添加学生【应用】1.2. 2.单元测试1.2.1. 2.1概述【理解】1.2.2. 2.2特点【理解】1.2.3. 2.3使用步骤【应用】1.2.4. 2.4相关注解【应用】1.3. 3.日志1.3.1. 3.1概述【理解】1.3.2. 3.2日志体系结构和Log4J【理解】1.3.3. 3.3入门案例【应用】1.3.4. 3.4配置文件详解【理解】1.3.5. 3.5在项目中的应用【应用】1.1. 1.管理系统与服务器集成 1.1.1. 1.1准备工作【应用】 需求 对之前写过的黑马信息管理系统进行改进,实现可以通过浏览器进行访问的功能 准备工作 将资料中的黑马管理系统代码拷贝到当前模块下 导包的代码可能报错,因为之前的包路径可能和当前代码不一致,将导包的代码修改下 业务分析 解析URL封装到HttpReques对象 DynamicResourceProcess类（执行指定动态资源的service方法） 定义servlet类完成查询学生、添加学生、删除学生、修改学生的逻辑 项目结构 1.1.2. 1.2HttpRequest类代码实现【应用】 实现步骤 提供一个存储url中用户信息的map集合 提供一个getParamter方法,用于根据请求参数的名称获取请求参数的值 提供一个parseParamter方法,用于解析请求参数把请求参数存储到map集合中 代码实现 // 此处只给出了新增的代码,其他代码同之前没有变化 public class HttpRequest { //用来存储请求URL中问号后面的那些数据 //id=1 name=itheima private Map paramterHashMap = new HashMap<>(); //parse — 获取请求数据 并解析 public void parse(){ try { SocketChannel socketChannel = (SocketChannel) selectionKey.channel(); StringBuilder sb = new StringBuilder(); //创建一个缓冲区 ByteBuffer byteBuffer = ByteBuffer.allocate(1024); int len; //循环读取 while((len = socketChannel.read(byteBuffer)) > 0){ byteBuffer.flip(); sb.append(new String(byteBuffer.array(),0,len)); //System.out.println(new String(byteBuffer.array(),0,len)); byteBuffer.clear(); } //System.out.println(sb); parseHttpRequest(sb); //解析请求参数，把请求参数存储到paramterHashMap集合 parseParamter(); } catch (IOException e) { e.printStackTrace(); } } //解析请求参数，把请求参数存储到paramterHashMap集合 private void parseParamter(){ //获取请求的uri String requestURI = this.requestURI; //按照问号进行切割，然后再获取到第二部分 String[] uriInfoArr = requestURI.split(”\\\\?“); //判断数组的长度，如果长度为2，说明是存在请求参数。 if(uriInfoArr.length == 2){ //获取请求参数内容（问号后面的那些参数） String paramterInfo = uriInfoArr[1]; //使用&进行切割 String[] paramterInfoArr = paramterInfo.split(”&“); //遍历数组 //id=1 name=itheima age =23 for (String paramter : paramterInfoArr) { String[] paramterArr = paramter.split(”=“); //获取请求参数名称 String paramterName = paramterArr[0]; //获取请求参数的值 String paramterValue = paramterArr[1]; //添加到集合中 paramterHashMap.put(paramterName,paramterValue); } } } //id=1 name=itheima //可以根据请求参数的名称来获取请求参数的值 public String getParamter(String name){ return paramterHashMap.get(name); } } 1.1.3. 1.3DynamicResourceProcess类代码实现【应用】 实现步骤 获取的uri是包含?后边的数据的,要进行切割,只要?号前边的内容 代码实现 // 此处只给出了新增的代码,其他代码同之前没有变化 public class DynamicResourceProcess { public void process(HttpRequest httpRequest,HttpResponse httpResponse){ //获取请求的uri String requestURI = httpRequest.getRequestURI(); //对requestURI进行切割操作 String[] split = requestURI.split(”\\\\?“); //根据请求的uri到map集合中直接找到对应的servlet的对象 HttpServlet httpServlet = ServletConcurrentHashMap.map.get(split[0]); System.out.println(httpServlet); // ... } } 1.1.4. 1.4StudentServlet类代码实现【应用】 实现步骤 在service方法中获取请求参数中的数据 判断是要添加学生还是修改学生等 调用对应的方法,执行对应的操作 代码实现 @WebServlet(urlPatterns = ”/servlet/studentservlet“) public class StudentServlet implements HttpServlet { @Override public void service(HttpRequest httpRequest, HttpResponse httpResponse) { //获取method请求参数 String method = httpRequest.getParamter(”method“); System.out.println(method); //判断 if (”addStudent“.equals(method)) { //添加学生 addStudent(httpRequest, httpResponse); } else if (”delStudent“.equals(method)) { //删除学生 delStudent(httpRequest, httpResponse); } else if (”updateStudent“.equals(method)) { //修改学生 updateStudent(httpRequest, httpResponse); } else if (”findStudent“.equals(method)) { //查询学生 findStudent(httpRequest, httpResponse); } } //查询学生 private void findStudent(HttpRequest httpRequest, HttpResponse httpResponse) { } //修改学生 private void updateStudent(HttpRequest httpRequest, HttpResponse httpResponse) { } //删除学生 private void delStudent(HttpRequest httpRequest, HttpResponse httpResponse) { } //添加学生 private void addStudent(HttpRequest httpRequest, HttpResponse httpResponse) { } } 1.1.5. 1.5查询学生【应用】 实现步骤 创建StudentService对象 调用StudentService中的findAllStudent方法，完成学生数据的查询操作 遍历数组，拼接成一个字符串 将拼接的结果响应给浏览器 代码实现 @WebServlet(urlPatterns = ”/servlet/studentservlet“) public class StudentServlet implements HttpServlet { //1.创建StudentService对象 private StudentService studentService = new StudentService(); @Override public void service(HttpRequest httpRequest, HttpResponse httpResponse) { //获取method请求参数 String method = httpRequest.getParamter(”method“); System.out.println(method); //判断 if (”addStudent“.equals(method)) { //添加学生 addStudent(httpRequest, httpResponse); } else if (”delStudent“.equals(method)) { //删除学生 delStudent(httpRequest, httpResponse); } else if (”updateStudent“.equals(method)) { //修改学生 updateStudent(httpRequest, httpResponse); } else if (”findStudent“.equals(method)) { //查询学生 findStudent(httpRequest, httpResponse); } } //查询学生 private void findStudent(HttpRequest httpRequest, HttpResponse httpResponse) { //2.调用StudentService中的findAllStudent方法，完成学生数据的查询操作 Student[] allStudent = studentService.findAllStudent(); //3.遍历数组，拼接成一个字符串 StringBuilder sb = new StringBuilder(); for (Student student : allStudent) { sb.append(student.getId()).append(”, “).append(student.getName()). append(”, “).append(student.getAge()).append(”, “). append(student.getBirthday()).append(”“); } String result = sb.toString(); //4.将拼接的结果响应给浏览器 //告诉浏览器响应的类型 httpResponse.setContentTpye(”text/html;charset=UTF-8“); if (result == null || ”“.equals(result)) { httpResponse.write(”暂无学生数据。。。。“); } else { httpResponse.write(result); } } //修改学生 private void updateStudent(HttpRequest httpRequest, HttpResponse httpResponse) { } //删除学生 private void delStudent(HttpRequest httpRequest, HttpResponse httpResponse) { } //添加学生 private void addStudent(HttpRequest httpRequest, HttpResponse httpResponse) { } } 1.1.6. 1.6添加学生【应用】 实现步骤 获取id的请求参数 判断id是否重复 如果重复。给浏览器响应，id已经重复 如果id不重复。添加学生。并给浏览器响应添加学生成功 代码实现 @WebServlet(urlPatterns = ”/servlet/studentservlet“) public class StudentServlet implements HttpServlet { //1.创建StudentService对象 private StudentService studentService = new StudentService(); @Override public void service(HttpRequest httpRequest, HttpResponse httpResponse) { //获取method请求参数 String method = httpRequest.getParamter(”method“); System.out.println(method); //判断 if (”addStudent“.equals(method)) { //添加学生 addStudent(httpRequest, httpResponse); } else if (”delStudent“.equals(method)) { //删除学生 delStudent(httpRequest, httpResponse); } else if (”updateStudent“.equals(method)) { //修改学生 updateStudent(httpRequest, httpResponse); } else if (”findStudent“.equals(method)) { //查询学生 findStudent(httpRequest, httpResponse); } } //查询学生 private void findStudent(HttpRequest httpRequest, HttpResponse httpResponse) { //... } //修改学生 private void updateStudent(HttpRequest httpRequest, HttpResponse httpResponse) { } //删除学生 private void delStudent(HttpRequest httpRequest, HttpResponse httpResponse) { } //添加学生 private void addStudent(HttpRequest httpRequest, HttpResponse httpResponse) { //1.获取id的请求参数 String id = httpRequest.getParamter(”id“); //2.判断id是否重复 boolean exists = studentService.isExists(id); httpResponse.setContentTpye(”text/html;charset=UTF-8“); if (exists) { //3.如果重复。给浏览器响应，id已经重复 httpResponse.write(”id已经存在，请重新输入。。。“); } else { //4.如果id不重复。添加学生。并给浏览器响应添加学生成功 String name = httpRequest.getParamter(”name“); String age = httpRequest.getParamter(”age“); String birthday = httpRequest.getParamter(”birthday“); //对数据进行处理 try { int ageInt = Integer.parseInt(age); SimpleDateFormat sdf = new SimpleDateFormat(”yyyy-MM-dd“); Date date = sdf.parse(birthday); //创建一个学生对象 Student s = new Student(); s.setId(id); s.setName(name); s.setAge(age); s.setBirthday(birthday); //调用studentservice里面的方法 studentService.addStudent(s); //给浏览器响应 httpResponse.write(”学生数据添加成功....“); } catch (ParseException e) { httpResponse.write(”日期格式不正确，正确的格式为:yyyy-MM-dd“); e.printStackTrace(); } catch (NumberFormatException e) { httpResponse.write(”年龄只能为整数“); e.printStackTrace(); } //birthday yyyy-MM-dd } } } 1.2. 2.单元测试 1.2.1. 2.1概述【理解】 JUnit是一个 Java 编程语言的单元测试工具。JUnit 是一个非常重要的测试工具 1.2.2. 2.2特点【理解】 JUnit是一个开放源代码的测试工具。 提供注解来识别测试方法。 JUnit测试可以让你编写代码更快，并能提高质量。 JUnit优雅简洁。没那么复杂，花费时间较少。 JUnit在一个条中显示进度。如果运行良好则是绿色；如果运行失败，则变成红色。 1.2.3. 2.3使用步骤【应用】 使用步骤 将junit的jar包导入到工程中 junit-4.9.jar 编写测试方法该测试方法必须是公共的无参数无返回值的非静态方法 在测试方法上使用@Test注解标注该方法是一个测试方法 选中测试方法右键通过junit运行该方法 代码示例 public class JunitDemo1 { @Test public void add() { System.out.println(2 / 0); int a = 10; int b = 20; int sum = a + b; System.out.println(sum); } } 1.2.4. 2.4相关注解【应用】 注解说明 | 注解 | 含义 | | -—— | ——— | | @Test | 表示测试该方法 | | @Before | 在测试的方法前运行 | | @After | 在测试的方法后运行 | 代码示例 public class JunitDemo2 { @Before public void before() { // 在执行测试代码之前执行，一般用于初始化操作 System.out.println(”before“); } @Test public void test() { // 要执行的测试代码 System.out.println(”test“); } @After public void after() { // 在执行测试代码之后执行，一般用于释放资源 System.out.println(”after“); } } 1.3. 3.日志 1.3.1. 3.1概述【理解】 概述 程序中的日志可以用来记录程序在运行的时候点点滴滴。并可以进行永久存储。 日志与输出语句的区别 | | 输出语句 | 日志技术 | | -— | -———— | ——————— | | 取消日志 | 需要修改代码，灵活性比较差 | 不需要修改代码，灵活性比较好 | | 输出位置 | 只能是控制台 | 可以将日志信息写入到文件或者数据库中 | | 多线程 | 和业务代码处于一个线程中 | 多线程方式记录日志，不影响业务代码的性能 | 1.3.2. 3.2日志体系结构和Log4J【理解】 体系结构 Log4J Log4j是Apache的一个开源项目。 通过使用Log4j，我们可以控制日志信息输送的目的地是控制台、文件等位置。 我们也可以控制每一条日志的输出格式。 通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程。 最令人感兴趣的就是，这些可以通过一个配置文件来灵活地进行配置，而不需要修改应用的代码。 Apache基金会 Apache软件基金会（也就是Apache Software Foundation，简称为ASF），为支持开源软件项目而办的一个非盈利性组织。 1.3.3. 3.3入门案例【应用】 使用步骤 导入log4j的相关jar包 编写log4j配置文件 在代码中获取日志的对象 按照级别设置记录日志信息 代码示例 // log4j的配置文件,名字为log4j.properties, 放在src根目录下 log4j.rootLogger=debug,my,fileAppender ### direct log messages to my ### log4j.appender.my=org.apache.log4j.ConsoleAppender log4j.appender.my.ImmediateFlush = true log4j.appender.my.Target=System.out log4j.appender.my.layout=org.apache.log4j.PatternLayout log4j.appender.my.layout.ConversionPattern=%d %t %5p %c{1}:%L - %m%n # fileAppender��ʾ log4j.appender.fileAppender=org.apache.log4j.FileAppender log4j.appender.fileAppender.ImmediateFlush = true log4j.appender.fileAppender.Append=true log4j.appender.fileAppender.File=D:/log4j-log.log log4j.appender.fileAppender.layout=org.apache.log4j.PatternLayout log4j.appender.fileAppender.layout.ConversionPattern=%d %5p %c{1}:%L - %m%n // 测试类 public class Log4JTest01 { //使用log4j的api来获取日志的对象 //弊端：如果以后我们更换日志的实现类，那么下面的代码就需要跟着改 //不推荐使用 //private static final Logger LOGGER = Logger.getLogger(Log4JTest01.class); //使用slf4j里面的api来获取日志的对象 //好处：如果以后我们更换日志的实现类，那么下面的代码不需要跟着修改 //推荐使用 private static final Logger LOGGER = LoggerFactory.getLogger(Log4JTest01.class); public static void main(String[] args) { //1.导入jar包 //2.编写配置文件 //3.在代码中获取日志的对象 //4.按照日志级别设置日志信息 LOGGER.debug(”debug级别的日志“); LOGGER.info(”info级别的日志“); LOGGER.warn(”warn级别的日志“); LOGGER.error(”error级别的日志“); } } 1.3.4. 3.4配置文件详解【理解】 三个核心 Loggers(记录器) 日志的级别 Loggers组件在此系统中常见的五个级别：DEBUG、INFO、WARN、ERROR 和 FATAL。 DEBUG Log4j有一个规则：只输出级别不低于设定级别的日志信息。 Appenders(输出源) 日志要输出的地方 把日志输出到不同的地方，如控制台（Console）、文件（Files）等。 org.apache.log4j.ConsoleAppender（控制台） org.apache.log4j.FileAppender（文件） Layouts(布局) 日志输出的格式 可以根据自己的喜好规定日志输出的格式 常用的布局管理器： ​ org.apache.log4j.PatternLayout（可以灵活地指定布局模式） ​ org.apache.log4j.SimpleLayout（包含日志信息的级别和信息字符串） org.apache.log4j.TTCCLayout（包含日志产生的时间、线程、类别等信息） 配置根Logger 格式 log4j.rootLogger=日志级别，appenderName1，appenderName2，… 日志级别 OFF、FATAL、ERROR、WARN、INFO、DEBUG、ALL或者自定义的级别。 appenderName1 就是指定日志信息要输出到哪里。可以同时指定多个输出目的地，用逗号隔开。 例如：log4j.rootLogger＝INFO，ca，fa ConsoleAppender常用的选项 ImmediateFlush=true 表示所有消息都会被立即输出，设为false则不输出，默认值是true。 Target=System.err 默认值是System.out。 FileAppender常用的选项 ImmediateFlush=true 表示所有消息都会被立即输出。设为false则不输出，默认值是true Append=false true表示将消息添加到指定文件中，原来的消息不覆盖。 false则将消息覆盖指定的文件内容，默认值是true。 File=D:/logs/logging.log4j 指定消息输出到logging.log4j文件中 PatternLayout常用的选项 ConversionPattern=%m%n 设定以怎样的格式显示消息 1.3.5. 3.5在项目中的应用【应用】 步骤 导入相关的依赖 将资料中的properties配置文件复制到src目录下 在代码中获取日志的对象 按照级别设置记录日志信息 代码实现 @WebServlet(urlPatterns = \"/servlet/loginservlet\") public class LoginServlet implements HttpServlet{ //获取日志的对象 private static final Logger LOGGER = LoggerFactory.getLogger(LoginServlet.class); @Override public void service(HttpRequest httpRequest, HttpResponse httpResponse) { //处理 System.out.println(\"LoginServlet处理了登录请求\"); LOGGER.info(\"现在已经处理了登录请求，准备给浏览器响应\"); //响应 httpResponse.setContentTpye(\"text/html;charset=UTF-8\"); httpResponse.write(\"登录成功\"); } } Copyright © MISIN 2022 | 豫ICP备2021006345号-1 all right reserved，powered by Gitbook该文件修订时间： 2022-11-10 13:09:25 "},"2.JavaWeb/1.Linux/Linux-01.html":{"url":"2.JavaWeb/1.Linux/Linux-01.html","title":"Linux 01 1","keywords":"","body":"1. Linux-v10.0-02天-课堂笔记2. 1 Linux文件管理2.1. 1.1 touch命令2.2. 1.2 vi与vim命令2.2.1. 1.2.1 vi/vim介绍2.2.2. 1.2.2 vi/vim模式2.2.3. 1.2.3 打开和新建文件2.2.4. 1.2.4 三种模式切换2.2.5. 1.2.5 文件查看2.2.6. 1.2.6 vim定位行2.2.7. 1.2.7 异常处理2.2.8. 1.2.8 操作扩展2.3. 1.3 echo 命令2.4. 1.4 awk命令2.5. 1.5 软连接2.6. 1.6 find查找2.7. 1.7 read命令2.8. 1.8 总结3. 2 Linux备份压缩3.1. 2.1 gzip命令3.2. 2.2 gunzip命令3.3. 2.3 tar命令3.4. 2.4 zip命令3.5. 2.5 unzip命令3.6. 2.6 bzip2命令3.7. 2.7 bunzip2命令3.8. 2.8 总结4. 3 网络与磁盘管理4.1. 3.1 网络命令4.1.1. 3.1.1 ifconfig命令4.1.2. 3.1.2 ping命令4.1.3. 3.1.3 netstat命令4.2. 3.2 磁盘命令4.2.1. 3.2.1 lsblk命令4.2.2. 3.2.2 df命令4.2.3. 3.2.3 mount命令4.3. 3.3 总结5. 4 shell与安装5.1. 4.1 yum使用5.1.1. 4.1.1 安装tree5.1.2. 4.1.2 移除tree5.1.3. 4.1.3 yum查找5.1.4. 4.1.4 yum源5.2. 4.2 rpm使用5.3. 4.3 shell使用5.3.1. 4.3.1 shell入门5.3.2. 4.3.2 shell注释5.3.3. 4.3.3 shell变量5.3.4. 4.3.4 shell数组5.3.5. 4.3.5 shell运算符5.3.6. 4.3.6 shell流程控制5.3.7. 4.3.7 shell函数5.3.8. 4.3.8 总结1. Linux-v10.0-02天-课堂笔记 学习目标 能够熟练编写文件相关命令 能够熟练编写文件解压缩命令 能够熟练编写网络查看简单命令 能够熟练编写查看磁盘命令、挂载命令 能够知道如何使用命令进行分区、格式化 能够熟练使用yum进行查找、安装、卸载软件 能够熟练使用rpm进行查找、安装、卸载软件 能够熟练编写常用的shell脚本 2. 1 Linux文件管理 2.1. 1.1 touch命令 在Windows系统中，我们如果想创建一个文本文档或者word文件的时候，通常的做法是 鼠标右键---新建---文本文档，这样的话，我们就成功的创建了一个文件，而在Linux中，我们可以通过字符命令的形式进行创建 touch命令用于创建文件、修改文件或者目录的时间属性，包括存取时间和更改时间。若文件不存在，系统会建立一个新的文件。 ls -l 可以显示档案的时间记录 使用者权限：所有权限用户 语法 touch [-acfm][-d][-r] [-t][--help][--version][文件或目录…] 参数说明： a 改变档案的读取时间记录。 m 改变档案的修改时间记录。 c 假如目的档案不存在，不会建立新的档案。与 --no-create 的效果一样。 f 不使用，是为了与其他 unix 系统的相容性而保留。 r 使用参考档的时间记录，与 --file 的效果一样。 d 设定时间与日期，可以使用各种不同的格式。 t 设定档案的时间记录，格式与 date 指令相同。 --no-create 不会建立新档案。 --help 列出指令格式。 --version 列出版本讯息。 使用 touch 创建一个空文件 在 Linux 系统上使用 touch 命令创建空文件，键入 touch，然后输入文件名。如下所示 touch czbk-devops.txt 查看 ls -l czbk-devops.txt 执行效果如下图 使用 touch 创建批量空文件 在实际的开发过程中可能会出现一些情况，我们必须为某些测试创建大量空文件，这可以使用 touch 命令轻松实现 touch czbk-{1..10}.txt 在上面的例子中，我们创建了 10 个名为 czbk-1.txt到czbk-10.txt` 的空文件，你可以根据需要更改名称和数字 执行查看命令 ls -l 执行效果如下 由上图我们发现，我们通过批量命令创建了10个txt文件 改变/更新文件访问时间 假设我们想要改变名为 czbk-devops.txt 文件的访问时间，在 touch 命令中使用 -a 选项，然后输入文件名。如下所示： 1、我们先 查看下czbk-devops.txt的时间属性 ls -l czbk-devops.txt 执行效果如下 我们发现，最后的访问时间是12月 18 11:34 更新时间属性，如下 touch czbk-devops.txt 执行ls命令查看，如下 ls -l czbk-devops.txt 我们发现，访问时间变成了 12月 18 13:50 我们也可以使用stat命令进行查看，如下： stat czbk-devops.txt 执行效果如下图 由上图可知：czbk-devops.txt的文件属性、包含访问时间、更改时间、最近改动时间都显示出来了。 关于stat命令： stat命令用于显示inode内容。 stat以文字的格式来显示inode的内容。 语法 stat [文件或目录] 2.2. 1.2 vi与vim命令 2.2.1. 1.2.1 vi/vim介绍 使用vi/vim其实就相当于我们在Windows系统中创建文件、打开文件、编辑文件、保存文件操作 1、vi介绍 vi是 visual interface的简称, 是linux中最经典的文本编辑器。 vi的特点 只能是编辑 文本内容, 不能对 字体 段落进行排版 不支持鼠标操作 没有菜单 只有命令 vi编辑器在 系统管理 服务器管理 编辑文件时, 其功能永远不是图形界面的编辑器能比拟的 2、vim介绍 vim:是从 vi （系统内置命令）发展出来的一个文本编辑器。代码补全、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。 简单的来说， vi 是老式的字处理器，不过功能已经很齐全了，但是还是有可以进步的地方。 vim 则可以说是程序开发者的一项很好用的工具。 2.2.2. 1.2.2 vi/vim模式 vi/vim模式主要分为以下三种： 命令模式：在Linux终端中输入“vim 文件名”就进入了命令模式,但不能输入文字。 编辑模式：在命令模式下按i就会进入编辑模式，此时就可以写入程式，按Esc可回到命令模式。 末行模式：在命令模式下按：进入末行模式，左下角会有一个冒号出现，此时可以敲入命令并执行。 下面是三种模式的简单分析图： 上图总结 上面的三种模式简单总结下就是： 1、vim 开始进入时是命令模式 2、按下I的时候会进入编辑模式 3、按下ESC然后在按下：的时候是末行模式 2.2.3. 1.2.3 打开和新建文件 使用vim不但可以打开一个现存的文件；也可以生成（vim后的文件不存在的情况下）一个文件；有点类似于我们在Windows中输入notepad命令一样，我们输入notepad后就会打开一个文本文档，然后进行编辑--另存为。 使用者权限：当前文件的权限用户 在终端中输入vim在后面跟上 文件名 即可 vim txtfile.txt 如果文件已经存在, 会直接打开该文件 如果文件不存在, 保存且退出时 就会新建一个文件 注意 我们通过下面的三种模式切换详细阐述vim的用法 2.2.4. 1.2.4 三种模式切换 1、进入命令模式 上接上面的例子，我们执行下面的命令其实就是进入了命令模式 vim txtfile.txt 执行效果如下图 2、进入编辑模式 上接上面的例子，按i进入插入模式 在 vi 中除了常用 i 进入编辑模式 外, 还提供了一下命令同样可以进入编辑模式 命令 英文 功能 常用 i insert 在当前字符前插入文本 常用 I insert 在行首插入文本 较常用 a append 在当前字符后添加文本 A append 在行末添加文本 较常用 o 在当前行后面插入一空行 常用 O 在当前行前面插入一空行 常用 上图可以表现为以下形式，如下图 执行效果如下图 由上图左下角我们看到【插入】（英文版为INSERT）,说明我们进入了编辑模式 我们在里面插入数据，如下图 因为我们是一个空文件，所以使用【I】或者【i】都可以 如果里面的文本很多，要使用【A】进入编辑模式，即在行末添加文本 3、进入末行模式 编辑模式不能保存文件 必须先推到命令模式 先按Esc键退出到命令模式 然后按小写的:wq 正常保存退出 进入末行模式—》按符号： 鼠标跑到屏幕的最后一行，执行效果如下图 然后按小写的:wq 正常保存退出 退出后显示【已写入】 以下为其他的退出模式： :q 当vim进入文件没有对文件内容做任何操作可以按\"q\"退出 :q! 当vim进入文件对文件内容有操作但不想保存退出 :wq 正常保存退出 :wq! 强行保存退出，只针对与root用户或文件所有人生 总结 三种模式的切换，其实就完成了文件创建、编辑、保存、退出四个步骤 那么接下来，我们学习下一个命令 查看刚才新创建的文件 2.2.5. 1.2.5 文件查看 比如查看一个txt文档，在windows中，我们通常是打开一个文件，通过鼠标滚动查看文件不同节选的内容，而在Linux中，通过下面的命令，可以减少在Windows中手工查找的步骤，在Linux中通过命令+参数的形式进行定位查看、搜索查看 以下5个为文件查看命令，我们只讲4个常用的命令，head不在赘述 序号 命令 对应英文 作用 01 cat 文件名 concatenate 查看小文件内容 02 less -N 文件名 less 分频 显示大文件内容 03 head -n 文件名 查看文件的前一部分 04 tail -n 文件名 查看文件的最后部分 05 grep 关键字 文件名 grep 根据关键词, 搜索文本文件内容 总结： 以上5个命令都可以查询文件的内容，他们的功能如下 通过 cat 会一次显示所有的内容, 适合 查看内容较少 的文本文件 less 命令适合查看 内容较多 的文本文件 通过 head 命令查看文档的前几行内容 通过 tail -10f 文件 命令 查看文档(日志)的后几行内容 通过 grep 命令 搜索存在 关键字 的行 1) cat命令 使用cat命令类似于我们在Windows中查看小型（太大的时候打开会卡死）的文件，cat常用的功能其实就等价于Windows中的 txt---打开--查看 cat 是一个文本文件查看和连接工具。查看一个文件的内容，用cat比较简单，就是cat 后面直接接文件名，如cat txtFiles.txt 使用者权限：当前文件的权限用户 语法格式 cat [-AbeEnstTuv] [--help] [--version] fileName 查看文件名为txtfile.txt的内容 cat txtfile.txt 执行效果如下图 查看文件名为txtfile.txt的内容（加入行号） cat -n txtfile.txt 执行效果如下图 2) grep命令 grep命令在使用的时候类似于我们的程序中的查询，或者在txt文档中通过ctr+f查找 grep除了能对文件操作为还可以查看我们的进程信息，类似于我们在Windows系统的任务管理器（任务栏--右键---启动任务管理器--进程）下的进程 grep 指令用于查找内容包含指定的范本样式的文件，如果发现某文件的内容符合所指定的范本样式，预设 grep 指令会把含有范本样式的那一列显示出来。若不指定任何文件名称，或是所给予的文件名为 -，则 grep 指令会从标准输入设备读取数据。 grep 命令用于查找文件里符合条件的字符串，语法如下： grep [-abcEFGhHilLnqrsvVwxy][-A][-B][-C][-d][-e][-f][--help][范本样式][文件或目录...] 使用者权限：当前文件的权限用户 我们还是使用上面的txtfile.txt文件，如下图 为了测试效果，我们新增了其他数据 增加过程不在赘述 1、搜索 存在关键字【eeee】 的行的文件 grep eeee txtfile.txt 执行效果如下 2、搜索 存在关键字【eeee】 的行 且 显示行号 grep -n eeee txtfile.txt 3、忽略大小写 搜索 存在关键字 的行 grep -i EEEE txtfile.txt 执行效果如下 4、搜索 不存在关键字 的行 grep -v 中国 txtfile.txt 执行效果如下 5、查找指定的进程信息（包含grep进程） ps -ef | grep sshd 执行效果如下 说明 除最后一条记录外，其他的都是查找出的进程；最后一条记录结果是grep进程本身，并非真正要找的进程 6、查找指定的进程信息（不包含grep进程） ps aux | grep sshd | grep -v \"grep\" 执行效果如下 7、查找进程个数 ps -ef|grep -c sshd 执行效果如下 由上图可知sshd的进程个数为4（包含grep进程本身） 3) tail命令 tail命令类似于我们在windows中通过鼠标手工查找，比如查看文件最后10行，从第2行一直查看到文件末尾，或者只查看文件末尾的一些信息，这些windows中都是通过人为干预的方式进行查找，在Linux中我们可以通过tail命令实现 tail 命令可用于查看文件的内容，有一个常用的参数 -f 常用于查阅正在改变的日志文件。 tail -f filename 会把 filename 文件里的最尾部的内容显示在屏幕上，并且不断刷新，只要 filename 更新就可以看到最新的文件内容。 使用者权限：当前文件的权限用户 命令格式： tail [参数] [文件] 1、要显示 txtfile.txt 文件的最后 3 行，请输入以下命令： tail -3 txtfile.txt 原始文件内容如下 最后3行内容如下 2、动态显示文档的最后内容,一般用来查看日志，请输入以下命令： tail -f txtfile.txt 执行效果如下： 此命令显示 txtfile.txt 文件的最后 10 行。当将某些行添加至 txtfile.txt 文件时，tail 命令会继续显示这些行。 显示一直继续，直到您按下（Ctrl-C）组合键停止显示。 如果要显示最后4行，命令如下： tail -4f txtfile.txt 执行效果如下 3、显示文件txtfile.txt 的内容，从第 2 行至文件末尾 tail -n +2 txtfile.txt 执行效果如下 4、显示文件 txtfile.txt的最后 10 个字符: tail -c 45 txtfile.txt 执行效果如下 总结 在tail使用的过程中，我们使用最多的就是查看文件末尾多多少行 使用tail -nf txtfile.txt 通常都是在查看日志信息（报错调试时使用） 4）less命令 less命令也是查看文件的，只不过它适合查看 内容较多的文本文件，它也可以用于分屏显示文件内容, 每次只显示一页内容，有点类似我们做分页查询 less用于查看文件，但是less 在查看之前不会加载整个文件。 使用者权限：当前文件的权限用户 语法 less [参数] 文件 1、查看txtfile.txt文件 less txtfile.txt 执行效果如下 2、查看命令历史使用记录并通过less分页显示 [itcast@localhost ~]$ history | less 1 ifconfig 2 reboot 3 ifconfig 4 reboot 5 ifconfig 6 su root 7 ifconfig 8 ping www.baidu.com 9 \\ 10 ifconfig 11 date 12 hwclock --systohc 13 su root ......略 我们输入【j】可以前进行 ​ 输入【k】可以后退行 ​ 输入【G】可以 移动到最后一行 ​ 输入【g】可以移动到第一行 ​ 输入【ctrl + F】 向前移动一屏(类似于我们在浏览器中的数据分页的下一页) ​ 输入【ctrl + B】 向后移动一屏(类似于我们在浏览器中的数据分页的上一页) 其他命令 1.全屏导航 ctrl + F - 向前移动一屏 ctrl + B - 向后移动一屏 ctrl + D - 向前移动半屏 ctrl + U - 向后移动半屏 2.单行导航 j - 向前移动一行 k - 向后移动一行 3.其它导航 G - 移动到最后一行 g - 移动到第一行 q / ZZ - 退出 less 命令 2.2.6. 1.2.6 vim定位行 在日常工作中,有可能会遇到打开一个文件,并定位到指定行的情况 例如: 在开发时, 知道某一行代码有错误,可以快速定位到出错误代码的位置 这个时候,可以使用以下命令打开文件 由于我们这里还没有学到上传文件的命令，所以我们这里还是使用上面的txtfile.txt例子，我们打开文件定位到第6行，如下： vim txtfile.txt +6 执行效果如下图 2.2.7. 1.2.7 异常处理 如果 vim异常退出, 在磁盘上可能会保存有 交换文件 下次再使用 vim 编辑文件时, 会看到以下屏幕信息, 解决方案： 将后缀名为.swp的文件删除即可恢复 再次编辑文件不在出现提示警告！ 2.2.8. 1.2.8 操作扩展 要熟练使用vi/vim, 首先应该学会怎么在 命令模式下 快速移动光标 编辑操作命令 能够和移动命令一起使用 1) 上 下 左 右 命令 功能 手指 h 向左 食指 j 向下 食指 k 向上 中指 l 向右 无名指 也可以使用键盘上的上下左右箭头，这个更有方向感。 2) 行内移动 命令 英文 功能 w word 向后移动一个单词 b back 向前移动一个单词 0 行首 ^ 行首, 第一个不是空白字符的位置 $ 行尾 3) 行数移动 命令 英文 功能 gg go 文件顶部 G go 文件末尾 数字gg go 移动到 数字 对应行数 数字G go 移动到 数字 对应行数 : 数字 移动到数字对应的 行数 4) 屏幕移动 命令 英文 功能 Ctrl + b back 向上翻页 Ctrl + f forward 向下翻页 H Head 屏幕顶部 M Middle 屏幕中间 L Low 屏幕底部 5) 选中文本(可视模式) 学习 复制 命令前, 应该先学会 怎么样选中 要复制的代码 在 vi/vim 中要选择文本, 需要显示 visual 命令切换到 可视模式 vi/vim 中提供了 三种 可视模式, 可以方便程序员的选择 选中文本的方式 按 ESC 可以放弃选中, 返回到 命令模式 命令 模式 功能 v 可视模式 从光标位置开始按照正常模式选择文本 V 可视化模式 选中光标经过的完整行 Ctrl + v 可是块模式 垂直方向选中文本 6) 撤销和恢复撤销(保命指令) 在学习编辑命令之前,先要知道怎样撤销之前一次 错误的 编辑操作 命令 英文 功能 u undo 撤销上次的命令(ctrl + z) Ctrl + r uredo 恢复撤销的命令 7) 删除文本 命令 英文 功能 x cut 删除光标所在的字符,或者选中的文字 d(移动命令) delete 删除移动命令对应的内容 dd delete 删除光标所在行, 可以删除多行 D delete 删除至行尾 提示: 如果使用 可视模式 已经选中了一段文本, 那么无论使用 d 还是 x, 都可以删除选中文本 删除命令可以和移动命令连用, 以下是常见的组合命令(扩展): 命令 作用 dw 从光标位置删除到单词末尾 d} 从光标位置删除到段落末尾 ndd 从光标位置向下连续删除 n 行 8) 复制和剪切 vi/vim 中提供有一个 被复制文本的缓冲区 复制 命令会将选中的文字保存在缓冲区 删除 命令删除的文字会被保存在缓冲区 在需要的位置, 使用 粘贴 命令可以将缓冲对的文字插入到光标所在的位置 命令 英文 功能 yy copy 复制行 d(剪切命令) delete 剪切 dd(剪切) delete 剪切一行, 可以 ndd 剪切n行 p paste 粘贴 提示: 命令 d 、x 类似于图形界面的 剪切操作 -- ctrl + x 命令 y 类似于 图形界面的 复制操作 -- Ctrl + 命令 p 类似于图形界面的 粘贴操作 -- Ctrl + v vi中的文本缓冲区只有一个,如果后续做过 复制、剪切操作, 之前缓冲区中的内容会被替换. 注意 vi中的 文本缓冲区 和 系统的 剪切板 不是同一个 所以在其他软件中使用 Ctrl + C 复制的内容, 不能再 vi 中通过 p 命令粘贴 可以在 编辑模式 下使用 鼠标右键粘贴 9) 替换 命令 英文 功能 工作模式 r replace 替换当前字符 命令模式 R replace 替换当前行光标后的字符 替换模式 R 命令可以进入 替换模式, 替换完成后, 按下ESC , 按下 ESC 可以回到 命令模式 替换命令 的作用就是不用进入 编辑模式, 对文件进行 轻量级的修改 10) 缩排和重复执行 命令 功能 >> 向右增加缩进 向左减少缩进 . 重复上次命令 缩进命令 在开发程序时, 统一增加代码的缩进 比较有用! 一次性 在选中代码前增加 4 个空格, 就叫做 增加缩进 一次性 在选中代码前删除 4 个空格, 就叫做 较少缩进 在 可视模式 下, 缩排命令 主需要使用 一个 > 或者 在程序中, 缩进 通常用来表示代码的归属关系 前面空格越少, 代码的级别越高 前面空格越多, 代码的级别越低 11) 查找 常规查找 命令 功能 /str 查找str 查找到指定内容之后, 使用 Next 查找下一个出现的位置 n : 查找下一个 N : 查找上一个 如果不想看到高亮显示, 可以随便查找一个文件中不存在的内容即可 单词快速匹配 命令 功能 * 向后查找当前光标所在单词 # 向前查找当前光标所在单词 在开发中, 通过单词快速匹配, 可以快速看到这个单词在其他位置使用过 12) 查找并替换 在 vi/vim 中查找和替换命令需要在 末行模式 下执行 记忆命令格式 :%s///g 1) 全局替换 一次向 替换文件中的 所有出现的旧文本 命令格式如下 :%s/旧文本/新文本/g 2) 可视区域替换 先选中 要替换文字的 范围 命令格式如下 :s/旧文本/新文本/g 3) 确认替换： c confirm 确认 如果把末尾的 g 改成 gc 在替换的时候, 会有提示! 推荐使用 命令格式如下 :%s/旧文本/新文本/gc y - yes 替换 n - no 不替换 a - all 替换所有 q -quit 退出替换 l - last 最后一个, 并把光标移动到行首 ^E 向下滚屏 ^Y 向上滚屏 2.3. 1.3 echo 命令 echo命令有点类似于我们在java se阶段学习的 System.out.print(\"hello\") 但是，echo还有一个功能就是追加文件内容到文件，类似于我们在java se阶段学习的append文件流写入一样 使用者权限：所有用户 echo string 将字符串输出到控制台 , 通常和 重定向 联合使用 echo hello world # 如果字符串有空格, 为了避免歧义 请增加 双引号 或者 单引号 echo \"hello world\" 6.3 重定向 >(覆盖) 和 >> (追加) 默认情况下 命令的结果 输出到 控制台 通过 重定向 可以将结果 输出到文件 6.2.3 实现 第一步: 将命令的成功结果 覆盖 指定文件内容 echo 传智博客 >czbk-txt.txt 执行结果如下（czbk-txt.txt文件如果没有会自动创建） 命令 作用 结果 > 文件名 > 表示输出, 会覆盖文件的原有内容 第二步: 将命令的成功结果 追加 指定文件的后面 echo 黑马程序员 >> czbk-txt.txt 执行结果如下 命令 作用 命令 >> 文件名 >> 表示追加, 会将内容追加到已有文件的末尾 第三步: 将命令的失败结果 追加 指定文件的后面 cat 不存在的目录 &>> error.log 执行效果如下 命令 作用 命令 &>> 文件 &>> 表示不区分错误类型 都放到 日志中 总结 通过 命令 > 文件 将命令的成功结果 覆盖 指定文件内容 通过 命令 >> 文件 将命令的成功结果 追加 指定文件的后面 通过 命令 &>> 文件 将 命令的失败结果 追加 指定文件的后面 2.4. 1.4 awk命令 AWK是一种处理文本文件的语言，是一个强大的文本分析工具。 之所以叫AWK是因为其取了三位创始人 Alfred Aho，Peter Weinberger, 和 Brian Kernighan 的 Family Name 的首字符。 具体语法如下 awk [选项参数] 'script' var=value file(s) 或 awk [选项参数] -f scriptfile var=value file(s) 1、数据准备：czbk-txt.txt文本内容如下： zhangsan 68 99 26 lisi 98 66 96 wangwu 38 33 86 zhaoliu 78 44 36 maq 88 22 66 zhouba 98 44 46 2、搜索含有 zhang 和 li 的学生成绩： cat czbk-txt.txt | awk '/zhang|li/' 执行效果如下 指定分割符, 根据下标显示内容 命令 含义 awk -F ',' '{print $1, $2, $3}' 文件 操作1.txt文件, 根据 逗号 分割, 打印 第一段 第二段 第三段 内容 选项 选项 英文 含义 -F ',' field-separator 使用 指定字符 分割 $ + 数字 获取第几段内容 $0 获取 当前行 内容 NF field 表示当前行共有多少个字段 $NF 代表 最后一个字段 $(NF-1) 代表 倒数第二个字段 NR 代表 处理的是第几行 # 查看文档内容 cat czbk-txt.txt #直接输出 cat score.txt | awk -F ' ' '{print $1,$2,$3}' 执行效果如下 指定分割符, 根据下标显示内容 命令 含义 awk -F ' ' '{OFS=\"===\"}{print $1, $2, $3}' 1.txt 操作1.txt文件, 根据 逗号 分割, 打印 第一段 第二段 第三段 内容 选项 选项 英文 含义 OFS=\"字符\" output field separator 向外输出时的段分割字符串 转义序列 含义 \\b 退格 \\f 换页 \\n 换行 \\r 回车 \\t 制表符 # 按照 === 进行分割, 打印 第一段 第二段 第三段 cat czbk-txt.txt | awk -F ' ' '{OFS=\"===\"}{print $1,$2,$3}' # 按照 制表符tab 进行分割, 打印 第一段 第二段 第三段 cat czbk-txt.txt| awk -F ' ' '{OFS=\"\\t\"}{print $1,$2,$3}' 执行效果如下 调用 awk 提供的函数 命令 含义 awk -F ',' '{print toupper($2)}' 1.txt 操作1.txt文件, 根据 逗号 分割, 打印 第一段 第二段 第三段 内容 常用函数如下: 函数名 含义 作用 toupper() upper 字符 转成 大写 tolower() lower 字符 转成小写 length() length 返回 字符长度 # 打印第一段内容 cat czbk-txt.txt | awk -F ' ' '{print $1}' # 将第一段内容转成大写 且 显示 cat czbk-txt.txt | awk -F ' ' '{print toupper($1)}' 执行效果如下 求指定学科平均分 命令 含义 awk 'BEGIN{初始化操作}{每行都执行} END{结束时操作}' 文件名 BEGIN{ 这里面放的是执行前的语句 }{这里面放的是处理每一行时要执行的语句}END {这里面放的是处理完所有的行后要执行的语句 } 查看czbk-txt.txt 文件内容 cat czbk-txt.txt 执行效果如下 查看总分 注意：这里计算的是第4列的总分 cat czbk-txt.txt| awk -F ' ' 'BEGIN{}{total=total+$4} END{print total}' 执行效果如下 查看总分, 总人数 注意：这里计算的是第4列的 cat czbk-txt.txt| awk -F ' ' 'BEGIN{}{total=total+$4} END{print total, NR}' 执行效果如下 查看总分, 总人数, 平均分 注意：这里计算的是第4列的 cat czbk-txt.txt | awk -F ' ' 'BEGIN{}{total=total+$4} END{print total, NR, (total/NR)}' 执行效果如下 总结 awk在使用过程中主要用作分析 简单来说awk就是把文件逐行的读入，以空格为默认分隔符将每行切片，切开的部分再进行各种分析处理 2.5. 1.5 软连接 软连接其实就类似于我们在Windows中的【快捷方式】 在Linux文件名 和 内容 是两个文件, 分开的! 创建软链接的原理, 如下 为什么有软连接？ 因为 某些文件和目录 的 路径很深, 所以 需要增加 软链接(快捷方式) 使用者权限：所有用户 语法如下: 命令 英文 作用 ln -s 目标文件绝对路径 快捷方式路径 link 给目标文件增加一个软链接, 通俗讲就是快捷方式 给home/itcast/txtfile.txt文件增加软连接 ln -s /home/itcast/txtfile.txt czbk-txt 上面；我们将/home/itcast/路径下的txtfile.txt文件增加软连接到 czbk-txt，然后通过cat 访问czbk-txt也是可以正常访问的 如下图 总结 通过 `ln -s 源文件的绝对路径 其实就是给目标文件 增加 快捷方式 2.6. 1.6 find查找 引子 find命令类似与在Windows中全局查找（如下图） find概念 find命令用来在指定目录下查找文件。 任何位于参数之前的字符串都将被视为欲查找的目录名。如果使用该命令时，不设置任何参数，则find命令将在当前目录下查找子目录与文件。并且将查找到的子目录和文件全部进行显示。 语法 find 1、将目前目录及其子目录下所有延伸档名是 gz 的文件查询出来 find . -name \"*.gz\" 执行效果如下图 2、将目前目录及其子目录下所有最近 1天内更新过的文件查询出来 find . -ctime -1 执行效果如下 3、全局搜索czbk /代表是全盘搜索,也可以指定目录搜索 find / -name 'czbk' 执行效果如下 2.7. 1.7 read命令 注意： read命令属于文件范畴的命令 在下面的演示中，会涉及到shell，shell章节在最后一章 建议：讲解shell的时候在回过来说下read命令的语法 我们在综合案例中也会降到read 引子： read命令相当于在java SE阶段我们学习的键盘录入输入Scanner（read命令会比Scanner更强大），开发人员可以动态的与程序交互， read命令用于从标准输入读取数值。 read 内部命令被用来从标准输入读取单行数据。这个命令可以用来读取键盘输入，当使用重定向的时候，可以读取文件中的一行数据。 语法 read [-ers] [-a aname] [-d delim] [-i text] [-n nchars] [-N nchars] [-p prompt] [-t timeout] [-u fd] [name ...] 1、简单读取 #!/bin/bash echo \"请您输入网站名: \" #读取从键盘的输入 read website echo \"你输入的网站名是 $website\" exit 0 #退出 执行效果如下 3、读取文件 每次调用 read 命令都会读取文件中的 \"一行\" 文本。当文件没有可读的行时，read 命令将以非零状态退出。 我们可以使用 cat 命令将结果直接传送给包含 read 命令的 while 命令。 测试文件 test.txt 内容如下： AAAAAAAAAAAAAAAAAAAAAA BBBBBBBBBBBBBBBBBBBBBB CCCCCCCCCCCCCCCCCCCCCC DDDDDDDDDDDDDDDDDDDDDD ================传智播客 脚本如下，可以将脚本放到xxx.sh中进行执行 #!/bin/bash count=1 cat test.txt | while read line # cat 命令的输出作为read命令的输入,read读到>的值放在line中 do echo \"Line $count:$line\" count=$[ $count + 1 ] # 注意中括号中的空格。 done echo \"finish\" exit 0 执行效果如下 总结 由此可看read命令不仅可以读取键盘输入，而且还可以读取静态文件 2.8. 1.8 总结 文件命令是我们在开发过程中最经常使用的到的命令，所以，我们在学习过程中一定要认真学习文件的常用命令，比如文件创建、编写、读取命令。 3. 2 Linux备份压缩 在Windows中我们对于一个大文件进行压缩的时候，通常会使用第三方工具，比如360压缩、快压等工具，把一个文件压缩成.zip格式的压缩文件；而在Linux中我们也可以通过各种命令实现压缩的功能。 3.1. 2.1 gzip命令 压缩/解压缩文件，不能压缩目录 windows下接触的压缩文件大多是.rar，.7z格式，Linux下，不能识别这种格式。 .zip格式的文件在Windows和Linux下都能使用。 压缩文件，能节省磁盘空间，传输时能节省网络带宽 gzip命令用于压缩文件。 gzip是个使用广泛的压缩程序，文件经它压缩过后，其名称后面会多出\".gz\"的扩展名 使用者权限：所有用户 语法 gzip[参数][文件或者目录] 1、压缩目录下的所有文件 数据准备，新建一个目录，里面随便新建4个文件 mkdir gzipTest cd gzipTest/ touch 001 touch 002 touch 003 touch 004 执行效果如下 1、压缩目录下的所有文件 gzip * 2、 列出详细的信息 解压文件并列出详细信息 gzip -dv * 执行效果如下图 3.2. 2.2 gunzip命令 gunzip是个使用广泛的解压缩程序，它用于解开被gzip压缩过的文件 gunzip命令用于解压文件。 语法 gunzip[参数][文件或者目录] gunzip 001.gz 执行效果如下图 001为解压后的文件 3.3. 2.3 tar命令 tar的主要功能是打包、压缩和解压文件。 tar本身不具有压缩功能。他是调用压缩功能实现的 。 使用者权限：所有用户 语法 tar[必要参数][选择参数][文件] 1、将 txtfile.txt文件打包（仅打包，不压缩） txtfile.txt文件为上面章节的例子 tar -cvf txt.tar txtfile.txt 执行效果如下 2、将 txtfile.txt文件打包压缩（打包压缩（gzip）） tar -zcvf txt.tar.gz txtfile.txt 执行效果如下 总结 参数 f 之后的文件档名是自己取的，我们习惯上都用 .tar 来作为辨识。 如果加 z 参数，则以 .tar.gz 或 .tgz 来代表 gzip 压缩过的 tar包 3、查看tar中有哪些文件 tar -ztvf txt.tar.gz 执行效果如下 压缩包中的文件有txtfile.txt 4、将tar 包解压缩 1.新建目录 mkdir ysFiles 2.复制 cp txt.tar.gz ./ysFiles/ 3.解压缩 tar -zxvf /home/itcast/ysFiles/txt.tar.gz 解压后的文件如下 3.4. 2.4 zip命令 引子 zip命令就完全的相当于在Windows下面选中文件右键进行压缩了 zip命令用于压缩文件。 zip是个使用广泛的压缩程序，文件经它压缩后会另外产生具有\".zip\"扩展名的压缩文件。 使用者权限：所有用户 语法 zip[必要参数][选择参数][文件] 将上面/home/itcast/gzipTest 这个目录下所有文件和文件夹打包为当前目录下的 zFiles.zip： 1.在目录下新建一个005目录 mkdir 005 执行效果如下 开始压缩 2.压缩 zip -q -r zFiles.zip * 执行效果如下 zFiles.zip文件就是我们刚刚压缩后的文件 3.5. 2.5 unzip命令 引子 unzip命令就完全的相当于在Windows下面选中文件右键进行解压缩了 Linux unzip命令用于解压缩zip文件 unzip为.zip压缩文件的解压缩程序 使用者权限：所有用户 语法 unzip[必要参数][选择参数][文件] 参数： 上接上面的zip的例子 1、查看压缩文件中包含的文件： unzip -l zFiles.zip 包含了压缩文件里面文件的详细信息 文件大小 日期 时间 文件名称 总数量和总大小 2、如果要把文件解压到指定的目录下，需要用到-d参数 1.新建目录 unFiles 2.解压缩 unzip -d ./unFiles zFiles.zip 执行效果如下 查看解压后的文件，如下图 3.6. 2.6 bzip2命令 引子 \".bz2\"格式是 Linux 的另一种压缩格式，从理论上来讲，\".bz2\"格式的算法更先进、压缩比更好；而 咱们上面学到的\".gz\"格式相对来讲时间更快 在使用过程中可以根据需求自由选择 bzip2命令是.bz2文件的压缩程序。 bzip2采用新的压缩演算法，压缩效果比传统的LZ77/LZ78压缩演算法来得好。若没有加上任何参数，bzip2压缩完文件后会产生.bz2的压缩文件，并删除原始的文件。 使用者权限：所有用户 语法 bzip2 [-cdfhkLstvVz][--repetitive-best][--repetitive-fast][- 压缩等级][要压缩的文件] 1、压缩文件 1.创建目录 mkdir bzFiles cd ./bzFiles/ 2.创建文件 touch 001 3.压缩 bzip2 001 ll 执行效果如下 如上图001.bz2就是压缩后的文件 3.7. 2.7 bunzip2命令 引子 Linux bunzip2命令是.bz2文件的解压缩程序。 使用者权限：所有用户 语法： bunzip2 [-fkLsvV][.bz2压缩文件] 参数： 解压.bz2文件 bunzip2 -v 001.bz2 执行效果如下图 001文件即是被解压后的 3.8. 2.8 总结 gz：由gzip压缩工具压缩的文件。 .bz2：由bzip2压缩工具压缩的文件。 .tar：由tar打包程序打包的文件（tar没有压缩功能，只是把一个 目录合并成一个文件） .tar.gz：可理解为先由tar打包，再由gz压缩。 .zip:可理解为由zip压缩工具直接压缩 4. 3 网络与磁盘管理 Tips: 重点讲解内容 4.1. 3.1 网络命令 4.1.1. 3.1.1 ifconfig命令 引子： ifconfig命令有点类似于Windows的ipconfig命令 ifconfig是Linux中用于显示或配置网络设备的命令，英文全称是network interfaces configuring ifconfig命令用于显示或设置网络设备。 ifconfig可设置网络设备的状态，或是显示目前的设置。 使用者权限：所有（设置级别的需要管理员）用户 语法 ifconfig [网络设备][down up -allmulti -arp -promisc][add][del][][io_addr][irq][media][mem_start][metric][mtu][netmask][tunnel][-broadcast][-pointopoint][IP地址] 1、显示激活的网卡信息 ifconfig 执行效果如下 ens33（有的是eth0）表示第一块网卡。 表示ens33网卡的 IP地址是 192.168.23.129，广播地址，broadcast 192.168.23.255，掩码地址netmask:255.255.255.0 ，inet6对应的是ipv6 ens37 表示第二块网卡 lo 是表示主机的回坏地址，这个一般是用来测试一个网络程序，但又不想让局域网或外网的用户能够查看，只能在此台主机上运行和查看所用的网络接口 启动关闭指定网卡 virbr0是一种虚拟网络接口 2、关闭网卡（需要切换到管理员账户） ifconfig ens37 down 执行效果如下 3、启用网卡（需要切换到管理员账户） ifconfig ens37 up 执行效果如下 4、配置ip信息 // 配置ip地址 ifconfig ens37 192.168.23.199 // 配置ip地址和子网掩码 ifconfig ens37 192.168.23.133 netmask 255.255.255.0 执行效果如下，配置ip地址： 查看ip，如下图 配置ip地址和子网掩码，执行效果如下图 这样的话我们就可以通过命令的方式设置网卡的网络信息了。 4.1.2. 3.1.2 ping命令 等价于Windows的ping命令 ping命令用于检测主机。 执行ping指令会使用ICMP传输协议，发出要求回应的信息，若远端主机的网络功能没有问题，就会回应该信息，因而得知该主机运作正常。 使用者权限：所有用户 语法 ping [-dfnqrRv][-c][-i][-I][-l][-p][-s][-t][主机名称或IP地址] 1、检测是否与主机连通 ping www.baidu.com 执行效果如下 icmp_seq：ping序列，从1开始 ttl:IP生存时间值 time: 响应时间,数值越小，联通速度越快 2、指定接收包的次数 和上面不同的是：收到两次包后，自动退出 ping -c 2 www.baidu.com 执行效果如下图 总结： ping命令也是我们在开发过程中常用到的命令 通常使用 ping xxx.xxx.xxx.xxx命令进行检测本地与目标机器是否连通 4.1.3. 3.1.3 netstat命令 利用netstat指令可让你得知整个Linux系统的网络情况 netstat命令用于显示网络状态。 使用者权限：所有用户 语法 netstat [-acCeFghilMnNoprstuvVwx][-A][--ip] 1、显示详细的连接状况 netstat -a 执行效果如下 比如上面的【0 0.0.0.0:ssh】它是远程终端连接Linux的ssh服务，默认使用了22端口，它的状态【State】是处于监听状态，属于正常。 2、显示网卡列表 netstat -i 执行效果如下 上图显示的是我们在介绍【ifconfig】命令的时候看到的网卡信息 4.2. 3.2 磁盘命令 4.2.1. 3.2.1 lsblk命令 使用lsblk命令可以以tree的形式展示所有设备的信息 lsblk命令的英文是“list block”，即用于列出所有可用块设备的信息，而且还能显示他们之间的依赖关系，但是它不会列出RAM盘的信息。 语法格式：lsblk [参数] 使用者权限：所有用户 1、lsblk命令默认情况下将以树状列出所有块设备： lsblk 执行效果如下图 NAME : 这是块设备名。 MAJ:MIN : 本栏显示主要和次要设备号。 RM : 本栏显示设备是否可移动设备。注意，在上面设备sr0的RM值等于1，这说明他们是可移动设备。 SIZE : 本栏列出设备的容量大小信息。 RO : 该项表明设备是否为只读。在本案例中，所有设备的RO值为0，表明他们不是只读的。 TYPE :本栏显示块设备是否是磁盘或磁盘上的一个分区。在本例中，sda和sdb是磁盘，而sr0是只读存储（rom）。 MOUNTPOINT : 本栏指出设备挂载的挂载点。 2、默认选项不会列出所有空设备： lsblk -f 执行效果如下图 NAME表示设备名称 FSTYPE表示文件类型 LABEL表示设备标签 UUID设备编号 MOUNTPOINT表示设备的挂载点 注意 我们学习这个命令主要是在下面将要学习的fdisk分区中会经常使用到 4.2.2. 3.2.2 df命令 引子（如下图）： Linux的df命令类似于在Windows中的【计算机】--【管理】--【磁盘管理】菜单对磁盘的统计情况查看 df命令用于显示目前在Linux系统上的文件系统的磁盘使用情况统计。 使用者权限：所有用户 语法 df [选项]... [FILE]... 1、显示磁盘使用情况统计情况 df 执行效果如下图 第一列指定文件系统的名称 第二列指定一个特定的文件系统1K-块1K是1024字节为单位的总容量。 已用和可用列分别指定的容量。 最后一个已用列指定使用的容量的百分比 最后一栏指定的文件系统的挂载点。 2、df命令也可以显示磁盘使用的文件系统信息 比如我们df下之前创建过的目录gzipTest的使用情况 df gzipTest/ 执行效果如下图 3、df显示所有的信息 df --total 执行效果如下图 我们看到输出的末尾，包含一个额外的行，显示总的每一列。 4、df换算后显示 df -h 执行效果如下图 我们可以看到输出显示的数字形式的'G'（千兆字节），\"M\"（兆字节）和\"K\"（千字节）。 这使输出容易阅读和理解，从而使显示可读的。请注意，第二列的名称也发生了变化，为了使显示可读的\"容量\"。 4.2.3. 3.2.3 mount命令 在Linux当中所有的存储设备如u盘、光盘、硬盘等，都必须挂载之后才能正常使用。 其实挂载可以理解为Windows当中的分配盘符（重要），只不过windows当中是以英文字母ABCD等作为盘符，而linux是拿系统目录作为盘符，当然linux当中也不叫盘符，而是称为挂载点，而把为分区或者光盘等存储设备分配一个挂载点的过程称为挂载 mount命令是经常会使用到的命令，它用于挂载Linux系统外的文件。 挂载概念 在安装linux系统时设立的各个分区，如根分区、/boot分区等都是自动挂载的，也就是说不需要我们人为操作，开机就会自动挂载。但是光盘、u盘等存储设备如果需要使用，就必须人为的进行挂载。 其实我们在windows下插入U盘也是需要挂载(分配盘符)的，只不过windows下分配盘符是自动的 Linux中的根目录以外的文件要想被访问，需要将其“关联”到根目录下的某个目录来实现，这种关联操作就是“挂载”，这个目录就是“挂载点”，解除次关联关系的过程称之为“卸载”。 注意：“挂载点”的目录需要以下几个要求： （1）目录事先存在，可以用mkdir命令新建目录； （2）挂载点目录不可被其他进程使用到； （3）挂载点下原有文件将被隐藏。 使用者权限：所有用户，设置级别的需要管理员 语法 mount [-hV] mount -a [-fFnrsvw] [-t vfstype] mount [-fnrsvw] [-o options [,...]] device | dir mount [-fnrsvw] [-t vfstype] [-o options] device dir 需求: 比如现在我们要通过挂载的方式查看Linux CD/DVD光驱里面的内容 1、CD/DVD设置 进入【虚拟机】--【设置】 设置CD/DVD的内容，我们这里使用的是F:\\CentOS-7-x86_64-DVD-1810.iso 查看F:\\CentOS-7-x86_64-DVD-1810.iso；里面的内容 2、创建挂载点 注意：一般用户无法挂载cdrom,只有root用户才可以操作 我们切换到root下创建一个挂载点（其实就是创建一个目录） mkdir -p mnt/cdrom 3、开始挂载 通过挂载点的方式查看上面的【ISO文件内容】 mount -t auto /dev/cdrom /mnt/cdrom 执行效果如下 表示挂载成功 4、查看挂载点内容 ls -l -a ./mnt/cdrom/ 执行效果如下图 如上图所示，我们通过挂载点查看CD/DVD的文件个数是14个，和上面的【ISO文件内容】个数一致。 5、卸载cdrom 在前面我们将CD/DVD挂载到了文件系统，如果我们不用了，就可以将其卸载掉 umount ./mnt/cdrom/ 执行效果如下图 我们发现卸载后，通过挂载点就无法查看CD/DVD里面的数据了。 4.3. 3.3 总结 关于挂载：用户不能直接访问 硬件设备需要将硬件设备 挂载 到 系统目录上, 才可以让用户访问。 5. 4 shell与安装 tips 重点讲解内容 5.1. 4.1 yum使用 引子： yum类似于开发工具idea、eclipse中的在线插件安装商店 我们输入一个将要安装的插件名字，进行搜索、安装的过程。 yum概念 yum（ Yellow dog Updater, Modified）是一个在Fedora和RedHat以及SUSE中的Shell前端软件包管理器。 yum提供了查找、安装、删除某一个、一组甚至全部软件包的命令，而且命令简洁而又好记。 yum原理 注意：必须联网 不同的服务通过yum命令连接远程yum源进行查找、下载、安装 使用者权限：管理员 语法 yum [options] [command] [package ...] options：可选，选项包括-h（帮助），-y（当安装过程提示选择全部为\"yes\"），-q（不显示安装的过程）等等。 command：要进行的操作。 package操作的对象。 yum常用命令 1.列出所有可更新的软件清单命令：yum check-update 2.更新所有软件命令：yum update 3.仅安装指定的软件命令：yum install 4.仅更新指定的软件命令：yum update 5.列出所有可安裝的软件清单命令：yum list 6.删除软件包命令：yum remove 7.查找软件包 命令：yum search 8.清除缓存命令: yum clean packages: 清除缓存目录下的软件包 yum clean headers: 清除缓存目录下的 headers yum clean oldheaders: 清除缓存目录下旧的 headers yum clean, yum clean all (= yum clean packages; yum clean oldheaders) :清除缓存目录下的软件包及旧的headers 5.1.1. 4.1.1 安装tree yum -y install tree //y当安装过程提示选择全部为\"yes\" 执行效果如下 注意：第一次在itcast用户执行的时候 提示我们【需要管理员权限】 安装完执行tree命令 tree 5.1.2. 4.1.2 移除tree yum remove tree 执行效果如下 此时，我们在执行tree命令 tree 执行效果如下 如上图，由于我们移除了tree，在执行tree命令的时候发现找不到这个命令了。 5.1.3. 4.1.3 yum查找 利用 yum 的功能，找出以 tom 为开头的软件名称有哪些 yum list tom* 执行效果如下 5.1.4. 4.1.4 yum源 概述 yum需要一个yum库，也就是yum源。 简单的说，我们安装软件的时候需要下载软件，将很多软件放在一起就是源。软件安装包的来源，所以yum源就是软件安装包来源 yum源分类 目前，yum默认使用的是CentOS的yum源，如下 目前，国内有很多不错的yum源，比如阿里、网易、搜狐等 安装阿里yum源 因为默认的yum源服务器在国外，我们在安装软件的时候会受到速度的影响，所以安装国内yum源在下载的时候速度、稳定性会比国外的好很多。 1) 安装wget yum install -y wget 执行效果如下 安装成功。 2) 备份/etc/yum.repos.d/CentOS-Base.repo文件 cd /etc/yum.repos.d/ mv CentOS-Base.repo CentOS-Base.repo.back 执行效果如下图 3) 下载阿里云的Centos-7.repo文件 wget -O CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo 注意 上面的url中要卸载Centos-7.repo；而不是Centos-6.repo 执行效果如下图 查看下载的阿里云的Centos-6.repo文件 cat CentOS-Base.repo 执行效果如下 # CentOS-Base.repo # # The mirror system uses the connecting IP address of the client and the # update status of each mirror to pick mirrors that are updated to and # geographically close to the client. You should use this for CentOS updates # unless you are manually picking other mirrors. # # If the mirrorlist= does not work for you, as a fall back you can try the # remarked out baseurl= line instead. # # [base] name=CentOS-$releasever - Base - mirrors.aliyun.com failovermethod=priority baseurl=http://mirrors.aliyun.com/centos/$releasever/os/$basearch/ http://mirrors.aliyuncs.com/centos/$releasever/os/$basearch/ http://mirrors.cloud.aliyuncs.com/centos/$releasever/os/$basearch/ gpgcheck=1 gpgkey=http://mirrors.aliyun.com/centos/RPM-GPG-KEY-CentOS-7 #released updates [updates] name=CentOS-$releasever - Updates - mirrors.aliyun.com failovermethod=priority baseurl=http://mirrors.aliyun.com/centos/$releasever/updates/$basearch/ http://mirrors.aliyuncs.com/centos/$releasever/updates/$basearch/ http://mirrors.cloud.aliyuncs.com/centos/$releasever/updates/$basearch/ gpgcheck=1 gpgkey=http://mirrors.aliyun.com/centos/RPM-GPG-KEY-CentOS-7 #additional packages that may be useful [extras] name=CentOS-$releasever - Extras - mirrors.aliyun.com failovermethod=priority baseurl=http://mirrors.aliyun.com/centos/$releasever/extras/$basearch/ http://mirrors.aliyuncs.com/centos/$releasever/extras/$basearch/ http://mirrors.cloud.aliyuncs.com/centos/$releasever/extras/$basearch/ gpgcheck=1 gpgkey=http://mirrors.aliyun.com/centos/RPM-GPG-KEY-CentOS-7 #additional packages that extend functionality of existing packages [centosplus] name=CentOS-$releasever - Plus - mirrors.aliyun.com failovermethod=priority baseurl=http://mirrors.aliyun.com/centos/$releasever/centosplus/$basearch/ http://mirrors.aliyuncs.com/centos/$releasever/centosplus/$basearch/ http://mirrors.cloud.aliyuncs.com/centos/$releasever/centosplus/$basearch/ gpgcheck=1 enabled=0 gpgkey=http://mirrors.aliyun.com/centos/RPM-GPG-KEY-CentOS-7 #contrib - packages by Centos Users [contrib] name=CentOS-$releasever - Contrib - mirrors.aliyun.com failovermethod=priority baseurl=http://mirrors.aliyun.com/centos/$releasever/contrib/$basearch/ http://mirrors.aliyuncs.com/centos/$releasever/contrib/$basearch/ http://mirrors.cloud.aliyuncs.com/centos/$releasever/contrib/$basearch/ gpgcheck=1 enabled=0 gpgkey=http://mirrors.aliyun.com/centos/RPM-GPG-KEY-CentOS-7 如上面的命令，之前是【CentOS】，现在是【aliyun】 4) 重新加载yum yum clean all 清理之前（CentOS）的缓存 执行效果如下 yum makecache 就是把服务器的包信息下载到本地电脑缓存起来，makecache建立一个缓存，以后用install时就在缓存中搜索，提高了速度。 执行效果如下 如上图，元数据缓存已建立,缓存成功。 5、验证yum源使用 yum search tomcat 执行效果如下 如上图所示，我们发现，现在查找软件信息使用了上面的yum缓存。 Loading mirror speeds from cached hostfile(从缓存的主机文件加载镜像速度) base: mirrors.aliyun.com extras: mirrors.aliyun.com updates: mirrors.aliyun.com 总结 yum -y install 软件包 卸载软件 yum -y remove 软件包 查找软件 yum list * yum源 版本: 比如我们使用的是CentOS7，在下载CentOS-Base.repo的时候要注意它的版本。 5.2. 4.2 rpm使用 RPM包管理类似于windows下的“添加/删除程序”但是功能却比“添加/删除程序”强大很多 1、rpm介绍 rpm(redhat package manager) 原本是 Red Hat Linux 发行版专门用来管理 Linux 各项套件的程序，由于它遵循 GPL 规则且功能强大方便，因而广受欢迎。逐渐受到其他发行版的采用。RPM 套件管理方式的出现，让 Linux 易于安装，升级，间接提升了 Linux 的适用度。 2、rpm与yum区别 rpm 只能安装已经下载到本地机器上的rpm 包. yum能在线下载并安装rpm包,能更新系统,且还能自动处理包与包之间的依赖问题,这个是rpm 工具所不具备的。 语法如下： 用法: rpm [选项...] rpm包 注意： 以上为扩展名为.rpm的包 可以理解成是Windows中的.exe文件 安装rpm软件包 rpm -ivh 软件全包名 卸载rpm软件包 rpm -e 软件全包名 列出所有安装过的包 rpm -qa 查询软件包信息 rpm -qi 软件全包名 查看文件安装位置 rpm -ql 软件全包名 5.3. 4.3 shell使用 shell脚本类似于我们在Windows中编写的批处理文件，它的扩展名是.bat，比如我们启动Tomcat（后面的课程我们会详细讲解）的时候经常启动的startup.bat，就是Windows下的批处理文件。 而在Linux中，shell脚本编写的文件是以.sh结尾的。比如Tomcat下我们经常使用startup.sh来启动我们的Tomcat，这个startup.sh文件就是shell编写的。 5.3.1. 4.3.1 shell入门 通过简单的学习，我们编写一个简单的入门shell程序。 我们通过前面学习的echo命令，在shell脚本中打印出一句话。 1) 什么是shell Shell 脚本（shell script），是一种为 shell 编写的脚本程序。 Shell 脚本（Shell Script）又称 Shell 命令稿、程序化脚本，是一种计算机程序使用的文本文件，内容由一连串的 shell 命令组成，经由 Unix Shell 直译其内容后运作 Shell 被当成是一种脚本语言来设计，其运作方式与解释型语言相当，由 Unix shell 扮演命令行解释器的角色，在读取 shell 脚本之后，依序运行其中的 shell 命令，之后输出结果。利用 shell 脚本可以进行系统管理，文件操作等。 在 Unix 及所有的系统中，如 Linux、FreeBSD 等操作系统，都存在 shell 脚本。依照 Unix shell 的各种不同类型，shell 脚本也有各种不同方言。在 DOS、OS/2、Microsoft Windows 中的批处理文件，跟 shell 脚本有类似的功能。 2) shell环境 java需要虚拟机解释器, 同理 shell脚本也需要解释器 Shell 编程跟 JavaScript、php 编程一样，只要有一个能编写代码的文本编辑器和一个能解释执行的脚本解释器就可以了。 查看解释器 cat /etc/shells 执行效果如下 Linux 的 Shell 种类众多，常见的有： Bourne Shell（/usr/bin/sh或/bin/sh） Bourne Again Shell（/bin/bash） C Shell（/usr/bin/csh） K Shell（/usr/bin/ksh） Shell for Root（/sbin/sh） 等等…… 我们当前课程使用的是 Bash，也就是 Bourne Again Shell，由于易用和免费，Bash 在日常工作中被广泛使用。同时，Bash 也是大多数Linux 系统默认的 Shell 3) 编写第一个shell 现在，我们打开文本编辑器(我们也可以使用 vi/vim 命令来创建文件)，新建一个文件 czbk.sh，扩展名为 sh（sh代表shell）： #!/bin/bash --- 指定脚本解释器 echo \"你好，传智播客 !\" //写shell的习惯 第一行指定解释器 //文件是sh为后缀名 //括号成对书写 //注释的时候尽量不用中文注释。不友好。 //[] 括号两端要要有空格。 [ neirong ] //习惯代码索引，增加阅读性 //写语句的时候，尽量写全了，比如if。。。 1、创建sh文件** vim czbk.sh 2、编写并保存 3、查看czbk.sh文件 ls -l 如上图，我们发现刚刚编写的czbk.sh文件的的权限是【-rw-rw-r--】，通过我们之前学过的知识，我们发现这个文件并没有执行的权限 我们需要将czbk.sh文件设置下它的执行权限【x】，如果不设置有执行权限，当前的文件不具备文件执行的能力。 通过chmod设置执行权限 chmod +x ./czbk.sh 执行效果如下 我们发现，czbk.sh拥有了【x】执行权限 下面，我们就开始执行czbk.sh 4、执行czbk.sh文件 --- bash a.sh0 ./czbk.sh 执行效果如下： 如上图，我们刚刚编写的shell在执行的时候正常打印出来了，说明czbk.sh具备执行的能力 注意： #! 是一个约定的标记，它告诉系统这个脚本需要什么解释器来执行，即使用哪一种 Shell。 echo 命令用于向窗口输出文本。 5.3.2. 4.3.2 shell注释 引子： 在Java SE课程中，我们也学习了注释 比如单行注释我们使用双斜杠// 多行注释我们使用/**开头表示注释多行 而在shell编程中，我们同样也要有注释，注释掉程序中不用的脚本 1、单行注释 以 # 开头的行就是注释，会被解释器忽略。 通过每一行加一个 # 号设置多行注释，如下： #-------------------------------------------- # 这是一个注释 #-------------------------------------------- ##### 开始 ##### # # # 这里可以添加脚本描述信息 # # ##### 结束 ##### 如果在开发过程中，遇到大段的代码需要临时注释起来，过一会儿又取消注释，怎么办呢？ 每一行加个#符号太费力了，此时，我们可以通过EOF进行多行注释，如下： 2、多行注释 多行注释还可以使用以下格式： : EOF 也可以使用其他符号: : 总结： 我们将在下面的小章节中使用注释，查看注释效果 5.3.3. 4.3.3 shell变量 引子： 这里的变量我们可以理解为我们在Java SE阶段定义的变量，比如在SE中我定义一个字符串类型的变量使用String stringStr=\"\"; 注意：下面的演示我们还是继续沿用test-shell.sh进行测试 1、定义变量: variable_name=\"czbk\" 变量名和等号之间不能有空格，这可能和你熟悉的所有编程语言都不一样。同时，变量名的命名须遵循如下规则： 命名只能使用英文字母，数字和下划线，首个字符不能以数字开头。 中间不能有空格，可以使用下划线（_）。 不能使用标点符号。 不能使用bash里的关键字（可用help命令查看保留关键字）。 有效的 Shell 变量名示例如下： RUNOOB LD_LIBRARY_PATH _var var2 无效的变量命名： ?var=123 user*name=runoob 2、使用变量 使用一个定义过的变量，只要在变量名前面加美元符号即可，如： variable_name=\"czbk\" echo $variable_name echo ${variable_name} 执行效果如下 变量名外面的花括号是可选的，加不加都行，加花括号是为了帮助解释器识别变量的边界，比如下面这种情况： echo \"I am good at ${shell-t}Script\" 通过上面的脚本我们发现，如果不给shell-t变量加花括号，写成echo \"I am good at $shell-tScript\"，解释器shell就会把$shell-tScript当成一个变量，由于我们前面没有定义shell-t变量，那么解释器执行执行的结果自然就为空了。这里我们推荐给所有变量加上花括号，这也是一个好的编程习惯。 已定义的变量，可以被重新定义，如： your_name=\"tom\" echo $your_name your_name=\"frank\" echo $your_name 执行效果如下图 这样写是合法的，但注意，第二次赋值的时候不能写$your_name=\"frank\"，使用变量的时候才加$。 3、只读变量 这里的只读变量其实有点类似于我们在java se阶段课程中定义的final变量，即在程序的上下文中不允许被程序修改 使用 readonly 命令可以将变量定义为只读变量，只读变量的值不能被改变。 下面的例子尝试更改只读变量，结果报错： #!/bin/bash myUrl=\"https://www.baidu.com\" readonly myUrl myUrl=\"https://cn.bing.com/\" 执行效果如下图 4、删除变量 使用 unset 命令可以删除变量。语法： unset variable_name 变量被删除后不能再次使用。unset 命令不能删除只读变量。 示例如下 #!/bin/sh myUrl=\"https://www.baidu.com\" unset myUrl echo $myUrl 执行效果如下图 如上面的shell脚本，我们定义了一个myUrl变量，通过unset删除这个变量，然后通过echo进行输出，结果是就是为空，没有任何的结果输出。 Shell 字符串 字符串是shell编程中最常用也是最有用的数据类型，字符串可以用单引号，也可以用双引号，也可以不用引号，正如我们开篇提到的，在Java SE中我们定义一个字符串可以通过Stirng stringStr=“abc\" 双引号的形式进行定义，而在shel中也是可以的。 单引号 str='this is a string variable' 单引号字符串的限制： 单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的； 单引号字串中不能出现单独一个的单引号（对单引号使用转义符后也不行），但可成对出现，作为字符串拼接使用。 双引号 your_name='frank' str=\"Hello, \\\"$your_name\\\"! \\n\" echo -e $str 输出结果为： 双引号的优点： 双引号里可以有变量 双引号里可以出现转义字符 拼接字符串 your_name=\"frank\" # 使用双引号拼接 greeting=\"hello, \"$your_name\" !\" greeting_1=\"hello, ${your_name} !\" echo $greeting $greeting_1 输出结果为： 获取字符串长度 string=\"czbk\" echo ${#string} 输出结果：4.表示长度为4 提取字符串 以下实例从字符串第 2 个字符开始截取 4 个字符： string=\"abcdefghijklmn\" echo ${string:1:4} 执行效果如下 输出为【bcde】，通过截取我们发现，它的下标和我们在java中的读取方式是一样的，下标也是从0开始。 5.3.4. 4.3.4 shell数组 这里的数组和我们在Java SE阶段的数组结果（或是性质）是一样的，只是定义的过程大同小异 bash支持一维数组（不支持多维数组），并且没有限定数组的大小。 定义数组 在 Shell 中，用括号来表示数组，数组元素用\"空格\"符号分割开。如下： 数组名=(值1 值2 ... 值n) 例如： array_name=(value0 value1 value2 value3) 或者 array_name=( value0 value1 value2 value3 ) 通过下标定义数组中的其中一个元素： array_name[0]=value0 array_name[1]=value1 array_name[n]=valuen 可以不使用连续的下标，而且下标的范围没有限制。 读取数组 读取数组元素值的一般格式是： ${数组名[下标]} 例如： valuen=${array_name[n]} 使用 @ 符号可以获取数组中的所有元素，例如： echo ${array_name[@]} 获取数组的长度 获取数组长度的方法与获取字符串长度的方法相同，例如： # 取得数组元素的个数 length=${#array_name[@]} # 或者 length=${#array_name[*]} 下面，我们通过一个例子，定义数组、提取数组元素的例子来验证下 #! /bin/bash g=(a b c d e f) echo \"数组下标为2的数据为:\" ${g[2]} echo \"数组所有数据为:\" ${#g[@]} echo \"数组所有数据为:\" ${#g[*]} 如下 执行效果如下： 5.3.5. 4.3.5 shell运算符 我们在前面课程中学习Java SE中也学到了运算符，比如算术、关系、布尔等，而在sehll编程中同样也有运算符，虽然表达的方式不一样，但是最终的目的都是一样的，都是为了解决编程中现存问题 Shell 和其他编程一样，支持包括：算术、关系、布尔、字符串等运算符。 原生 bash 不支持 简单的数学运算，但是可以通过其他命令来实现，例如expr。 expr 是一款表达式计算工具，使用它能完成表达式的求值操作。 例如，两个数相加,我们还是利用上面的例子test-shell.sh 1、算数运算符 val=`expr 2 + 2` echo \"相加之后的结果为：\" $val 执行效果如下 注意： 表达式和运算符之间要有空格，例如 2+2 是不对的，必须写成 2 + 2。 完整的表达式要被 ` 包含，注意不是单引号。 下表列出了常用的算术运算符，假定变量 a 为 10，变量 b 为 20： 运算符 说明 举例 + 加法 expr $a + $b 结果为 30。 - 减法 expr $a - $b 结果为 -10。 * 乘法 expr $a \\* $b 结果为 200。 / 除法 expr $b / $a 结果为 2。 % 取余 expr $b % $a 结果为 0。 = 赋值 a=$b 将把变量 b 的值赋给 a。 == 相等。用于比较两个数字，相同则返回 true。 [ $a == $b ] 返回 false。 != 不相等。用于比较两个数字，不相同则返回 true。 [ $a != $b ] 返回 true。 注意：条件表达式要放在方括号之间，并且要有空格，例如: [$a==$b] 是错误的，必须写成 [ $a == $b ]。 下面是运算符shell脚本（还是采用之前的例子test-shell.sh ）w #! /bin/bash #g=(a b c d e f) #echo \"数组下标为2的数据为:\" ${g[2]} #echo \"数组所有数据为:\" ${#g[@]} #echo \"数组所有数据为:\" ${#g[*]} : 上面的shell命令#开头的为单行注释 : 执行效果如下 2、字符串运算符 下表列出了常用的字符串运算符，假定变量 a 为 \"abc\"，变量 b 为 \"efg\"： 运算符 说明 举例 = 检测两个字符串是否相等，相等返回 true。 [ $a = $b ] 返回 false。 != 检测两个字符串是否相等，不相等返回 true。 [ $a != $b ] 返回 true。 -z 检测字符串长度是否为0，为0返回 true。 [ -z $a ] 返回 false。 -n 检测字符串长度是否为0，不为0返回 true。 [ -n \"$a\" ] 返回 true。 $ 检测字符串是否为空，不为空返回 true。 [ $a ] 返回 true。 字符串运算符实例如下（还是采用之前的例子test-shell.sh ）： a=\"abc\" b=\"efg\" if [ $a = $b ] then echo \"$a = $b : a 等于 b\" else echo \"$a = $b: a 不等于 b\" fi if [ $a != $b ] then echo \"$a != $b : a 不等于 b\" else echo \"$a != $b: a 等于 b\" fi 执行效果如下 3、关系运算符 关系运算符只支持数字，不支持字符串，除非字符串的值是数字。 下表列出了常用的关系运算符，假定变量 a 为 10，变量 b 为 20： 运算符 说明 举例 -eq 检测两个数是否相等，相等返回 true。 [ $a -eq $b ] 返回 false。 -ne 检测两个数是否不相等，不相等返回 true。 [ $a -ne $b ] 返回 true。 -gt 检测左边的数是否大于右边的，如果是，则返回 true。 [ $a -gt $b ] 返回 false。 -lt 检测左边的数是否小于右边的，如果是，则返回 true。 [ $a -lt $b ] 返回 true。 -ge 检测左边的数是否大于等于右边的，如果是，则返回 true。 [ $a -ge $b ] 返回 false。 -le 检测左边的数是否小于等于右边的，如果是，则返回 true。 [ $a -le $b ] 返回 true。 关系运算符（还是采用之前的例子test-shell.sh ） a=10 b=20 if [ $a -eq $b ] then echo \"$a -eq $b : a 等于 b\" else echo \"$a -eq $b: a 不等于 b\" fi if [ $a -ne $b ] then echo \"$a -ne $b: a 不等于 b\" else echo \"$a -ne $b : a 等于 b\" fi if [ $a -gt $b ] then echo \"$a -gt $b: a 大于 b\" else echo \"$a -gt $b: a 不大于 b\" fi if [ $a -lt $b ] then echo \"$a -lt $b: a 小于 b\" else echo \"$a -lt $b: a 不小于 b\" fi if [ $a -ge $b ] then echo \"$a -ge $b: a 大于或等于 b\" else echo \"$a -ge $b: a 小于 b\" fi if [ $a -le $b ] then echo \"$a -le $b: a 小于或等于 b\" else echo \"$a -le $b: a 大于 b\" fi 执行效果如下： 4、布尔运算符 下表列出了常用的布尔运算符，假定变量 a 为 10，变量 b 为 20： 运算符 说明 举例 ! 非运算，表达式为 true 则返回 false，否则返回 true。 [ ! false ] 返回 true。 -o 或运算，有一个表达式为 true 则返回 true。 [ $a -lt 20 -o $b -gt 100 ] 返回 true。 -a 与运算，两个表达式都为 true 才返回 true。 [ $a -lt 20 -a $b -gt 100 ] 返回 false。 布尔运算符实例如下（还是采用之前的例子test-shell.sh ）： a=10 b=20 if [ $a != $b ] then echo \"$a != $b : a 不等于 b\" else echo \"$a == $b: a 等于 b\" fi if [ $a -lt 100 -a $b -gt 15 ] then echo \"$a 小于 100 且 $b 大于 15 : 返回 true\" else echo \"$a 小于 100 且 $b 大于 15 : 返回 false\" fi if [ $a -lt 100 -o $b -gt 100 ] then echo \"$a 小于 100 或 $b 大于 100 : 返回 true\" else echo \"$a 小于 100 或 $b 大于 100 : 返回 false\" fi if [ $a -lt 5 -o $b -gt 100 ] then echo \"$a 小于 5 或 $b 大于 100 : 返回 true\" else echo \"$a 小于 5 或 $b 大于 100 : 返回 false\" fi 执行效果如下 5、逻辑运算符 假定变量 a 为 10，变量 b 为 20: 运算符 说明 举例 && 逻辑的 AND [[ $a -lt 100 && $b -gt 100 ]] 返回 false \\ \\ 逻辑的 OR [[ $a -lt 100 \\ \\ $b -gt 100 ]] 返回 true 逻辑运算符实例如下（还是采用之前的例子test-shell.sh ）： a=10 b=20 if [[ $a -lt 100 && $b -gt 100 ]] then echo \"返回 true\" else echo \"返回 false\" fi if [[ $a -lt 100 || $b -gt 100 ]] then echo \"返回 true\" else echo \"返回 false\" fi 执行效果如下 5.3.6. 4.3.6 shell流程控制 在前面的Java SE课程中，我们学习了很多的流程控制语句，比如有if-else、if else-if else、switch、for、while等语句； 在shell编程中，我们同样也有这些流程控制，只是语法和java SE有所区别，但是目的是一样的。 1、if 语句： 主要用于判断，相当于java se中的if，我们还是采用之前的例子test-shell.sh if condition then command1 command2 ... commandN fi 比如，我们现在通过前面学习的知识查找一个进程，如果进程存在就打印true if [ $(ps -ef | grep -c \"ssh\") -gt 1 ]; then echo \"true\"; fi 注意 末尾的fi就是if倒过来拼写 执行效果如下 2、if else 语句： 主要用于判断，相当于java se中的if else，我们还是采用之前的例子test-shell.sh。 if condition then command1 command2 ... commandN else command fi 上接上面的例子，如果找不到sshAAA（此处可以随便输入一个）进程，我们就打印false if [ $(ps -ef | grep -c \"sshAAA\") -gt 1 ]; then echo \"true\"; else echo \"false\"; fi 执行效果如下 3、if else-if else 语句： 主要用于判断，相当于java se中的if else-if else if condition1 then command1 elif condition2 then command2 else commandN fi 以下实例判断两个变量是否相等 我们继续使用上面的例子（test-shell.sh ） a=10 b=20 if [ $a == $b ] then echo \"a 等于 b\" elif [ $a -gt $b ] then echo \"a 大于 b\" elif [ $a -lt $b ] then echo \"a 小于 b\" else echo \"没有符合的条件\" fi 执行效果如下 4、for 循环 主要用于循环，相当于java se中的for循环，我们还是采用之前的例子test-shell.sh for循环格式为 for var in item1 item2 ... itemN do command1 command2 ... commandN done 顺序输出当前列表中的字母： for loop in A B C D E F G do echo \"顺序输出字母为: $loop\" done 执行效果如下 5、while循环 主要用于循环，相当于java se中的while循环 while循环用于不断执行一系列命令，也用于从输入文件中读取数据 语法格式为 while condition do command done 以下是一个基本的while循环，测试条件是：如果int小于等于10，那么条件返回真。int从0开始，每次循环处理时，int加1。 还是采用之前的例子test-shell.sh #!/bin/bash int=1 while(( $int 执行效果如下图 6、case ... esac语句 主要用于分支条件选择，相当于java se中的switch case循环 case ... esac 与其他语言中的 switch ... case 语句类似，是一种多分枝选择结构，每个 case 分支用右圆括号开始，用两个分号 ;; 表示 break，即执行结束，跳出整个 case ... esac 语句，esac（就是 case 反过来）作为结束标记。 还是采用之前的例子test-shell.sh case ... esac 语法格式如下： case 值 in 模式1) command1 command2 command3 ;; 模式2） command1 command2 command3 ;; *) command1 command2 command3 ;; esac case 后为取值，值可以为变量或常数。 值后为关键字 in，接下来是匹配的各种模式，每一模式最后必须以右括号结束，模式支持正则表达式。 下面通过v的值进行case--esac v=\"czbk\" case \"$v\" in \"czbk\") echo \"传智播客\" ;; \"baidu\") echo \"baidu 搜索\" ;; \"google\") echo \"google 搜索\" ;; esac 执行效果如下 5.3.7. 4.3.7 shell函数 我们将要学习的shell函数，我们可以理解成在Java SE阶段我们学习的方法，它和shell函数的作用是一样的。 函数语法如下： [ function ] funname [()] { action; [return int;] } 注意： 1、可以使用function fun() 定义函数，也可以直接fun() 定义,不带任何参数。 2、函数参数返回，可以显示加：return 返回，如果不加，将以最后一条命令运行结果，作为返回值。 return后跟数值n(0-255 下面我们将定义一个函数，并发生函数调用 还是采用之前的例子test-shell.sh #!/bin/bash czbk(){ echo \"这是第一个函数!\" } echo \"-----这里是函数开始执行-----\" czbk echo \"-----这里是函数执行完毕-----\" 执行效果如下图 下面，我们定义一个带有return语句的函数： function czbk(){ echo \"对输入的两个数字进行相加运算...\" echo \"输入第一个数字: \" read aNum echo \"输入第二个数字: \" read anotherNum echo \"两个数字分别为 $aNum 和 $anotherNum !\" return $(($aNum+$anotherNum)) } czbk echo \"输入的两个数字之和为 $? !\" 注意： 函数返回值在调用该函数后通过 $? 来获得。 注意：所有函数在使用前必须定义。这意味着必须将函数放在脚本开始部分，直至shell解释器首次发现它时，才可以使用。调用函数仅使用其函数名即可。 5.3.8. 4.3.8 总结 在企业级开发过程中，我们（开发人员）学习Linux主要的目的就是在Linux系统中能够熟练的操作目录、文件，还有就是通过所学的命令系统化的编写sh文件，所以，在当前章节中，我们要熟练的编写shell脚本相关命令以及综合案例中的知识点。 Copyright © MISIN 2022 | 豫ICP备2021006345号-1 all right reserved，powered by Gitbook该文件修订时间： 2022-11-09 04:17:52 "},"2.JavaWeb/1.Linux/Linux-01-1.html":{"url":"2.JavaWeb/1.Linux/Linux-01-1.html","title":"Linux 01","keywords":"","body":"1. Linux-v10.0-01天-课堂笔记2. 1 初识Linux2.1. 1.1 操作系统2.2. 1.2 Linux发展历程2.3. 1.3 Linux简介2.3.1. 1.3.1 什么是 Linux2.3.2. 1.3.2 Linux的特点2.4. 1.4 Linux和Unix区别2.5. 1.5 Linux和Windows区别2.6. 1.6 Linux发行商和常见发行版2.7. 1.7 Linux 应用领域2.8. 1.8 Linux之CentOS2.9. 1.9 总结3. 2 系统与设置命令3.1. 2.1 学习命令的原因3.2. 2.2 Linux 用户和用户组管理3.2.1. 2.2.1 Linux账号管理3.2.2. 2.2.2 Linux用户组3.2.3. 2.2.3 将用户添加到组3.3. 2.3 系统管理3.3.1. 2.3.1 日期管理3.3.2. 2.3.2 显示用户3.3.3. 2.3.3 su切换账户3.3.4. 2.3.4 id命令3.3.5. 2.3.5 sudo执行3.3.6. 2.3.6 top命令3.3.7. 2.3.7 ps命令3.3.8. 2.3.8 kill命令3.3.9. 2.3.9 关机命令3.3.10. 2.3.10 重启命令3.3.11. 2.3.11 who命令3.3.12. 2.3.12 timedatectl命令3.3.13. 2.3.13 clear命令3.3.14. 2.3.14 exit命令3.4. 2.4 总结4. 3 Linux目录管理4.1. 3.1 Linux 文件与目录管理4.1.1. 3.1.1 目录常用命令4.2. 3.2 Linux 文件基本属性4.3. 3.3 Linux文件属主和属组4.3.1. 3.3.1 chgrp更改属组4.3.2. 3.3.2 chown更改属主和属组**4.3.3. 3.3.3 chmod权限命令4.4. 3.4 综合案例4.5. 3.5 总结1. Linux-v10.0-01天-课堂笔记 学习目标 能够知道什么是Linux系统以及它的应用场景 能够独立完成安装VMware虚拟机和网络配置 能够独立完成安装CentOS以及远程终端SecureCRT 能够熟练编写账户管理、用户组的增删改查和添加命令 能够熟练编写系统管理的常用命令 能够熟练编写目录常用命令 能够熟练编写权限常用命令 能够知道用户组实际应用场景 2. 1 初识Linux 在前面的课程中，我们无论是开发、测试。部署、存储都在Windwos操作系统的环境中，从今天开始我们一起学习下Linux,Linux系统和Windows系统最大的区别就是图形化界面操作和用途上有所差异，除了这两点，两者有异曲同工之妙，在国内， Linux 系统更多的是应用于服务器上，而桌面操作系统更多使用的是 Windows，也就是说Linux与Windows一样，同样也是操作系统只是在使用以及应用上有所差异，其他都是一样的； 因为Linux也是操作系统 所以在正式进入Linux学习之前，我们先简单的学习操作系统的知识，然后在讲解Linux 2.1. 1.1 操作系统 操作系统(Operation System, OS)，是管理计算机硬件与软件资源的计算机程序，同时也是计算机系统的内核与基石。操作系统需要处理如管理与配置内存、决定系统资源供需的优先次序、控制输入设备与输出设备、操作网络与管理文件系统等基本事务。操作系统也提供一个让用户与系统交互的操作界面。 操作系统作为接口的示意图: 如上图所示，在操作系统的最上层是用户，中间层是操作系统（里面可能装了很多的应用程序），最下层是硬件的支撑，包含CPU/内存/硬盘等 这就是一个完成的操作系统结构图 主流操作系统按照应用领域的划分 1、桌面操作系统 Window 系列 用户群体大 macOS 细节处理的更好, 没有windows软件丰富, 价格高 Linux 应用软件少 2、服务器操作系统 Linux 安全、稳定、免费 占有率高 Windows Server 付费 占有率低 3、嵌入式操作系统 ​ Linux 4、移动设备操作系统 IOS Android (基于Linux) 华为鸿蒙(基于linux) 2.2. 1.2 Linux发展历程 引子 在上面，我们学习了操作系统的知识，也知道了主流操作系统按照应用领域划分了四个类型的操作系统，其中Linux操作系统在四个领域都有提名，因为它是至今开源序列最好的操作系统，下面，我们就一起看下Linux的发展历程，看看它是怎么诞生的... 1984年，Andrew S.Tanenbaum 开发了用于教学的Unix系统，命名为Minix，但是仅仅用于教学 1989年，Andrew S.Tanenbaum将Minix系统运行于x86的pc平台 1990年，芬兰赫尔辛基大学学生Linus Torvalds首次接触Minix系统 1991年，Linus Torvalds开始在Minix上编写各种驱动程序等操作系统内核组件 1991年年底，Linus Torvalds公开了Linux内核源码0.02版，仅仅是内核 1994年，Linux 1.0版本发行，Linux转向GPL版权协议 至此，Linux开始盛行开来... Linux 内核最初是由李纳斯•托瓦兹（Linus Torvalds）在赫尔辛基大学读书时出于个人爱好而编写的，当时他觉得教学用的迷你版 Unix操作系统 Minix 太难用了，于是决定自己开发一个操作系统。 第 1 版本于 1991 发布，当时仅有 10 000 行代码。 李纳斯•托瓦兹没有保留 Linux 源代码的版权，公开了代码，并邀请他人一起完善 Linux。与 Windows 及其他有专利权的操作系统不同，Linux 开放源代码，任何人都可以免费使用它。 据估计，现在只有 2% 的 Linux 核心代码是由李纳斯•托瓦兹自己编写的，虽然他仍然拥有 Linux 内核（操作系统的核心部分），并且保留了选择新代码和需要合并的新方法的最终裁定权。现在大家所使用的 Linux，我更倾向于说是由李纳斯•托瓦兹和后来陆续加入的众多 Linux 好者共同开发完成的。 Unix Unix 操作系统由肯•汤普森（Ken Thompson）和丹尼斯•里奇（Dennis Ritchie）发明。它的部分技术来源可追溯到从 1965 年开始的 Multics 工程计划，该计划由贝尔实验室、美国麻省理工学院和通用电气公司联合发起，目标是开发一种交互式的、具有多道程序处理能力的分时操作系统，以取代当时广泛使用的批处理操作系统。 Unix是一个强大的多用户、多任务操作系统。于1969年在AT&T的贝尔实验室开发。Unix 的商标权由国际开放标准组织（The Open Group）所拥有。Unix操作系统是商业版，需要收费，价格比Microsoft Windows正版要贵一些。 2.3. 1.3 Linux简介 引子 Linux和我们常见的Windows一样，都是操作系统， 例如：新浪、百度、淘宝等互联网公司，他们使用的服务器全都是Linux系统；全球500强企业95%的服务器使用的都是Linux系统。 2.3.1. 1.3.1 什么是 Linux Linux是一套免费使用和自由传播的类Unix操作系统，是一个基于POSIX和Unix的多用户、多任务、支持多线程和多CPU的操作系统。它能运行主要的Unix工具软件、应用程序和网络协议。它支持32位和64位硬件。Linux继承了Unix以网络为核心的设计思想，是一个性能稳定的多用户网络操作系统。 Linux 的标志和吉祥物是一只名字叫做Tux(它克斯)的企鹅，Linux是基于Unix的。 Linux是一种自由和开放源码的操作系统，存在着许多不同的Linux版本，但它们都使用了Linux内核。Linux可安装在各种计算机硬件设备中，比如手机、平板电脑、路由器、台式计算机 Linux不仅系统性能稳定，而且是开源软件。其核心防火墙组件性能高效、配置简单，保证了系统的安全。在很多企业网络中，为了追求速度和安全，Linux操作系统不仅仅是被网络运维人员当作服务器使用，Linux既可以当作服务器，又可以当作网络防火墙是Linux的 一大亮点。 Linux与其他操作系统相比 ，具有开放源码、没有版权、技术社区用户多等特点 ，开放源码使得用户可以自由裁剪，灵活性高，功能强大，成本低。尤其系统中内嵌网络协议栈 ，经过适当的配置就可实现路由器的功能。这些特点使得Linux成为开发路由交换设备的理想开发平台。 2.3.2. 1.3.2 Linux的特点 基本思想 Linux的基本思想有两点： 第一：一切都是文件 第二：每个软件都有确定的用途 其中第一条详细来讲就是系统中的所有都归结为一个文件，包括命令、硬件和软件设备、操作系统、进程等等对于操作系统内核而言，都被视为拥有各自特性或类型的文件。至于说Linux是基于Unix的，很大程度上也是因为这两者的基本思想十分相近 完全免费 Linux是一款免费的操作系统，用户可以通过网络或其他途径免费获得，并可以任意修改其源代码。这是其他的操作系统所做不到的。正是由于这一点，来自全世界的无数程序员参与了Linux的修改、编写工作，程序员可以根据自己的兴趣和灵感对其进行改变，这让Linux吸收了无数程序员的精华，不断壮大。 完全兼容POSIX1.0标准 这使得可以在Linux下通过相应的模拟器运行常见的DOS、Windows的程序。这为用户从Windows转到Linux奠定了基础。许多用户在考虑使用Linux时，就想到以前在Windows下常见的程序是否能正常运行，这一点就消除了他们的疑虑。 多用户、多任务 Linux支持多用户，各个用户对于自己的文件设备有自己特殊的权利，保证了各用户之间互不影响。多任务则是现在电脑最主要的一个特点，Linux可以使多个程序同时并独立地运行。 良好的界面 Linux同时具有字符界面和图形界面。在字符界面用户可以通过键盘输入相应的指令来进行操作。它同时也提供了类似Windows图形界面的X-Window系统，用户可以使用鼠标对其进行操作。在X-Window环境中就和在Windows中相似，可以说是一个Linux版的Windows。 支持多种平台 Linux可以运行在多种硬件平台上，如具有x86、680x0、SPARC、Alpha等处理器的平台。此外Linux还是一种嵌入式操作系统，可以运行在掌上电脑、机顶盒或游戏机上。2001年1月份发布的Linux 2.4版内核已经能够完全支持Intel64位芯片架构。同时Linux也支持多处理器技术。多个处理器同时工作，使系统性能大大提高。 优点 1)Linux由众多微内核组成，其源代码完全开源； 2)Linux继承了Unix的特性，具有非常强大的网络功能，其支持所有的因特网协议，包括TCP/IPv4、 TCP/IPv6和链路层拓扑程序等，且可以利用Unix的网络特性开发出新的协议栈； 3)Linux系统工具链完整，简单操作就可以配置出合适的开发环境，可以简化开发过程，减少开发中仿真工具的障碍，使系统具有较强的移植性； 2.4. 1.4 Linux和Unix区别 1、开源情况 Unix 是商业化的，而 Linux 是开源的，是免费、公开源代码的。 2、硬件适用 Unix 系统大多是与硬件配套的，也就是说，大多数Unix系统如AIX、HP-UX等是无法安装在 x86 服务器和个人计算机上的，而 Linux则可以运行在多种硬件平台上。 可以先学习Linux后再学习Unix，因为Linux可以方便的在虚拟机上运行，防止新手的误操作。 3、本质不同 Linux是开放源代码的自由软件，用户对前者有很高的自主权，在实际的的开发是处在一个完全开放的环境之中； 而Unix是对源代码实行知识产权保护的传统商业软件，用户的开发完全是处在一个黑箱之中，只有相关的开发人员才能够接触的产品的原型； Unix 诞生于 20 世纪 60 年代末，Windows 诞生于 20 世纪 80 年代中期，Linux 诞生于 20 世纪 90 年代初，可以说 Unix是操作系统中的\"老大哥\"，后来的 Windows 和 Linux 都参考了 Unix 2.5. 1.5 Linux和Windows区别 目前国内 Linux 更多的是应用于服务器上，而桌面操作系统更多使用的是 Windows。主要区别如下 比较 Windows Linux 界面 界面统一，外壳程序固定所有 Windows 程序菜单几乎一致，快捷键也几乎相同 图形界面风格依发布版不同而不同，可能互不兼容。GNU/Linux 的终端机是从 Unix传承下来，基本命令和操作方法也几乎一致。 驱动程序 驱动程序丰富，版本更新频繁。默认安装程序里面一般包含有该版本发布时流行的硬件驱动程序，之后所出的新硬件驱动依赖于硬件厂商提供。对于一些老硬件，如果没有了原配的驱动有时很难支持。另外，有时硬件厂商未提供所需版本的 Windows 下的驱动，也会比较头痛。 由志愿者开发，由 Linux 核心开发小组发布，很多硬件厂商基于版权考虑并未提供驱动程序，尽管多数无需手动安装，但是涉及安装则相对复杂，使得新用户面对驱动程序问题（是否存在和安装方法）会一筹莫展。但是在开源开发模式下，许多老硬件尽管在Windows下很难支持的也容易找到驱动。HP、Intel、AMD 等硬件厂商逐步不同程度支持开源驱动，问题正在得到缓解。 使用 使用比较简单，容易入门。图形化界面对没有计算机背景知识的用户使用十分有利。 图形界面使用简单，容易入门。文字界面，需要学习才能掌握。 学习 系统构造复杂、变化频繁，且知识、技能淘汰快，深入学习困难。 系统构造简单、稳定，且知识、技能传承性好，深入学习相对容易。 软件 每一种特定功能可能都需要商业软件的支持，需要购买相应的授权。 大部分软件都可以自由获取，同样功能的软件选择较少。 Windows与Linux在其他方面的不同 开放性 所谓的开放性就是Linux 操作系统是开放源码系统，可以对其程序进行编辑修改。而微软的Windows 系统是受微软版权保护，就是只能微软内部进行开发及修改。 文件格式不同 Windows 操作系统内核是NT，而Linux 是 shell； 另外，windows 硬盘文件格式是fat32或NTFS，而Linux 需要的文件格式是ext2或ext3，该操作系统还多一个SWAP格式的交换分区 免费与收费 在中国，对个人用户Windows 和Linux 都是免费的，对公用户Windows 需要收费，Linux 是免费的。 技术支持 Windows 较普及。Linux 需要深度的Linux 版块支持。 安全性 Linux 相对Windows 来说安全性更高。 开源 开源就是指对外部开放软件源代码。Linux 开源，而Windows并不开源。 使用习惯 Windows 放弃了dos的字符模式，主攻图形界面，让桌面系统更易用。Linux 字符模式运行的更好，图形界面还只是附带品，可有可无。 软件与支持 Windows 下可以运行绝大部分软件、玩99.999％的游戏、硬件厂商近乎100%的支持。Linux 下可直接运行的软件数量和win下比起来就是1和99的区别，而且目前选择Linux 的人基本不会考虑玩游戏，同时Linux 正期待更多硬件厂商的支持 2.6. 1.6 Linux发行商和常见发行版 Linux发行版是由个人，自由组织，以及商业机构和志愿者组织编写。它们通常包括了其他的系统软件和应用软件，以及一个用来简化系统初始安装的安装工具，和让软件安装升级的集成管理器。大多数系统还包括了像提供GUI界面的XFree86之类的曾经运行于BSD的程序。 一个典型的Linux发行版包括：Linux内核，一些GNU程序库和工具，命令行shell，图形界面的桌面环境，如KDE或GNOME，并包含数千种从办公套件，编译器，文本编辑器到科学工具的应用软件 Linux发行版的某些版本是不需要安装，只需通过CD或者可启动的USB存储设备就能使用的版本，他们称为LiveCD。 Linux的版本号分为两部分：内核版本和发行版本。 1．Linux的内核版本 内核版本指的是在Linus Torvalds领导下的开发小组开发出的系统内核的版本号，通常，内核版本号的第二位是偶数表示是稳定的版本，如2.6.25；是奇数表示有一些新的东西加入，是不稳定的测试版本，如2.5.6。Linux操作系统的核心就是它的内核，Linus Torvalds和他的小组在不断地开发和推出新内核。 任务：进程调度、内存管理、配置管理虚拟文件系统、提供网络接口以及支持进程间通信。像所有软件一样，Linux的内核也在不断升级。 2．Linux的发行版本 一个完整的操作系统不仅仅只有内核，还包括一系列为用户提供各种服务的外围程序。外围程序包括GNU程序库和工具，命令行shell，图形界面的X Window系统和相应的桌面环境，如KDE或GNOME，并包含数千种从办公套件，编译器，文本编辑器到科学工具的应用软件。所以，许多个人、组织和企业，开发了基于GNU/Linux的Linux发行版，他们将Linux系统的内核与外围应用软件和文档包装起来，并提供一些系统安装界面和系统设置与管理工具， 这样就构成了一个发行版本。 实际上，Linux的发行版本就是Linux内核再加上外围的实用程序组成的一个大软件包而已。相对于操作系统内核版本，发行版本的版本号是随发布者的不同而不同，与Linux系统内核的版本号是相对独立的，例如：RedHat EnterpriseLinux 5.2的操作系统内核是Linux-2.6.18。 Linux的发行版本大体可以分为两类： 一类是商业公司维护的发行版本 一类是社区组织维护的发行版本，前者以著名的RedHatLinux为代表，后者以Debian为代表 以下为Linux的主流版本： 目前市面上较知名的发行版有：Ubuntu、RedHat、CentOS、Debian、Fedora、SuSE、OpenSUSE、Arch Linux、SolusOS 等 以下是主要的发行版本 需要注意的： 下面的内容主要是介绍了下Linux发行家族以及发行版本的一些详细信息，虽然我们当前的课程讲解的是CentOS,但是其他的一些发行商、主流的发行版本比如Ubuntu、Redhat也需要让学生多多了解下，毕竟这是Linux体系内产品线 注意 下面的文字虽然很多，但是只要让学生知道有这么回事即可 在下面会简单的总结.. 1、Debian 介绍 Debian名字的由来----DebianGNU/Linux是由一个叫做伊恩·默多克（IanMurdock）在1993年发起的，他的名字以Ian开头，他太太的名字Debra开头三个字母是Deb。 Debian是社区类Linux的典范，是迄今为止最遵循GNU规范的Linux系统。Debian最早由 Ian Murdock于1993年创建，分为三个版本分支： stable(服务器版), testing(稳定版) 和unstable(测试版)。 2、Ubuntu介绍 Ubuntu严格来说不能算一个独立的发行版本，Ubuntu是基于Debian的unstable版本加强而来，可以这么说，Ubuntu就是一个拥有Debian所有的优点，以及自己所加强的优点的近乎完美的 Linux桌面系统。 共分三个版本: 基于Gnome的Ubuntu， 基于KDE的Kubuntu以。 基于Xfc的 Xubuntu。 特点是界面非常友好，容易上手，对硬件的支持非常全面，是最适合做桌面系统的Linux发行版本。稳定性，其实都差不多，难易度嘛， Ubuntu 默认桌面环境采用 GNOME，一个 Unix和 Linux 主流桌面套件和开发平台。 Ubuntu的版本和发布号 Ubuntu的版本号是由该次发布的年份和月份组成，并未反映其实际版本。我们的首次发布是在2004年10月，因此该版本为4.10。当前版本(DapperDrake)于2006年6月发布，因此版本号为6.06 LTS。 3、Redhat 可能这是最著名的Linux版本了，Red Hat Linux已经创造了自己的品牌，越来越多的人听说过它。Red Hat在1994年创业，当时聘用了全世界500多名员工，他们都致力于开放的源代码体系。 Red Hat Linux是公共环境中表现上佳的服务器。它拥有自己的公司，能向用户提供一套完整的服务，这使得它特别适合在公共网络中使用。这个版本的Linux也使用最新的内核，还拥有大多数人都需要使用的主体软件包。 Red Hat Linux的安装过程也十分简单明了。它的图形安装过程提供简易设置服务器的全部信息。磁盘分区过程可以自动完成，还可以选择GUI工具完成，即使对于 Linux新手来说这些都非常简单。选择软件包的过程也与其他版本类似；用户可以选择软件包种类或特殊的软件包。系统运行起来后，用户可以从Web站点和 Red Hat那里得到充分的技术支持。我发现Red Hat是一个符合大众需求的最优版本。在服务器和桌面系统中它都工作得很好。Red Hat的唯一缺陷是带有一些不标准的内核补丁，这使得它难于按用户的需求进行定制。 Red Hat通过论坛和邮件列表提供广泛的技术支持，它还有自己公司的电话技术支持，后者对要求更高技术支持水平的集团客户更有吸引力 4、Fedora Fedora和Redhat这两个Linux的发行版放联系很密切。Redhat 自9.0以后，不再发布桌面版的，而是把这个项目与开源社区合作，于是就有了Fedora 这个 Linux 发行版。Fedora项目是由 Red Hat 赞助，由开源社区与 Red Hat 工程师合作开发的项目统称。Fedora 的目标，是推动自由和开源软件更快地进步。 特点： １、 Fedora 是一个开放的、创新的、前瞻性的操作系统和平台，基于 Linux。它允许任何人自由地使用、修改和重发布，无论现在还是将来。可运行的体系结构包括x86(即i386),x86_64 和PowerPC！ ２、Fedora 可以说是Redhat 桌面版本的延续，只不过是与开源社区合作。 ３、Fedora 是一个独立的inux发行版本的操作系统。 5、centos CentOS（Community ENTerprise Operating System）是来自于Red Hat Enterprise Linux依照开放源代码规定释出的源代码所编译而成。由于出自同样的源代码，因此有些要求高度稳定性的服务器以CentOS替代商业版的Red Hat Enterprise Linux使用（我会告诉你，以为企业想省钱，运维要靠这个东西来赚钱嘛，国内运维主流是CentOS剩下版本很少）。两者的不同，在于CentOS并不包含封闭源代码软件，CentOS 是一个基于Red Hat Linux 提供的可自由使用源代码的企业级Linux发行版本。每个版本的CentOS都会获得十年的支持（通过安全更新方式）。新版本的 CentOS 大约每两年发行一次，而每个版本的 CentOS 会定期（大概每六个月）更新一次，以便支持新的硬件。这样，建立一个安全、低维护、稳定、高预测性、高重复性的 Linux 环境 6、Slackware介绍 Slackware 由PatrickVolkerding(帕特里克.沃克登)创建于1992年。算起来应当是历史最悠久的Linux发行版。尽管如此，Slackware仍然深入人心（大部分都是比较有经验的 Linux老手）。Slackware稳定、安全，所以仍然有大批的忠实用户。由于Slackware尽量采用原版的软件包而不进行任何修改，所以制造新 bug的几率便低了很多。Slackware的版本更新周期较长（大约1年），但是新版本的软件仍然不间断的提供给用户下载。 7、openSUSE介绍 SUSE是德国最著名的Linux发行版，在全世界范围中也享有较高的声誉。SUSE自主开发的软件包管理系统也大受好评。SUSE于2003年年末被Novell收购。SUSE在收购之后的发布显得比较混乱，比如9.0版本是收费的，而10.0版本（也许由于各种压力）又免费发布。这使得一部分用户感到困惑，也转而使用其它发行版本。最近还跟微软扯到了一起。但是瑕不掩瑜，SUSE仍然是一个非常专业、优秀的发行版。 openSUSE 项目是由Novell公司资助的全球性社区计划，旨在推进 Linux 的广泛使用。这个计划提供免费的openSUSE 操作系统。这里是一个由普通用户和开发者共同构成的社区，我们拥有一个共同的目标—创造世界上最好用的 Linux 发行版。openSUSE 是 Novell 公司发行的企业级 Linux 产品的系统基础。 openSUSE 项目是由Novell 发起的开源社区计划。 旨在推进 Linux 的广泛使用。提供了自由简单的方法来获得世界上最好用的 Linux 发行版，SUSE Linux。openSUSE 项目为 Linux 开发者和爱好者提供了开始使用 Linux 所需要的一切。 8、中国大陆的Linux发行版 红旗Linux(RedflagLinux) ，冲浪Linux(Xteam Linux) ，蓝点Linux ， GNU/Linux，OpenDesktop等等 。 9、 台湾地区的Linux发行版 鸿奇Linux 目前最著名的发行版本：Debian，ubuntu、OpenSuse(原Suse)、CentOS、fedora等。国内比较著名的红旗Linux版本 对于上面的知识我们做下重点总结 redhat：目前，全球最大的linux发行厂商，功能全面、稳定。 Redhat 被 IBM 收购! ubuntu：目前，是linux桌面操作系统做的最好的。 centos：免费版的redhat，centos 基于 redhat 发行版基础之上，再重新编译发布的版本。 目前 centos 已经被 Redhat 公司收购，但是依然免费 2.7. 1.7 Linux 应用领域 今天各种场合都有使用各种 Linux 发行版，从嵌入式设备到超级计算机，并且在服务器领域确定了地位。在企业级开发中，我们通常使用Linux作为我们的服务器。 比如：服务器系统Web应用服务器、数据库服务器、接口服务器、DNS、FTP等等； 嵌入式系统路由器、防火墙、手机、PDA、IP 分享器、交换器、家电用品的微电脑控制器等等，高性能运算、计算密集型应用Linux有强大的运算能力。 目前 Linux 不仅在家庭与企业中使用，并且在政府中也很受欢迎。 巴西联邦政府由于支持 Linux 而世界闻名。 有新闻报道俄罗斯军队自己制造的 Linux 发布版的，做为 G.H.ost 项目已经取得成果。 印度的 Kerala 联邦计划在向全联邦的高中推广使用 Linux。 中华人民共和国为取得技术独立，在龙芯处理器中排他性地使用 Linux。 在西班牙的一些地区开发了自己的 Linux 发布版，并且在政府与教育领域广泛使用，如 Extremadura 地区的 gnuLinEx 和 Andalusia 地区的 Guadalinex。 葡萄牙同样使用自己的 Linux 发布版 Caixa Mágica，用于 Magalh?es 笔记本电脑和 e-escola 政府软件。 法国和德国同样开始逐步采用 Linux。 2.8. 1.8 Linux之CentOS 前面章节介绍了一些Linux的基本知识，前已经对Linux有了一个初步的认识，也知道了在Linux发行版中有各个家族的发行版本；比如比较知名的ubuntu、CentOS，在今天的Linux课程中我们将采用发行版CentOS作为我们Linux课程的讲解内容。 CentOS，是基于 Red Hat Linux 提供的可自由使用源代码的企业级 Linux 发行版本；是一个稳定，可预测，可管理和可复制的免费企业级计算平台 主要特点: 1.主流： 目前的Linux操作系统主要应用于生产环境，主流企业级Linux系统仍旧是RedHat或者CentOS 2.免费： RedHat 和CentOS差别不大，CentOS是一个基于Red Hat Linux 提供的可自由使用源代码的企业级Linux发行版本 3.更新方便：CentOS独有的yum命令支持在线升级，可以即时更新系统，不像RED HAT那样需要花钱购买支持服务！ 我们在当前课程中的环境： Windows7 , VMware Workstation15.02, CentOS Linux release 7.6.1810 2.9. 1.9 总结 当前章节主要介绍了Linux发行的主要版本（我们使用的是CentOS Linux release 7.6.1810 ）、以及与Unix、Windows系统的区别；主要让学生了解Linux是基于Unix的以及与Windows一样，Linux也是操作系统即可。 3. 2 系统与设置命令 在前面的两个章节中，我们主要介绍了Linux基本知识和虚拟机的安装，从当前章节开始，我们一起学习下Linux的基本命令，在当前章节，我们先简单的学习下一些系统的基本命令，慢慢的由浅入深，在后面的章节中我们将学习其他的命令比如文件操作、备份压缩等 3.1. 2.1 学习命令的原因 命令我们可以理解成在Windows中我们常常为了查看ip输入的ipconfig，在Linux中也有很多的命令，比如操作目录、文件、网络、磁盘等等命令 Linux刚面世时并没有图形界面, 所有的操作全靠命令完成, 如 磁盘操作、文件存取、目录操作、进程管理、文件权限 设定等 在职场中，大量的 服务器维护工作 都是在 远程 通过SSH客户端 来完成的， 并没有图形界面， 所有的维护工作都需要通过命令来完成 在职场中， 作为后端程序员或者运维， 必须要或多或少的掌握一些Linux常用的终端命令 Linux发行版本的命令大概有200多个， 但是常用的命令只有几十个而已 总结 学习终端命令的技巧： - 不需要死记硬背， 对于常用命令， 记住语法是关键，在用的时候去查下参数选项，有的很常用的命令，用的多自然就记住了 - 不要尝试一次学会所有的命令， 有些命令是非常不常用的，临时遇到，就去根据语法找参数选项 3.2. 2.2 Linux 用户和用户组管理 3.2.1. 2.2.1 Linux账号管理 从当前章节开始，我们正式进入CentOS的学习，我们先从简单的命令开始，比如操作账号、用户组、系统管理等。 在实际使用场景中，用户账号的管理主要涉及到用户账号的添加、修改和删除操作。 现在，我们就通过命令的方式添加用户账号（账号名字可以自定义，但是是要符合书写规范） 在操作前，确保我们的SecureCRT成功连接到了虚拟机. 下面的章节不在赘述SecureCRT，默认已经成功连接。 1) 添加用户 我们在Windows创建账号主要是是控制面板--用户账户--创建一个新账户，这是在Windows创建账户的流程，而在Linux中，我们可以通过命令的方式进行创建账户 使用者权限：管理员用户 useradd 选项 用户名 参数说明： 选项: -c comment 指定一段注释性描述。 -d 目录 指定用户主目录，如果此目录不存在，则同时使用-m选项，可以创建主目录。 -g 用户组 指定用户所属的用户组。 -G 用户组，用户组 指定用户所属的附加组。 -s Shell文件 指定用户的登录Shell。 -u 用户号 指定用户的用户号，如果同时有-o选项，则可以重复使用其他用户的标识号。 用户名: 指定新账号的用户名(后续我们可以使用这个用户名进行系统登录)。 添加用户czbk（传智播客的首拼）执行 useradd czbk 我们使用useradd命令创建了一个用户czbk useradd 可用来建立用户帐号。帐号建好之后，再用 passwd 设定帐号的密码。 执行如下 由上图我们发现，我们在使用useradd新增用户的时候，出现了权限不足，也就是说我们使用用户itcast没有创建用户的权限。 我们通过管理员账号root进行创建，首先我们从控制台中切换到root su root 在 密码的地方输入我们的root密码【root】即可进入到root用户下。 我们在root下继续创建czbk用户 以下是useradd常用选项 2) 用户口令 引子： 相当于我们在Windows系统中给个用户更改密码，只是我们在CentOS中是更改密码是通过命令完成的。 用户管理的一项重要内容是用户口令的管理。用户账号刚创建时没有口令，但是被系统锁定，无法使用，必须为其指定口令后才可以使用 使用者权限：管理员用户 指定和修改用户口令的Shell命令是passwd。超级用户可以为自己和其他用户指定口令，普通用户只能用它修改自己的口令。命令的格式为： passwd 选项 用户名 可使用的选项： -l 锁定口令，即禁用账号。 -u 口令解锁。 -d 使账号无口令。 -f 强迫用户下次登录时修改口令。 设置当前用户的口令 passwd czbk 此处我们设置密码和itcast账号密码一致，为【Itheima888】 3) 修改用户 相当于我们在Windows系统中修改一个用户，只是我们在CentOS中是修改用户是通过命令完成的。 usermod 命令通过修改系统帐户文件来修改用户账户信息 修改用户账号就是根据实际情况更改用户的有关属性，如用户号、主目录、用户组、登录Shell等。 使用者权限：管理员用户 修改已有用户的信息使用usermod命令，其格式如下： usermod 选项 用户名 下面命令将用户czbk用户名修改成czbk2019 usermod -l czbk2019 czbk 以下是usermod常用选项 4) 删除用户 相当于我们在Windows系统中删除一个用户，只是我们在CentOS中是删除用户是通过命令完成的。 假如我们其中一个用户的账号不再使用，可以从系统中删除。删除用户账号就是要将/etc/passwd等系统文件中的该用户记录删除，必要时还删除用户的主目录。 使用者权限：管理员用户 删除一个已有的用户账号使用userdel命令，其格式如下： userdel 选项 用户名 -f：强制删除用户，即使用户当前已登录; -r：删除用户的同时，删除与用户相关的所有文件 此命令删除用户czbk2019 userdel czbk2019 成功删除用户czbk2019 以下是userdel常用选项 3.2.2. 2.2.2 Linux用户组 引子： 为了方便用户管理, 提出了 组 的概念, 如下图所示 新增一个账户，它默认属于自己（账户）的组 比如新建账户【张三】，那么它默认对应的组就是张三 一个用户可以有一个或者多个组 假如说（如上图），我们在企业级开发过程中，我们有多个组，其中一个开发组对应三个账户，张三、李四、王五、如果就像上面提到的，一个用户默认对应一个组，那么三个账户张三、李四、王五就有了三个不同的组，如果大家都操做一个文件，在进行权限分配的时候，就要对不同的三个组进行授权，显然这样是不合理的，因为太过繁琐。 所以，才有了组（新建组）的概念，我们把张三、李四、王五统一放到【开发组】，在对文件授权的时候，我们只对【开发组】进行授权由此，这样的话【张三、李四、王五】都有相等的权利操作了。 1) 增加用户组 新增一个用户组（组名可见名知意，符合规范即可），然后将用户添加到组中 使用者权限：管理员用户 groupadd 选项 用户组 使用的选项有： -g GID 指定新用户组的组标识号（GID）。 -o 一般与-g选项同时使用，表示新用户组的GID可以与系统已有用户组的GID相同 新增用户组czbk-it groupadd czbk-it 上面的命令向系统中增加了一个新组czbk-it，新组的组标识号是在当前已有的最大组标识号的基础上加1 以下是groupadd常用选项 2) 修改用户组 使用者权限：管理员用户 groupmod 选项 用户组 常用的选项有： -g GID 为用户组指定新的组标识号。 -o 与-g选项同时使用，用户组的新GID可以与系统已有用户组的GID相同。 -n新用户组 将用户组的名字改为新名字 groupmod -n czbk-it-2019 czbk-it 上面的命令将组czbk-it的组名修改为czbk-it-2019。 以下是groupmod常用选项 3) 查询用户所属组 在查询用户所属的用户组前，我们先增加一个用户ituser-groups useradd ituser-groups 要查询一个用户属于哪个用户组，使用groups命令，其格式如下 groups 用户名 查询用户ituser-groups属于某个用户组，执行groups命令 groups ituser-groups 由此可见，ituser-groups用户属于用户组ituser-groups（用户组默认与用户名一样） 4) 删除用户组 使用者权限：管理员用户 要删除一个已有的用户组，使用groupdel命令，其格式如下 groupdel 用户组 删除czbk-it-2019用户组 groupdel czbk-it-2019 删除成功 以下是groupdel常用选项 3.2.3. 2.2.3 将用户添加到组 引子： 在上面我们学习如何新增用户，也学习了如何新增用户组，在当前的小节中，我们新建一个用户、新建一个用户组、然后把新建的用户添加到新的组中 在实际开发过程中，我们通常把多个用户按照业务需求归并到统一的一个组中，进行有序管理 1、创建一个新的组，并添加组ID（需要切换到root用户） groupadd -g 8888 itbj2020group 执行效果如下 2、创建3个用户（需要切换到root用户） useradd itbeijinguser1 useradd itbeijinguser2 useradd itbeijinguser3 3、将上面三个用户添加到组itbj2020group 我们通过passwd命令将三个用户添加到组 什么是gpasswd： gpasswd 是 Linux 下工作组文件 /etc/group 和 /etc/gshadow 管理工具，用于将一个用户添加到组或者从组中删除。 语法 gpasswd [可选项] 组名 将上面的三个用户使用gpasswd添加到组（需要切换到root用户） gpasswd -a itbeijinguser1 itbj2020group gpasswd -a itbeijinguser2 itbj2020group gpasswd -a itbeijinguser3 itbj2020group 执行如下 查看用户组下所有用户（所有用户） 注意 此处的grep命令我们将在文件管理章节详细讲解，这里先使用它查看下效果 grep 'itbj2020group' /etc/group 执行效果如下（或者直接打开/etc/group文件都可以） 由上图可知：三个用户全部都加入到了itbj2020group组。 3.3. 2.3 系统管理 系统管理，说的就是我们的CentOS系统，它不同于Windwos，CentOS是字符界面，我们需要通过命令进行操作，在当前章节，我们先从基本命令学起，比如创建用户、设置密码、修改用户以及用户组的相关操作。也为我们后面的章节打下基础 3.3.1. 2.3.1 日期管理 当前日期如果通过date进行设置，在系统重启后不会保存date的设置，常用的只是通过date命令查看日期 date 可以用来显示或设定系统的日期与时间 使用者权限：所有用户 语法如下： date [参数选项] 参数 -d：显示字符串所指的日期与时间。字符串前后必须加上双引号； -s：根据字符串来设置日期与时间。字符串前后必须加上双引号； -u：显示GMT； --help：在线帮助； --version：显示版本信息 1、设置时间 用 -s选项可以设置系统时间，如下： date -s \"2019-12-11 16:15:00\" 2、显示时间 date （1）UTC 协调世界时，又称世界统一时间、世界标准时间、国际协调时间。由于英文（CUT）和法文（TUC）的缩写不同，作为妥协，简称UTC。。 （2）GMT 即格林尼治 平太阳时间，是指格林尼治所在地的标准时间，也是表示地球自转速率的一种形式 外文名:Universal Time 其他外文名G.M.T.(Greenwich Mean Time) （3）CST 北京时间 （中国国家标准时间） 北京时间是中国采用国际时区东八时区的区时作为标准时间。 北京时间并不是北京（东经116.4°）的地方时间，而是东经120°的地方时间，故东经120度地方时比北京的地方时早约14分半钟。因为北京处于国际时区划分中的东八区，同格林尼治时间（世界时）整整相差8小时（即北京时间=世界时+8小时），故命名为“北京时间”。东八区包括的范围从东经112.5°到东经127.5°，以东经120°为中心线，东西各延伸7.5°，总宽度为15°的区域。 而中国幅员辽阔，东西相跨5个时区（即东五区、东六区、东七区、东八区、东九区5个时区）授时台必须建在地理中心地带，从而也就产生了长短波授。“北京时间”与“北京当地时间”是两个概念， “北京时间”的发播不在北京，而在陕西蒲城（处于东七区） （4）东八区 东八区（UTC/GMT+08:00）是比世界协调时间（UTC）/格林尼治时间（GMT）快8小时的时区，理论上的位置是位于东经112.5度至127.5度之间，是东盟标准的其中一个候选时区。当格林尼治标准时间为0:00时，东八区的标准时间为08:00 总结： 上面提到了很多知识：即UTC/GMT/CST/东八区 总结一下就是，北京时间(中国国家标准时间CST)采用东八区区时，即： 协调世界时(UTC)+8 / 格林尼治时间(GMT)+8 也就是说+8后的时间才是北京时间 3.3.2. 2.3.2 显示用户 logname命令用于显示用户名称。 执行logname指令，它会显示目前用户的名称 语法为如下： logname [--help][--version] 参数： --help 　在线帮助。 --vesion 　显示版本信息。 显示登录账号的信息 logname 3.3.3. 2.3.3 su切换账户 引子： 比如我们在新增用户、修改用户或者操作用户组的时候常常需要切换到管理员账户，这个时候，我们就可以使用su进行快速切换 su命令用于变更为其他使用者的身份，除 root 外，需要键入该使用者的密码。 使用权限：所有使用者。 语法如下： su 变更帐号为 root 并在执行 ls 指令后退出返回原使用者 su -c ls root 切换到root su root 这样的话，我们就进入到了root用户下。 3.3.4. 2.3.4 id命令 我们如果需要查看当前账号详细信息的时候，比如查看它的用户id、群组id以及所属组的时候，我们就可以使用id命令进行查看 id命令用于显示用户的ID，以及所属群组的ID。 id会显示用户以及所属群组的实际与有效ID。若两个ID相同，则仅显示实际ID。若仅指定用户名称，则显示目前用户的ID。 使用者权限：所有用户 语法 id [-gGnru][--help][--version][用户名称] 参数说明： -g或--group 　显示用户所属群组的ID。 -G或--groups 　显示用户所属附加群组的ID。 -n或--name 　显示用户，所属群组或附加群组的名称。 -r或--real 　显示实际ID。 -u或--user 　显示用户ID。 -help 　显示帮助。 -version 　显示版本信息。 显示当前用户信息 id 执行效果如下 总结 id命令参数虽然很多 但是常用的也就是id命令，不带参数的 主要看他的uid和组信息 3.3.5. 2.3.5 sudo执行 比如我们使用普通用户操作用户或者操作用户组、以及修改网卡配置文件的时候，需要切换到root用户才操作，此时我们可以使用sudo命令提高普通用户的操作权限，以达到操作目的 sudo:控制用户对系统命令的使用权限,root允许的操作。 通过sudo可以提高普通用户的操作权限 使用者权限：普通用户 语法如下： sudo -V sudo -h sudo -l sudo -v sudo -k sudo -s sudo -H sudo [ -b ] [ -p prompt ] [ -u username/#uid] -s sudo command 参数说明： -V 显示版本编号 -h 会显示版本编号及指令的使用方式说明 -l 显示出自己（执行 sudo 的使用者）的权限 -v 因为 sudo 在第一次执行时或是在 N 分钟内没有执行（N 预设为五）会问密码，这个参数是重新做一次确认，如果超过 N 分钟，也会问密码 -k 将会强迫使用者在下一次执行 sudo 时问密码（不论有没有超过 N 分钟） -b 将要执行的指令放在背景执行 -p prompt 可以更改问密码的提示语，其中 %u 会代换为使用者的帐号名称， %h 会显示主机名称 -u username/#uid 不加此参数，代表要以 root 的身份执行指令，而加了此参数，可以以 username 的身份执行指令（#uid 为该 username 的使用者号码） -s 执行环境变数中的 SHELL 所指定的 shell ，或是 /etc/passwd 里所指定的 shell -H 将环境变数中的 HOME 指定为要变更身份的使用者HOME目录（如不加 -u 参数就是系统管理者 root ） command 要以系统管理者身份（或以 -u 更改为其他人）执行的指令 sudo命令使用 sudo ls 指定root用户执行指令 sudo -u root ls -l 修改网卡配置文件 比如，在下面的例子中，我们使用普通用户修改网卡的配置文件，在进行保存的时候，提示我们【无法打开并写入文件】，那么此时，我们可以通过sudo命令来提升自己的写入权限 执行： vi /etc/sysconfig/network-scripts/ifcfg-ens33 执行效果如下（保存） 然后点击回车 那么我们在修改上面的 命令，使用sudo进行修改 sudo vi /etc/sysconfig/network-scripts/ifcfg-ens33 执行效果如下（键入itcast密码） 执行保存 我们发现此时就不在报错了 3.3.6. 2.3.6 top命令 在企业级开发中，开发人员（运维人员也会经常使用）常常为了查看服务器上运行的程序占用的CPU情况以及占用内存情况，目的就是检测我们的程序是否在正常范围内运行 top命令用于实时显示 process 的动态。 使用权限：所有使用者。 显示进程信息 top 执行效果如下 各进程（任务）的状态监控属性解释说明： PID — 进程id USER — 进程所有者 PR — 进程优先级 NI — nice值。负值表示高优先级，正值表示低优先级 VIRT — 进程使用的虚拟内存总量，单位kb。VIRT=SWAP+RES RES — 进程使用的、未被换出的物理内存大小，单位kb。RES=CODE+DATA SHR — 共享内存大小，单位kb S — 进程状态。D=不可中断的睡眠状态 R=运行 S=睡眠 T=跟踪/停止 Z=僵尸进程 %CPU — 上次更新到现在的CPU时间占用百分比 %MEM — 进程使用的物理内存百分比 TIME+ — 进程使用的CPU时间总计，单位1/100秒 COMMAND — 进程名称（命令名/命令行） 显示完整命令，与top命令不同的就是command属性像是进行了命令补全 top -c 执行效果如下 显示指定的进程信息，以下显示进程号为6972的进程信息，CPU、内存占用率等 top -p 6972 执行效果如下 top命令的用法很多 但是常用的就是top（不带参数），有的时候，在进程比较多的时候，我们常常记住进程的pid，然后通过top -p pid进行查看 也就是说，top+ top -p是经常被用到的 3.3.7. 2.3.7 ps命令 ps命令类似于我们在Windows中通过任务管理器查看进程信息 Linux ps命令用于显示当前进程 (process) 的状态信息 使用者权限：所有用户 语法如下： ps 显示进程信息 ps -A 显示指定用户信息 ps -u itcast 显示所有进程信息 ps -ef 3.3.8. 2.3.8 kill命令 引子： 前面，我们刚刚学习完了Windows上开发，比如，我们经常遇到的要给问题就是，我们需要经常的启动或者重启tomcat，有的时候会报端口冲突，这个时候，我们可能就去Windows的任务管理器中去结束这个进程 那么在Linux中我们可以通过kill命令来实现Windwos上手工结束进程的操作 Linux kill命令用于删除执行中的程序或工作(可强制中断) 使用者权限：所有用户 语法如下： kill [-s ][程序]　或　kill [-l ] 参数说明： -l 　若不加选项，则-l参数会列出全部的信息名称。 -s 　指定要送出的信息。 [程序] 　[程序]可以是程序的PID或是PGID，也可以是工作编号。 杀死一个进程 kill 15642 强制杀死进程 kill -KILL 15642 彻底杀死进程 kill -9 15642 杀死指定用户所有进程 1.方法一 过滤出itcast用户进程 kill -9 $(ps -ef | grep itcast) 2.方法二，直接杀死 kill -u itcast 注意 上面列举了很多kill进程的命令 但是我们我们常用的就是kill -9命令，我们常常找到进程的pid 然后通过kill -9进行杀死进程 3.3.9. 2.3.9 关机命令 shutdown命令可以用来进行关闭系统，并且在关机以前传送讯息给所有使用者正在执行的程序，shutdown 也可以用来重开机 使用者权限：管理员用户 语法如下： shutdown [-t seconds] [-rkhncfF] time [message] 参数说明： -t seconds : 设定在几秒钟之后进行关机程序。 -k : 并不会真的关机，只是将警告讯息传送给所有使用者。 -r : 关机后重新开机。 -h : 关机后停机。 -n : 不采用正常程序来关机，用强迫的方式杀掉所有执行中的程序后自行关机。 -c : 取消目前已经进行中的关机动作。 -f : 关机时，不做 fcsk 动作(检查 Linux 档系统)。 -F : 关机时，强迫进行 fsck 动作。 time : 设定关机的时间。 message : 传送给所有使用者的警告讯息。 立即关机 shutdown -h now 或者 shudown 指定1分钟后关机，1分钟关机并显示警告信息 shutdown +1 “System will shutdown after 1 minutes” 指定1分钟后重启，并发出警告信息 shutdown –r +1 “1分钟后关机重启” 3.3.10. 2.3.10 重启命令 reboot命令用于用来重新启动计算机 使用者权限：管理员、普通（需要验证）用户 语法如下： reboot [-n] [-w] [-d] [-f] [-i] 参数： -n : 在重开机前不做将记忆体资料写回硬盘的动作 -w : 并不会真的重开机，只是把记录写到 /var/log/wtmp 档案里 -d : 不把记录写到 /var/log/wtmp 档案里（-n 这个参数包含了 -d） -f : 强迫重开机，不呼叫 shutdown 这个指令 -i : 在重开机之前先把所有网络相关的装置先停止 开始重新启动 reboot 重启效果如下 此时我们的虚拟机正在重启（别忘记使用root用户执行） 3.3.11. 2.3.11 who命令 在企业级开发过程中，我们使用who命令的时候常常需要快速重启服务器，在重启之前需要检测下有没有终端在连接（处理程序），如果有，可能就不会重启（会私下询问何时弄完，弄完后在重启），如果没有其他人连接，将执行快速重启 who命令用于显示系统中有哪些使用者正在上面，显示的资料包含了使用者 ID、使用的终端机、从哪边连上来的、上线时间、呆滞时间、CPU 使用量、动作等等 使用者权限：所有使用者都可使用。 语法如下： who - [husfV] [user] 参数说明： -H 或 --heading：显示各栏位的标题信息列； -i 或 -u 或 --idle：显示闲置时间，若该用户在前一分钟之内有进行任何动作，将标示成\".\"号，如果该用户已超过24小时没有任何动作，则标示出\"old\"字符串； -m：此参数的效果和指定\"am i\"字符串相同； -q 或--count：只显示登入系统的帐号名称和总人数； -s：此参数将忽略不予处理，仅负责解决who指令其他版本的兼容性问题； -w 或-T或--mesg或--message或--writable：显示用户的信息状态栏； --help：在线帮助； --version：显示版本信息 显示当前登录系统的用户 who 显示明细(标题)信息 who -H 由上图可知，截止到现在只有itcast在线。 3.3.12. 2.3.12 timedatectl命令 引子： timedatectl是用于控制系统时间和日期。可以用来查询和更改系统时钟于设定，同时可以设定和修改时区信息。 在实际开发过程中，系统时间的显示会和实际出现不同步；我们一般为了校正服务器时间、时区的时候会使用timedatectl命令 使用者权限：所有使用者都可使用，设置时间需要管理员，下面会标注。 几个常见的概念，进行总结如下： 显示系统的当前时间和日期，使用命令行中的timedatectl命令 timedatectl status 执行效果如下 在上面的示例中，分别显示时区、CST时间和UTC时间，其中,RTC time就是硬件时钟的时间，硬件时间默认为UTC。 查看当前时区 timedatectl | grep Time 或者 timedatectl 执行效果如下 上图显示中国时区 查看所有可用的时区 timedatectl list-timezones 执行效果如下（下面数据没有截全） 设置本地时区 timedatectl set-timezone \"Asia/Shanghai\" 执行效果如下 禁用时间同步（使用管理员账户） timedatectl set-ntp false 在执行 timedatectl set-time \"2019-03-11 20:45:00\" 执行效果如下 注意: 如果ntp时间同步为true时无法修改时间设定，下面马上介绍 打开ntp timedatectl set-ntp true 在执行 timedatectl set-time \"2019-03-11 20:45:00\" 执行效果如下（ntp时间同步为true时无法修改时间设定） 报错信息 如下 启用时间同步 NTP即Network Time Protocol（网络时间协议），是一个互联网协议，用于同步计算机之间的系统时钟。timedatectl实用程序可以自动同步你的Linux系统时钟到使用NTP的远程服务器。 要开始自动时间同步到远程NTP服务器，在终端键入以下命令。 timedatectl set-ntp true 比如，在上面我们使用timedatectl set-time \"2019-03-11 20:45:00\"，如下图 此时我们执行timedatectl set-ntp true，发现时间正常同步过来了如下图 要禁用NTP时间同步，在终端键入以下命令 timedatectl set-ntp false 执行上面的 命令即可关闭ntp 总结 在实际使用过程中 我们经常使用timedatectl进行时区、CST、UTC的设置 3.3.13. 2.3.13 clear命令 clear命令用于清除屏幕 使用者权限：所有使用者都可使用。 语法 clear 执行clear前 执行clear后 通过执行clear命令，就可以把缓冲区的命令全部清理干净了 3.3.14. 2.3.14 exit命令 exit命令用于退出目前的shell。 执行exit可使shell以指定的状态值退出。若不设置状态值参数，则shell以预设值退出。状态值0代表执行成功，其他值代表执行失败。exit也可用在script，离开正在执行的script，回到shell。 退出码（exit status，或exit code）的约定： 0表示成功（Zero - Success） 非0表示失败（Non-Zero - Failure） 2表示用法不当（Incorrect Usage） 127表示命令没有找到（Command Not Found） 126表示不是可执行的（Not an executable） >=128 信号产生 语法如下 exit [状态值] 退出终端 # exit exit会被经常在shell中使用 我们在明天的课程【综合案例】中会使用到exit 3.4. 2.4 总结 用户账号管理和用户组是我们在实际使用过程中常用的命令，学习完创建账号、创建组后，需要通过gpasswd命令将用户添加到组，这也是我们学习的最终目的 系统管理的常用命令都是在开发过程中经常使用到的 4. 3 Linux目录管理 注意： 在下面的讲解中，每个命令都有很多的参数说明（选项），我们只讲其中的几个，关键是让学生掌握命令的语法；学生学习完语法后，就可以自己按照参数书写各种命令，这也是我们最终的目的。常用命令，我们在企业级开发过程中，经常书写的命令。会非常被容易记住，不常用的命令，只要我们学习完了语法之后，在去查找参数手册，会非常容易的解决我们的问题，所以，每个命令不是建立在死记硬背的基础上的，要理解语法+查找参数=解决问题 4.1. 3.1 Linux 文件与目录管理 在Linux系统中，所有的的目录结构为树状结构，最顶级的目录为根目录 /。 在实际开发过程中，文件的操作是非常频繁也是非常重要的 下面的章节我们将学习下Linux系统所有的系统目录和文件通过命令是如何进行管理的 4.1.1. 3.1.1 目录常用命令 ls: 列出目录 cd： 切换目录 pwd： 显示目前的目录 mkdir：创建一个新的目录 rmdir：删除一个空的目录 cp: 复制文件或目录 rm: 移除文件或目录 mv: 移动文件与目录或修改文件与目录的名称 自动补全 在敲出 文件/ 目录 / 命令 的前几个字母之后, 按下 tab键 如果还存在其他 文件 / 目录 / 命令, 再按一下tab键, 系统会提示可能存在的命令 1) ls (列出目录) ls命令相当于我们在Windows系统中打开磁盘、或者打开文件夹看到的目录以及文件的明细，如下图 【查看磁盘下的目录与文件】 【查看文件夹下的目录与文件】 注意：在Linux系统当中， ls 命令算是比较常用的命令 使用者权限：所有使用者都可使用。 语法如下： ls [选项] 目录名称 选项与参数： -a ：全部的文件，连同隐藏档( 开头为 . 的文件) 一起列出来(常用) -d ：仅列出目录本身，而不是列出目录内的文件数据(常用) -l ：长数据串列出，包含文件的属性与权限等等数据；(常用) 将根目录下的所有文件列出来(含属性与隐藏档) ls -al ~ 执行效果如下 ls -l ls -l 可以查看文件夹下文件的详细信息, 从左到右 依次是: 权限（A区域）, 第一个字符如果是 d 表示目录 硬链接数（B区域）, 通俗的讲就是有多少种方式, 可以访问当前目录和文件 属主（C区域）, 文件是所有者、或是叫做属主 属组（D区域）, 文件属于哪个组 大小（E区域）：文件大小 时间（F区域）：最后一次访问时间 名称（G区域）:文件的名称 ls 总结 以上三种是经常被使用到的命令 它们之间的区别是 ls 显示不隐藏的文件与文件夹 ls -l 显示不隐藏的文件与文件夹的详细信息 ls -al 显示所有文件与文件夹的详细信息 2) pwd显示当前目录 执行pwd命令相当于我们在Windows系统路径导航栏中查看到的当前浏览位置信息 如下图 pwd 是 Print Working Directory 的缩写，也就是显示目前所在当前目录的命令。 使用者权限：所有使用者都可使用。 查看当前所在目录 pwd -P 执行效果如下 3) cd (切换目录) Linux的cd切换目录，相当于我们在Windows中通过鼠标或者快捷键点开不同的目录 注意：在Linux系统当中， cd 命令算是比较常用的命令 cd是Change Directory的缩写，这是用来变换工作目录的命令 使用者权限：所有使用者都可使用。 语法如下： cd [相对路径或绝对路径] 在正式学习cd命令前面，我们通过下面一个座位图的形式讲解下相对路径和绝对路径是怎么表现的。 绝对路径： 路径的写法，由根目录 / 写起，例如： /usr/share/doc 这个目录。 相对路径： 路径的写法，不是由 / 写起，例如由 /usr/share/doc 要到 /usr/share/man 底下时，可以写成： cd ../man 这就是相对路径的写法啦！ 1、使用相对路径定位目标 特征: 相对路径 输入路径时, 最前面不是以 \"/\" 开始的, 表示相对 当前目录 所在的位置 缺点: 参照工作目录 发生变化 相对路径也要发生变化 需求1: 当前工作目录是 /usr, 使用相对路径 切换到 /usr/tmp 目录下 需求2: 当前工作目录是 /root, 使用相对路径 切换到 /usr/tmp 目录下 执行效果如下 注意： cd ~ 表示回到根目录 2、使用绝对路径定位目标 特征: 绝对路径 在输入路径时, 最前面是以 / 开始的, 表示 从 根目录 开始的具体目录位置 优点: 定位准确, 不会因为 工作目录变化 而变化 需求1: 当前工作目录是 /usr, 使用绝对路径 切换到 /usr/tmp 目录下 需求2: 当前工作目录是 /root, 使用绝对路径 切换到 /usr/tmp 目录下 执行效果如下 总结 相对路径 在输入路径时, 最前面不是以 / 开始的 , 表示相对 当前目录 所在的目录位置 绝对路径 在输入路径时, 最前面是以 / 开始的, 表示 从 根目录 开始的具体目录位置 4) mkdir(创建目录) 引子： Linux的mkdir命令相当于我们在Windows中通过鼠标或者快捷键新建文件夹 mkdir命令用于建立名称为 dirName 之子目录 使用权限：于目前目录有适当权限的所有使用者 语法 mkdir [-p] dirName 参数说明： -p 确保目录名称存在，不存在的就建一个 建立一个名为jinyanlong 的子目录 mkdir jinyanlong 执行效果如下 查看新建的 文件 在工作目录下的 aaa目录中，建立一个名为 bbb的子目录。 若 aaa目录原本不存在，则建立一个。（注：本例若不加 -p，且原本 aaa目录不存在，则产生错误。） mkdir -p aaa/bbb 执行效果如下 这里为了显示更直观，我们使用了tree命令 后面在讲解到yum的时候，会详细讲解 此处先使用 由上图我们发现，aaa目录被强制创建，里面包含了bbb文件。 5) rmdir(删空目录) Linux的rmdir命令相当于我们在Windows中通过鼠标或者快捷键删除文件夹。 稍微有点不同的就是在Linux中删除子目录的时候，如果主目录下没有了目录以及文件，会连同主目录同时删除了（需要写Linux带有P的参数） rmdir命令删除空的目录 使用权限：于目前目录有适当权限的所有使用者。 语法 rmdir [-p] dirName 参数： -p 是当子目录被删除后使它也成为空目录的话，则顺便一并删除。 将工作目录下，名为 jinyanlong 的子目录删除 : rmdir jinyanlong 在工作目录下的 aaa目录中，删除名为 bbb的子目录。若 bbb删除后，aaa目录成为空目录，则 aaa同时也会被删除 rmdir -p aaa/bbb 总结： rmdir -p aaa/bbb也就是说 在删除bbb目录完成后，发现aaa目录也是空目录了，在删除完bbb后aaa也同时被删除了。 6) cp(文件复制) Linux的cp命令相当于我们在Windows中通过鼠标或者快捷键复制文件或者目录 cp命令主要用于复制文件或目录。 使用权限：于目前目录有适当权限的所有使用者 语法 cp [options] source dest 或 cp [options] source... directory 参数说明： -a：此选项通常在复制目录时使用，它保留链接、文件属性，并复制目录下的所有内容。其作用等于dpR参数组合。 -d：复制时保留链接。这里所说的链接相当于Windows系统中的快捷方式。 -f：覆盖已经存在的目标文件而不给出提示。 -i：与-f选项相反，在覆盖目标文件之前给出提示，要求用户确认是否覆盖，回答\"y\"时目标文件将被覆盖。 -p：除复制文件的内容外，还把修改时间和访问权限也复制到新文件中。 -r/R：若给出的源文件是一个目录文件，此时将复制该目录下所有的子目录和文件。 -l：不复制文件，只是生成链接文件。 我们将当前目录\"aaa/\"下的所有目录以及文件复制到新目录\"ccc\"下，输入如下命令： 1、数据准备 创建aaa目录并且aaa下包含bbb目录 mkdir -p aaa/bbb mkdir -p ccc 执行效果如下 aaa目录下有bbb ccc下面没有目录和文件 2、执行复制 cp –r aaa/* ccc 执行效果如下 我们将aaa下面的所有文件、目录复制到了目录c下面 总结： 用户使用该指令复制目录时，必须使用参数\"-r\"或者\"-R\"。 如果不加参数\"-r\"或者\"-R\",只复制文件，而略过目录 7) rm(删除目录) Linux的rm命令相当于我们在Windows中通过鼠标或者快捷键删除文件或者目录 rm命令用于删除一个文件或者目录。 使用权限：于目前目录有适当权限的所有使用者 语法 rm [options] name... 参数： -i 删除前逐一询问确认。 -f 即使原档案属性设为唯读，亦直接删除，无需逐一确认。 -r 将目录及以下之档案亦逐一删除。 如果我们要删除文件可以直接使用rm命令，若删除目录则必须配合选项\"-r\"，例如： rm -r ccc 执行删除，如下图 注意 文件一旦通过rm命令删除，则无法恢复，所以必须格外小心地使用该命令 如果删除文件（比如.sh 、.txt） 直接使用rm name.txt 8) mv(移动文件) Linux的mv命令相当于我们在Windows中通过鼠标或者快捷键剪切（+重命名）+粘贴文件或者目录 mv 命令用来为文件或目录改名、或将文件或目录移入其它位置 语法 mv [options] source dest mv [options] source... directory 参数说明： -i: 若指定目录已有同名文件，则先询问是否覆盖旧文件; -f: 在 mv 操作要覆盖某已有的目标文件时不给任何指示; 将文件 aaa 更名为 bbb : 1、创建aaa目录、 mkdir aaa 2、开始重命名 mv aaa bbb 执行后 将ccc目录放入ddd目录中。 注意，如果ddd目录不存在，则该命令将ccc改名为ddd。 创建ccc mkdir ccc 开始移动 mv ccc/ ddd 由上图我们发现，由于ddd目录不存在，所以在mv的时候将ccc目录改名为了ddd。 4.2. 3.2 Linux 文件基本属性 在Wndows系统中，我们可以选中一个文件，右键属性，可以查看到这个文件的文件类型（基本信息），以及文件的权限信息，在Linux中，它是通过不同字符的排序顺序来表示文件的类型以及权限所属信息的。 Linux系统是一种典型的多用户系统，不同的用户处于不同的地位，拥有不同的权限。为了保护系统的安全性，Linux系统对不同的用户访问同一文件（包括目录文件）的权限做了不同的规定。 下面我们就一起学习下Linux系统不同权限的文件和目录在怎么表示的 在Linux中我们可以使用ll或者ls –l命令来显示一个文件的属性以及文件所属的用户和组，如： ls -l 实例中，bin文件的第一个属性用\"d\"表示。\"d\"在Linux中代表该文件是一个目录文件。 在Linux中第一个字符代表这个文件是目录、文件或链接文件等等。 当为[ d ]则是目录 当为[ - ]则是文件； 若是[ l ]则表示为链接文档(link file)； 若是[ b ]则表示为装置文件里面的可供储存的接口设备(可随机存取装置)； 若是[ c ]则表示为装置文件里面的串行端口设备，例如键盘、鼠标(一次性读取装置)。 接下来的字符中，以三个为一组，且均为『rwx』 的三个参数的组合。其中，[ r ]代表可读(read)、[ w ]代表可写(write)、[ x ]代表可执行(execute)。 要注意的是，这三个权限的位置不会改变，如果没有权限，就会出现减号[ - ]而已。 每个文件的属性由左边第一部分的10个字符来确定（如下图）。 从左至右用0-9这些数字来表示。 第0位确定文件类型，第1-3位确定属主（该文件的所有者）拥有该文件的权限。 第4-6位确定属组（所有者的同组用户）拥有该文件的权限，第7-9位确定其他用户拥有该文件的权限。 其中，第1、4、7位表示读权限，如果用\"r\"字符表示，则有读权限，如果用\"-\"字符表示，则没有读权限； 第2、5、8位表示写权限，如果用\"w\"字符表示，则有写权限，如果用\"-\"字符表示没有写权限；第3、6、9位表示可执行权限，如果用\"x\"字符表示，则有执行权限，如果用\"-\"字符表示，则没有执行权限。 4.3. 3.3 Linux文件属主和属组 引子： 对于一个文件来说，它都有一个特定的所有者，也就是对该文件具有所有权的用户。 也就是所谓的属主，它属于哪个用户的意思。 除了属主，还有属组，也就是说，这个文件是属于哪个组的（用户所属的组）。 文件的【属主】有一套【读写执行权限rwx】 文件的【属组】有一套【读写执行权限rwx】 还有它权限，下面我们在介绍 在以上实例中，aaa文件是一个目录文件，属主和属组都为 itcast，属主有可读、可写、可执行的权限（rwx）；与属主同组的其他用户有可读可写和可执行的权限（rwx）；其他用户也有可读和可执行的权限（r-x）。 4.3.1. 3.3.1 chgrp更改属组 实际开发中我们经常会创建新建目录和文件，一般情况下，通过命令进行新建， 在创建完成后，使用不同的用户访问，可能就会出现报错，无法访问等等问题。 然后经过一番这查找,发现该有的文件都在，大小写也没问题，路径也没问题 其实并不是这些问题。而是权限问题导致我们无法访问！是因为一个文件默认隶属于一个属组，而使用其他用户访问这个文件肯定无法访问(因为访问用户所属的组和文件所在的不是同一个组) 那么怎么可以正常访问呢？其实就是通过更改用户组（用户组、文件组）来解决这些问题 chgrp命令用于变更文件或目录的所属群组。 文件或目录权限的的拥有者由所属群组来管理。您可以使用chgrp指令去变更文件与目录的所属群组，设置方式采用群组名称或群组识别码皆可 为了方便初学者记忆，可以将 chgrp 理解为是 \"change group\" 的缩写 语法如下 chgrp [-cfhRv][--help][--version][所属群组][文件或目录...] 或 chgrp [-cfhRv][--help][--reference=][--version][文件或目录...] 改变文件的群组属性 我们通过root用户进入（如下图），上接上面的例子 我们的aaa文件的属主和属组都属于itcast（如下图） 我们现在通过chgrp命令将文件aaa的属组更改成root（其他也可以） chgrp -v root aaa 执行效果如下 我们通过下面的命令查询文件aaa的属组是否发生了变化，执行 ls -l 由上图我们发现，文件aaa的属组由itcast变成了root 这样的话，文件的属组就发生了变化。 4.3.2. 3.3.2 chown更改属主和属组** 我们为了让一些用户有权限查看某一文档，比如是一个时间表，而编写时间表的人要具有读写执行的权限(属主) 我们想让一些用户知道这个时间表的内容，而不让他们修改，所以我们可以把这些用户都划到一个组（属组），然后来修改这个文件的权限，让用户组可读，这样用户组下面的每个用户都是可读的 Linux是多任务操作系统，所有的档案皆有拥有者。利用 chown 可以将档案的拥有者加以改变。一般来说，这个指令只有是由系统管理者(root)所使用，一般使用者没有权限可以改变别人的档案拥有者，也没有权限可以自己的档案拥有者改设为别人。只有系统管理者(root)才有这样的权限 使用权限 : 管理员账户 语法如下 chown [–R] 属主名 文件名 chown [-R] 属主名：属组名 文件名 我们通过root用户进入（如下图），上接上面的例子 我们的aaa文件的属主属于itcast、属组属于root 我们现在通过chgrp命令将文件aaa的属主更改成root，执行 chown root aaa 效果如下 我们通过下面的命令查询文件aaa的属主是否发生了变化，执行 ls -l 由上图我们发现，文件aaa的属主和属组都变成了root。 我们将aaa文件的拥有者与群组改回为itcast： 注意：chown命令可以更改属主和属组 chown itcast:itcast aaa 我们通过下面的命令查询文件aaa的属主是否发生了变化，执行 ls -l 由上图可知，aaa文件的属主和属组都被更改回来了。 4.3.3. 3.3.3 chmod权限命令 Linux文件属性有两种设置方法，一种是数字，一种是符号 Linux的文件调用权限分为三级 : 文件属主、属组、其他。利用 chmod 可以控制文件如何被他人所调用。 使用权限 : 所有使用者 语法 chmod [-cfvR] [--help] [--version] mode file... 参数说明 mode : 权限设定字串，格式如下 [ugoa...][[+-=][rwxX]...][,...] 解释： u 表示该档案的拥有者，g 表示与该档案的拥有者属于同一个群体(group)者，o 表示其他以外的人，a 表示这三者皆是。 +表示增加权限、- 表示取消权限、= 表示唯一设定权限。 r 表示可读取，w 表示可写入，x 表示可执行，X 表示只有当该档案是个子目录或者该档案已经被设定过为可执行。 1) 数字权限 Linux文件的基本权限就有九个，分别是owner/group/others三种身份各有自己的read/write/execute权限。 先复习一下刚刚上面提到的数据：文件的权限字符为：『-rwxrwxrwx』， 这九个权限是三个三个一组（owner/group/others就是所说的三个一组 ）的，我们也可以使用数字来代表各个权限，各权限的分数对照表如下 各权限的数字对照表：[r]:4;[w]:2;[x]:1;[-]:0 每种身份(owner/group/others)各自的三个权限(r/w/x)分数是需要累加的，例如当权限为： [-rwxrwx---] 分数则是： owner = rwx = 4+2+1 = 7 group = rwx = 4+2+1 = 7 others= --- = 0+0+0 = 0 所以等一下我们设定权限的变更时，该文件的权限数字就是770啦,变更权限的指令chmod的语法是这样的 chmod [-R] xyz 文件或目录 选项与参数： xyz : 就是刚刚提到的数字类型的权限属性，为 rwx 属性数值的相加。 -R : 进行递归(recursive)的持续变更，亦即连同次目录下的所有文件都会变更 上面的 可以表示如下 chmod -R 770 档案或目录 上面说了这么多，我们举例说明一下： 我们进入itcast用户创建文件czbk.txt touch as.txt 然后切换到root 比如，我们如果要将as.txt这个文件所有的权限都设定启用 那么命令如下： chmod -R 777 as.txt 由此可见，as.txt的属主权限、属组权限、其他权限都发生了改变 由之前的【-rw-rw-r--】变成【-rwxrwxrwx】 根据前面的换算我们已经知道如何将一个文件的属主、属组、其他权限换算成数字了，换算成数字后，我们只需要通过chmod命令即可更改文件的权限 2) 符号权限 还有一个改变权限的方法，就是 符号权限，我们先回顾下之前提到的9个权限 (1)user 属主权限 (2)group 属组权限 (3)others 其他权限 那么我们就可以使用 u, g, o 来代表三种身份的权限！ 此外， a 则代表 all，即全部的身份。读写的权限可以写成 r, w, x，也就是可以使用下表的方式来看 如果我们需要将文件权限设置为 -rwxr-xr-- ，可以使用 chmod u=rwx,g=rx,o=r 文件名 来设定: 上接上面的例子，如下图 我们将as.txt的权限设置为-rwxr-xr-- 执行 chmod u=rwx,g=rx,o=r as.txt 由上图我们发现，as.txt的权限变成了-rwxr-xr-- 假如我们要将权限去掉而不改变其他已存在的权限呢？举个例子，比如我要拿掉全部人的可读权限，则 chmod a-r as.txt 执行如下 由此可见，as.txt的其他权限都没有了，变成了【---】 4.4. 3.4 综合案例 在前面的章节中我们讲解了用户、用户组、文件属主、属组以及权限，知识点比较零散，下面，我们就通过一个简单小案例把这些知识点串联起来 需求： 比如一个公司的开发团队有三个用户：java、erlang、golang有一个文件目录tmp/work供他们开发，如何实现让这三个用户都对其具有写权限 1、首先，我们创建三个账户（切换到root） adduser java adduser erlang adduser golang 执行效果如下 2、增加用户组 groupadd -g 8888 dev-group 执行效果如下 3、创建公共文件并设置权限 给文件/tmp/project2019/设置属组为dev-group mkdir /tmp/project2019 chown -R :dev-group /tmp/project2019/ 或者 chgrp -R dev-group /tmp/project2019/ 执行效果如下 4、将用户添加到组 gpasswd -a java dev-group gpasswd -a erlang dev-group gpasswd -a golang dev-group 执行效果如下 查询dev-group组下所有用户 grep 'dev-group' /etc/group 执行效果如下 5、切换到java用户 切换到java用户看看是否有写入权限 su java 新建文件 在我们上面创建的目录tmp/project2019/下面创建文件 mkdir java-files-new 由此发现，我们在tmp/project2019/下面创建文件发生了权限不足，我们去查看下tmp/project2019/的文件属性，如下图 我们在/tmp目录下执行 ls -l 执行效果如下 我们发现目录project2019的文件属性为【drwxr-xr-x】 根据前面学的知识，我们拆分如下 【d】:文件类型 【rwx】：属主 【r-x】：属组 【r-x】：其他 现在答案就出来了，也就是说我们的属组权限是【r-x】，只有读和执行权限，没有写入权限，那么下面我们就给project2019目录增加写入权限。 6、增加写入权限 给project2019目录增加写入权限，执行下面的命令（前面已经学习过了） 记得切换到root下执行 chmod -R 770 project2019 执行效果如下 此时我们发现project2019目录的属组权限变成了【rwx】即可读、可写、可执行 7、切换用户，继续写入 su java mkdir java-files-new ls -l 执行效果如下 由此发现，这个时候我们有了写入权限，java-files-new文件被成功写入 那么，其他两个用户golang、erlang也是和java一个组的，他们能不能正常写入呢，我们试试（从root切换过去） su su erlang mkdir erlang-files-new ============================== su su golang mkdir golang-files-new ls -l 执行效果（erlang新建文件） 执行效果（golanglang新建文件） 查看所有文件 由此可见，我们组的三个用户都成功创建了文件（拥有了写入权限） 8、验证结论 为了验证上面的结论，我们新增一个用户itbeijing 看看能否正常新建文件 useradd itbeijing su itbeijing mkdir itbeijing-files-new 执行效果如下 由上图我们发现，我们刚刚新创建的用户在创建文件的时候发现了权限不足。 由此说明用户itbeijing用户的属组和文件的属组不一样，所以没有权限。 4.5. 3.5 总结 在企业级开发过程中，实际操作目录是最经常出现的，对于目录常用命令我们要熟练掌握并能熟练编写 因为Linux是多用户系统，所以权限也是非常核心和重要的，我们要熟练编写权限（属主、属组、其他权限）的常用命令。 Copyright © MISIN 2022 | 豫ICP备2021006345号-1 all right reserved，powered by Gitbook该文件修订时间： 2022-11-09 04:15:56 "},"2.JavaWeb/10.Vue+Element/Vue和Element.html":{"url":"2.JavaWeb/10.Vue+Element/Vue和Element.html","title":"Vue和Element","keywords":"","body":"1. 1、Vue 快速入门1.1. 1.1、Vue的介绍1.2. 1.2、Vue的快速入门1.3. 1.3、Vue快速入门详解1.4. 1.4、Vue快速入门的升级1.5. 1.5、Vue小结2. 2、Vue 常用指令2.1. 2.1、指令介绍2.2. 2.2、文本插值2.3. 2.3、绑定属性2.4. 2.4、条件渲染2.5. 2.5、列表渲染2.6. 2.6、事件绑定2.7. 2.7、表单绑定2.8. 2.8、小结3. 3、Element 基本使用3.1. 3.1、Element介绍3.2. 3.2、Element快速入门3.3. 3.3、基础布局3.4. 3.4、容器布局3.5. 3.5、表单组件3.6. 3.6、表格组件3.7. 3.7、顶部导航栏组件3.8. 3.8、侧边导航栏组件3.9. 3.9、小结4. 4、综合案例 学生列表4.1. 4.1、案例效果和分析4.2. 4.2、头部区域的实现4.3. 4.3、侧边栏区域的实现4.4. 4.4、主区域的实现1. 1、Vue 快速入门 1.1. 1.1、Vue的介绍 Vue是一套构建用户界面的渐进式前端框架。 只关注视图层，并且非常容易学习，还可以很方便的与其它库或已有项目整合。 通过尽可能简单的API来实现响应数据的绑定和组合的视图组件。 特点 易用：在有HTMLCSSJavaScript的基础上，快速上手。 灵活：简单小巧的核心，渐进式技术栈，足以应付任何规模的应用。 性能：20kbmin+gzip运行大小、超快虚拟DOM、最省心的优化。 1.2. 1.2、Vue的快速入门 开发步骤 下载和引入vue.js文件。 编写入门程序。 视图：负责页面渲染，主要由HTML+CSS构成。 脚本：负责业务数据模型（Model）以及数据的处理逻辑。 代码实现 快速入门 // 脚本 new Vue({ el:”#div”, data:{ msg:”Hello Vue” } }); 1.3. 1.3、Vue快速入门详解 Vue 核心对象：每一个 Vue 程序都是从一个 Vue 核心对象开始的。 let vm = new Vue({ 选项列表; }); 选项列表 el选项：用于接收获取到页面中的元素。(根据常用选择器获取)。 data选项：用于保存当前Vue对象中的数据。在视图中声明的变量需要在此处赋值。 methods选项：用于定义方法。方法可以直接通过对象名调用，this代表当前Vue对象。 数据绑定 在视图部分获取脚本部分的数据。 1.4. 1.4、Vue快速入门的升级 快速入门升级 姓名： 班级： 打招呼 修改班级 // 脚本 let vm = new Vue({ el:”#div”, data:{ name:”张三”, classRoom:”黑马程序员” }, methods:{ study(){ alert(this.name + “正在” + this.classRoom + “好好学习!”); } } }); //定义打招呼方法 function hi(){ vm.study(); } //定义修改班级 function update(){ vm.classRoom = “传智播客”; } 1.5. 1.5、Vue小结 Vue是一套构建用户界面的渐进式前端框架。 Vue的程序包含视图和脚本两个核心部分。 脚本部分 Vue核心对象。 选项列表 el：接收获取的元素。 data：保存数据。 methods：定义方法。 视图部分 数据绑定： 2. 2、Vue 常用指令 2.1. 2.1、指令介绍 指令：是带有 v- 前缀的特殊属性，不同指令具有不同含义。例如 v-html，v-if，v-for。 使用指令时，通常编写在标签的属性上，值可以使用 JS 的表达式。 常用指令 2.2. 2.2、文本插值 v-html：把文本解析为 HTML 代码。 文本插值 new Vue({ el:”#div”, data:{ msg:”Hello Vue” } }); 2.3. 2.3、绑定属性 v-bind：为 HTML 标签绑定属性值。 绑定属性 .my{ border: 1px solid red; } 百度一下 百度一下 我是div new Vue({ el:”#div”, data:{ url:”https://www.baidu.com”, cls:”my” } }); 2.4. 2.4、条件渲染 v-if：条件性的渲染某元素，判定为真时渲染,否则不渲染。 v-else：条件性的渲染。 v-else-if：条件性的渲染。 v-show：根据条件展示某元素，区别在于切换的是display属性的值。 条件渲染 div1 div2 div3 div4 new Vue({ el:”#div”, data:{ num:1, flag:false } }); 2.5. 2.5、列表渲染 v-for：列表渲染，遍历容器的元素或者对象的属性。 列表渲染 new Vue({ el:”#div”, data:{ names:[“张三”,”李四”,”王五”], student:{ name:”张三”, age:23 } } }); 2.6. 2.6、事件绑定 v-on：为 HTML 标签绑定事件。 事件绑定 改变div的内容 改变div的内容 改变div的内容 new Vue({ el:”#div”, data:{ name:”黑马程序员” }, methods:{ change(){ this.name = “传智播客” } } }); 2.7. 2.7、表单绑定 表单绑定 v-model：在表单元素上创建双向数据绑定。 双向数据绑定 更新data数据，页面中的数据也会更新。 更新页面数据，data数据也会更新。 MVVM模型(ModelViewViewModel)：是MVC模式的改进版 在前端页面中，JS对象表示Model，页面表示View，两者做到了最大限度的分离。 将Model和View关联起来的就是ViewModel，它是桥梁。 ViewModel负责把Model的数据同步到View显示出来，还负责把View修改的数据同步回Model。 表单绑定 姓名： 年龄： new Vue({ el:”#div”, data:{ username:”张三”, age:23 } }); 2.8. 2.8、小结 指令：是带有v-前缀的特殊属性，不同指令具有不同含义。 文本插值 v-html：把文本解析为HTML代码。 绑定属性 v-bind：为HTML标签绑定属性值。 条件渲染 v-if：条件性的渲染某元素，判定为真时渲染,否则不渲染。 v-else：条件性的渲染。 v-else-if：条件性的渲染。 v-show：根据条件展示某元素，区别在于切换的是display属性的值。 列表渲染 v-for：列表渲染，遍历容器的元素或者对象的属性。 事件绑定 v-on：为HTML标签绑定事件。 表单绑定 v-model：在表单元素上创建双向数据绑定。 3. 3、Element 基本使用 3.1. 3.1、Element介绍 Element：网站快速成型工具。是饿了么公司前端开发团队提供的一套基于Vue的网站组件库。 使用Element前提必须要有Vue。 组件：组成网页的部件，例如超链接、按钮、图片、表格等等~ Element官网：https://element.eleme.cn/#/zh-CN 自己完成的按钮 Element 提供的按钮 3.2. 3.2、Element快速入门 开发步骤 下载 Element 核心库。 引入 Element 样式文件。 引入 Vue 核心 js 文件。 引入 Element 核心 js 文件。 编写按钮标签。 通过 Vue 核心对象加载元素。 代码实现 快速入门 我是按钮 默认按钮 主要按钮 成功按钮 信息按钮 警告按钮 危险按钮 朴素按钮 主要按钮 成功按钮 信息按钮 警告按钮 危险按钮 圆角按钮 主要按钮 成功按钮 信息按钮 警告按钮 危险按钮 new Vue({ el:”#div” }); 3.3. 3.3、基础布局 将页面分成最多 24 个部分，自由切分。 代码实现 基础布局 .el-row { /* 行距为20px */ margin-bottom: 20px; } .bg-purple-dark { background: red; } .bg-purple { background: blue; } .bg-purple-light { background: green; } .grid-content { /* 边框圆润度 */ border-radius: 4px; /* 行高为36px */ min-height: 36px; } new Vue({ el:”#div” }); 3.4. 3.4、容器布局 将页面分成头部区域、侧边栏区域、主区域、底部区域。 代码实现 容器布局 .el-header, .el-footer { background-color: #d18e66; color: #333; text-align: center; height: 100px; } .el-aside { background-color: #55e658; color: #333; text-align: center; height: 580px; } .el-main { background-color: #5fb1f3; color: #333; text-align: center; height: 520px; } 头部区域 侧边栏区域 主区域 底部区域 new Vue({ el:”#div” }); 3.5. 3.5、表单组件 由输入框、下拉列表、单选框、多选框等控件组成，用以收集、校验、提交数据。 代码实现 表单组件 - 立即创建 重置 new Vue({ el:”#div”, data:{ ruleForm: { name: ‘’, region: ‘’, date1: ‘’, date2: ‘’, delivery: false, type: [], resource: ‘’, desc: ‘’ }, rules: { name: [ { required: true, message: ‘请输入活动名称’, trigger: ‘blur’ }, { min: 3, max: 5, message: ‘长度在 3 到 5 个字符’, trigger: ‘blur’ } ], region: [ { required: true, message: ‘请选择活动区域’, trigger: ‘change’ } ], date1: [ { type: ‘date’, required: true, message: ‘请选择日期’, trigger: ‘change’ } ], date2: [ { type: ‘date’, required: true, message: ‘请选择时间’, trigger: ‘change’ } ], type: [ { type: ‘array’, required: true, message: ‘请至少选择一个活动性质’, trigger: ‘change’ } ], resource: [ { required: true, message: ‘请选择活动资源’, trigger: ‘change’ } ], desc: [ { required: true, message: ‘请填写活动形式’, trigger: ‘blur’ } ] } }, methods:{ submitForm(formName) { this.$refs[formName].validate((valid) => { if (valid) { alert(‘submit!’); } else { console.log(‘error submit!!’); return false; } }); }, resetForm(formName) { this.$refs[formName].resetFields(); } } }); 3.6. 3.6、表格组件 用于展示多条结构类似的数据，可对数据进行编辑、删除或其他自定义操作。 代码实现 表格组件 编辑 删除 new Vue({ el:”#div”, data:{ tableData: [{ date: ‘2016-05-02’, name: ‘王小虎’, address: ‘上海市普陀区金沙江路 1518 弄’ }, { date: ‘2016-05-04’, name: ‘王小虎’, address: ‘上海市普陀区金沙江路 1517 弄’ }, { date: ‘2016-05-01’, name: ‘王小虎’, address: ‘上海市普陀区金沙江路 1519 弄’ }, { date: ‘2016-05-03’, name: ‘王小虎’, address: ‘上海市普陀区金沙江路 1516 弄’ }] } }); 3.7. 3.7、顶部导航栏组件 代码实现 顶部导航栏 处理中心 我的工作台 选项1 选项2 选项3 选项4 选项1 选项2 选项3 消息中心 订单管理 new Vue({ el:”#div” }); 3.8. 3.8、侧边导航栏组件 代码实现 侧边导航栏 导航一 分组一 选项1 选项2 选项3 选项4 选项1 导航二 导航三 导航四 new Vue({ el:”#div” }); 3.9. 3.9、小结 Element：网站快速成型工具。是一套为开发者、设计师、产品经理准备的基于Vue的桌面端组件库。 使用Element前提必须要有Vue。 使用步骤 1.下载Element核心库。 2.引入Element样式文件。 3.引入Vue核心js文件。 4.引入Element核心js文件。 5.借助常用组件编写网页。 常用组件 网页基本组成部分，布局、按钮、表格、表单等等~~~ 常用组件不需要记住，只需要在Element官网中复制使用即可。 4. 4、综合案例 学生列表 4.1. 4.1、案例效果和分析 4.2. 4.2、头部区域的实现 实现思路 头部效果实现。 侧边栏和主区域效果实现。 代码实现 学生列表 .el-header{ background-color: #545c64; } .header-1img{ width: 100px; margin-top: 20px; } 处理中心 我的工作台 选项1 选项2 选项3 首页 new Vue({ el:\"#div\" }); 4.3. 4.3、侧边栏区域的实现 学工部 在校学生管理 学生升级/留级 学生就业情况 咨询部 意向学生管理 未报名学生管理 已报名学生管理 教研部 已有课程管理 正在研发课程管理 新技术课程管理 4.4. 4.4、主区域的实现 主区域和侧边栏区域放在一起 学生列表 添加学生 编辑 删除 在vue中定义data new Vue({ el:\"#div\", data:{ tableData:[ { date:\"2088-08-08\", name:\"张三\", address:\"北京市昌平区\" },{ date:\"2088-08-08\", name:\"李四\", address:\"北京市昌平区\" },{ date:\"2088-08-08\", name:\"王五\", address:\"北京市昌平区\" }, ] } }); Copyright © MISIN 2022 | 豫ICP备2021006345号-1 all right reserved，powered by Gitbook该文件修订时间： 2022-11-10 13:55:05 "},"2.JavaWeb/10.Vue+Element/Vue和综合案例.html":{"url":"2.JavaWeb/10.Vue+Element/Vue和综合案例.html","title":"Vue和综合案例","keywords":"","body":"1. 1、Vue 高级使用1.1. 1.1、自定义组件1.2. 1.2、Vue的生命周期1. 1、Vue 高级使用 1.1. 1.1、自定义组件 学完了 Element 组件后，我们会发现组件其实就是自定义的标签。例如 就是对的封装。 本质上，组件是带有一个名字且可复用的 Vue 实例，我们完全可以自己定义。 定义格式 Vue.component(组件名称, { props:组件的属性, data: 组件的数据函数, template: 组件解析的标签模板 }) 代码实现 自定义组件 我的按钮 Vue.component(“my-button”,{ // 属性 props:[“style”], // 数据函数 data: function(){ return{ msg:”我的按钮” } }, //解析标签模板 template:”” }); new Vue({ el:”#div” }); 1.2. 1.2、Vue的生命周期 生命周期 生命周期的八个阶段 代码实现 ```html 生命周期 let vm = new Vue({ el: ‘#app’, data: { message: ‘Vue的生命周期’ }, beforeCreate: function() { console.group(‘——beforeCreate创建前状态——‘); console.log(“%c%s”, “color:red”, “el : “ + this.$el); //undefined console.log(“%c%s”, “color:red”, “data : “ + this.$data); //undefined console.log(“%c%s”, “color:red”, “message: “ + this.message);//undefined }, created: function() { console.group(‘——created创建完毕状态——‘); console.log(“%c%s”, “color:red”, “el : “ + this.$el); //undefined console.log(“%c%s”, “color:red”, “data : “ + this.$data); //已被初始化 console.log(“%c%s”, “color:red”, “message: “ + this.message); //已被初始化 }, beforeMount: function() { console.group(‘——beforeMount挂载前状态——‘); console.log(“%c%s”, “color:red”, “el : “ + (this.$el)); //已被初始化 console.log(this.$el); console.log(“%c%s”, “color:red”, “data : “ + this.$data); //已被初始化 console.log(“%c%s”, “color:red”, “message: “ + this.message); //已被初始化 }, mounted: function() { console.group(‘——mounted 挂载结束状态——‘); console.log(“%c%s”, “color:red”, “el : “ + this.$el); //已被初始化 console.log(this.$el); console.log(“%c%s”, “color:red”, “data : “ + this.$data); //已被初始化 console.log(“%c%s”, “color:red”, “message: “ + this.message); //已被初始化 }, beforeUpdate: function() { console.group(‘beforeUpdate 更新前状态===============》’); let dom = document.getElementById(“app”).innerHTML; console.log(dom); console.log(“%c%s”, “color:red”, “el : “ + this.$el); console.log(this.$el); console.log(“%c%s”, “color:red”, “data : “ + this.$data); console.log(“%c%s”, “color:red”, “message: “ + this.message); }, updated: function() { console.group(‘updated 更新完成状态===============》’); let dom = document.getElementById(“app”).innerHTML; console.log(dom); console.log(“%c%s”, “color:red”, “el : “ + this.$el); console.log(this.$el); console.log(“%c%s”, “color:red”, “data : “ + this.$data); console.log(“%c%s”, “color:red”, “message: “ + this.message); }, beforeDestroy: function() { console.group(‘beforeDestroy 销毁前状态===============》’); console.log(“%c%s”, “color:red”, “el : “ + this.$el); console.log(this.$el); console.log(“%c%s”, “color:red”, “data : “ + this.$data); console.log(“%c%s”, “color:red”, “message: “ + this.message); }, destroyed: function() { console.group(‘destroyed 销毁完成状态===============》’); console.log(“%c%s”, “color:red”, “el : “ + this.$el); console.log(this.$el); console.log(“%c%s”, “color:red”, “data : “ + this.$data); console.log(“%c%s”, “color:red”, “message: “ + this.message); } }); // 销毁Vue对象 //vm.$destroy(); //vm.message = “hehe”; // 销毁后 Vue 实例会解绑所有内容 // 设置data中message数据值 vm.message = “good...”; ## 1.3、Vue异步操作 - **在Vue中发送异步请求，本质上还是AJAX。我们可以使用axios这个插件来简化操作！** - **使用步骤** 1.引入axios核心js文件。 2.调用axios对象的方法来发起异步请求。 3.调用axios对象的方法来处理响应的数据。 - **axios常用方法** ![](./2img/axios常用方法.png) - **代码实现** - **html代码** ```html 异步操作 发起请求 new Vue({ el:”#div”, data:{ name:”张三” }, methods:{ send(){ // GET方式请求 // axios.get(“testServlet?name=“ + this.name) // .then(resp => { // alert(resp.data); // }) // .catch(error => { // alert(error); // }) // POST方式请求 axios.post(“testServlet”,”name=“+this.name) .then(resp => { alert(resp.data); }) .catch(error => { alert(error); }) } } }); java代码 package com.itheima; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; @WebServlet(“/testServlet”) public class TestServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { //设置请求和响应的编码 req.setCharacterEncoding(“UTF-8”); resp.setContentType(“text/html;charset=UTF-8”); //获取请求参数 String name = req.getParameter(“name”); System.out.println(name); //响应客户端 resp.getWriter().write(“请求成功”); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { this.doGet(req,resp); } } 1.4、小结 自定义组件：本质上，组件是带有一个名字且可复用的 Vue 实例，我们可以自己来定义。 Vue.component(组件名称, { props:组件的属性, data: 组件的数据函数, template: 组件解析的标签模板 }) 生命周期：核心八个阶段 beforeCreate：创建前 created：创建后 beforeMount：载入前 mounted：载入后 beforeUpdate：更新前 updated：更新后 beforeDestroy：销毁前 destroyed：销毁后 异步操作：通过 axios 插件来实现。 2、综合案例 学生管理系统 2.1、效果环境的介绍 2.2、登录功能的实现 环境搭建 从当天的资料中解压《学生管理系统原始项目》，并导入。 代码实现 html代码 onSubmit(formName) { // 为表单绑定验证功能 this.$refs[formName].validate((valid) => { if (valid) { //请求服务器完成登录功能 axios.post(\"userServlet\",\"username=\" + this.form.username + \"&password=\" + this.form.password) .then(resp => { if(resp.data == true) { //登录成功，跳转到首页 location.href = \"index.html\"; }else { //登录失败，跳转到登录页面 alert(\"登录失败，请检查用户名和密码\"); location.href = \"login.html\"; } }) } else { return false; } }); } java代码 UserServlet.java package com.itheima.controller; import com.itheima.bean.User; import com.itheima.service.UserService; import com.itheima.service.impl.UserServiceImpl; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; import java.util.List; @WebServlet(\"/userServlet\") public class UserServlet extends HttpServlet { private UserService service = new UserServiceImpl(); @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { //设置请求和响应编码 req.setCharacterEncoding(\"UTF-8\"); resp.setContentType(\"text/html;charset=UTF-8\"); //1.获取请求参数 String username = req.getParameter(\"username\"); String password = req.getParameter(\"password\"); //2.封装User对象 User user = new User(username,password); //3.调用业务层的登录方法 List list = service.login(user); //4.判断是否查询出结果 if(list.size() != 0) { //将用户名存入会话域当中 req.getSession().setAttribute(\"username\",username); //响应给客户端true resp.getWriter().write(\"true\"); }else { //响应给客户端false resp.getWriter().write(\"false\"); } } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { doGet(req,resp); } } UserService.java package com.itheima.service; import com.itheima.bean.User; import java.util.List; /* 业务层约束接口 */ public interface UserService { /* 登录方法 */ public abstract List login(User user); } UserServiceImpl.java package com.itheima.service.impl; import com.itheima.bean.User; import com.itheima.mapper.UserMapper; import com.itheima.service.UserService; import org.apache.ibatis.io.Resources; import org.apache.ibatis.session.SqlSession; import org.apache.ibatis.session.SqlSessionFactory; import org.apache.ibatis.session.SqlSessionFactoryBuilder; import java.io.IOException; import java.io.InputStream; import java.util.List; public class UserServiceImpl implements UserService { @Override public List login(User user) { InputStream is = null; SqlSession sqlSession = null; List list = null; try{ //1.加载核心配置文件 is = Resources.getResourceAsStream(\"MyBatisConfig.xml\"); //2.获取SqlSession工厂对象 SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is); //3.通过SqlSession工厂对象获取SqlSession对象 sqlSession = sqlSessionFactory.openSession(true); //4.获取UserMapper接口的实现类对象 UserMapper mapper = sqlSession.getMapper(UserMapper.class); //5.调用实现类对象的登录方法 list = mapper.login(user); }catch (Exception e) { e.printStackTrace(); } finally { //6.释放资源 if(sqlSession != null) { sqlSession.close(); } if(is != null) { try { is.close(); } catch (IOException e) { e.printStackTrace(); } } } //7.返回结果到控制层 return list; } } UserMapper.java package com.itheima.mapper; import com.itheima.bean.User; import org.apache.ibatis.annotations.Select; import java.util.List; public interface UserMapper { /* 登录方法 */ @Select(\"SELECT * FROM user WHERE username=#{username} AND password=#{password}\") public abstract List login(User user); } 2.3、分页查询功能的实现 代码实现 html代码 new Vue({ el:\"#div\", data:{ dialogTableVisible4add: false, //添加窗口显示状态 dialogTableVisible4edit: false, //编辑窗口显示状态 formData:{},//添加表单的数据 editFormData: {},//编辑表单的数据 tableData:[],//表格数据 pagination: { currentPage: 1, //当前页 pageSize: 5, //每页显示条数 total: 0 //总条数 }, rules: { number: [ {required: true, message: '请输入学号', trigger: 'blur'}, {min: 2, max: 10, message: '长度在 2 到 10 个字符', trigger: 'blur'} ], name: [ {required: true, message: '请输入姓名', trigger: 'blur'}, {min: 2, max: 10, message: '长度在 2 到 10 个字符', trigger: 'blur'} ], birthday: [ {required: true, message: '请选择日期', trigger: 'change'} ], address: [ {required: true, message: '请输入地址', trigger: 'blur'}, {min: 2, max: 200, message: '长度在 2 到 200 个字符', trigger: 'blur'} ], } }, methods:{ //分页查询功能 selectByPage(){ axios.post(\"studentServlet\",\"method=selectByPage&currentPage=\" + this.pagination.currentPage + \"&pageSize=\" + this.pagination.pageSize) .then(resp => { //将查询出的数据赋值tableData this.tableData = resp.data.list; //设置分页参数 //当前页 this.pagination.currentPage = resp.data.pageNum; //总条数 this.pagination.total = resp.data.total; }) }, //改变每页条数时执行的函数 handleSizeChange(pageSize) { //修改分页查询的参数 this.pagination.pageSize = pageSize; //重新执行查询 this.selectByPage(); }, //改变页码时执行的函数 handleCurrentChange(pageNum) { //修改分页查询的参数 this.pagination.currentPage = pageNum; //重新执行查询 this.selectByPage(); }, showAddStu() { //弹出窗口 this.dialogTableVisible4add = true; }, resetForm(addForm) { //双向绑定，输入的数据都赋值给了formData， 清空formData数据 this.formData = {}; //清除表单的校验数据 this.$refs[addForm].resetFields(); }, showEditStu(row) { //1. 弹出窗口 this.dialogTableVisible4edit = true; //2. 显示表单数据 this.editFormData = { number:row.number, name:row.name, birthday:row.birthday, address:row.address, } } }, mounted(){ //调用分页查询功能 this.selectByPage(); } }); java代码 1、创建StudentServlet.java package com.itheima.controller; import com.fasterxml.jackson.databind.ObjectMapper; import com.github.pagehelper.Page; import com.github.pagehelper.PageInfo; import com.itheima.bean.Student; import com.itheima.service.StudentService; import com.itheima.service.impl.StudentServiceImpl; import org.apache.commons.beanutils.BeanUtils; import org.apache.commons.beanutils.ConvertUtils; import org.apache.commons.beanutils.Converter; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; import java.text.ParseException; import java.text.SimpleDateFormat; import java.util.Date; import java.util.Map; @WebServlet(\"/studentServlet\") public class StudentServlet extends HttpServlet { private StudentService service = new StudentServiceImpl(); @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { //设置请求和响应编码 req.setCharacterEncoding(\"UTF-8\"); resp.setContentType(\"text/html;charset=UTF-8\"); //1.获取方法名 String method = req.getParameter(\"method\"); if(method.equals(\"selectByPage\")) { //分页查询功能 selectByPage(req,resp); } } /* 分页查询功能 */ private void selectByPage(HttpServletRequest req, HttpServletResponse resp) { //获取请求参数 String currentPage = req.getParameter(\"currentPage\"); String pageSize = req.getParameter(\"pageSize\"); //调用业务层的查询方法 Page page = service.selectByPage(Integer.parseInt(currentPage), Integer.parseInt(pageSize)); //封装PageInfo PageInfo info = new PageInfo(page); //将info转成json，响应给客户端 try { String json = new ObjectMapper().writeValueAsString(info); resp.getWriter().write(json); } catch (Exception e) { e.printStackTrace(); } } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { doGet(req,resp); } } 2、创建StudentService.java package com.itheima.service; import com.github.pagehelper.Page; import com.itheima.bean.Student; /* 学生业务层接口 */ public interface StudentService { /* 分页查询方法 */ public abstract Page selectByPage(Integer currentPage, Integer pageSize); } 3、创建StudentServiceImpl.java package com.itheima.service.impl; import com.github.pagehelper.Page; import com.github.pagehelper.PageHelper; import com.itheima.bean.Student; import com.itheima.mapper.StudentMapper; import com.itheima.service.StudentService; import org.apache.ibatis.io.Resources; import org.apache.ibatis.session.SqlSession; import org.apache.ibatis.session.SqlSessionFactory; import org.apache.ibatis.session.SqlSessionFactoryBuilder; import java.io.IOException; import java.io.InputStream; /* 学生业务层实现类 */ public class StudentServiceImpl implements StudentService { /* 分页查询功能 */ @Override public Page selectByPage(Integer currentPage, Integer pageSize) { InputStream is = null; SqlSession sqlSession = null; Page page = null; try{ //1.加载核心配置文件 is = Resources.getResourceAsStream(\"MyBatisConfig.xml\"); //2.获取SqlSession工厂对象 SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is); //3.通过SqlSession工厂对象获取SqlSession对象 sqlSession = sqlSessionFactory.openSession(true); //4.获取StudentMapper接口实现类对象 StudentMapper mapper = sqlSession.getMapper(StudentMapper.class); //5.设置分页参数 page = PageHelper.startPage(currentPage,pageSize); //6.调用实现类对象查询全部方法 mapper.selectAll(); } catch (Exception e) { e.printStackTrace(); } finally { //7.释放资源 if(sqlSession != null) { sqlSession.close(); } if(is != null) { try { is.close(); } catch (IOException e) { e.printStackTrace(); } } } //8.返回结果到控制层 return page; } } 4、创建StudentMapper.java package com.itheima.mapper; import com.itheima.bean.Student; import org.apache.ibatis.annotations.Delete; import org.apache.ibatis.annotations.Insert; import org.apache.ibatis.annotations.Select; import org.apache.ibatis.annotations.Update; import java.util.List; /* 学生持久层接口 */ public interface StudentMapper { /* 查询全部方法 */ @Select(\"SELECT * FROM student\") public abstract List selectAll(); } 2.4、添加功能的实现 代码实现 html代码 在stuList.html中增加“添加功能”代码 //添加学生功能 addStu(){ let param = \"method=addStu&number=\" + this.formData.number + \"&name=\" + this.formData.name + \"&birthday=\" + this.formData.birthday + \"&address=\" + this.formData.address + \"&currentPage=\" + this.pagination.currentPage + \"&pageSize=\" + this.pagination.pageSize; axios.post(\"studentServlet\",param) .then(resp => { //将查询出的数据赋值tableData this.tableData = resp.data.list; //设置分页参数 //当前页 this.pagination.currentPage = resp.data.pageNum; //总条数 this.pagination.total = resp.data.total; }) //关闭添加窗口 this.dialogTableVisible4add = false; } java代码 1、在StudentServlet.java中增加“添加功能”代码-addStu /* *1、直接复制会报错 *2、需要将此行代码需要添加到“doGet”方法中 *3、增加“addStu”方法名的判断 */ else if(method.equals(\"addStu\")) { //添加数据功能 addStu(req,resp); } ================================================================================== /* 添加数据功能 */ private void addStu(HttpServletRequest req, HttpServletResponse resp) { //获取请求参数 Map map = req.getParameterMap(); String currentPage = req.getParameter(\"currentPage\"); String pageSize = req.getParameter(\"pageSize\"); //封装Student对象 Student stu = new Student(); //注册日期转换器方法 dateConvert(); try { BeanUtils.populate(stu,map); } catch (Exception e) { e.printStackTrace(); } //调用业务层的添加方法 service.addStu(stu); //重定向到分页查询功能 try { resp.sendRedirect(req.getContextPath() + \"/studentServlet?method=selectByPage&currentPage=\" + currentPage + \"&pageSize=\" + pageSize); } catch (IOException e) { e.printStackTrace(); } } /* 日期转换 */ private void dateConvert() { ConvertUtils.register(new Converter() { public Object convert(Class type, Object value) { SimpleDateFormat simpleDateFormat = new SimpleDateFormat(\"yyyy-MM-dd\"); try { return simpleDateFormat.parse(value.toString()); } catch (ParseException e) { e.printStackTrace(); } return null; } }, Date.class); } 2、在StudentService.java中增加“添加功能”-addStu /* 添加数据方法 */ public abstract void addStu(Student stu); 3、StudentServiceImpl.java中增加“添加功能”-addStu /* 添加数据方法 */ @Override public void addStu(Student stu) { InputStream is = null; SqlSession sqlSession = null; try{ //1.加载核心配置文件 is = Resources.getResourceAsStream(\"MyBatisConfig.xml\"); //2.获取SqlSession工厂对象 SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is); //3.通过SqlSession工厂对象获取SqlSession对象 sqlSession = sqlSessionFactory.openSession(true); //4.获取StudentMapper接口实现类对象 StudentMapper mapper = sqlSession.getMapper(StudentMapper.class); //5.调用实现类对象添加方法 mapper.addStu(stu); } catch (Exception e) { e.printStackTrace(); } finally { //6.释放资源 if(sqlSession != null) { sqlSession.close(); } if(is != null) { try { is.close(); } catch (IOException e) { e.printStackTrace(); } } } } 4、StudentMapper.java中增加“添加功能”-addStu /* 添加数据方法 */ @Insert(\"INSERT INTO student VALUES (#{number},#{name},#{birthday},#{address})\") public abstract void addStu(Student stu); 2.5、修改功能的实现 代码实现 html代码 在stuList.html中增加“修改功能”代码 //修改数据功能 updateStu() { let param = \"method=updateStu&number=\" + this.editFormData.number + \"&name=\" + this.editFormData.name + \"&birthday=\" + this.editFormData.birthday + \"&address=\" + this.editFormData.address + \"&currentPage=\" + this.pagination.currentPage + \"&pageSize=\" + this.pagination.pageSize; axios.post(\"studentServlet\",param) .then(resp => { //将查询出的数据赋值tableData this.tableData = resp.data.list; //设置分页参数 //当前页 this.pagination.currentPage = resp.data.pageNum; //总条数 this.pagination.total = resp.data.total; }) //关闭编辑窗口 this.dialogTableVisible4edit = false; } java代码 1、在StudentServlet.java中增加“修改功能”-updateStu /* 修改数据功能 */ private void updateStu(HttpServletRequest req, HttpServletResponse resp) { //获取请求参数 Map map = req.getParameterMap(); String currentPage = req.getParameter(\"currentPage\"); String pageSize = req.getParameter(\"pageSize\"); //封装Student对象 Student stu = new Student(); //注册日期转换器方法 dateConvert(); try { BeanUtils.populate(stu,map); } catch (Exception e) { e.printStackTrace(); } //调用业务层的修改方法 service.updateStu(stu); //重定向到分页查询功能 try { resp.sendRedirect(req.getContextPath() + \"/studentServlet?method=selectByPage&currentPage=\" + currentPage + \"&pageSize=\" + pageSize); } catch (IOException e) { e.printStackTrace(); } } 2、在StudentService.java中增加“修改功能”-updateStu /* 修改数据方法 */ public abstract void updateStu(Student stu); 3、StudentServiceImpl.java中增加“修改功能”-updateStu /* *1、直接复制会报错 *2、需要将此行代码需要添加到“doGet”方法中 *3、增加“updateStu”方法名的判断 */ else if(method.equals(\"updateStu\")) { //添加数据功能 updateStu(req,resp); } ================================================================================== /* 修改数据方法 */ @Override public void updateStu(Student stu) { InputStream is = null; SqlSession sqlSession = null; try{ //1.加载核心配置文件 is = Resources.getResourceAsStream(\"MyBatisConfig.xml\"); //2.获取SqlSession工厂对象 SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is); //3.通过SqlSession工厂对象获取SqlSession对象 sqlSession = sqlSessionFactory.openSession(true); //4.获取StudentMapper接口实现类对象 StudentMapper mapper = sqlSession.getMapper(StudentMapper.class); //5.调用实现类对象修改方法 mapper.updateStu(stu); } catch (Exception e) { e.printStackTrace(); } finally { //6.释放资源 if(sqlSession != null) { sqlSession.close(); } if(is != null) { try { is.close(); } catch (IOException e) { e.printStackTrace(); } } } } 4、StudentMapper.java中增加“修改功能”-updateStu /* 修改数据方法 */ @Update(\"UPDATE student SET number=#{number},name=#{name},birthday=#{birthday},address=#{address} WHERE number=#{number}\") public abstract void updateStu(Student stu); 2.6、删除功能的实现 代码实现 html代码 在stuList.html中增加“删除功能”代码 //删除数据功能 deleteStu(row) { if(confirm(\"确定要删除\" + row.number + \"数据?\")) { let param = \"method=deleteStu&number=\" + row.number + \"&currentPage=\" + this.pagination.currentPage + \"&pageSize=\" + this.pagination.pageSize; axios.post(\"studentServlet\",param) .then(resp => { //将查询出的数据赋值tableData this.tableData = resp.data.list; //设置分页参数 //当前页 this.pagination.currentPage = resp.data.pageNum; //总条数 this.pagination.total = resp.data.total; }) } } java代码 1、在StudentServlet.java中增加“删除功能”- ```java /* *1、直接复制会报错 *2、需要将此行代码需要添加到“doGet”方法中 *3、增加“deleteStu”方法名的判断 */ else if(method.equals(\"deleteStu\")) { //添加数据功能 deleteStu(req,resp); } ================================================================================== /* 删除数据功能 */ private void deleteStu(HttpServletRequest req, HttpServletResponse resp) { //获取请求参数 String number = req.getParameter(\"number\"); String currentPage = req.getParameter(\"currentPage\"); String pageSize = req.getParameter(\"pageSize\"); //调用业务层的删除方法 service.deleteStu(number); //重定向到分页查询功能 try { resp.sendRedirect(req.getContextPath() + \"/studentServlet?method=selectByPage&currentPage=\" + currentPage + \"&pageSize=\" + pageSize); } catch (IOException e) { e.printStackTrace(); } } ``` - 2、在StudentService.java中增加“删除功能”- ```java /* 删除数据方法 */ public abstract void deleteStu(String number); ``` - 3、StudentServiceImpl.java中增加“删除功能”- ```java /* 删除数据方法 */ @Override public void deleteStu(String number) { InputStream is = null; SqlSession sqlSession = null; try{ //1.加载核心配置文件 is = Resources.getResourceAsStream(\"MyBatisConfig.xml\"); //2.获取SqlSession工厂对象 SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is); //3.通过SqlSession工厂对象获取SqlSession对象 sqlSession = sqlSessionFactory.openSession(true); //4.获取StudentMapper接口实现类对象 StudentMapper mapper = sqlSession.getMapper(StudentMapper.class); //5.调用实现类对象删除方法 mapper.deleteStu(number); } catch (Exception e) { e.printStackTrace(); } finally { //6.释放资源 if(sqlSession != null) { sqlSession.close(); } if(is != null) { try { is.close(); } catch (IOException e) { e.printStackTrace(); } } } } ``` - 4、StudentMapper.java中增加“删除功能”- ```java /* 删除数据方法 */ @Delete(\"DELETE FROM student WHERE number=#{number}\") public abstract void deleteStu(String number); ``` Copyright © MISIN 2022 | 豫ICP备2021006345号-1 all right reserved，powered by Gitbook该文件修订时间： 2022-11-10 13:55:39 "},"2.JavaWeb/11.Redis/Redis.html":{"url":"2.JavaWeb/11.Redis/Redis.html","title":"Redis","keywords":"","body":"1. 第一章 Redis基础1.1. 学习目标：1.2. 1. Redis 简介1.2.1. 1.1 NoSQL概念1.2.2. 1.2 Redis概念1.2.3. 1.3 Redis 的下载与安装1.2.4. 1.4 Redis服务器启动1.2.5. 1.5 配置文件启动与常用配置1.2.6. 1.6 Redis基本操作1.3. 2. 数据类型1.3.1. 2.1 数据存储类型介绍1.3.2. 2.2 string数据类型1.3.3. 2.3 string 类型数据的扩展操作1.3.4. 2.4string应用场景与key命名约定1.3.5. 2.5 hash的基本操作1.3.6. 2.6 hash的拓展操作1.3.7. 2.7 hash应用场景1.3.8. 2.8 list基本操作1.3.9. 2.9 list扩展操作1.3.10. 2.10 list 应用场景1.3.11. 2.11 set 基本操作1.3.12. 2.12 set 类型数据的扩展操作1.3.13. 2.13 set应用场景1.3.14. 2.14 实践案例1.4. 3. 常用指令1.4.1. 3.1 key 操作分析1.4.2. 3.2 数据库指令1.5. 4. Jedis1.5.1. 4.1 Jedis简介1.5.2. 4.2 Jedis简易工具类开发1.5.3. 4.3 可视化客户端1.6. 5. 持久化1.6.1. 5.1 持久化简介1.6.2. 5.2 RDB1.6.3. 5.3 AOF1.6.4. 5.4 RDB与AOF区别1. 第一章 Redis基础 课程计划 | 1. Redis 入 门 | （了解） | （操作） | | | -——————— | ———— | ———— | ———— | | 2. 数据类型 | （重点） | （操作） | （理解） | | 3. 常用指令 | | （操作） | | | 4. Jedis | （重点） | （操作） | | | 5. 持 久 化 | （重点） | | （理解） | | 6. 数据删除与淘汰策略 | | | （理解） | | 7. 主从复制 | （重点） | （操作） | （理解） | | 8. 哨 兵 | （重点） | （操作） | （理解） | | 9. Cluster集群方案 | （重点） | （操作） | （理解） | | 10. 企业级缓存解决方案 | （重点） | | （理解） | | 11. 性能指标监控 | （了解） | | | 1.1. 学习目标： 目标1：能够说出NoSQL的概念，redis的应用场景，能够完成redis的下载安装与启动以及一些常用的配置 目标2：能够说出redis常用的5种数据类型，对应这些数据类型的基本操作，应用场景及对应的解决方案 目标3：能够说出redis中常用的一些基本指令 目标4：能够使用jedis完成客户端应用程序的开发 目标5：能够说出redis数据持久化的两种方式，各自相关的操作配置及指令，以及两种方式的优缺点比较 1.2. 1. Redis 简介 在这个部分，我们将学习以下3个部分的内容，分别是： ◆ Redis 简介（NoSQL概念、Redis概念） ◆ Redis 的下载与安装 ◆ Redis 的基本操作 1.2.1. 1.1 NoSQL概念 1.1.1 问题现象 在讲解NoSQL的概念之前呢，我们先来看一个现象： （1）问题现象 每年到了过年期间，大家都会自觉自发的组织一场活动，叫做春运！以前我们买票都是到火车站排队，后来呢有了12306，有了他以后就更方便了，我们可以在网上买票，但是带来的问题，大家也很清楚，春节期间买票进不去，进去了刷不着票。什么原因呢，人太多了！ 除了这种做铁路的，它系统做的不专业以外，还有马爸爸做的淘宝，它面临一样的问题。淘宝也崩，也是用户量太大！作为我们整个电商界的东哥来说，他第一次做图书促销的时候，也遇到了服务器崩掉的这样一个现象，原因同样是因为用户量太大！ （2）现象特征 再来看这几个现象，有两个非常相似的特征： 第一，用户比较多，海量用户 第二，高并发 这两个现象出现以后，对应的就会造成我们的服务器瘫痪。核心本质是什么呢？其实并不是我们的应用服务器，而是我们的关系型数据库。关系型数据库才是最终的罪魁祸首！ （3）造成原因 什么样的原因导致的整个系统崩掉的呢： 1.性能瓶颈：磁盘IO性能低下 关系型数据库菜存取数据的时候和读取数据的时候他要走磁盘IO。磁盘这个性能本身是比较低的。 2.扩展瓶颈：数据关系复杂，扩展性差，不便于大规模集群 我们说关系型数据库，它里面表与表之间的关系非常复杂，不知道大家能不能想象一点，就是一张表，通过它的外键关联了七八张表，这七八张表又通过她的外件，每张又关联了四五张表。你想想，查询一下，你要想拿到数据，你就要从A到B、B到C、C到D的一直这么关联下去，最终非常影响查询的效率。同时，你想扩展下，也很难! （4）解决思路 面对这样的现象，我们要想解决怎么版呢。两方面： 一，降低磁盘IO次数，越低越好。 二，去除数据间关系，越简单越好。 降低磁盘IO次数，越低越好，怎么搞？我不用你磁盘不就行了吗？于是，内存存储的思想就提出来了，我数据不放到你磁盘里边，放内存里，这样是不是效率就高了。 第二，你的数据关系很复杂，那怎么办呢？干脆简单点，我断开你的关系，我不存关系了，我只存数据，这样不就没这事了吗？ 把这两个特征一合并一起，就出来了一个新的概念：NoSQL 1.1.2 NoSQL的概念 （1）概念 NoSQL：即 Not-Only SQL（ 泛指非关系型的数据库），作为关系型数据库的补充。 作用：应对基于海量用户和海量数据前提下的数据处理问题。 他说这句话说的非常客气，什么意思呢？就是我们数据存储要用SQL，但是呢可以不仅仅用SQL，还可以用别的东西，那别的东西叫什么呢？于是他定义了一句话叫做NoSQL。这个意思就是说我们存储数据，可以不光使用SQL，我们还可以使用非SQL的这种存储方案，这就是所谓的NoSQL。 （2）特征 可扩容，可伸缩。SQL数据关系过于复杂，你扩容一下难度很高，那我们Nosql 这种的，不存关系，所以它的扩容就简单一些。 大数据量下高性能。包数据非常多的时候，它的性能高，因为你不走磁盘IO，你走的是内存，性能肯定要比磁盘IO的性能快一些。 灵活的数据模型、高可用。他设计了自己的一些数据存储格式，这样能保证效率上来说是比较高的，最后一个高可用，我们等到集群内部分再去它！ （3）常见 Nosql 数据库 目前市面上常见的Nosql产品：Redis、memcache、HBase、MongoDB （4）应用场景-电商为例 我们以电商为例，来看一看他在这里边起到的作用。 第一类，在电商中我们的基础数据一定要存储起来，比如说商品名称，价格，生产厂商，这些都属于基础数据，这些数据放在MySQL数据库。 第二类，我们商品的附加信息，比如说，你买了一个商品评价了一下，这个评价它不属于商品本身。就像你买一个苹果，“这个苹果很好吃”就是评论，但是你能说很好吃是这个商品的属性嘛？不能这么说，那只是一个人对他的评论而已。这一类数据呢，我们放在另外一个地方，我们放到MongoDB。它也可以用来加快我们的访问，他属于NoSQL的一种。 第三，图片内的信息。注意这种信息相对来说比较固定，他有专用的存储区，我们一般用文件系统来存储。至于是不是分布式，要看你的系统的一个整个 瓶颈 了？如果说你发现你需要做分布式，那就做，不需要的话，一台主机就搞定了。 第四，搜索关键字。为了加快搜索，我们会用到一些技术，有些人可能了解过，像分ES、Lucene、solr都属于搜索技术。那说的这么热闹，我们的电商解决方案中还没出现我们的redis啊！注意第五类信息。 第五，热点信息。访问频度比较高的信息，这种东西的第二特征就是它具有波段性。换句话说他不是稳定的，它具有一个时效性的。那么这类信息放哪儿了，放到我们的redis这个解决方案中来进行存储。 具体的我们从我们的整个数据存储结构的设计上来看一下。 我们的基础数据都存MySQL,在它的基础之上，我们把它连在一块儿，同时对外提供服务。向上走，有一些信息加载完以后,要放到我们的MongoDB中。还有一类信息，我们放到我们专用的文件系统中（比如图片），就放到我们的这个搜索专用的，如Lucene、solr及集群里边，或者用ES的这种技术里边。那么剩下来的热点信息，放到我们的redis里面。 1.2.2. 1.2 Redis概念 1.2.1 redis概念 概念：Redis (REmote DIctionary Server) 是用 C 语言开发的一个开源的高性能键值对（key-value）数据库。 特征： （1）数据间没有必然的关联关系； （2）内部采用单线程机制进行工作； （3）高性能。官方提供测试数据，50个并发执行100000 个请求,读的速度是110000 次/s,写的速度是81000次/s。 （4）多数据类型支持 字符串类型，string list 列表类型，hash set 散列类型，zset/sorted_set 集合类型 有序集合类型 （5）支持持久化，可以进行数据灾难恢复 1.2.2 redis的应用场景 （1）为热点数据加速查询（主要场景）。如热点商品、热点新闻、热点资讯、推广类等高访问量信息等。 （2）即时信息查询。如各位排行榜、各类网站访问统计、公交到站信息、在线人数信息（聊天室、网站）、设备信号等。 （3）时效性信息控制。如验证码控制、投票控制等。 （4）分布式数据共享。如分布式集群架构中的 session 分离 消息队列. 1.2.3. 1.3 Redis 的下载与安装 后期所有资料分4中不同色块显示，详情如下： 1.3.1 Redis 的下载与安装 本课程所示，均基于Center OS7安装Redis。 （1)下载Redis 下载安装包： wget http://download.redis.io/releases/redis-5.0.0.tar.gz 解压安装包： tar –xvf redis-5.0.0.tar.gz 编译（在解压的目录中执行）： make 安装（在解压的目录中执行）： make install （2）安装 Redis redis-server，服务器启动命令 客户端启动命令 redis-cli，redis核心配置文件 redis.conf，RDB文件检查工具（快照持久化文件） redis-check-dump，AOF文件修复工具 redis-check-aof 1.2.4. 1.4 Redis服务器启动 1.4.1 Redis服务器启动 启动服务器——参数启动 redis-server [—port port] 范例 redis-server —port 6379 启动服务器——配置文件启动 redis-server config_file_name 范例 redis-server redis.conf 1.4.2 Redis客户端启动 启动客户端 redis-cli [-h host] [-p port] 范 例 redis-cli –h 61.129.65.248 –p 6384 注意：服务器启动指定端口使用的是—port，客户端启动指定端口使用的是-p。-的数量不同。 1.4.3 Redis基础环境设置约定 创建配置文件存储目录 mkdir conf 创建服务器文件存储目录（包含日志、数据、临时配置文件等） mkdir data 创建快速访问链接 ln -s redis-5.0.0 redis 1.2.5. 1.5 配置文件启动与常用配置 1.5.1 服务器端设定 设置服务器以守护进程的方式运行，开启后服务器控制台中将打印服务器运行信息（同日志内容相同） daemonize yes|no 绑定主机地址 bind ip 设置服务器端口 port port 设置服务器文件保存地址 dir path 1.5.2 客户端配置 服务器允许客户端连接最大数量，默认0，表示无限制。当客户端连接到达上限后，Redis会拒绝新的连接 maxclients count 客户端闲置等待最大时长，达到最大值后关闭对应连接。如需关闭该功能，设置为 0 timeout seconds 1.5.3 日志配置 设置服务器以指定日志记录级别 loglevel debug|verbose|notice|warning 日志记录文件名 logfile filename 注意：日志级别开发期设置为verbose即可，生产环境中配置为notice，简化日志输出量，降低写日志IO的频度。 1.2.6. 1.6 Redis基本操作 1.6.1 命令行模式工具使用思考 功能性命令 帮助信息查阅 退出指令 清除屏幕信息 1.6.2 信息读写 设置 key，value 数据 set key value 范例 set name itheima 根据 key 查询对应的 value，如果不存在，返回空（nil） get key 范例 get name 1.6.3 帮助信息 获取命令帮助文档 help [command] 范例 help set 获取组中所有命令信息名称 help [@group-name] 范例 help @string 1.6.4 退出命令行客户端模式 退出客户端 quit exit 快捷键 Ctrl+C 1.6.4 redis入门总结 到这里，Redis 入门的相关知识，我们就全部学习完了，再来回顾一下，这个部分我们主要讲解了哪些内容呢？ 首先，我们对Redis进行了一个简单介绍，包括NoSQL的概念、Redis的概念等。 然后，我们介绍了Redis 的下载与安装。包括下载与安装、服务器与客户端启动、以及相关配置文件（3类）。 最后，我们介绍了Redis 的基本操作。包括数据读写、退出与帮助信息获取。 1.3. 2. 数据类型 在这个部分，我们将学习一共要学习三大块内容，首先需要了解一下数据类型，接下来将针对着我们要学习的数据类型进行逐一的讲解，如string、hash、list、set等，最后我们通过一个案例来总结前面的数据类型的使用场景。 1.3.1. 2.1 数据存储类型介绍 2.1.1 业务数据的特殊性 在讲解数据类型之前，我们得先思考一个问题，数据类型既然是用来描述数据的存储格式的，如果你不知道哪些数据未来会进入到我们来的redis中，那么对应的数据类型的选择，你就会出现问题，我们一块来看一下： （1）原始业务功能设计 秒杀。他这个里边数据变化速度特别的快，访问量也特别的高，用户大量涌入以后都会针对着一部分数据进行操作，这一类要记住。 618活动。对于我们京东的618活动、以及天猫的双11活动，相信大家不用说都知道这些数据一定要进去，因为他们的访问频度实在太高了。 排队购票。我们12306的票务信息。这些信息在原始设计的时候，他们就注定了要进redis。 （2）运营平台监控到的突发高频访问数据 此类平台临时监控到的这些数据，比如说现在出来的一个八卦的信息，这个新闻一旦出现以后呢，顺速的被围观了，那么这个时候，这个数据就会变得访量特别高，那么这类信息也要进入进去。 （3）高频、复杂的统计数据 在线人数。比如说直播现在很火，直播里边有很多数据，例如在线人数。进一个人出一个人，这个数据就要跳动，那么这个访问速度非常的快，而且访量很高，并且它里边有一个复杂的数据统计，在这里这种信息也要进入到我们的redis中。 投票排行榜。投票投票类的信息他的变化速度也比较快，为了追求一个更快的一个即时投票的名次变化，这种数据最好也放到redis中。 2.1.2 Redis 数据类型(5种常用) 基于以上数据特征我们进行分析，最终得出来我们的Redis中要设计5种 数据类型： string、hash、list、set、sorted_set/zset（应用性较低） 1.3.2. 2.2 string数据类型 在学习第一个数据类型之前，先给大家介绍一下，在随后这部分内容的学习过程中，我们每一种数据类型都分成三块来讲：首先是讲下它的基本操作，接下来讲一些它的扩展操作，最后我们会去做一个小的案例分析。 2.2.1Redis 数据存储格式 在学习string这个数据形式之前，我们先要明白string到底是修饰什么的。我们知道redis 自身是一个 Map，其中所有的数据都是采用 key : value 的形式存储。 对于这种结构来说，我们用来存储数据一定是一个值前面对应一个名称。我们通过名称来访问后面的值。按照这种形势，我们可以对出来我们的存储格式。前面这一部分我们称为key。后面的一部分称为value，而我们的数据类型，他一定是修饰value的。 数据类型指的是存储的数据的类型，也就是 value 部分的类型，key 部分永远都是字符串。 2.2.2 string 类型 （1）存储的数据：单个数据，最简单的数据存储类型，也是最常用的数据存储类型。 string，他就是存一个字符串儿，注意是value那一部分是一个字符串，它是redis中最基本、最简单的存储数据的格式。 （2）存储数据的格式：一个存储空间保存一个数据 每一个空间中只能保存一个字符串信息，这个信息里边如果是存的纯数字，他也能当数字使用，我们来看一下，这是我们的数据的存储空间。 （3）存储内容：通常使用字符串，如果字符串以整数的形式展示，可以作为数字操作使用. 一个key对一个value，而这个itheima就是我们所说的string类型，当然它也可以是一个纯数字的格式。 2.2.3 string 类型数据的基本操作 （1）基础指令 添加/修改数据添加/修改数据 set key value 获取数据 get key 删除数据 del key 判定性添加数据 setnx key value 添加/修改多个数据 mset key1 value1 key2 value2 … 获取多个数据 mget key1 key2 … 获取数据字符个数（字符串长度） strlen key 追加信息到原始信息后部（如果原始信息存在就追加，否则新建） append key value （2）单数据操作与多数据操作的选择之惑 即set 与mset的关系。这对于这两个操作来说，没有什么你应该选哪个，而是他们自己的特征是什么，你要根据这个特征去比对你的业务，看看究竟适用于哪个。 假如说这是我们现在的服务器，他要向redis要数据的话，它会发出一条指令。那么当这条指令发过来的时候，比如说是这个set指令过来，那么它会把这个结果返回给你，这个时候我们要思考这里边一共经过了多长时间。 首先，发送set指令要时间，这是网络的一个时间，接下来redis要去运行这个指令要消耗时间，最终把这个结果返回给你又有一个时间，这个时间又是一个网络的时间，那我们可以理解为：一个指令发送的过程中需要消耗这样的时间. 但是如果说现在不是一条指令了，你要发3个set的话，还要多长时间呢？对应的发送时间要乘3了，因为这是三个单条指令,而运行的操作时间呢，它也要乘3了，但最终返回的也要发3次，所以这边也要乘3。 于是我们可以得到一个结论：单指令发3条它需要的时间，假定他们两个一样，是6个网络时间加3个处理时间，如果我们把它合成一个mset呢，我们想一想。 假如说用多指令发3个指令的话，其实只需要发一次就行了。这样我们可以得到一个结论，多指令发3个指令的话，其实它是两个网络时间加上3个redis的操作时间，为什么这写一个小加号呢，就是因为毕竟发的信息量变大了，所以网络时间有可能会变长。 那么通过这张图，你就可以得到一个结论，我们单指令和多指令他们的差别就在于你发送的次数是多还是少。当你影响的数据比较少的时候，你可以用单指令，也可以用多指令。但是一旦这个量大了，你就要选择多指令了，他的效率会高一些。 1.3.3. 2.3 string 类型数据的扩展操作 2.3.1 string 类型数据的扩展操作 下面我们来看一string的扩展操作，分成两大块：一块是对数字进行操作的，第二块是对我们的key的时间进行操作的。 设置数值数据增加指定范围的值 incr key incrby key increment incrbyfloat key increment 设置数值数据减少指定范围的值 decr key decrby key increment 设置数据具有指定的生命周期 setex key seconds value psetex key milliseconds value 2.3.2 string 类型数据操作的注意事项 (1)数据操作不成功的反馈与数据正常操作之间的差异 表示运行结果是否成功 (integer) 0 → false 失败 (integer) 1 → true 成功 表示运行结果值 (integer) 3 → 3 3个 (integer) 1 → 1 1个 (2)数据未获取到时，对应的数据为（nil），等同于null (3)数据最大存储量：512MB (4)string在redis内部存储默认就是一个字符串，当遇到增减类操作incr，decr时会转成数值型进行计算 (5)按数值进行操作的数据，如果原始数据不能转成数值，或超越了redis 数值上限范围，将报错 9223372036854775807（java中Long型数据最大值，Long.MAX_VALUE） (6)redis所有的操作都是原子性的，采用单线程处理所有业务，命令是一个一个执行的，因此无需考虑并发带来的数据影响. 1.3.4. 2.4string应用场景与key命名约定 2.4.1 应用场景 它的应用场景在于：主页高频访问信息显示控制，例如新浪微博大V主页显示粉丝数与微博数量。 我们来思考一下：这些信息是不是你进入大V的页面儿以后就要读取这写信息的啊，那这种信息一定要存储到我们的redis中，因为他的访问量太高了！那这种数据应该怎么存呢？我们来一块儿看一下方案！ 2.4.2 解决方案 （1）在redis中为大V用户设定用户信息，以用户主键和属性值作为key，后台设定定时刷新策略即可。 eg: user:id:3506728370:fans → 12210947 eg: user:id:3506728370:blogs → 6164 eg: user:id:3506728370:focuses → 83 （2）也可以使用json格式保存数据 eg: user:id:3506728370 → {“fans”：12210947，“blogs”：6164，“ focuses ”：83 } （3） key 的设置约定 数据库中的热点数据key命名惯例 | | 表名 | 主键名 | 主键值 | 字段名 | | —— | ——— | -——— | ——— | -——— | | eg1： | order | id | 29437595 | name | | eg2： | equip | id | 390472345 | type | | eg3： | news | id | 202004150 | title | 1.3.5. 2.5 hash的基本操作 下面我们来学习第二个数据类型hash。 2.5.1 数据存储的困惑 对象类数据的存储如果具有较频繁的更新需求操作会显得笨重！ 在正式学习之前，我们先来看一个关于数据存储的困惑： 比如说前面我们用以上形式存了数据，如果我们用单条去存的话，它存的条数会很多。但如果我们用json格式，它存一条数据就够了。问题来了，假如说现在粉丝数量发生变化了，你要把整个值都改了。但是用单条存的话就不存在这个问题，你只需要改其中一个就行了。这个时候我们就想，有没有一种新的存储结构，能帮我们解决这个问题呢。 我们一块儿来分析一下： 如上图所示：单条的话是对应的数据在后面放着。仔细观察：我们看左边是不是长得都一模一样啊，都是对应的表名、ID等的一系列的东西。我们可以将右边红框中的这个区域给他封起来。 那如果要是这样的形式的话，如下图，我们把它一合并，并把右边的东西给他变成这个格式，这不就行了吗？ 这个图其实大家并不陌生，第一，你前面学过一个东西叫hashmap不就这格式吗？第二，redis自身不也是这格式吗？那是什么意思呢？注意，这就是我们要讲的第二种格式，hash。 在右边对应的值，我们就存具体的值，那左边儿这就是我们的key。问题来了，那中间的这一块叫什么呢？这个东西我们给他起个名儿，叫做field字段。那么右边儿整体这块儿空间我们就称为hash，也就是说hash是存了一个key value的存储空间。 2.5.2 hash 类型 新的存储需求：对一系列存储的数据进行编组，方便管理，典型应用存储对象信息 需要的存储结构：一个存储空间保存多个键值对数据 hash类型：底层使用哈希表结构实现数据存储 如上图所示，这种结构叫做hash，左边一个key，对右边一个存储空间。这里要明确一点，右边这块儿存储空间叫hash，也就是说hash是指的一个数据类型，他指的不是一个数据，是这里边的一堆数据，那么它底层呢，是用hash表的结构来实现的。 值得注意的是： 如果field数量较少，存储结构优化为类数组结构 如果field数量较多，存储结构使用HashMap结构 2.5.3 hash 类型数据的基本操作 添加/修改数据 hset key field value 获取数据 hget key field hgetall key 删除数据 hdel key field1 [field2] 设置field的值，如果该field存在则不做任何操作 hsetnx key field value 添加/修改多个数据 hmset key field1 value1 field2 value2 … 获取多个数据 hmget key field1 field2 … 获取哈希表中字段的数量 hlen key 获取哈希表中是否存在指定的字段 hexists key field 1.3.6. 2.6 hash的拓展操作 在看完hash的基本操作后，我们再来看他的拓展操作，他的拓展操作相对比较简单： 2.6.1 hash 类型数据扩展操作 获取哈希表中所有的字段名或字段值 hkeys key hvals key 设置指定字段的数值数据增加指定范围的值 hincrby key field increment hincrbyfloat key field increment 2.6.2 hash类型数据操作的注意事项 (1)hash类型中value只能存储字符串，不允许存储其他数据类型，不存在嵌套现象。如果数据未获取到，对应的值为（nil）。 (2）每个 hash 可以存储 232 - 1 个键值对 hash类型十分贴近对象的数据存储形式，并且可以灵活添加删除对象属性。但hash设计初衷不是为了存储大量对象而设计 的，切记不可滥用，更不可以将hash作为对象列表使用。 (3)hgetall 操作可以获取全部属性，如果内部field过多，遍历整体数据效率就很会低，有可能成为数据访问瓶颈。 1.3.7. 2.7 hash应用场景 2.7.1 应用场景 双11活动日，销售手机充值卡的商家对移动、联通、电信的30元、50元、100元商品推出抢购活动，每种商品抢购上限1000 张。 也就是商家有了，商品有了，数量有了。最终我们的用户买东西就是在改变这个数量。那你说这个结构应该怎么存呢？对应的商家的ID作为key，然后这些充值卡的ID作为field，最后这些数量作为value。而我们所谓的操作是其实就是increa这个操作，只不过你传负值就行了。看一看对应的解决方案： 2.7.2 解决方案 以商家id作为key 将参与抢购的商品id作为field 将参与抢购的商品数量作为对应的value 抢购时使用降值的方式控制产品数量 注意：实际业务中还有超卖等实际问题，这里不做讨论 1.3.8. 2.8 list基本操作 前面我们存数据的时候呢，单个数据也能存，多个数据也能存，但是这里面有一个问题，我们存多个数据用hash的时候它是没有顺序的。我们平时操作，实际上数据很多情况下都是有顺序的，那有没有一种能够用来存储带有顺序的这种数据模型呢，list就专门来干这事儿。 2.8.1 list 类型 数据存储需求：存储多个数据，并对数据进入存储空间的顺序进行区分 需要的存储结构：一个存储空间保存多个数据，且通过数据可以体现进入顺序 list类型：保存多个数据，底层使用双向链表存储结构实现 先来通过一张图，回忆一下顺序表、链表、双向链表。 list对应的存储结构是什么呢？里边存的这个东西是个列表，他有一个对应的名称。就是key存一个list的这样结构。对应的基本操作，你其实是可以想到的。 来看一下，因为它是双向的，所以他左边右边都能操作，它对应的操作结构两边都能进数据。这就是链表的一个存储结构。往外拿数据的时候怎么拿呢？通常是从一端拿，当然另一端也能拿。如果两端都能拿的话，这就是个双端队列，两边儿都能操作。如果只能从一端进一端出，这个模型咱们前面了解过，叫做栈。 2.8.2 list 类型数据基本操作 最后看一下他的基本操作 添加/修改数据 lpush key value1 [value2] …… rpush key value1 [value2] …… 获取数据 lrange key start stop lindex key index llen key 获取并移除数据 lpop key rpop key 1.3.9. 2.9 list扩展操作 2.9.1 list 类型数据扩展操作 移除指定数据 lrem key count value 规定时间内获取并移除数据 blpop key1 [key2] timeout brpop key1 [key2] timeout brpoplpush source destination timeout 2.9.2 list 类型数据操作注意事项 （1）list中保存的数据都是string类型的，数据总容量是有限的，最多232 - 1 个元素(4294967295)。 （2）list具有索引的概念，但是操作数据时通常以队列的形式进行入队出队操作，或以栈的形式进行入栈出栈操作 （3）获取全部数据操作结束索引设置为-1 （4）list可以对数据进行分页操作，通常第一页的信息来自于list，第2页及更多的信息通过数据库的形式加载 1.3.10. 2.10 list 应用场景 2.10.1 应用场景 企业运营过程中，系统将产生出大量的运营数据，如何保障多台服务器操作日志的统一顺序输出？ 假如现在你有多台服务器，每一台服务器都会产生它的日志，假设你是一个运维人员，你想看它的操作日志，你怎么看呢？打开A机器的日志看一看，打开B机器的日志再看一看吗？这样的话你会可能会疯掉的！因为左边看的有可能它的时间是11:01，右边11:02，然后再看左边11:03，它们本身是连续的，但是你在看的时候就分成四个文件了，这个时候你看起来就会很麻烦。能不能把他们合并呢？答案是可以的！怎么做呢？建立起redis服务器。当他们需要记日志的时候，记在哪儿,全部发给redis。等到你想看的时候，通过服务器访问redis获取日志。然后得到以后，就会得到一个完整的日志信息。那么这里面就可以获取到完整的日志了，依靠什么来实现呢？就依靠我们的list的模型的顺序来实现。进来一组数据就往里加，谁先进来谁先加进去，它是有一定的顺序的。 2.10.2 解决方案 依赖list的数据具有顺序的特征对信息进行管理 使用队列模型解决多路信息汇总合并的问题 使用栈模型解决最新消息的问题 1.3.11. 2.11 set 基本操作 2.11.1 set类型 新的存储需求：存储大量的数据，在查询方面提供更高的效率 需要的存储结构：能够保存大量的数据，高效的内部存储机制，便于查询 set类型：与hash存储结构完全相同，仅存储键，不存储值（nil），并且值是不允许重复的 通过这个名称，大家也基本上能够认识到和我们Java中的set完全一样。我们现在要存储大量的数据，并且要求提高它的查询效率。用list这种链表形式，它的查询效率是不高的，那怎么办呢？这时候我们就想，有没有高效的存储机制。其实前面咱讲Java的时候说过hash表的结构就非常的好，但是这里边我们已经有hash了，他做了这么一个设定，干嘛呢，他把hash的存储空间给改一下，右边你原来存数据改掉,全部存空，那你说数据放哪儿了？放到原来的filed的位置，也就在这里边存真正的值，那么这个模型就是我们的set 模型。 set类型：与hash存储结构完全相同，仅存储键，不存储值（nil），并且值是不允许重复的。 看一下它的整个结构： 2.11.2 set类型数据的基本操作 添加数据 sadd key member1 [member2] 获取全部数据 smembers key 删除数据 srem key member1 [member2] 获取集合数据总量 scard key 判断集合中是否包含指定数据 sismember key member 随机获取集合中指定数量的数据 srandmember key [count] 随机获取集中的某个数据并将该数据移除集合 spop key [count] 1.3.12. 2.12 set 类型数据的扩展操作 2.12.1 set 类型数据的扩展操作 求两个集合的交、并、差集 sinter key1 [key2 …] sunion key1 [key2 …] sdiff key1 [key2 …] 求两个集合的交、并、差集并存储到指定集合中 sinterstore destination key1 [key2 …] sunionstore destination key1 [key2 …] sdiffstore destination key1 [key2 …] 将指定数据从原始集合中移动到目标集合中 smove source destination member 通过下面一张图回忆一下交、并、差 2.12.2 set 类型数据操作的注意事项 set 类型不允许数据重复，如果添加的数据在 set 中已经存在，将只保留一份。 set 虽然与hash的存储结构相同，但是无法启用hash中存储值的空间。 1.3.13. 2.13 set应用场景 2.13.1 set应用场景 （1）黑名单 资讯类信息类网站追求高访问量，但是由于其信息的价值，往往容易被不法分子利用，通过爬虫技术， 快速获取信息，个别特种行业网站信息通过爬虫获取分析后，可以转换成商业机密进行出售。例如第三方火 车票、机票、酒店刷票代购软件，电商刷评论、刷好评。 同时爬虫带来的伪流量也会给经营者带来错觉，产生错误的决策，有效避免网站被爬虫反复爬取成为每个网站都要考虑的基本问题。在基于技术层面区分出爬虫用户后，需要将此类用户进行有效的屏蔽，这就是黑名单的典型应用。 ps:不是说爬虫一定做摧毁性的工作，有些小型网站需要爬虫为其带来一些流量。 （2）白名单 对于安全性更高的应用访问，仅仅靠黑名单是不能解决安全问题的，此时需要设定可访问的用户群体， 依赖白名单做更为苛刻的访问验证。 2.13.2 解决方案 基于经营战略设定问题用户发现、鉴别规则 周期性更新满足规则的用户黑名单，加入set集合 用户行为信息达到后与黑名单进行比对，确认行为去向 黑名单过滤IP地址：应用于开放游客访问权限的信息源 黑名单过滤设备信息：应用于限定访问设备的信息源 黑名单过滤用户：应用于基于访问权限的信息源 1.3.14. 2.14 实践案例 2.14.1业务场景 使用微信的过程中，当微信接收消息后，会默认将最近接收的消息置顶，当多个好友及关注的订阅号同时发 送消息时，该排序会不停的进行交替。同时还可以将重要的会话设置为置顶。一旦用户离线后，再次打开微信时，消息该按照什么样的顺序显示。 我们分析一下： 100这台手机代表你。而200、300、400这三台代表你好友的手机。在这里有一些东西需要交代一下，因为我们每个人的都会对自己的微信中的一些比较重要的人设置会话置顶，将他的那条对话放在最上面。我们假定这个人有两个会话置顶的好友，分别是400和500，而这里边就包含400. 下面呢，我们就来发这个消息，第一个发消息的是300，他发了个消息给100。发完以后，这个东西应该怎么存储呢？在这里面一定要分开，记录置顶的这些人的会话，对应的会话显示顺序和非置顶的一定要分两。 这里面我们创建两个模型，一个是普通的，一个是置顶的，而上面的这个置顶的用户呢，我们用set来存储，因为不重复。而下面这些因为有顺序，很容易想到用list去存储,不然你怎么表达顺序呢？ 那当300发给消息给100以后，这个时候我们先判定你在置顶人群中吗？不在,那好，300的消息对应的顺序就应该放在普通的列表里边。而在这里边，我们把300加进去。第一个数据也就是现在300。 接下来400，发了个消息。判断一下，他是需要置顶的，所以400将进入list的置顶里边放着。当前还没有特殊的地方。 再来200发消息了，和刚才的判定方法一样，先看在不在置顶里，不在的话进普通，然后在普通里边把200加入就行了，OK，到这里目前还没有顺序变化。 接下来200又发消息过来，同一个人给你连发了两条，那这个时候200的消息到达以后，先判断是否在置顶范围，不在，接下来他要放在list普通中，这里你要注意一点，因为这里边已经有200，所以进来以后先干一件事儿，把200杀掉，没有200，然后再把200加进来，那你想一下，现在这个位置顺序是什么呢？就是新的都在右边，对不对？ 还记得我们说list模型，如果是一个双端队列，它是可以两头进两头出。当然我们双端从一头进一头出，这就是栈模型，现在咱们运用的就是list模型中的栈模型。 现在300发消息，先判定他在不在，不在，用普通的队列，接下来按照刚才的操作，不管你里边原来有没有300，我先把300杀掉，没了，200自然就填到300的位置了，他现在是list里面唯一一个，然后让300进来，注意是从右侧进来的，那么现在300就是最新的。 那么到这里呢，我们让100来读取消息。你觉得这个消息顺序应该是什么样的？首先置顶的400有一个，他跑在最上面，然后list普通如果出来的话，300是最新的消息，而200在他后面的。用这种形式，我们就可以做出来他的消息顺序来。 2.14.2 解决方案 看一下最终的解决方案： 依赖list的数据具有顺序的特征对消息进行管理，将list结构作为栈使用 置顶与普通会话分别创建独立的list分别管理 当某个list中接收到用户消息后，将消息发送方的id从list的一侧加入list（此处设定左侧） 多个相同id发出的消息反复入栈会出现问题，在入栈之前无论是否具有当前id对应的消息，先删除对应id 推送消息时先推送置顶会话list，再推送普通会话list，推送完成的list清除所有数据 消息的数量，也就是微信用户对话数量采用计数器的思想另行记录，伴随list操作同步更新 2.14.3 数据类型总结 总结一下，在整个数据类型的部分，我们主要介绍了哪些内容： 首先我们了解了一下数据类型，接下来针对着我们要学习的数据类型，进行逐一讲解了string、hash、list、set等，最后通过一个案例总结了一下前面的数据类型的使用场景。 1.4. 3. 常用指令 在这部分中呢，我们家学习两个知识，第一个是key的常用指令，第二个是数据库的常用指令。和前面我们学数据类型做一下区分，前面你学的那些指令呢，都是针对某一个数据类型操作的，现在学的都是对所有的操作的，来看一下，我们在学习Key的操作的时候，我们先想一下的操作我们应该学哪些东西: 1.4.1. 3.1 key 操作分析 3.1.1 key应该设计哪些操作？ key是一个字符串，通过key获取redis中保存的数据 对于key自身状态的相关操作，例如：删除，判定存在，获取类型等 对于key有效性控制相关操作，例如：有效期设定，判定是否有效，有效状态的切换等 对于key快速查询操作，例如：按指定策略查询key 3.1.2 key 基本操作 删除指定key del key 获取key是否存在 exists key 获取key的类型 type key 3.1.3 拓展操作 排序 sort 改名 rename key newkey renamenx key newkey 3.1.3 key 扩展操作（时效性控制） 为指定key设置有效期 expire key seconds pexpire key milliseconds expireat key timestamp pexpireat key milliseconds-timestamp 获取key的有效时间 ttl key pttl key 切换key从时效性转换为永久性 persist key 3.1.4 key 扩展操作（查询模式） 查询key keys pattern 查询模式规则 *匹配任意数量的任意符号 ? 配合一个任意符号 [] 匹配一个指定符号 keys * keys 查询所有 it* keys 查询所有以it开头 *heima 查询所有以heima结尾 keys ??heima 查询所有前面两个字符任意，后面以heima结尾 查询所有以 keys user:? user:开头，最后一个字符任意 keys u[st]er:1 查询所有以u开头，以er:1结尾，中间包含一个字母，s或t 1.4.2. 3.2 数据库指令 3.2.1 key 的重复问题 在这个地方我们来讲一下数据库的常用指令，在讲这个东西之前，我们先思考一个问题： 假如说你们十个人同时操作redis，会不会出现key名字命名冲突的问题。 一定会，为什么?因为你的key是由程序而定义的。你想写什么写什么，那在使用的过程中大家都在不停的加，早晚有一天他会冲突的。 redis在使用过程中，伴随着操作数据量的增加，会出现大量的数据以及对应的key。 那这个问题我们要不要解决？要！怎么解决呢？我们最好把数据进行一个分类，除了命名规范我们做统一以外，如果还能把它分开，这样是不是冲突的机率就会小一些了，这就是咱们下面要说的解决方案！ 3.2.2 解决方案 redis为每个服务提供有16个数据库，编号从0到15 每个数据库之间的数据相互独立 在对应的数据库中划出一块区域，说他就是几，你就用几那块，同时，其他的这些都可以进行定义，一共是16个，这里边需要注意一点，他们这16个共用redis的内存。没有说谁大谁小，也就是说数字只是代表了一块儿区域，区域具体多大未知。这是数据库的一个分区的一个策略！ 3.2.3 数据库的基本操作 切换数据库 select index 其他操作 ping 3.2.4 数据库扩展操作 数据移动 move key db 数据总量 dbsize 数据清除 flushdb flushall 1.5. 4. Jedis 在学习完redis后，我们现在就要用Java来连接redis了，也就是我们的这一章要学的Jedis了。在这个部分，我们主要讲解以下3个内容： HelloWorld（Jedis版） Jedis简易工具类开发 可视化客户端 1.5.1. 4.1 Jedis简介 4.1.1 编程语言与redis 对于我们现在的数据来说，它是在我们的redis中，而最终我们是要做程序。那么程序就要和我们的redis进行连接。干什么事情呢？两件事：程序中有数据的时候，我们要把这些数据全部交给redis管理。同时，redis中的数据还能取出来，回到我们的应用程序中。那在这个过程中，在Java与redis之间打交道的这个东西就叫做Jedis.简单说，Jedis就是提供了Java与redis的连接服务的，里边有各种各样的API接口，你可以去调用它。 除了Jedis外，还有没有其他的这种连接服务呢？其实还有很多，了解一下： Java语言连接redis服务 Jedis（SpringData、Redis 、 Lettuce） 其它语言：C 、C++ 、C# 、Erlang、Lua 、Objective-C 、Perl 、PHP 、Python 、Ruby 、Scala 4.1.2 准备工作 (1)jar包导入 下载地址：https://mvnrepository.com/artifact/redis.clients/jedis 基于maven redis.clients jedis 2.9.0 (2)客户端连接redis 连接redis Jedis jedis = new Jedis(“localhost”, 6379); 操作redis jedis.set(“name”, “itheima”); jedis.get(“name”); 关闭redis连接 jedis.close(); API文档 http://xetorthio.github.io/jedis/ 4.1.3 代码实现 创建：com.itheima.JedisTest public class JedisTest { public static void main(String[] args) { //1.获取连接对象 Jedis jedis = new Jedis(“192.168.40.130”,6379); //2.执行操作 jedis.set(“age”,”39”); String hello = jedis.get(“hello”); System.out.println(hello); jedis.lpush(“list1”,”a”,”b”,”c”,”d”); List list1 = jedis.lrange(“list1”, 0, -1); for (String s:list1 ) { System.out.println(s); } jedis.sadd(“set1”,”abc”,”abc”,”def”,”poi”,”cba”); Long len = jedis.scard(“set1”); System.out.println(len); //3.关闭连接 jedis.close(); } } 1.5.2. 4.2 Jedis简易工具类开发 前面我们做的程序还是有点儿小问题，就是我们的Jedis对象的管理是我们自己创建的，真实企业开发中是不可能让你去new一个的，那接下来咱们就要做一个工具类，简单来说，就是做一个创建Jedis的这样的一个工具。 4.2.1 基于连接池获取连接 JedisPool：Jedis提供的连接池技术 poolConfig:连接池配置对象 host:redis服务地址 port:redis服务端口号 JedisPool的构造器如下： public JedisPool(GenericObjectPoolConfig poolConfig, String host, int port) { this(poolConfig, host, port, 2000, (String)null, 0, (String)null); } 4.2.2 封装连接参数 创建jedis的配置文件：jedis.properties jedis.host=192.168.40.130 jedis.port=6379 jedis.maxTotal=50 jedis.maxIdle=10 4.2.3 加载配置信息 创建JedisUtils：com.itheima.util.JedisUtils，使用静态代码块初始化资源 public class JedisUtils { private static int maxTotal; private static int maxIdel; private static String host; private static int port; private static JedisPoolConfig jpc; private static JedisPool jp; static { ResourceBundle bundle = ResourceBundle.getBundle(“redis”); maxTotal = Integer.parseInt(bundle.getString(“redis.maxTotal”)); maxIdel = Integer.parseInt(bundle.getString(“redis.maxIdel”)); host = bundle.getString(“redis.host”); port = Integer.parseInt(bundle.getString(“redis.port”)); //Jedis连接池配置 jpc = new JedisPoolConfig(); jpc.setMaxTotal(maxTotal); jpc.setMaxIdle(maxIdel); jp = new JedisPool(jpc,host,port); } } 4.2.4 获取连接 对外访问接口，提供jedis连接对象，连接从连接池获取，在JedisUtils中添加一个获取jedis的方法：getJedis public static Jedis getJedis(){ Jedis jedis = jedisPool.getResource(); return jedis; } 1.5.3. 4.3 可视化客户端 4.3.1 Redis Desktop Manager 1.6. 5. 持久化 下面呢，进入到持久化的学习.这部分内容理解的东西多，操作的东西少。在这个部分，我们将讲解四个东西： 持久化简介 RDB AOF RDB与AOF区别 1.6.1. 5.1 持久化简介 5.1.1 场景-意外断电 不知道大家有没有遇见过，就是正工作的时候停电了，如果你用的是笔记本电脑还好，你有电池，但如果你用的是台式机呢，那恐怕就比较灾难了，假如你现在正在写一个比较重要的文档，如果你要使用的是word，这种办公自动化软件的话，他一旦遇到停电，其实你不用担心，因为它会给你生成一些其他的文件。 其实他们都在做一件事儿，帮你自动恢复，有了这个文件，你前面的东西就不再丢了。那什么是自动恢复呢？你要先了解他的整个过程。 我们说自动恢复，其实基于的一个前提就是他提前把你的数据给存起来了。你平常操作的所有信息都是在内存中的，而我们真正的信息是保存在硬盘中的，内存中的信息断电以后就消失了，硬盘中的信息断电以后还可以保留下来！ 我们将文件由内存中保存到硬盘中的这个过程，我们叫做数据保存，也就叫做持久化。但是把它保存下来不是你的目的，最终你还要把它再读取出来，它加载到内存中这个过程，我们叫做数据恢复，这就是我们所说的word为什么断电以后还能够给你保留文件，因为它执行了一个自动备份的过程，也就是通过自动的形式，把你的数据存储起来，那么有了这种形式以后，我们的数据就可以由内存到硬盘上实现保存。 5.1.2 什么是持久化 (1)什么是持久化 利用永久性存储介质将数据进行保存，在特定的时间将保存的数据进行恢复的工作机制称为持久化 。 持久化用于防止数据的意外丢失，确保数据安全性。 (2)持久化过程保存什么？ 我们知道一点，计算机中的数据全部都是二进制，如果现在我要你给我保存一组数据的话，你有什么样的方式呢，其实最简单的就是现在长什么样，我就记下来就行了，那么这种是记录纯粹的数据，也叫做快照存储，也就是它保存的是某一时刻的数据状态。 还有一种形式，它不记录你的数据，它记录你所有的操作过程，比如说大家用idea的时候，有没有遇到过写错了ctrl+z撤销，然后ctrl+y还能恢复，这个地方它也是在记录，但是记录的是你所有的操作过程，那我想问一下，操作过程，我都给你留下来了，你说数据还会丢吗？肯定不会丢，因为你所有的操作过程我都保存了。这种保存操作过程的存储，用专业术语来说可以说是日志，这是两种不同的保存数据的形式啊。 总结一下： 第一种：将当前数据状态进行保存，快照形式，存储数据结果，存储格式简单，关注点在数据。 第二种：将数据的操作过程进行保存，日志形式，存储操作过程，存储格式复杂，关注点在数据的操作过程。 1.6.2. 5.2 RDB 5.2.1 save指令 手动执行一次保存操作 save save指令相关配置 设置本地数据库文件名，默认值为 dump.rdb，通常设置为dump-端口号.rdb dbfilename filename 设置存储.rdb文件的路径，通常设置成存储空间较大的目录中，目录名称data dir path 设置存储至本地数据库时是否压缩数据，默认yes，设置为no，节省 CPU 运行时间，但存储文件变大 rdbcompression yes|no 设置读写文件过程是否进行RDB格式校验，默认yes，设置为no，节约读写10%时间消耗，单存在数据损坏的风险 rdbchecksum yes|no save指令工作原理 需要注意一个问题，来看一下，现在有四个客户端各自要执行一个指令，把这些指令发送到redis服务器后，他们执行有一个先后顺序问题，假定就是按照1234的顺序放过去的话，那会是什么样的？ 记得redis是个单线程的工作模式，它会创建一个任务队列，所有的命令都会进到这个队列里边，在这儿排队执行，执行完一个消失一个，当所有的命令都执行完了，OK，结果达到了。 但是如果现在我们执行的时候save指令保存的数据量很大会是什么现象呢？ 他会非常耗时，以至于影响到它在执行的时候，后面的指令都要等，所以说这种模式是不友好的，这是save指令对应的一个问题，当cpu执行的时候会阻塞redis服务器，直到他执行完毕，所以说我们不建议大家在线上环境用save指令。 5.2.2 bgsave指令 之前我们讲到了当save指令的数据量过大时，单线程执行方式造成效率过低，那应该如何处理？ 此时我们可以使用：bgsave指令，bg其实是background的意思，后台执行的意思 手动启动后台保存操作，但不是立即执行 bgsave bgsave指令相关配置 后台存储过程中如果出现错误现象，是否停止保存操作，默认yes stop-writes-on-bgsave-error yes|no 其 他 dbfilename filename dir path rdbcompression yes|no rdbchecksum yes|no bgsave指令工作原理 当执行bgsave的时候，客户端发出bgsave指令给到redis服务器。注意，这个时候服务器马上回一个结果告诉客户端后台已经开始了，与此同时它会创建一个子进程，使用Linux的fork函数创建一个子进程，让这个子进程去执行save相关的操作，此时我们可以想一下，我们主进程一直在处理指令，而子进程在执行后台的保存，它会不会干扰到主进程的执行吗？ 答案是不会，所以说他才是主流方案。子进程开始执行之后，它就会创建啊RDB文件把它存起来，操作完以后他会把这个结果返回，也就是说bgsave的过程分成两个过程，第一个是服务端拿到指令直接告诉客户端开始执行了；另外一个过程是一个子进程在完成后台的保存操作，操作完以后回一个消息。 5.2.3 save配置自动执行 设置自动持久化的条件，满足限定时间范围内key的变化数量达到指定数量即进行持久化 save second changes 参数 second：监控时间范围 changes：监控key的变化量 范例： save 900 1 save 300 10 save 60 10000 其他相关配置： dbfilename filename dir path rdbcompression yes|no rdbchecksum yes|no stop-writes-on-bgsave-error yes|no save配置工作原理 5.2.4 RDB三种启动方式对比 方式 save指令 bgsave指令 读写 同步 异步 阻塞客户端指令 是 否 额外内存消耗 否 是 启动新进程 否 是 RDB特殊启动形式 服务器运行过程中重启 debug reload 关闭服务器时指定保存数据 shutdown save 全量复制（在主从复制中详细讲解） RDB优点： RDB是一个紧凑压缩的二进制文件，存储效率较高 RDB内部存储的是redis在某个时间点的数据快照，非常适合用于数据备份，全量复制等场景 RDB恢复数据的速度要比AOF快很多 应用：服务器中每X小时执行bgsave备份，并将RDB文件拷贝到远程机器中，用于灾难恢复。 RDB缺点 RDB方式无论是执行指令还是利用配置，无法做到实时持久化，具有较大的可能性丢失数据 bgsave指令每次运行要执行fork操作创建子进程，要牺牲掉一些性能 Redis的众多版本中未进行RDB文件格式的版本统一，有可能出现各版本服务之间数据格式无法兼容现象 1.6.3. 5.3 AOF 为什么要有AOF,这得从RDB的存储的弊端说起： 存储数据量较大，效率较低，基于快照思想，每次读写都是全部数据，当数据量巨大时，效率非常低 大数据量下的IO性能较低 基于fork创建子进程，内存产生额外消耗 宕机带来的数据丢失风险 那解决的思路是什么呢？ 不写全数据，仅记录部分数据 降低区分数据是否改变的难度，改记录数据为记录操作过程 对所有操作均进行记录，排除丢失数据的风险 5.3.1 AOF概念 AOF(append only file)持久化：以独立日志的方式记录每次写命令，重启时再重新执行AOF文件中命令 达到恢复数据的目的。与RDB相比可以简单理解为由记录数据改为记录数据产生的变化 AOF的主要作用是解决了数据持久化的实时性，目前已经是Redis持久化的主流方式 AOF写数据过程 启动AOF相关配置 开启AOF持久化功能，默认no，即不开启状态 appendonly yes|no AOF持久化文件名，默认文件名为appendonly.aof，建议配置为appendonly-端口号.aof appendfilename filename AOF持久化文件保存路径，与RDB持久化文件保持一致即可 dir AOF写数据策略，默认为everysec appendfsync always|everysec|no 5.3.2 AOF执行策略 AOF写数据三种策略(appendfsync) always(每次）：每次写入操作均同步到AOF文件中数据零误差，性能较低，不建议使用。 everysec（每秒）：每秒将缓冲区中的指令同步到AOF文件中，在系统突然宕机的情况下丢失1秒内的数据 数据准确性较高，性能较高，建议使用，也是默认配置 no（系统控制）：由操作系统控制每次同步到AOF文件的周期，整体过程不可控 5.3.3 AOF重写 场景：AOF写数据遇到的问题，如果连续执行如下指令该如何处理 什么叫AOF重写？ 随着命令不断写入AOF，文件会越来越大，为了解决这个问题，Redis引入了AOF重写机制压缩文件体积。AOF文件重 写是将Redis进程内的数据转化为写命令同步到新AOF文件的过程。简单说就是将对同一个数据的若干个条命令执行结 果转化成最终结果数据对应的指令进行记录。 AOF重写作用 降低磁盘占用量，提高磁盘利用率 提高持久化效率，降低持久化写时间，提高IO性能 降低数据恢复用时，提高数据恢复效率 AOF重写规则 进程内具有时效性的数据，并且数据已超时将不再写入文件 非写入类的无效指令将被忽略，只保留最终数据的写入命令 如del key1、 hdel key2、srem key3、set key4 111、set key4 222等 如select指令虽然不更改数据，但是更改了数据的存储位置，此类命令同样需要记录 对同一数据的多条写命令合并为一条命令 如lpushlist1 a、lpush list1 b、lpush list1 c可以转化为：lpush list1 a b c。 为防止数据量过大造成客户端缓冲区溢出，对list、set、hash、zset等类型，每条指令最多写入64个元素 AOF重写方式 手动重写 bgrewriteaof 手动重写原理分析： 自动重写 auto-aof-rewrite-min-size size auto-aof-rewrite-percentage percentage 自动重写触发条件设置 auto-aof-rewrite-min-size size auto-aof-rewrite-percentage percent 自动重写触发比对参数（ 运行指令info Persistence获取具体信息 ） aof_current_size aof_base_size 自动重写触发条件公式： 5.3.4 AOF工作流程及重写流程 1.6.4. 5.4 RDB与AOF区别 5.4.1 RDB与AOF对比（优缺点） 持久化方式 RDB AOF 占用存储空间 小（数据级：压缩） 大（指令级：重写） 存储速度 慢 快 恢复速度 快 慢 数据安全性 会丢失数据 依据策略决定 资源消耗 高/重量级 低/轻量级 启动优先级 低 高 5.4.2 RDB与AOF应用场景 RDB与AOF的选择之惑 对数据非常敏感，建议使用默认的AOF持久化方案 AOF持久化策略使用everysecond，每秒钟fsync一次。该策略redis仍可以保持很好的处理性能，当出 现问题时，最多丢失0-1秒内的数据。 注意：由于AOF文件存储体积较大，且恢复速度较慢 数据呈现阶段有效性，建议使用RDB持久化方案 数据可以良好的做到阶段内无丢失（该阶段是开发者或运维人员手工维护的），且恢复速度较快，阶段 点数据恢复通常采用RDB方案 注意：利用RDB实现紧凑的数据持久化会使Redis降的很低，慎重总结： 综合比对 RDB与AOF的选择实际上是在做一种权衡，每种都有利有弊 如不能承受数分钟以内的数据丢失，对业务数据非常敏感，选用AOF 如能承受数分钟以内的数据丢失，且追求大数据集的恢复速度，选用RDB 灾难恢复选用RDB 双保险策略，同时开启 RDB和 AOF，重启后，Redis优先使用 AOF 来恢复数据，降低丢失数据的量 Copyright © MISIN 2022 | 豫ICP备2021006345号-1 all right reserved，powered by Gitbook该文件修订时间： 2022-11-10 13:56:12 "},"2.JavaWeb/12.Maven/Maven基础.html":{"url":"2.JavaWeb/12.Maven/Maven基础.html","title":"Maven基础","keywords":"","body":"1. Maven基础1.1. 学习目标1.2. 1.Maven简介1.2.1. 1.1 Maven是什么1.2.2. 1.2 Maven的作用1.3. 2.Maven环境搭建1.3.1. 2.1 下载1.3.2. 2.2 安装1.3.3. 2.3 环境配置1.4. 3.Maven基础概念1.4.1. 3.1 仓库1.4.2. 3.2 坐标1.4.3. 3.3 仓库配置1.5. 4.Maven项目搭建1.5.1. 4.1 手动搭建maven项目1.5.2. 4.2 IDEA工具搭建maven项目1.6. 5.Maven依赖管理1.6.1. 5.1 依赖配置与依赖传递1.6.2. 5.2 依赖范围1.7. 6.Maven生命周期与插件1.7.1. 6.1 生命周期1.7.2. 6.2 插件1. Maven基础 1.1. 学习目标 目标1：能够说出maven的作用，POM的概念 目标2：完成maven的下载，安装和环境配置 目标3：能够说出仓库，坐标的概念，完成仓库的配置 目标4：完成手动搭建maven项目的案例 目标5：完成IDEA工具搭建maven项目的案例 目标6：能够说出依赖的传递方式和如何解决依赖传递冲突 目标7：能够说出maven的生命周期 1.2. 1.Maven简介 1.2.1. 1.1 Maven是什么 在学习Maven之前，我们先来看一下我们现在做的项目都有哪些问题。假设你现在做了一个crm的系统，项目中肯定要用到一些jar包，比如说mybatis，log4j，JUnit等，除了这些之外，你有可能用到你的同事开发的其他的东西，比如说别人做了一个财务模块或做了一个结算的模块，你在这里边有可能要用到这些东西。 假如有一天你们的项目中mybatis进行了一个升级，但是它内部使用的JUnit没有升级，你升级以后的mybatis假如要用5.0的JUnit，而你项目中目前用的是4.0的，会不会冲突？必然会出问题！这个时候管理起来会比较麻烦，你需要各种调整。更有甚者，假如同事做的这些东西升级了但又没有通知你，这个时候，就会出现几种严重的问题： （1）jar包不统一，jar不兼容 （2）工程升级维护过程操作繁琐 除此之外，还会有其它的一系列问题。那么要解决这些问题，就用到了我们今天要讲的Maven了。 那Maven是什么？ ​ Maven的本质是一个项目管理工具，将项目开发和管理过程抽象成一个项目对象模型（POM） Maven是用Java语言编写的。他管理的东西统统以面向对象的形式进行设计，最终他把一个项目看成一个对象，而这个对象叫做POM(project object model)，即项目对象模型 我们说一个项目就是一个对象，作为对象的行为、对象的属性都有哪些呢？ Maven说我们需要编写一个pom.xml文件，Maven通过加载这个配置文件就可以知道我们项目的相关信息了！到这里我们知道了Maven离不开一个叫pom.xml的文件。因为这个文件代表就一个项目。 提个问题大家思考，如果我们做8个项目，对应的是1个文件，还是8个文件？肯定是8个！ 那Maven是如何帮我们进行项目资源管理的呢？这就需要用到Maven中的第二个东西：依赖管理。这也是它的第二个核心！ 所谓依赖管理就是maven对项目所有依赖资源的一种管理，它和项目之间是一种双向关系，即当我们做项目的时候maven的依赖管理可以帮助你去管理你所需要的其他资源，当其他的项目需要依赖我们项目的时候，maven也会把我们的项目当作一种资源去进行管理，这就是一种双向关系。 那maven的依赖管理它管理的这些资源存在哪儿呢？主要有三个位置：本地仓库，私服，中央仓库 本地仓库顾名思义就是存储在本地的一种资源仓库，如果本地仓库中没有相关资源，可以去私服上获取，私服也是一个资源仓库，只不过不在本地，是一种远程仓库，如果私服上也没有相关资源，可以去中央仓库去获取，中央仓库也是一种远程仓库。 Maven除了帮我们管理项目资源之外还能帮助我们对项目进行构建，管理项目的整个生命周期，当然它的这些功能需要使用一些相关的插件来完成，当然整个生命周期过程中插件是需要配合使用的，单独一个无法完成完整的生命周期。 1.2.2. 1.2 Maven的作用 Maven的作用我们可以分成三类： （1）项目构建：提供标准的，跨平台的自动化构建项目的方式 （2）依赖管理：方便快捷的管理项目依赖的资源（jar包），避免资源间的版本冲突等问题 （3）统一开发结构：提供标准的，统一的项目开发结构，如下图所示： 各目录存放资源类型说明： src/main/java：项目java源码 src/main/resources：项目的相关配置文件（比如mybatis配置，xml映射配置，自定义配置文件等） src/main/webapp：web资源（比如html，css，js等） src/test/java：测试代码 src/test/resources：测试相关配置文件 src/pom.xml：项目pom文件 1.3. 2.Maven环境搭建 maven的官网：http://maven.apache.org/ 1.3.1. 2.1 下载 官方下载地址：http://maven.apache.org/download.cgi 在今日课程资料安装程序中给大家提供了已经下载好的包，我们可以直接使用 1.3.2. 2.2 安装 maven是一个绿色软件，解压即安装，非常容易， 我们找到今日课程资料中的安装程序，将里面的apache-maven-3.6.1-bin.zip直接解压到D盘根目录下即可 解压完成后我们可以查看一下maven自己的一个目录结构如下 各目录结构说明： bin：可执行程序目录， boot：maven自身的启动加载器 conf：maven配置文件的存放目录 lib：maven运行所需库的存放目录 1.3.3. 2.3 环境配置 maven的运行需要java的环境，需要我们配置JAVA_HOME环境变量，这个相信大家已经存在了 下面在去配置MAVEN_HOME的环境变量 1：我的电脑-------->属性--------->高级系统设置---------->新建系统变量MAVEN_HOME， 系统变量值就是maven软件的根目录，我们刚刚已经将maven解压到D盘了，因此变量值就如图中所示 2：环境变量配置好之后需要测试环境配置结果，我们需要在DOS命令窗口下输入以下命令查看输出 mvn -v 如果能够看到输出的maven的版本信息代表配置成功 1.4. 3.Maven基础概念 1.4.1. 3.1 仓库 仓库：用于存储资源，主要是各种jar包 关于仓库，我们前面讲到了有三种：本地仓库，私服，中央仓库，其中私服和中央仓库都属于远程仓库 中央仓库：maven团队自身维护的仓库，属于开源的 私服：各公司/部门等小范围内存储资源的仓库，私服也可以从中央仓库获取资源 本地仓库：开发者自己电脑上存储资源的仓库，也可从远程仓库获取资源 私服的作用： （1）保存具有版权的资源，包含购买或自主研发的jar （2）一定范围内共享资源，能做到仅对内不对外开放 1.4.2. 3.2 坐标 我们说maven的仓库里存储了各种各样的资源（jar包），那这些资源我们如何找到它们呢？我们需要知道它们具体的一个位置才能知道如何找到它们，这个就叫坐标 坐标：maven中的坐标用于描述仓库中资源的位置 https://repo1.maven.org/maven2/ 那maven中的坐标是如何构成的呢？ maven坐标的主要组成如下： groupId：定义当前资源隶属组织名称（通常是域名反写，如：org.mybatis；com.itheima） artifactId：定义当前资源的名称（通常是项目或模块名称，如：crm，sms） version：定义当前资源的版本号 packaging：定义资源的打包方式，取值一般有如下三种 （1）jar：该资源打成jar包，默认是jar （2）war：该资源打成war包 （3）pom：该资源是一个父资源（表明使用maven分模块管理），打包时只生成一个pom.xml不生成jar或其他包结构 如果要查询maven某一个资源的坐标，我们通常可以去maven的仓库进行查询， https://mvnrepository.com/，在该网站中可直接搜索想要的资源，然后就能得到该资源的坐标 输入资源名称进行检索 点击你想要的资源进行查看 选择版本查看坐标 maven坐标的作用： 使用唯一标识，唯一性定义资源位置，通过该标识可以将资源的识别与下载工作交由机器完成。 1.4.3. 3.3 仓库配置 开发者要在自己电脑上做开发，首先要做的就是配置本地仓库 默认情况下maven本地仓库的位置在哪儿呢？ 我们可以选择在全局进行配置，在maven的配置文件conf/settings.xml中可以找到它的说明 /path/to/local/repo --> 也就是在系统盘当前用户目录下的.m2/repository，比如我当前的系统用户是zs，则默认的本地仓库仓库位置在C:\\Users\\zs\\.m2\\repository 因为我们平时开发项目所有的资源会比较多，而且各种资源还有好多的版本，资源与资源之间还有相互依赖的这种情况，因此本地仓库保存的内容会非常的多，它的体积会很大，如果放在C盘下不太合适，因此我们可以自己来指定一个位置作为本地仓库的位置，这个指定同样是需要来修改maven的配置文件conf/settings.xml 在我们前面查看这个文件的时候大家会发现它提供了一个标签/path/to/local/repo， 这个标签中配置的值就是我们本地仓库的位置，但是这个标签是在注释中的，也就是说目前不起作用，因此我们要将该标签挪出注释，并修改标签内的值，指定一个新的位置作为本地仓库的位置，例如 /path/to/local/repo --> D:\\maven-repository 如果是局部用户配置：在仓库的同级目录也可以包含一个settings.xml配置文件，在里面也可以进行指定 注意：局部用户配置优先与全局配置（遇见相同配置项的时候） 另外大家需要注意：maven默认连接的远程仓库位置是：（即中央仓库） 此站点并不在国内，因此有时候下载速度非常慢，因此我们可以配置一个国内站点镜像，可用于加速下载资源 我们在conf/settings.xml配置文件中找到标签，在这组标签下添加镜像的配置，如下 nexus-aliyun central Nexus aliyun http://maven.aliyun.com/nexus/content/groups/public 1.5. 4.Maven项目搭建 我们回顾一下maven规范的目录结构： 1.5.1. 4.1 手动搭建maven项目 我们先使用手动的方式来创建maven项目 （1）在D盘下创建目录mvnproject并进入该目录，作为我们的操作目录 （2）创建我们的maven项目，创建一个目录project-java作为我们的项目文件夹，并进入到该目录 （3）创建java代码（源代码）所在目录，即创建src/main/java （4）创建配置文件所在目录，即创建src/main/resources （5）创建测试源代码所在目录，即创建src/test/java （6）创建测试存放配置文件存放目录，即src/test/resources （7）在src/main/java中创建一个包（注意在windos文件夹下就是创建目录）com/itheima，在该目录下创建Demo.java文件，作为演示所需java程序，内容如下 package com.itheima; public class Demo{ public String say(String name){ System.out.println(\"hello \"+name); return \"hello \"+name; } } （8）在src/test/java中创建一个测试包（目录）com/itheima，在该包下创建测试程序DemoTest.java package com.itheima; import org.junit.*; public class DemoTest{ @Test public void testSay(){ Demo d = new Demo(); String ret = d.say(\"maven\"); Assert.assertEquals(\"hello maven\",ret); } } （9）在project-java/src下创建pom.xml文件，编辑如下 4.0.0 com.itheima project-java 1.0 jar junit junit 4.12 通过前面的操作，我们已经搭建好了maven的项目结构，下面要通过maven来构建我们的项目 maven的构建命令以mvn开头，后面添加功能参数，可以一次性执行多个命令，用空格分离 mvn compile：编译 mvn clean：清理 mvn test：测试 mvn package：打包 mvn install：安装到本地仓库 下面我们来进行操作： （1）在项目project-java所在的DOS命令窗口下执行mvn compile进行源码编译，当然首次执行需要先下载相关插件 编辑结果如下： 编译完成后在项目project-java下多了一个目录target，在这个目录下就存放的是maven编译好的一些东西 我们可以进入到target目录查看 其中生成的classes目录就是编译好的字节码文件 （2）当然如果我们想清理掉这些东西，我们只需执行mvn clean命令即可，清理掉后target目录也就消失了 （3）如果我们要执行测试包中的测试程序，我们只需执行mvn test命令即可 此时在看target目录会多一些东西 其中产生的test-classes就是测试代码的字节码文件，surefire-reports是它产生的测试报告 （4）使用mvn package命令进行打包，如下 在生成的target目录中可以看到打包的结果 当然，如果仔细看DOS窗口输出的我们会发现，mvn package命令的时候maven会把前面两个命令mvn compile,mvn test都执行一遍 （5）使用mvn install命令进行安装，将项目打好的包存入本地仓库 仔细查看输出会发现mvn install命令执行的时候也会将前面的命令都执行一遍 此时我们可以去本地仓库中查找，如何查找？这个很重要 maven是按照groupId/artifactId/version的结构在本地仓库进行存储 前面我们是通过手动的方式创建的maven项目，相对来说比较的麻烦，maven本身也是这样觉得的，因此maven本身就给我们提供了相关的插件来帮助我们快速构建项目，当然这是一些命令： 这些命令不用记，因为实际操作的时候也用不着，因为实际开发的时候我们基本都是用过一些IDE工具来进行项目开发，这些IDE工具基本都集成了Maven，我们操作起来非常简单。 1.5.2. 4.2 IDEA工具搭建maven项目 前面学习的基本都是通过命令来构建和管理项目，但是这在实际开发过程中基本不常用，常用的是通过相关IDE工具来进行项目的构建和管理，因此我们使用IDEA工具进行maven项目的搭建 需要注意的是：Maven和IDEA在版本上存在一些兼容性问题，因为要合理的选择Maven和IDEA的版本，本课程中提供安装maven-3.6.1版本是可用的 4.2.1 不使用原型创建项目 （1）在IDEA中配置Maven （2）创建maven工程 （3）填写本项目的坐标 （4）查看各目录颜色标记是否正确 （5）IDEA右侧有一个maven管理界面，可点开查看 （6）在项目的pom.xml文件中添加项目资源依赖 junit junit 4.12 （7）创建源代码：com.itheima.Demo package com.itheima; /** * Created by 传智播客*黑马程序员. */ public class Demo{ public String say(String name){ System.out.println(\"hello \"+name); return \"hello \"+name; } } （8）创建测试代码：com.itheima.DemoTest package com.itheima; import org.junit.Assert; import org.junit.Test; /** * Created by 传智播客*黑马程序员. */ public class DemoTest{ @Test public void testSay(){ Demo d = new Demo(); String ret = d.say(\"maven\"); Assert.assertEquals(\"hello maven\",ret); } } 然后可以进行测试运行 运行的时候可以编辑运行模板： 然后点击运行： 4.2.2 使用原型创建项目 首先我们来看普通的java工程如何创建： （1）创建maven项目的时候选择使用原型骨架 （2）创建完成后发现通过这种方式缺少一些目录，如下图 我们需要手动去补全目录，并且要对补全的目录进行标记，切记 然后我们在来看web工程如何创建： （1）选择web对应的原型骨架 有很多的webapp原型骨架，选择哪个基本都差不多，包括前面创建普通项目也是一样，quickstart原型也有很多 （2）和前面创建普通项目一样，通过原型创建web项目得到的目录结构是不全的，因此需要我们自行补全，同时要标记正确，最终需要得到如下结构 （3）web工程创建好之后需要启动运行，需要使用一个tomcat插件来运行我们的项目，在pom.xml中添加插件的坐标即可，最终改好的pom.xml如下 4.0.0 com.itheima web01 1.0-SNAPSHOT war web01 Maven Webapp http://www.example.com UTF-8 1.8 1.8 junit junit 4.12 test web01 org.apache.tomcat.maven tomcat7-maven-plugin 2.1 （4）插件配置好后，在IDEA右侧maven-project操作面板上可以看到该插件，并且可以利用该插件启动项目 运行后该插件会给我们一个可运行地址： 如果我们想更换端口，只需要在pom.xml中配置该插件即可 org.apache.tomcat.maven tomcat7-maven-plugin 2.1 80 （5）同时为了运行方便我们也可以创建运行模板： 1.6. 5.Maven依赖管理 1.6.1. 5.1 依赖配置与依赖传递 依赖是指在当前项目中运行所需的jar，依赖配置的格式如下图 依赖传递： 依赖具有传递性，分两种 （1）直接依赖：在当前项目中通过依赖配置建立的依赖关系 （2）间接依赖：被依赖的资源如果依赖其他资源，则表明当前项目间接依赖其他资源 注意：直接依赖和间接依赖其实也是一个相对关系 依赖传递的冲突问题： 在依赖传递过程中产生了冲突，我们有三种优先法则 （1）路径优先：当依赖中出现相同资源时，层级越深，优先级越低，反之则越高 （2）声明优先：当资源在相同层级被依赖时，配置顺序靠前的覆盖靠后的 （3）特殊优先：当同级配置了相同资源的不同版本时，后配置的覆盖先配置的 可选依赖： 排除依赖： 1.6.2. 5.2 依赖范围 依赖的jar默认情况可以在任何地方可用，可以通过scope标签设定其作用范围 这里的范围主要是指以下三种范围 （1）主程序范围有效（src/main目录范围内） （2）测试程序范围内有效（src/test目录范围内） （3）是否参与打包（package指令范围内） 此外：scope标签的取值有四种：compile,test,provided,runtime 这四种取值与范围的对应情况如下： 依赖范围的传递性： 1.7. 6.Maven生命周期与插件 1.7.1. 6.1 生命周期 maven的构建生命周期描述的是一次构建过程经历了多少个事件 比如我们项目最常用的一套流程如下： 当然maven的生命周期不止这一套，总共分为3套，每套里面包含的事件如下 （1）clean：清理工作 pre-clean：执行一些在clean之前的工作 clean：移除上一次构建产生的所有文件 post-clean：执行一些在clean之后立刻完成的工作 （2）default：核心工作，例如编译，测试，打包，部署等 这里面的事件非常的多，如下图 对于default生命周期，每个事件在执行之前都会将之前的所有事件依次执行一遍 （3）site：产生报告，发布站点等 pre-site：执行一些在生成站点文档之前的工作 site：生成项目的站点文档 post-site：执行一些在生成站点文档之后完成的工作，为部署做准备 site-deploy：将生成的站点文档部署到特定的服务器上 1.7.2. 6.2 插件 前面我们讲了maven生命周期中的相关事件，那这些事件是谁来执行的呢？答案是maven的插件 插件： 插件与生命周期内的阶段绑定，在执行到对应生命周期时执行对应的插件 maven默认在各个生命周期上都绑定了预先设定的插件来完成相应功能 插件还可以完成一些自定义功能 插件的配置方式如下： 在maven官网中有对插件的介绍： http://maven.apache.org/plugins/index.html Copyright © MISIN 2022 | 豫ICP备2021006345号-1 all right reserved，powered by Gitbook该文件修订时间： 2020-06-22 01:14:32 "},"2.JavaWeb/2.HTML+CSS/JavaEE-Css+Nginx.html":{"url":"2.JavaWeb/2.HTML+CSS/JavaEE-Css+Nginx.html","title":"Java EE Css Nginx","keywords":"","body":"1. 1 CSS入门1.1. 1.1 初识CSS1.1.1. 1.1.1 概述1.1.2. 1.1.2 CSS的组成1.2. 1.2 入门案例1.3. 1.3 Chrome开发者工具1.4. 1.4 总结2. 2 基本语法2.1. 2.1 引入方式2.1.1. 2.1.1 内联样式2.1.2. 2.1.2 内部样式表2.1.3. 2.1.3 外部样式表2.2. 2.2 关于注释2.3. 2.3 关于选择器2.3.1. 2.2.1 基本选择器2.3.2. 2.2.2 属性选择器2.3.3. 2.2.3 伪类选择器2.4. 2.4 总结3. 3 CSS案例-头条页面3.1. 3.1 案例效果3.2. 3.2 案例分析3.2.1. 3.2.1 语义化标签3.2.2. 3.2.2 常见样式属性3.3. 3.3 使用技术3.4. 3.4 实现步骤4. 4 CSS案例-登录页面4.1. 4.1 案例效果4.2. 4.2 案例分析4.2.1. 4.2.1 Table标签4.2.2. 4.2.2 常见样式属性4.2.3. 4.2.3 盒子模型4.3. 4.3 使用技术4.4. 4.4 实现步骤5. 5 HTML案例-网站发布5.1. 5.1 案例效果5.2. 5.2 案例分析5.2.1. 5.2.1 Nginx服务器概述5.2.2. 5.2.2 在Linux上使用Nginx5.3. 5.3 实现步骤5.4. 5.4 操作实现5.4.1. 5.4.1 发布项目5.4.2. 5.4.2 配置 nginx.conf 文件5.4.3. 5.4.3 启动服务器5.4.4. 5.4.4 浏览器访问前端入门——CSS 1. 1 CSS入门 1.1. 1.1 初识CSS 1.1.1. 1.1.1 概述 在学习了基本HTML标签和样式后，接下来学习前端开发的第二门技术。 我们发现，虽然标签的属性可以调整一些样式，但是效果不够理想，而我们更愿意把样式编写在 标签中，让页面设计更美观更丰富，实际上，这是通过CSS实现的。那么什么是CSS呢？ 如果说，HTML是网页的\"素颜\"，那么CSS就是页面的\"美妆师\"，它就是让网页的外观更漂亮！ CSS (层叠样式表——Cascading Style Sheets，缩写为 CSS），简单的说，它是用于设置和布局网页的计算机语言。会告知浏览器如何渲染页面元素。例如，调整内容的字体，颜色，大小等样式，设置边框的样式，调整模块的间距等。 所谓层叠 : 是指样式表允许以多种方式规定样式信息。可以规定在单个元素中，可以在页面头元素中，也可以在另一个CSS文件中，规定的方式会有次序的差别（讲解引入时说明）。 所谓样式：是指丰富的样式外观。拿边框距离来说，允许任何设置边框，允许设置边框与框内元素的距离，允许设置边框与边框的距离等等。 CSS发展简史【了解】 CSS1：1994 年，Hkon Wium Lie 最初提出了 CSS 的想法，联合当时正在设计 Argo 的浏览器的Bert Bos，他们决定一起合作设计 CSS，于是创造了 CSS 的最初版本。1996 年 12 月，W3C 推出了 CSS 规范的第一版本。 CSS2：1998 年，W3C 发布了 CSS 的第二个版本，目前的主流浏览器都采用这标准。CSS2 的规范是基于 CSS1 设计的，包含了 CSS1 所有的功能，并扩充和改进了很多更加强大的属性。 CSS3：2005 年 12 月，W3C 开始 CSS3 标准的制定，并遵循模块化开发，所以没有固定的发布时间，而是一段时间发布一些特性模块。 图片了解资料： https://www.cnblogs.com/LO-ME/p/3651140.html 1.1.2. 1.1.2 CSS的组成 CSS是一门基于规则的语言 — 你能定义用于你的网页中特定元素的一组样式规则。这里面提到了两个概念，一是特定元素，二是样式规则。对应CSS的语法，也就是选择器（selects）和声明（eclarations）。 选择器：指定将要添加样式的 HTML元素的方式。可以使用标签名，class值，id值等多种方式。 声明：形式为属性(property):值(value)，用于设置特定元素的属性信息。 属性：指示文体特征，例如font-size，width，background-color。 值：每个指定的属性都有一个值，该值指示您如何更改这些样式。 格式： 选择器 { 属性名:属性值; 属性名:属性值; 属性名:属性值; } 举例： h1 { color: red; font-size: 5px; } 视频老师了解资料 格式简介：语法由一个 选择器(selector)起头。 它 选择(selects) 了我们将要用来添加样式的 HTML元素。 在这个例子中我们为一级标题添加样式。 接着输入一对大括号{ }。 在大括号内部定义一个或多个形式为 属性(property):值(value); 的 声明(eclarations)。每个声明都指定了我们所选择元素的一个属性，之后跟一个我们想赋给这个属性的值。 冒号之前是属性，冒号之后是值。不同的CSS 属性(properties) 对应不同的合法值。在这个例子中，我们指定了 color 属性，它可以接受许多 颜色值(lor values)。 还有 font-size 属性， 它可以接收许多 size units 值。 1.2. 1.2 入门案例 在初始页面的标签中，加入一对 标签。标签规定的固定的标题样式。 页面标题 今天开始变漂亮!!! 在标签中加入一对 标签中，表示准备应用样式。 页面标题 今天开始变漂亮!!! 编写样式 h1{ color: red; /* 设置颜色为红色*/ font-size:100px; /* 设置字体大小为100像素*/ } 打开浏览器查看，文字的颜色和大小都发生改变，应用了新的样式，效果如图： 1.3. 1.3 Chrome开发者工具 打开开发者工具 打开浏览器，点击键盘F12键，显示开发者工具窗口。 查看开发者工具 演示选择元素 演示修改样式 1.4. 1.4 总结 CSS是对HTML的补充，指定页面如何展示的语言。 CSS的主要部分有： 选择器：用来选择页面元素的方式。 声明：用来设置样式，格式属性名：值。 在学习CSS时，要抓住两个方面： 掌握多种选择器，能够灵活的选择页面元素。 掌握样式的声明，能够使用多种属性来设置多样的效果。 2. 2 基本语法 2.1. 2.1 引入方式 2.1.1. 2.1.1 内联样式 了解,几乎不用,维护艰难 内联样式是CSS声明在元素的style属性中，仅影响一个元素： 格式： 内容 举例： Hello World! 效果如下： 虽然格式简单，但是样式作用无法复用到多个元素上，不利于维护，此格式了解即可。 2.1.2. 2.1.2 内部样式表 内部样式表是将CSS样式放在style标签中，通常style标签编写在HTML 的head标签内部。 格式： 选择器 { 属性名: 属性值; 属性名: 属性值; } 举例： h1 { color: blue; background-color: yellow; border: 1px solid black; } 效果如下： 内部样式只能作用在当前页面上，如果是多个页面，就无法复用了。 2.1.3. 2.1.3 外部样式表 外部样式表是CSS附加到文档中的最常见和最有用的方法，因为您可以将CSS文件链接到多个页面，从而允许您使用相同的样式表设置所有页面的样式。 外部样式表是指将CSS编写在扩展名为.css 的单独文件中，并从HTML 元素引用它，通常link标签编写在HTML 的head标签内部。： 格式： rel：表示“关系 (relationship) ”，属性值指链接方式与包含它的文档之间的关系，引入css文件固定值为stylesheet。 href：属性需要引用某文件系统中的一个文件。 举例： 创建styles.css文件 h1 { color: blue; background-color: yellow; border: 1px solid black; } link标签引入文件 Hello World! 效果如下： 当然也可以把CSS文件放在其他地方，并调整指定的路径以匹配，例如： 为了保证CSS文件的管理，建议在项目中创建一个css文件夹，专门保存样式文件。 注意：引入样式的优先级问题。 规则层叠于一个样式表中，其中数字 4 拥有最高的优先权： 浏览器缺省设置 外部样式表 内部样式表（位于 标签内部） 内联样式（在 HTML 元素内部） 2.2. 2.2 关于注释 了解讲解： 简单格式，提一下就可以了 与HTML一样，鼓励您在CSS中进行注释，以帮助您理解几个月后返回的代码工作方式，并帮助其他使用该代码的人对其进行理解。 CSS中的注释以/*和开头*/。在下面的代码块中，我已使用注释标记了不同的不同代码段的开始。 格式： /* 设置h1的样式 */ h1 { color: blue; background-color: yellow; border: 1px solid black; } 2.3. 2.3 关于选择器 重点讲解： 选择器作为CSS的重要部分，这里强调基本选择器的使用和其他选择器的基本格式。 讲到CSS就不得不说到选择器，为了样式化某些元素，我们会通过选择器来选中HTML文档中的这些元素。如果你的样式没有生效，那很可能是你的选择器没有像你想象的那样选中你想要的元素。 每个CSS规则都以一个选择器或一组选择器为开始，去告诉浏览器这些规则应该应用到哪些元素上。 接下来我们将要详细的学习各种选择器的使用。 选择器的分类： 分类 名称 符号 作用 示例 基本选择器 元素选择器 标签名 基于标签名匹配元素 div{ } 类选择器 . 基于class属性值匹配元素 .center{ } ID选择器 # 基于id属性值匹配元素 #username{ } 属性选择器 属性选择器 [] 基于某属性匹配元素 [type]{ } 伪类选择器 伪类选择器 : 用于向某些选择器添加特殊的效果 a : hover{ } 组合选择器 后代选择器 空格 使用空格符号结合两个选择器，基于第一个选择器，匹配第二个选择器的所有后代元素 .top li{ } 子级选择器 > 使用 > 结合两个选择器，基于第一个选择器，匹配第二个选择器的直接子级元素 .top > li{ } 同级选择器 ~ 使用 ~ 结合两个选择器，基于第一个选择器，匹配第二个选择器的所有兄弟元素 .l1 ~ li{ } 相邻选择器 + 使用 + 结合两个选择器，基于第一个选择器，匹配第二个选择器的相邻兄弟元素 .l1 + li{ } 通用选择器 * 匹配文档中的所有内容 *{ } 2.3.1. 2.2.1 基本选择器 1）元素选择器 页面元素： List item 1 List item 2 List item 3 List item 1 List item 2 List item 3 选择器： 选择所有li标签,背景变成蓝色 li{ background-color: aqua; } 2）类选择器 页面元素： List item 1 List item 2 List item 3 List item 1 List item 2 List item 3 选择器： 选择class属性值为l2的,背景变成蓝色 .l2{ background-color: aqua; } 选择class属性值为olist l2的,字体为白色 .olist.l2{ color: wheat; } 3）ID选择器 页面元素： List item 1 List item 2 List item 3 List item 1 List item 2 List item 3 选择器： #tow{ background-color: aqua; } 效果如图： 4）通用选择器 页面元素： List item 1 List item 2 List item 3 List item 1 List item 2 List item 3 选择器： 所有标签 *{ background-color: aqua; } 2.3.2. 2.2.2 属性选择器 页面元素： List item 1 List item 2 List item 3 List item 1 List item 2 List item 3 p item 选择器和效果图，示例1 [属性名]{ } 选择器和效果图，示例2 标签名[属性名]{ } 选择器和效果图，示例3 标签名[属性名='属性值']{ } 2.3.3. 2.2.3 伪类选择器 伪类选择器，用于选择处于特定状态的元素，例如，一些元素中的第一个元素，或者某个元素被鼠标指针悬停。 格式： 标签名:伪类名{ } 常用伪类: 锚伪类 在支持 CSS 的浏览器中，链接的不同状态都可以以不同的方式显示 a:link {color:#FF0000;} /* 未访问的链接 */ a:visited {color:#00FF00;} /* 已访问的链接 */ a:hover {color:#FF00FF;} /* 鼠标悬停链接 */ a:active {color:#0000FF;} /* 已选中的链接 */ 注意： 伪类顺序 link ，visited，hover，active，否则有可能失效。 代码示例： ```html HTML 代码 ： 黑马 传智 CSS 代码 ： / 选择a标签,class值为red ,设置访问后为红色链接/ a.red:visited { color: red; } ### 2.2.4 组合选择器 **页面元素：** ```html List item 1 List item 2 List item 3 List item 1 List item 2 List item 3 1）后代选择器 选择器： .l1 li{ background-color: aqua; } 2）子级选择器 选择器： .l1 > li{ background-color: aqua; } 3）同级选择器 选择器： .l1 ~ li{ background-color: aqua; } 4）相邻选择器 选择器： .l1 + li{ background-color: aqua; } 2.4. 2.4 总结 CSS的引入方式有三种，建议使用外部样式表。 注释类似于java多行注释。 选择器是CSS的重要部分： 基本选择器：可以通过元素，类，id来选择元素。 属性选择器：可以通过属性值选择元素 伪类选择器：可以指定元素的某种状态，比如链接 组合选择器：可以组合基本选择器，更加精细的划分如何选择 3. 3 CSS案例-头条页面 3.1. 3.1 案例效果 3.2. 3.2 案例分析 3.2.1. 3.2.1 语义化标签 了解讲解： 简单介绍作用即可，后续在案例中使用。 为了更好的组织文档，HTML5规范中设计了几个语义元素，可以将特殊含义传达给浏览器。 标签 名称 作用 备注 header 标头元素 表示内容的介绍 块元素，文档中可以定义多个 nav 导航元素 表示导航链接 常见于网站的菜单，目录和索引等，可以嵌套在header中 article 文章元素 表示独立内容区域 标签定义的内容本身必须是有意义且必须独立于文档的其他部分 footer 页脚元素 表示页面的底部 块元素，文档中可以定义多个 标签结构示例如图： 3.2.2. 3.2.2 常见样式属性 其他属性： 分类 属性名 作用 边框 border 边框 border-top 底部边框 border-radius 设置边框圆角 文本 color 颜色 font-family 字体样式 font-size 字体大小 text-decoration 下划线 text-align 文本水平对齐 line-height 行高，行间距 vertical-align 文本垂直对齐 1）边框样式 在之前学习了简写属性来设置边框样式，接下来我们将研究如何创造性地使用边框。 div { border: 1px solid black; } 单个边框 设置一个方向边框的宽度、样式和颜色，例如： .box { border-top: 1px solid black; border-left: 5px double yellow; border-bottom: 5px dotted green; border-right: 5px dashed red; } border-top: 上边框 border-left: 左边框 border-bottom: 底边框 border-right: 右边框 无边框 当border值为none时，可以让边框不显示，用于特殊效果。 div { width: 200px; height: 200px; border: none; } 圆角 通过使用border-radius属性设置盒子的圆角，虽然能分别设置四个角，但是通常我们使用一个值，来设置整体效果，例如 div { width: 200px; height: 200px; border: 10px solid blue; border-radius: 50px; } 2）文本样式 颜色 该color属性设置所选元素的前景色的颜色 p { color: red; } 颜色的值，可以由多种方式赋值，常见的有颜色单词，RGB十六进制，例如： 字体种类 使用font-family属性-这允许您指定一种字体 字体大小 字体大小使用font-size属性设置，可以采用常见单位： px：像素，文本高度像素绝对数值。 em：1em等于我们要设置样式的当前元素的父元素上设置的字体大小，这是相对数值，能看懂即可。 文本修饰 text-decoration:设置字体上的文本装饰线。 文本对齐 该text-align属性用于控制文本如何在其包含的内容框中对齐。可用值如下，它们的工作方式与常规字处理器应用程序中的工作方式几乎相同： left：左对齐文本。 right：右对齐文本。 center：使文本居中。 justify：使文本散布，改变单词之间的间距，以使文本的所有行都具有相同的宽度。 行高 该line-height属性设置每行文本的高度，也就是行距。 3.3. 3.3 使用技术 使用语义化标签，header，footer，article，nav。 使用CSS常见属性 3.4. 3.4 实现步骤 创建初始页面，拷贝图片素材。 编写css文件，引入css样式，实现整体布局。 header部分 实现顶部条。 实现导航条。 实现中部 实现左侧分享区域。 实现中间正文区域。 实现右侧广告区域。 实现底部页脚。 4. 4 CSS案例-登录页面 4.1. 4.1 案例效果 4.2. 4.2 案例分析 4.2.1. 4.2.1 Table标签 1）什么是表格 表格是由行和列组成的结构化数据集(表格数据)。 2）表格标签 标签名 作用 备注 table 表示表格，是数据单元的行和列的两维表 容器，默认无样式 tr table row，表示表中单元的行 td table data，表示表中一个单元格 th table header，表格单元格的表头，通常字体样式加粗居中 通过表格标签，我们可以创建出一张表格，代码如下 First name Last name John Doe Jane Doe 3）跨行跨列======== 让我们使用 colspan 和 rowspan 来改进现有的表格。 GROUP name First name Last name G1 John Doe Jane Doe G2 Aohn Doa Bane Dob Cane Doc 4）表格结构【了解】 了解讲解： 表格布局标签，作为了解内容，案例中的使用部分，可以省略 标签名 作用 备注 thead 定义表格的列头的行 一个表格中仅有一个 tbody 定义表格的主体 用来封装一组表行（tr元素） tfoot 定义表格的各列汇总行 一个表格中仅有一个 示例： 项目 金额 手机 3,000 电脑 18,000 4.2.2. 4.2.2 常见样式属性 1）背景 CSS background属性用来设置背景相关的样式。 背景色 该background-color属性定义CSS中任何元素的背景色。 .box { background-color: #567895; } 背景图 该background-image属性允许在元素的背景中显示图像。使用url函数指定图片路径。 body { background-image: url(bg.jpg); } 控制背景重复 该background-repeat属性用于控制图像的平铺行为。可用值为： no-repeat -停止完全重复背景。 repeat-x —水平重复。 repeat-y —反复重复。 repeat—默认值；双向重复。 body { background-image: url(star.png); background-repeat: no-repeat; } 2）轮廓 轮廓outline：是绘制于元素周围的一条线，位于边框边缘的外围，可起到突出元素的作用。 input { outline: dotted; } 设置为none时，可以取消默认轮廓样式，用于特殊效果。 input { outline: none; } 3）显示 display属性，用来设置一个元素应如何显示。可以设置块级和行内元素的切换，也可以设置元素隐藏。 元素显示 /* 把列表项显示为内联元素，无长宽*/ li {display:inline;} /* 把span元素作为块元素，有换行*/ span {display:block;} /* 行内块元素，结合的行内和块级的优点，既可以行内显示，又可以设置长宽，*/ li {display:inline-block;} 代码演示： li { display: inline-block; width: 200px; } 元素隐藏 当设置为none时，可以隐藏元素。 li { display: none; } 4.2.3. 4.2.3 盒子模型 万物皆\"盒子\"。盒子模型是通过设置元素框与元素内容和外部元素的边距，而进行布局的方式。 - element : 元素。 - padding : 内边距，也有资料将其翻译为填充。 - border : 边框。 - margin : 外边距，也有资料将其翻译为空白或空白边。 基本布局 内边距、边框和外边距都是可选的，默认值是零。但是，许多元素将由用户代理样式表设置外边距和内边距。在 CSS 中，width 和 height 指的是内容区域的宽度和高度。 div{ border: 2px solid blue; } .big{ width: 200px; height: 200px; } .small{ width: 100px; height: 100px; margin: 30px;/* 外边距 */ } 增加内边距会增加元素框的总尺寸。 div{ border: 2px solid blue; } .big{ width: 200px; height: 200px; padding: 30px;/*内边距 */ } .small{ width: 100px; height: 100px; } 外边距 单独设置边框的外边距，设置上、右、下、左方向： margin-top margin-right margin-bottom margin-left 值含义： 一个值时 /* 所有 4 个外边距都是 10px */ margin:10px; 两个值时 /* 上外边距和下外边距是 10px 右外边距和左外边距是 5px */ margin:10px 5px; margin:10px auto; auto 浏览器自动计算外边距，具有居中效果。 三个值时 /* 上外边距是 10px 右外边距和左外边距是 5px 下外边距是 15px*/ margin:10px 5px 15px; 四个值时 /*上外边距是 10px 右外边距是 5px 下外边距是 15px 左外边距是 20px*/ margin:10px 5px 15px 20px; 内边距 与外边距类似，单独设置边框的内边距，设置上、右、下、左方向： padding-top padding-right padding-bottom padding-left 4.3. 4.3 使用技术 div盒子布局 form标签和table标签 input button thead， tbody ，tfoot，th，tr，td 设置背景，字体等css样式 4.4. 4.4 实现步骤 设置背景 整体布局，上中底三部分 上部 logo设置 中部 表单表格布局 加入表头 加入输入框 加入按钮 底部 底部布局 其他方式分割线 其他方式图片 底部文本 5. 5 HTML案例-网站发布 将网站部署到服务器，浏览器通过URL地址访问页面 5.1. 5.1 案例效果 在地址栏输入URL地址，访问服务器上的页面。 5.2. 5.2 案例分析 5.2.1. 5.2.1 Nginx服务器概述 Nginx是一种服务器软件，其最主要，最基本的功能是可以与服务器硬件(电脑)结合，让程序员可以将程序发布在Nginx服务器上，让成千上万的用户可以浏览。 ​ 除此之外，Nginx还是一种高性能的HTTP和反向代理服务器，同时也是一个代理邮件服务器。也就是说，我们在Nginx上可以： 可以发布网站(静态, html,css,js) 可以实现负载均衡, 代理服务器 可以作为邮件服务器实现收发邮件等功能 本课程我们只讨论Nginx发布网站的功能，其它的功能后续课程会深入学习. 5.2.2. 5.2.2 在Linux上使用Nginx 1）下载Nginx 进入http://nginx.org/网站，下载nginx-1.17.5.tar.gz文件 2）上传到虚拟机 使用客户端将刚下载好的nginx-1.17.5.tar.gz文件上传到home目录下。 使用命令查看 3）准备依赖环境 #安装Nginx依赖环境，‐y表示所有提示默认选择y yum -y install pcre pcre-devel yum ‐y install zlib zlib‐devel yum ‐y install openssl openssl‐devel 4）解压和编译安装 # 进入home目录,解压 tar -zxvf nginx-1.17.5.tar.gz -C /home # 进入 nginx目录 cd nginx-1.17.5 # 编译并安装【已经有gcc编译环境】 ./configure make make install # 安装成功之后,就会在/usr/local下多出了一个nginx目录. 5）启动服务器 #进入nginx的sbin目录 cd /usr/local/nginx/sbin #在sbin目录下启动 ./nginx #在sbin目录下停止 ./nginx ‐s stop #在sbin目录下重写加载 ./nginx ‐s reload #开放linux的对外访问的端口80，在默认情况下，Linux不会开放80端口号 #需要编辑iptables文件,参考 4.5 操作 #查看是否有nginx的线程是否存在 ps ‐ef | grep nginx 6）浏览器访问 浏览器输入虚拟机ip地址，默认80端口 5.3. 5.3 实现步骤 发布项目 配置Nginx服务器 浏览器访问 5.4. 5.4 操作实现 5.4.1. 5.4.1 发布项目 在/home目录下，创建toutiao目录 # 进入home目录 cd /home # 创建目录 mkdir toutiao 上传项目文件到toutiao目录 项目文件: toutiao目录: 5.4.2. 5.4.2 配置 nginx.conf 文件 5.4.3. 5.4.3 启动服务器 #启动服务器 ， 加载配置文件 /usr/local/nginx/sbin/nginx -c /home/nginx-1.17.5/conf/nginx.conf 5.4.4. 5.4.4 浏览器访问 浏览器输入虚拟机ip地址，默认80端口，访问首页 index.html 跳转登录页面 http://172.16.17.99/login/login.html Copyright © MISIN 2022 | 豫ICP备2021006345号-1 all right reserved，powered by Gitbook该文件修订时间： 2022-11-10 10:41:12 "},"2.JavaWeb/2.HTML+CSS/JavaEE-HTML.html":{"url":"2.JavaWeb/2.HTML+CSS/JavaEE-HTML.html","title":"Java EE HTML","keywords":"","body":"1. JavaEE-v4.0-HTML-授课2. 1 HTML入门2.1. 1.1 初识HTML2.1.1. 1.1.1 概述2.1.2. 1.1.2 HTML的组成2.2. 1.2 入门案例2.2.1. 1.2.1 初始页面2.2.2. 1.2.2 案例实现2.3. 1.3 总结3. 2 基本语法3.1. 2.1 关于注释3.2. 2.2 关于标签3.2.1. 2.2.1 空元素3.2.2. 2.2.2 嵌套元素3.2.3. 2.2.3 块级和行内3.3. 2.3 关于属性3.4. 2.4 特殊字符3.5. 2.5 总结4. 3 HTML案例-新闻文本4.1. 3.1 案例效果4.2. 3.2 案例分析4.2.1. 3.2.1 div样式布局4.2.2. 3.2.2 文本标签4.3. 3.3 使用标签4.4. 3.4 实现步骤5. 4 HTML案例-头条页面5.1. 4.1 案例效果5.2. 4.2 案例分析5.2.1. 4.2.1 div布局的进阶5.2.2. 4.2.2 设置背景5.2.3. 4.2.3 图片标签5.2.4. 4.2.4 超链接5.3. 4.3 使用标签5.4. 4.4 实现步骤5.4.1. 4.5.2 实现顶部条5.4.2. 4.5.3 实现导航条5.4.3. 4.5.4 实现左部分享5.4.4. 4.5.5 实现中部正文5.4.5. 4.5.6 实现右侧广告5.4.6. 4.5.7 实现底部页脚6. 5 HTML案例-登录页面6.1. 5.1 案例效果6.2. 5.2 案例分析6.2.1. 5.2.1 表单标签6.2.2. 5.2.2 表单元素入门6.2.3. 5.2.3 关于属性值6.2.4. 5.2.4 更多表单元素6.3. 5.3 使用标签6.4. 5.4 实现步骤1. JavaEE-v4.0-HTML-授课 2. 1 HTML入门 2.1. 1.1 初识HTML 2.1.1. 1.1.1 概述 网络世界已经跟我们息息相关，当我们打开一个网站，首先映入眼帘的就是一个个华丽多彩的网页。这些网页，不仅呈现着基本的内容，还具备优雅的布局和丰富的动态效果，这一切都是如何做到的呢？前端入门课程，为您一层层的揭开网页的面纱。 网页的构成 HTML：通常用来定义网页内容的含义和基本结构。 CSS：通常用来描述网页的表现与展示效果。 JavaScript：通常用来执行网页的功能与行为。 HTML（超文本标记语言——HyperText Markup Language）是构成 Web 世界的一砖一瓦。它是一种用来告知浏览器如何组织页面的标记语言。 所谓超文本Hypertext，是指连接单个或者多个网站间的网页的链接。我们通过链接，就能访问互联网中的内容。 所谓标记Markup ，是用来注明文本，图片等内容，以便于在浏览器中显示，例如,等。 HTML发展简史【了解】 HTML 1.0在1993年6月作为互联网工程工作小组（IETF）工作草案发布（并非标准） HTML 2.0——1995年11月作为RFC 1866发布，在RFC 2854于2000年6月发布之后被宣布已经过时 HTML 3.2——1997年1月14日，W3C推荐标准 HTML 4.0——1997年12月18日，W3C推荐标准 HTML 4.01（微小改进）——1999年12月24日，W3C推荐标准 HTML5 —— 2014年10月29日，万维网联盟宣布，经过接近8年的艰苦努力，该标准规范终于制定完成。是目前最为流行的版本，提供了很多标签新特性，现代大多数浏览器已经具备了 HTML5的支持。 扩展资料： w3c是万维网联盟（World Wide Web Consortium，W3C），又称W3C理事会。1994年10月在麻省理工学院计算机科学实验室成立。建立者是万维网的发明者蒂姆·伯纳斯-李，负责制定web相关标准的制定。 2.1.2. 1.1.2 HTML的组成 HTML页面由一系列的元素（elements） 组成，而元素是使用标签创建的。 1）标签 一对标签（ tags）可以设置一段文字样式，添加一张图片或者添加超链接等等。 例如： 今天是个好日子 在HTML中，标签表示标题，那么，我们可以使用开始标签和结束标签包围文本内容，这样其中的内容就以标题的形式显示了。 显示效果如下： 2）属性 HTML标签可以拥有属性。属性提供了有关 HTML 元素的更多的信息。我们只能在开始标签中，加入属性。通常以名称=值成对的形式出现，比如：name='value'。例如： 今天是个好日子!!! 在HTML标签中，align 属性表示水平对齐方式，我们可以赋值为 center 表示 居中 。 显示效果如下： 2.2. 1.2 入门案例 2.2.1. 1.2.1 初始页面 1）创建一个标准的初始化页面 右键点击创建新页面 自定义文件名字，比如index 点击ok，页面创建成功。 2）页面说明 : 声明文档类型。规定了HTML页面必须遵从的良好规则，从HTML5后，是最短的有效的文档声明。 文字作为了解资料 很久以前，早期的HTML(大约1991年2月)，文档类型声明类似于链接，能自动检测错误和其他有用的东西。使用如下： 然而现在没有人再这样写，需要保证每一个东西都正常工作已成为历史。 ：这个标签包裹了整个完整的页面，是一个根元素（顶级元素）。其他所有元素必须是此元素的后代，每篇HTML文档只有一个根元素。 ：这个标签是一个容器，它包含了所有你想包含在HTML页面中但不想在HTML页面中显示的内容。这些内容包括你想在搜索结果中出现的关键字和页面描述，CSS样式，字符集声明等等。以后的章节能学到更多关于 元素的内容。目前主要了解两个标签： ：这个标签是页面的元数据信息，设置文档使用utf-8字符集编码，utf-8字符集包含了人类大部分的文字。基本上他能识别你放上去的所有文本内容，能够避免页面乱码问题。 ：这个标签定义文档标题，位置出现在浏览器标签上，而不是页面正文中。在收藏页面时，它可用来描述页面。 ：包含了文档内容，你访问页面时所有显示在页面上的文本，图片，音频，游戏等等。 2.2.2. 1.2.2 案例实现 在初始化页面的标签中，加入一对 标签。标签表示文本的一个段落，具有整段文本之间相分离的效果。 页面标题 在一对 标签中，编写文本内容。 页面标题 这是第一个页面 打开浏览器查看，效果如下： 2.3. 1.3 总结 HTML是一种标记语言，用来组织页面，使用元素和属性。 这个元素的主要部分有： 元素（Element）：开始标签、结束标签与内容相结合，便是一个完整的元素。 开始标签（Opening tag）：包含元素的名称（本例为 p），被左、右角括号所包围。表示元素从这里开始或者开始起作用 —— 在本例中即段落由此开始。 结束标签（Closing tag）：与开始标签相似，只是其在元素名之前包含了一个斜杠。这表示着元素的结尾 —— 在本例中即段落在此结束。初学者常常会犯忘记包含结束标签的错误，这可能会产生一些奇怪的结果。 内容（Content）：元素的内容，本例中就是所输入的文本本身。 属性（Attribute）：标签的附加信息。 在学习HTML时，要抓住两个方面： 掌握标签所代表的含义。 掌握在标签中加入的属性的含义。 3. 2 基本语法 3.1. 2.1 关于注释 如同大部分的编程语言一样，在HTML中有一种可用的机制来在代码中书写注释。 为了将一段HTML中的内容置为注释，你需要将其用特殊的记号包括起来， 比如： 我在注释外！ 我在注释内！ --> 3.2. 2.2 关于标签 3.2.1. 2.2.1 空元素 不是所有元素都拥有开始标签，内容和结束标记。一些元素只有一个标签，叫做空元素。它是在开始标签中进行关闭的。例子如下： 第一行文档 第二行文档 3.2.2. 2.2.2 嵌套元素 你也可以把元素放到其它元素之中——这被称作嵌套。比如，我们想要强调第一个，可以将标签包围第一个，这样b标签就是嵌套在了p标签中： 这是第一个页面 3.2.3. 2.2.3 块级和行内 1）概念 在HTML中有两种重要元素类别，块级元素和内联元素。 块级元素： 独占一行。块级元素（block）在页面中以块的形式展现。相对于其前面的内容它会出现在新的一行，其后的内容也会被挤到下一行展现。比如 ，， ，等。 行内元素 行内显示。行内元素不会导致换行。通常出现在块级元素中并环绕文档内容的一小部分，而不是一整个段落或者一组内容。比如，，， 等。 注意：一个块级元素不会被嵌套进内联元素中，但可以嵌套在其它块级元素中。 2）div和span 是一个通用的内容容器，并没有任何特殊语义。它可以被用来对其它元素进行分组，一般用于样式化相关的需求。它是一个块级元素。 是短语内容的通用行内容器，并没有任何特殊语义。它可以被用来编组元素以达到某种样式。它是一个行内元素。 注意：div和span在页面布局中有重要作用。 3.3. 2.3 关于属性 【重点讲解】 属性作为HTML的重要部分，这里强调属性的格式和作用。 标签属性，主要用于拓展标签。属性包含元素的额外信息，这些信息不会出现在实际的内容中。但是可以改变标签的一些行为或者提供数据，属性总是以name = value的格式展现。 属性名：同一个标签中，属性名不得重复。 大小写：属性和属性值对大小写不敏感。不过W3C标准中，推荐使用小写的属性/属性值。 引号：双引号是最常用的，不过使用单引号也没有问题。 常用属性： | 属性名 | 作用 | | ------ | ------------------------------------------------------------ | | class | 定义元素类名，用来选择和访问特定的元素 | | id | 定义元素唯一标识符，在整个文档中必须是唯一的 | | name | 定义元素名称，可以用于提交服务器的表单字段 | | value | 定义在元素内显示的默认值 | | style | 定义CSS样式，这些样式会覆盖之前设置的样式（第一天简单了解，第二天主要内容） | 3.4. 2.4 特殊字符 了解讲解： 内容简单，迅速带过。 在HTML中，字符 , >,\",' 和 & 是特殊字符. 它们是HTML语法自身的一部分, 那么你如何将这些字符包含进你的文本中呢 原义字符 等价字符引用 &lt; > &gt; \" &quot; ' &apos; & &amp; 空格 &nbsp; 3.5. 2.5 总结 HTML的基本语法比较简单，在使用的过程中注意写法即可。 4. 3 HTML案例-新闻文本 重点讲解： div布局的基本方式 文本标签的基本使用 文本结构的页面基本是由标题和段落构成的，内容结构化会使读者的阅读体验更轻松。 4.1. 3.1 案例效果 显示新闻文本。 4.2. 3.2 案例分析 4.2.1. 3.2.1 div样式布局 文本由几部分构成，我们可以使用div将页面分割布局。先来了解一下，使用div如何进行简单的布局。 在head标签中，通过style标签加入样式。 基本格式： 格式: 标签名{ 属性名:属性值; } 多个属性名格式： 标签名{ 属性名1:属性值1; 属性名2:属性值2; 属性名3:属性值3; } 效果如下： div的多样式： 一个属性名可以含有多个值，同时设置多样式。 格式: 标签名{ 属性名:属性值1 属性值2 属性值3; } 【提示】 为了布局方便，我们通常可以先设置边框的样式，进行布局。结束后，再去掉边框，直观展示完整界面。 4.2.2. 3.2.2 文本标签 使用文本内容标签设置文字基本样式。 标签名 作用 p 表示文本的一个段落 h 表示文档标题，– ，呈现了六个不同的级别的标题， 级别最高，而 级别最低 hr 表示段落级元素之间的主题转换，一般显示为水平线 li 表示列表里的条目。 ul 表示一个无序列表，可含多个元素，无编号显示。 ol 表示一个有序列表，通常渲染为有带编号的列表 em 表示文本着重，一般用斜体显示 strong 表示文本重要，一般用粗体显示 font 表示字体，可以设置样式（已过时） i 表示斜体 b 表示加粗文本 【建议】 文本标签，建议视频老师根据PPT，准备材料，简单演示即可。 重点演示li的不换行效果： li{ display: inline; // 内联样式,有宽度,无高度} li{ display: inline-block; // 内联样式,有宽度,有高度} 4.3. 3.3 使用标签 简单布局，使用div标签。 文本样式，使用基本文本标签。 4.4. 3.4 实现步骤 创建初始页面。 使用div标签划分区域（标题，作者，副标题，正文），设置div样式。 编辑正文。 使用h1标签加入标题。 使用em标签加入作者信息。 使用hr标签加入分割线。 使用h3标签加入副标题。 使用p标签加入正文。 使用ol标签，li标签加入列表信息。 使用strong标签，加入文字强调效果。 5. 4 HTML案例-头条页面 5.1. 4.1 案例效果 5.2. 4.2 案例分析 5.2.1. 4.2.1 div布局的进阶 想要将div布局成案例效果，首先需要对多个div进行区分，再分别设置每一个div自身的效果。 1）div的class值 首先编写三个div，设置边框样式 div{ border: 1px solid blue;} left center right 发现通过div设置的样式都是一致的，无法个性化布局。如何区分不同的div呢？ 使用class的值，格式： .class值{ 属性名:属性值; } 提示: class是自定义的值 所以，使用class属性值，可以帮助我们区分div，更加精确的设置标签的样式。 2）浮动布局和清除 主体部分分为三列，而div是独占一行的，所以想要使用div布局，就还需要加入浮动 属性。 概念 float：指定一个元素应沿其容器的左侧或右侧放置，允许文本或者内联元素环绕它，该元素从网页的正常流动中移除，其他部分保持正常文档流顺序。 格式： float：none；不浮动 float：left；左浮动 float：right；右浮动 clear：both；清除两侧浮动，此元素不再收浮动元素布局影响。 加入三部分div left center right 浮动布局 .left{ width: 20%; float: left; } .center{ width: 59%; float: left; } .right{ width: 20%; float: left; } 至此完成左中右三部分的布局。 加入footer 部分 .footer{ border: 5px solid blue; } footer 发现蓝色footer的div，延续正常文档流布局，摆放在navbar的下方，与浮动元素重叠。想要清除浮动影响，所以要设置清除浮动属性clear。 .footer{ border: 5px solid blue; clear: both; } footer 设置center 增加center 高度，完成基本的布局效果。 .center{ width: 59%; float: left; height: 600px; } 5.2.2. 4.2.2 设置背景 设置背景的格式： 背景色: background-color: black; 背景图: background-image: url(\"../img/bg.png\"); 请设置如下布局，效果如下 代码实现 div{ height: 666px; background-color: gray; } /*左侧分享*/ .left { width: 10%; float: left; } /*中间文本*/ .center { width: 80%;/*最后去除边框宽度恢复为60%*/ float: left; background-image: url(\"../img/star.gif\"); } /*右侧广告*/ .right { width: 10%; float: left; } 5.2.3. 4.2.3 图片标签 标签名 作用 备注 img 可以显示一张图片(本地或网络) src属性，这是一个必需的属性，表示图片的地址。 其他属性： 属性名 作用 备注 title 鼠标悬停（hover）时显示文本。 alt 图形不显示时的替换文本。 height 图像的高度。 width 图像的宽度。 5.2.4. 4.2.4 超链接 标签名 作用 备注 a 表示超链接。 href属性，表示超链接指向的URL地址。 属性名 作用 target 页面的打开方式(_self当前页 _blank新标签页)。 去掉下划线 根据某些样式的布局需求，去除下划线更为美观。 a { text-decoration:none; // none 表示不显示 } 5.3. 4.3 使用标签 使用div标签，设置布局，背景和浮动等。 基本文本标签 图片标签 超链接标签 5.4. 4.4 实现步骤 创建初始页面，拷贝图片等素材。 整体布局。 实现顶部条（图片）。 实现导航条（图片）。 实现左侧分享区域（图片）。 实现中间正文区域（文本+图片）。 实现右侧广告区域（图片）。 实现底部页脚（链接）。 5.4.1. 4.5.2 实现顶部条 HTML代码 样式代码 img{ width: 100%; } 效果如下： 5.4.2. 4.5.3 实现导航条 HTML代码 样式代码 hr { color: lightgrey; size: 1px; } 效果如下： 5.4.3. 4.5.4 实现左部分享 HTML代码 效果如下： 5.4.4. 4.5.5 实现中部正文 HTML代码 支付宝特权福利！芝麻分600以上用户惊喜，网友：幸福来得突然？ 作者 2019-11-11 11:11:11 支付宝特权福利！芝麻分600以上用户惊喜，网友：幸福来得突然？ 这些年，马云的风头正盛，但是上个月他毅然辞去了阿里巴巴的职务。而马云所做的很多事情也的确改变了这个世界，特别是在移动支付领域，更是走在了世界的前列。如今中国的移动支付已经成为老百姓的必备，支付宝对中国社会的变革都带来了深远的影响。不过马云依然没有满足，他认为移动互联网将会成为人类的基础设施，而且这里面的机会和各种挑战还非常多。 支付宝的诞生就是为了解决淘宝网的客户们的买卖问题，而随着支付宝的用户的不断增加，支付宝也推出了一系列的附加功能。比如生活缴费、转账汇款、还信用卡、 车主服务、公益理财等，往简单的说，支付宝既可以满足人们的日常生活，又可以利用芝麻信用进行资金周转服务。除了芝麻分能够进行周转以外，互联网信用体系 下的产品多多，我们对比以下几个产品看看区别: 蚂蚁借呗，芝麻分600并且受到邀请开通福利，这个就是支付宝贷款，直接秒杀了银行贷款和线下金融公司，是现在支付宝用户使用最多的。 微粒贷：于2015年上线，主要面向QQ和微信征信极好的用户而推出，受到邀请才能申请开通，额度最高有30万，难度较大 蚂蚁巴士：这个在微信 蚂蚁巴士 公众平台申请,对于信用分要求530分以上才可以,额度1-30万不等，目前非常火爆 说起支付宝中的芝麻信用功能，相信更是受到了许多人的推崇，因为随着自己使用的不断增多，信用分会慢慢提高，而达到了一个阶段，就可以获得许多的福利。而当 我们的芝麻信用分可以达到600分以上的时候，会有令我们想象不到的惊喜，接下来就让我们一起来看看，具体都有哪些惊喜吧。 一、芝麻分600以上福利之信用购。 网购相信大家都不陌生，但是很多时候，网购都有一个通病，就是没办法试用，导致很多人买了很多自己不喜欢的东西。但是只要你的支付宝芝麻分在650及以上，就能立马享有0元下单，收到货使用满意了再进行付款。还能享用美食的专属优惠，是不是很耐斯 二、芝麻分600以上福利之信用免押。芝麻信用与木鸟短租联合推出信用住宿服务，芝麻分600及以上的用户可享受免押入住特权。木鸟短租拥有全国50万套房源，是国内领先的短租民宿预订平台。包括大家知道的飞猪信用住，大部分酒店可以免押金入住，离店再交钱。 三、芝麻分600以上福利之国际驾照。我们经常听说的可能只是中国驾照，但现在芝麻分已经应用到了国际领域，只要你的芝麻分够550就可以免费办理国际驾照，也有不少人非常佩服马云，一个简单的芝麻分居然有如此大的功能，也从侧面反应出来马云在国际上的地位，这个国际驾照是由新西兰、德国、澳大利亚联合认证，可以在全球200多个国家通行，相信大家一定都有一个自驾全球的梦想吧，而现在支付宝就给了你一把钥匙，剩下的就你自己搞定了！有没有想带着你的女神来一次浪漫之旅呢？ 随着互联网对我们生活的改变越来越大，信用这一词也被大家推上风口浪尖，不论是生活出行，还是其他的互联网服务，与信用体系已经密不可分了，马云当初说道，找老婆需要拼芝麻分，如今似乎也要成为现实，那么你们的芝麻分有多少了呢？ 样式代码 .center { width: 60%; /*最后去除边框宽度恢复为60%*/ float: left; } 5.4.5. 4.5.6 实现右侧广告 HTML代码 效果如下： 5.4.6. 4.5.7 实现底部页脚 HTML代码 关于黑马&nbsp; 帮助中心&nbsp; 开放平台&nbsp; 诚聘英才&nbsp; 联系我们&nbsp; 法律声明&nbsp; 隐私政策&nbsp; 知识产权&nbsp; 廉正举报&nbsp; 样式代码 .footer { clear: both; background-color: cornflowerblue; text-align: center; } a{ text-decoration: none; color: white; } 6. 5 HTML案例-登录页面 6.1. 5.1 案例效果 6.2. 5.2 案例分析 6.2.1. 5.2.1 表单标签 标签名 作用 备注 form 表示表单，是用来收集用户输入信息并向 Web 服务器提交的一个容器 举例： //表单元素 表单的属性 属性名 作用 备注 action 处理此表单信息的Web服务器的URL地址 method 提交此表单信息到Web服务器的方式 可能的值有get和post，默认为get autocomplete 自动补全，指示表单元素是否能够拥有一个默认值，配合input标签使用 HTML5 举例： GET与POST说明： post：指的是 HTTP POST 方法；表单数据会包含在表单体内然后发送给服务器。 get：指的是 HTTP GET 方法；表单数据会附加在 action 属性的URI中，并以 '?' 作为分隔符，然后这样得到的 URI 再发送给服务器。 GET方式举例： GET与POST对比： 地址栏可见 数据安全 数据大小 GET 可见 不安全 有限制（取决于浏览器） POST 不可见 相对安全 无限制 6.2.2. 5.2.2 表单元素入门 表单元素指的是 input 元素、复选框、下拉框、提交按钮等等。 标签名 作用 备注 label 表单元素的说明，配合表单元素使用 for属性值为相关表单元素的id属性值 input 表单中输入控件，多种输入类型，用于接受来自用户数据 type属性值决定输入类型 button 页面中可点击的按钮，可以配合表单进行提交 type属性值决定按钮类型 1）简单的文本输入框 label标签：表单的说明。 for属性值：匹配input标签的id属性值 input标签：输入控件。 type属性：表示输入类型，text值为普通文本框 id属性：表示标签唯一标识 name属性：表示标签名称 value属性：表示标签数据值 代码实现： Username: 效果如图： 2）提交用户名的表单 button标签：表示按钮。 type属性：表示按钮类型，submit值为提交按钮。 Username: login 6.2.3. 5.2.3 关于属性值 1）NAME和VALUE属性 属性名 作用 name 的名字，在提交整个表单数据时，可以用于区分属于不同的值 value 这个元素当前的值，允许用户通过页面输入 使用方式： 以name属性值作为键，value属性值作为值，构成键值对提交到服务器，多个键值对浏览器使用&进行分隔。 举例： 2）TYPE属性 input标签的type属性 【建议】 这是今天的重点讲解内容，type的值决定输入的类型 基本的文本属性 | 属性值 | 作用 | 备注 | | -------- | ---------------------------------------------------- | ----- | | text | 单行文本字段 | | | password | 单行文本字段，值被遮盖 | | | email | 用于编辑 e-mail 的字段，可以对e-mail地址进行简单校验 | HTML5 | 举例： Username: Password: Email:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; login 单选多选属性 | 属性值 | 作用 | | -------- | ------------------------------------------------------------ | | radio | 单选按钮。 1. 在同一个”单选按钮组“中，所有单选按钮的 name 属性使用同一个值；一个单选按钮组中是，同一时间只有一个单选按钮可以被选择。 2. 必须使用 value 属性定义此控件被提交时的值。 3. 使用checked 必须指示控件是否缺省被选择。 | | checkbox | 复选框。 1. 必须使用 value 属性定义此控件被提交时的值。 2. 使用 checked 属性指示控件是否被选择。 3. 选中多个值时，所有的值会构成一个数组而提交到Web服务器 | 举例： ```html 性别: 男 女 爱好: 体育 科技 娱乐 短视频 ``` ![1573090505218](1img/1573090505218.png) 按钮属性 | 属性值 | 作用 | | ------ | ------------------------------------------------------------ | | button | 无行为按钮，用于结合JavaScript实现自定义动态效果 | | submit | 提交按钮，用于提交表单数据。 | | reset | 重置按钮，用于将表单中内容恢复为默认值。 | | image | 图片提交按钮。必须使用 src 属性定义图片的来源及使用 alt 定义替代文本。还可以使用 height 和 width 属性以像素为单位定义图片的大小。 | HTML5新增的type值 | 属性值 | 作用 | 备注 | | -------------- | -------------------------------------- | ------------------------------------------------------------ | | date | HTML5 用于输入日期的控件 | 年，月，日，不包括时间 | | time | HTML5 用于输入时间的控件 | 不含时区 | | datetime-local | HTML5 用于输入日期时间的控件 | 不包含时区 | | number | HTML5 用于输入浮点数的控件 | | | range | HTML5 用于输入不精确值控件 | max-规定最大值min-规定最小值 step-规定步进值 value-规定默认值 | | search | HTML5 用于输入搜索字符串的单行文本字段 | 可以点击x清除内容 | | tel | HTML5 用于输入电话号码的控件 | | | url | HTML5 用于编辑URL的字段 | 可以校验URL地址格式 | 属性值 作用 备注 file 此控件可以让用户选择文件，用于文件上传。 使用 accept 属性可以定义控件可以选择的文件类型。 hidden 此控件用户在页面上不可见，但它的值会被提交到服务器，用于传递隐藏值 button标签的type属性 | 属性值 | 作用 | 备注 | | ------ | ------------------------------------------------------------ | ---------------------------- | | submit | 此按钮将表单数据提交给服务器。如果未指定属性，或者属性动态更改为空值或无效值，则此值为默认值。 | 同 | | reset | 此按钮重置所有组件为初始值。 | 同/> | | button | 此按钮没有默认行为。它可以有与元素事件相关的客户端脚本，当事件出现时可触发。 | 同 | 3）HTML5新增属性 属性名 作用 备注 placeholder 提示用户输入框的作用。用于提示的占位符文本不能包含回车或换行。 仅适用于当type 属性为text, search, tel, url or email时; 否则会被忽略。 required 这个属性指定用户在提交表单之前必须为该元素填充值 1. 布尔属性，可省略属性值表示true2. 当type属性是hidden,image或者button类型时不可使用 autocomplete 自动补全，规定表单或输入字段是否应该自动完成。当自动完成开启，浏览器会基于用户之前的输入值自动填写值。 1. 开启为on，关闭为off2. 可以设置指定的字段为off，关闭自动补全 6.2.4. 5.2.4 更多表单元素 标签名 作用 备注 select 表单的控件，下拉选项菜单 与option配合实用 optgroup option的分组标签 与option配合实用 option select的子标签，表示一个选项 textarea 表示多行纯文本编辑控件 rows表示行高度， cols表示列宽度 fieldset 用来对表单中的控制元素进行分组(也包括 label 元素) legend 用于表示它的fieldset内容的标题。 fieldset 的子元素 select举例： Choose a pet: --Please choose an option-- Dog Cat Hamster Parrot Spider Goldfish textarea举例： Write something here fieldset举例： 是否同意 同意 不同意 6.3. 5.3 使用标签 简单布局，使用div标签 基本文本标签 表单标签 图片标签 6.4. 5.4 实现步骤 设置背景图。 基本上下两部分布局。 实现上部（图片） 实现下部（表单） 实现页面跳转，从案例2跳转到案例3。 Copyright © MISIN 2022 | 豫ICP备2021006345号-1 all right reserved，powered by Gitbook该文件修订时间： 2022-11-10 10:40:16 "},"2.JavaWeb/3.JavaWeb核心/1.Tomcat&Http协议-授课.html":{"url":"2.JavaWeb/3.JavaWeb核心/1.Tomcat&Http协议-授课.html","title":"1.Tomcat&Http协议-授课","keywords":"","body":"1. Tomcat&Http协议-授课2. 1 企业开发简介2.1. 1.1 JavaEE规范2.2. 1.2 Web概述2.3. 1.3 系统结构2.3.1. 1.3.1 系统结构简介2.3.2. 1.3.2 C/S结构2.3.3. 1.3.3 B/S结构2.3.4. 1.3.4 两种结构的区别及优略3. 2 Tomcat3.1. 2.1 Tomcat介绍3.1.1. 2.1.1 关于服务器3.1.2. 2.1.2 Tomcat下载与安装3.1.3. 2.1.3 Tomcat各版本所需支持3.1.4. 2.1.4 Tomcat目录结构详解3.2. 2.2 Tomcat基本使用3.2.1. 2.2.1 Tomcat启动和停止及问题分析解决3.2.2. 2.2.2 IDEA集成Tomcat服务器3.2.3. 2.2.3 Linux系统安装Tomcat3.3. 2.3 Tomcat发布应用-JavaWeb应用3.3.1. 2.3.1 JavaWeb工程概述3.3.2. 2.3.2 JavaWeb应用目录结构详解3.3.3. 2.3.3 JavaWeb应用的创建3.3.4. 2.3.4 JavaWeb应用的部署3.3.5. 2.4.1 Tomcat配置虚拟目录3.3.6. 2.4.2 Tomcat配置虚拟主机3.3.7. 2.4.3 Tomcat默认项配置4. 3 HTTP协议4.1. 3.1 HTTP协议概述4.1.1. 3.1.1 HTTP协议概念4.1.2. 3.1.2 HTTP协议版本4.1.3. 3.1.3 HTTP协议相关说明4.2. 3.2 HTTP协议组成4.2.1. 3.2.1请求部分4.2.2. 3.2.2 响应部分4.2.3. 3.3.3 消息头的共性分析4.3. 3.3 请求部分详解4.3.1. 3.3.1 请求行详解4.3.2. 3.3.2 请求消息头详解4.3.3. 3.3.3 请求正文详解4.4. 3.4 响应部分详解4.4.1. 3.4.1 响应行详解4.4.2. 3.4.2 响应消息头详解4.4.3. 3.4.3 响应正文详解5. 4 综合案例-Tomcat的具体应用5.1. 4.1 静态资源案例-门户类网站的部署和访问5.1.1. 4.1.1 案例介绍5.1.2. 4.1.2 实现步骤5.2. 4.2 动态资源的案例-学生管理系统的部署和访问5.2.1. 4.2.1 案例介绍5.2.2. 4.2.2 实现步骤5.2.3. 4.3.2 创建案例中的动态资源-Servlet1. Tomcat&Http协议-授课 2. 1 企业开发简介 2.1. 1.1 JavaEE规范 JavaEE规范是J2EE规范的新名称，早期被称为J2EE规范，其全称是Java 2 Platform Enterprise Edition，它是由SUN公司领导、各厂家共同制定并得到广泛认可的工业标准（JCP组织成员）。之所以改名为JavaEE，目的还是让大家清楚J2EE只是Java企业应用。在2004年底中国软件技术大会Ioc微容器(也就是Jdon框架的实现原理)演讲中指出：我们需要一个跨J2SE/WEB/EJB的微容器，保护我们的业务核心组件，以延续它的生命力，而不是依赖J2SE/J2EE版本.此次J2EE改名为Java EE，实际也反映出业界这种共同心声。 JavaEE规范是很多Java开发技术的总称。这些技术规范都是沿用自J2EE的。一共包括了13个技术规范。例如：jsp/servlet，jndi，jaxp，jdbc，jni，jaxb，jmf，jta，jpa，EJB等。 其中，JCP组织的全称是Java Community Process。它是一个开放的国际组织，主要由Java开发者以及被授权者组成，职能是发展和更新。成立于1998年。官网是：JCP JavaEE的版本是延续了J2EE的版本，但是没有继续采用其命名规则。J2EE的版本从1.0开始到1.4结束，而JavaEE版本是从JavaEE 5版本开始，目前最新的的版本是JavaEE 8。 详情请参考：JavaEE8规范概览 2.2. 1.2 Web概述 Web在英文中的含义是网状物，网络。在计算机领域，它通常指的是后者，即网络。像我们前面接触的WWW，它是由3个单词组成的，即：World Wide Web，中文含义是万维网。而我们前面学的HTML，CSS和JS的参考文档《W3School全套教程》中的W3C就是万维网联盟。他们的出现都是为了让我们在网络的世界中获取资源，这些资源的存放之处，我们称之为网站。我们通过输入网站的地址（即：网址），就可以访问网站中提供的资源。在网上我们能访问到的内容全是资源（不区分局域网还是广域网）。只不过，不同类型的资源展示的效果不一样。 首先，我们先来介绍资源的分类，它分为静态资源和动态资源。其中： 静态资源指的是，网站中提供给人们展示的资源是一成不变的，也就是说不同人或者在不同时间，看到的内容都是一样的。例如：我们看到的新闻，网站的使用手册，网站功能说明文档等等。而作为开发者，我们编写的html,css,js,图片，多媒体等等都可以称为静态资源。 动态资源它指的是，网站中提供给人们展示的资源是由程序产生的，在不同的时间或者用不同的人员由于身份的不同，所看到的内容是不一样的。例如：我们在12306上购买火车票，火车票的余票数由于时间的变化，会逐渐的减少，直到最后没有余票。还有，我们在CSDN上下载资料，只有登录成功后，且积分足够时才能下载。否则就不能下载，这就是访客身份和会员身份的区别。作为开发人员，我们编写的JSP，servlet，php，ASP等都是动态资源。 关于广域网和局域网的划分，广域网指的就是万维网，也就是我们说的互联网。局域网是指的是在一定范围之内可以访问的网络，出了这个范围，就不能再使用的网络。 2.3. 1.3 系统结构 2.3.1. 1.3.1 系统结构简介 在我们前面课程的学习中，开发的都是Java工程。这些工程在企业中称之为项目或者产品。项目也好，产品也罢，它是有系统架构的，系统架构的划分有很多种方式。我们今天讨论的是基础结构上的划分。除此之外，还有技术选型划分，部署方式划分等等。 基础结构划分：C/S结构，B/S结构两类。 技术选型划分：Model1模型，Model2模型，MVC模型和三层架构+MVC模型。 部署方式划分：一体化架构，垂直拆分架构，分布式架构，流动计算架构，微服务架构。 2.3.2. 1.3.2 C/S结构 它指的是客户端——服务器的方式。其中C代表着Client，S代表着服务器。C/S结构的系统设计图如下： 2.3.3. 1.3.3 B/S结构 它指的是浏览器——服务器的方式。其中B代表着Browser，S代表着服务器。B/S结构的系统设计图如下： 2.3.4. 1.3.4 两种结构的区别及优略 两种结构的区别 第一：硬件环境不同，C/S通常是建立在专用的网络或小范围的网络环境上（即局域网），且必须要安装客户端。而B/S是建立在广域网上的，适应范围强，通常有操作系统和浏览器就行。 第二：C/S结构比B/S结构更安全，因为用户群相对固定，对信息的保护更强。 第三：B/S结构维护升级比较简单，而C/S结构维护升级相对困难。 优略 1 C/S：是能充分发挥客户端PC的处理能力，很多工作可以在客户端处理后再提交给服务器。对应的优点就是客户端响应速度快。 2 B/S：总体拥有成本低、维护方便、 分布性强、开发简单，可以不用安装任何专门的软件就能 实现在任何地方进行操作，客户端零维护，系统的扩展非常容易，只要有一台能上网的电脑就能使用。 关于课程中结构的选择 我们的课程中涉及的系统结构都是是基于B/S结构。 3. 2 Tomcat 3.1. 2.1 Tomcat介绍 3.1.1. 2.1.1 关于服务器 服务器的概念非常的广泛，它可以指代一台特殊的计算机（相比普通计算机运行更快、负载更高、价格更贵），也可以指代用于部署网站的应用。我们这里说的服务器，其实是web服务器，或者应用服务器。它本质就是一个软件，一个应用。作用就是发布我们的应用（工程），让用户可以通过浏览器访问我们的应用。 常见的应用服务器，请看下表： 服务器名称 说明 weblogic 实现了javaEE规范，重量级服务器，又称为javaEE容器 websphereAS 实现了javaEE规范，重量级服务器。 JBOSSAS 实现了JavaEE规范，重量级服务器。免费的。 Tomcat 实现了jsp/servlet规范，是一个轻量级服务器，开源免费。 3.1.2. 2.1.2 Tomcat下载与安装 Tomcat官网下载地址 3.1.3. 2.1.3 Tomcat各版本所需支持 3.1.4. 2.1.4 Tomcat目录结构详解 3.2. 2.2 Tomcat基本使用 3.2.1. 2.2.1 Tomcat启动和停止及问题分析解决 1）启动和停止 Tomcat服务器的启动文件在二进制文件目录中：，这两个文件就是Tomcat的启动文件。 Tomcat服务器的停止文件也在二进制文件目录中：，这两个文件就是Tomcat的停止文件。 其中.bat文件是针对windows系统的运行程序，.sh文件是针对linux系统的运行程序。 2）启动问题 第一个问题：启动一闪而过 原因：没有配置环境变量。 解决办法：配置上JAVA_HOME环境变量 第二个：Address already in use : JVM_Bind 原因：端口被占用 解决办法：找到占用该端口的应用 ​ 进程不重要：使用cmd命令：netstat -a -o 查看pid 在任务管理器中结束占用端口的进程。 ​ 进程很重要：修改自己的端口号。修改的是Tomcat目录下\\conf\\server.xml中的配置。 ​ 第三个：启动产生很多异常，但能正常启动 原因：Tomcat中部署着很多项目，每次启动这些项目都会启动。而这些项目中有启动报异常的。 解决办法： ​ 能找到报异常的项目，就把它从发布目录中移除。 ​ 不能确定报异常的项目，就重新解压一个新的Tomcat。 第四个：其它问题 例如：启动产生异常，但是不能正常启动。此时就需要解压一个新的Tomcat启动，来确定是系统问题，还是Tomcat的问题。 所以，此时就需要具体问题，具体分析，然后再对症解决。 3.2.2. 2.2.2 IDEA集成Tomcat服务器 第一步 第二步 第三步 第四步 3.2.3. 2.2.3 Linux系统安装Tomcat 第一步：下载tomcat 参考2.1.2小节的《Tomcat下载与安装》进入Tomcat官网，找到对应版本点击download进入下载页面，如下图： 第二步：上传到linux 在crt上 使用 alt+p 将windows上的软件拖进去即可(root目录) 第三步：在 /usr/local 新建一个文件夹tomcat mkdir /usr/local/tomcat 第四步：移动 tomcat...tar.gz 到 /usr/local/tomcat mv apache-tomcat-8.5.32.tar.gz /usr/local/tomcat/ 第五步：进入/usr/local/tomcat目录,解压Tomcat cd /usr/local/tomcat tar -xvf apache-tomcat-8.5.32.tar.gz 第六步：进入 /usr/local/tomcat/apache-tomcat-8.5.32/bin cd /usr/local/tomcat/apache-tomcat-8.5.32/bin 第七步：启动tomcat 方式1: sh startup.sh 方式2: ./startup.sh 第八步：修改防火墙的规则 方式1:service iptables stop 关闭防火墙(不建议); 用到哪一个端口号就放行哪一个(80,8080,3306...) 方式2:放行8080 端口 修改配置文件 cd /etc/sysconfig vi iptables 复制(yy , p) -A INPUT -m state --state NEW -m tcp -p tcp --dport 22 -j ACCEPT 改成 -A INPUT -m state --state NEW -m tcp -p tcp --dport 8080 -j ACCEPT 重启加载防火墙或者重启防火墙 service iptables reload 或者 service iptables restart 3.3. 2.3 Tomcat发布应用-JavaWeb应用 3.3.1. 2.3.1 JavaWeb工程概述 JavaWeb应用是一个全新的应用种类。这类应用程序指供浏览器访问的程序，通常也简称为web应用。 一个web应用由多个静态web资源和动态web资源组成，例如：html、css、js文件，jsp文件、java程序、支持jar包、工程配置文件、图片、音视频等等。 Web应用开发好后，若想供外界访问，需要把web应用所在目录交给Web服务器管理（Tomcat就是Web服务器之一），这个过程称之为虚似目录的映射。 3.3.2. 2.3.2 JavaWeb应用目录结构详解 myapp--------------应用名称 1.html css/css.css js/demo.js WEB-INF--------如果有web.xml或者.class文件时，该目录必须存在，且严格区分大小写。 --------该目录下的资源，客户端是无法直接访问的。 --------目录中内容如下： classes目录----------------web应用的class文件（加载顺序：我们的class，lib目录中的jar包，tomcat的lib目录中的jar包。优先级依次降低） lib目录--------------------web应用所需的jar包（tomcat的lib目录下jar为所有应用共享） web.xml-------------------web应用的主配置文件 3.3.3. 2.3.3 JavaWeb应用的创建 第一步 第二步 第三步 第四步 3.3.4. 2.3.4 JavaWeb应用的部署 1）IDEA部署 第一步 第二步 第三步 2）war包发布 第一步：使用jar -cvf war 包的名称 当前目录中哪些资源要打入war 第二步：把打好的war拷贝到tomcat的webapps目录中 第三步：启动服务时，tomcat会自动解压。 3.3.5. 2.4.1 Tomcat配置虚拟目录 虚拟目录的配置，支持两种方式。第一种是通过在主配置文件中添加标签实现。第二种是通过写一个独立配置文件实现。 第一种方式：在server.xml的元素中加一个元素。 ​ path：访问资源URI。URI名称可以随便起，但是必须在前面加上一个/ ​ docBase：资源所在的磁盘物理地址。 第二种方式：是写一个独立的xml文件，该文件名可以随便起。在文件内写一个元素。 ​ 该文件要放在Tomcat目录中的conf\\Catalina\\localhost\\目录下。 需要注意的是，在使用了独立的配置文件之后，访问资源URI就变成了/+文件的名称。而Context的path属性就失效了。 3.3.6. 2.4.2 Tomcat配置虚拟主机 在元素中添加一个，其中： ​ name：指定主机的名称 ​ appBase：当前主机的应用发布目录 ​ unparkWARs：启动时是否自动解压war包 ​ autoDeploy：是否自动发布 配置示例如下： 3.3.7. 2.4.3 Tomcat默认项配置 配置默认端口 Tomcat服务器主配置文件中配置着访问端口，它在配置文件中写的值是：8080。但是它不是Tomcat的默认端口。我们此处说的默认端口是，当使用默认值的时候，端口号可以省略。Tomcat的默认端口是80。 配置方式如下： 配置默认应用 有两种方式配置默认应用。 第一种：把要作为默认应用的应用，名称改为ROOT。放到webapps目录中。 第二种：写一个独立的配置文件，文件名称为ROOT.xml。 ​ 注意：ROOT必须大写。当使用了独立的ROOT.xml文件时，webapps下ROOT应用就不是默认应用了。 配置默认主页 首先要明确的是，配置默认主页是针对应用说的。是应用的默认主页。 在应用的web.xml中配置： 默认主页 例如： index.html index.htm index.jsp 4. 3 HTTP协议 4.1. 3.1 HTTP协议概述 4.1.1. 3.1.1 HTTP协议概念 HTTP的全称是：Hyper Text Transfer Protocol，意为 超文本传输协议。它指的是服务器和客户端之间交互必须遵循的一问一答的规则。形容这个规则：问答机制、握手机制。 它规范了请求和响应内容的类型和格式。 HTTP协议是由W3C组织管理和维护的。 4.1.2. 3.1.2 HTTP协议版本 目前HTTP协议主要是1.0版本和1.1版本。这两个版本的区别主要是两个方面。 第一：HTTP1.1版本比1.0版本多了一些消息头。 第二：HTTP1.1版本和1.0版本的执行过程不一样。执行过程如下： HTTP1.0 HTTP1.1 创建连接（TCP/IP） 创建连接（TCP/IP） 发送请求 发送请求1 得到响应 得到响应1 关闭连接 发送请求2 创建连接（TCP/IP） 得到响应2 发送请求 ....... 得到响应 ....... 关闭连接 连接超时或手动关闭连接 4.1.3. 3.1.3 HTTP协议相关说明 HTTP协议概念是客户浏览器和服务器一种一问一答的规则，那么必须要有问有答，而且要先问后答。 但是我们使用,和标签，没有手动发起请求，但是仍然能从服务器端拿到数据，原因就是：在浏览器遇到,,标签时会自动发出请求。 4.2. 3.2 HTTP协议组成 由HTTP协议的概念可知，它分为问和答两部分。其中问指的就是请求部分，而答指的就是响应部分。 4.2.1. 3.2.1请求部分 请求行： 永远位于请求的第一行 请求消息头： 从第二行开始，到第一个空行结束 请求的正文： 从第一个空行后开始，到正文的结束 4.2.2. 3.2.2 响应部分 响应行： 永远位于响应的第一行 响应消息头： 从第二行开始，到第一个空行结束 响应的正文： 从第一个空行后开始，到正文的结束 4.2.3. 3.3.3 消息头的共性分析 消息头名称首字母大写，多个单词每个单词的首字母都大写。 多个单词用-分隔 名称和值之间用冒号加空格分隔 多个值之间用逗号加空格分隔 两个头之间用回车分隔 4.3. 3.3 请求部分详解 4.3.1. 3.3.1 请求行详解 请求行：GET /myapp/2.html HTTP/1.1 内容 说明 GET 请求的方式。（还有POST） /myapp/2.html 请求的资源。 HTTP/1.1 使用的协议，及协议的版本。 4.3.2. 3.3.2 请求消息头详解 内容 说明 Accept 告知服务器，客户浏览器所支持的MIME类型。 Accept-Encoding 告知服务器，客户浏览器所支持的压缩编码格式。最常用的就是gzip压缩。 Accept-Language 告知服务器，客户浏览器所支持的语言。一般都是zh_CN或en_US等。 Referer 告知服务器，当前请求的来源。只有当前请求有来源的时候，才有这个消息头。从地址栏输入的没有来源。作用：1 投放广告 2 防盗链 Content-Type 告知服务器，请求正文的MIME类型。 Content-Length 告知服务器，请求正文的长度。 User-Agent 浏览器相关信息 Connection: Keep-Alive 连接的状态：保持连接 If-Modified-Since 告知服务器，客户浏览器缓存文件的最后修改时间。 Cookie（**） 会话管理相关，非常的重要。 4.3.3. 3.3.3 请求正文详解 第一：只有post请求方式，才有请求的正文。get方式的正文是在地址栏中的。 第二：表单的输入域有name属性的才会被提交。不分get和post的请求方式。 第三：表单的enctype属性取值决定了请求正文的体现形式。概述的含义是：请求正文的MIME编码类型。 enctype取值 请求正文体现形式 示例 application/x-www-form-urlencoded key=value&key=value username=test&password=1234 multipart/form-data 此时变成了多部分表单数据。多部分是靠分隔符分隔的。 -----------------------------7df23a16c0210Content-Disposition: form-data; name=\"username\"test-----------------------------7df23a16c0210Content-Disposition: form-data; name=\"password\"1234-----------------------------7df23a16c0210Content-Disposition: form-data; name=\"headfile\"; filename=\"C:\\Users\\zhy\\Desktop\\请求部分.jpg\"Content-Type: image/pjpeg-----------------------------7df23a16c0210 4.4. 3.4 响应部分详解 4.4.1. 3.4.1 响应行详解 响应行：HTTP/1.1 200 OK 内容 说明 HTTP/1.1 使用协议的版本。 200 响应状态码 OK 状态码描述 常用状态码介绍： 状态码 说明 200 一切都OK> 302/307 请求重定向(客户端行为，两次请求，地址栏发生改变) 304 请求资源未发生变化，使用缓存 404 请求资源未找到 500 服务器错误 4.4.2. 3.4.2 响应消息头详解 消息头 说明 Location 请求重定向的地址，常与302,307配合使用。 Server 服务器相关信息。 Content-Type 告知客户浏览器，响应正文的MIME类型。 Content-Length 告知客户浏览器，响应正文的长度。 Content-Encoding 告知客户浏览器，响应正文使用的压缩编码格式。常用的gzip压缩。 Content-Language 告知客户浏览器，响应正文的语言。zh_CN或en_US等等。 Content-Disposition 告知客户浏览器，以下载的方式打开响应正文。 Refresh 定时刷新 Last-Modified 服务器资源的最后修改时间。 Set-Cookie（*） 会话管理相关，非常的重要 Expires:-1 服务器资源到客户浏览器后的缓存时间 Catch-Control: no-catch 不要缓存，//针对http协议1.1版本 Pragma:no-catch 不要缓存，//针对http协议1.0版本 4.4.3. 3.4.3 响应正文详解 就和我们在浏览器上右键查看源文件看到的内容是一样的。 5. 4 综合案例-Tomcat的具体应用 5.1. 4.1 静态资源案例-门户类网站的部署和访问 5.1.1. 4.1.1 案例介绍 需求： ​ 在浏览器中输入地址，访问静态HTML页面。 细节说明： ​ 把HTML和CSS课程中制作的页面加入到JavaWeb工程中，在Tomcat中部署工程，然后启动Tomcat服务器，并使用浏览器访问。 5.1.2. 4.1.2 实现步骤 第一步：创建工程并选择使用的Tomcat版本 第二步：拷贝资源到工程的web目录中 第三步：在web.xml中配置默认主页 第四步：部署工程到Tomcat服务器 第五步：测试浏览器访问 5.2. 4.2 动态资源的案例-学生管理系统的部署和访问 5.2.1. 4.2.1 案例介绍 需求： ​ 把JavaSE进阶阶段的学生管理系统的服务器改用Tomcat实现。 细节说明： ​ 把学生管理系统涉及的HTML和样式以及图片文件拷贝到JavaWeb工程中，在Tomcat中部署工程，然后启动Tomcat服务器，并使用浏览器访问。 5.2.2. 4.2.2 实现步骤 第一步：创建工程 第二步：拷贝资源 第三步：配置默认主页 第四步：部署项目 5.2.3. 4.3.2 创建案例中的动态资源-Servlet 1） Servlet简介 Servlet翻译成中文是服务端脚本，它是SUN公司推出的一套规范，称为Servlet规范。Servlet规范是JavaEE规范中的一部分。我们可以通过查阅JavaEE规范的API来了解Servlet的基本概念。通过点击JavaEE8官方文档，就可以看到关于Servlet的内容介绍。 2） 按步骤编写Servlet 前期准备：在IDEA创建Javaweb工程 第一步：编写一个普通类实现Servlet接口或者继承GenericServlet类或者继承HttpServlet 第二步：重写service方法，输出一句话 第三步：在web.xml配置Servlet 第四步：启动tomcat服务器测试 在地址栏输入：http://localhost:8585/crm/studentServlet 测试访问结果 3）测试访问 Copyright © MISIN 2022 | 豫ICP备2021006345号-1 all right reserved，powered by Gitbook该文件修订时间： 2022-11-10 10:43:08 "},"2.JavaWeb/3.JavaWeb核心/2.Servlet-授课.html":{"url":"2.JavaWeb/3.JavaWeb核心/2.Servlet-授课.html","title":"2.Servlet-授课","keywords":"","body":"1. Servlet-授课2. 1 Servlet2.1. 1.1 Servlet概述2.2. 1.2 Servlet入门2.2.1. 1.2.1 Servlet编码步骤2.2.2. 1.2.2 Servlet执行过程分析2.2.3. 1.2.3 Servlet类视图2.2.4. 1.2.4 Servlet编写方式2.3. 1.3 Servlet使用细节2.3.1. 1.3.1 Servlet的生命周期2.3.2. 1.3.2 Servlet的线程安全2.3.3. 1.3.3 Servlet的注意事项2.3.4. 1.4 Servlet关系总图3. 2 ServletConfig3.1. 2.1 ServletConfig概述3.1.1. 2.1.1 基本概念3.1.2. 2.1.2 生命周期3.2. 2.2 ServletConfig的使用3.2.1. 2.2.1 如何获取3.2.2. 2.2.2 如何配置3.2.3. 2.2.3 常用方法4. 3 ServletContext4.1. 3.1 ServletContext概述4.1.1. 3.1.1 基本介绍4.1.2. 3.1.2 生命周期4.1.3. 3.1.3 域对象概念4.2. 3.2 ServletContext的使用4.2.1. 3.2 1 ServletContext介绍4.2.2. 3.2.2 域对象4.2.3. 3.2.3 ServletContext配置4.2.4. 3.2.4 ServletContext常用方法5. 4 注解开发Servlet5.1. 4.1 Servlet3.0规范5.2. 4.2 注解开发入门案例5.2.1. 4.2.1 自动注解配置5.2.2. 4.2.2 手动创建容器6. 5 Servlet应用案例-学生管理系统6.1. 5.1 案例介绍6.1.1. 5.1.1 案例需求6.1.2. 5.1.2 技术选型1. Servlet-授课 2. 1 Servlet 2.1. 1.1 Servlet概述 Servlet是SUN公司提供的一套规范，名称就叫Servlet规范，它也是JavaEE规范之一。我们可以像学习Java基础一样，通过API来学习Servlet。这里需要注意的是，在我们之前JDK的API中是没有Servlet规范的相关内容，需要使用JavaEE的API。目前在Oracle官网中的最新版本是JavaEE8，该网址中介绍了JavaEE8的一些新特性。当然，我们可以通过访问官方API，学习和查阅里面的内容。 打开官方API网址，在左上部分找到javax.servlet包，在左下部分找到Servlet，如下图显示： 通过阅读API，我们得到如下信息： 第一：Servlet是一个运行在web服务端的java小程序 第二：它可以用于接收和响应客户端的请求 第三：要想实现Servlet功能，可以实现Servlet接口，继承GenericServlet或者HttpServlet 第四：每次请求都会执行service方法 第五：Servlet还支持配置 具体请看下图： 2.2. 1.2 Servlet入门 2.2.1. 1.2.1 Servlet编码步骤 1）编码步骤 第一步：前期准备-创建JavaWeb工程 第二步：编写一个普通类继承GenericServlet并重写service方法 第三步：在web.xml配置Servlet 2）测试 在Tomcat中部署项目 在浏览器访问Servlet 2.2.2. 1.2.2 Servlet执行过程分析 我们通过浏览器发送请求，请求首先到达Tomcat服务器，由服务器解析请求URL，然后在部署的应用列表中找到我们的应用。接下来，在我们的应用中找应用里的web.xml配置文件，在web.xml中找到FirstServlet的配置，找到后执行service方法，最后由FirstServlet响应客户浏览器。整个过程如下图所示： 一句话总结执行过程： 浏览器——>Tomcat服务器——>我们的应用——>应用中的web.xml——>FirstServlet——>响应浏览器 2.2.3. 1.2.3 Servlet类视图 在《Tomcat和Http协议》这天课程和刚才的入门案例中，我们都定义了自己的Servlet，实现的方式都是选择继承GenericServlet，在Servlet的API介绍中，它提出了我们除了继承GenericServlet外还可以继承HttpServlet，通过查阅servlet的类视图，我们看到GenericServlet还有一个子类HttpServlet。同时，在service方法中还有参数ServletRequest和ServletResponse，它们的关系如下图所示： 2.2.4. 1.2.4 Servlet编写方式 1）编写方式说明 我们在实现Servlet功能时，可以选择以下三种方式： 第一种：实现Servlet接口，接口中的方法必须全部实现。 ​ 使用此种方式，表示接口中的所有方法在需求方面都有重写的必要。此种方式支持最大程度的自定义。 第二种：继承GenericServlet，service方法必须重写，其他方可根据需求，选择性重写。 ​ 使用此种方式，表示只在接收和响应客户端请求这方面有重写的需求，而其他方法可根据实际需求选择性重写，使我们的开发Servlet变得简单。但是，此种方式是和HTTP协议无关的。 第三种：继承HttpServlet，它是javax.servlet.http包下的一个抽象类，是GenericServlet的子类。如果我们选择继承HttpServlet时，只需要重写doGet和doPost方法，不要覆盖service方法。 ​ 使用此种方式，表示我们的请求和响应需要和HTTP协议相关。也就是说，我们是通过HTTP协议来访问的。那么每次请求和响应都符合HTTP协议的规范。请求的方式就是HTTP协议所支持的方式（目前我们只知道GET和POST，而实际HTTP协议支持7种请求方式，GET POST PUT DELETE TRACE OPTIONS HEAD )。 2）HttpServlet的使用细节 第一步：在入门案例的工程中创建一个Servlet继承HttpServlet 注意：不要重写任何方法，如下图所示： 第二步：部署项目并测试访问 当我们在地址栏输入ServletDemo2的访问URL时，出现了访问错误，状态码是405。提示信息是：方法不允许。 第三步：分析原因 得出HttpServlet的使用结论： ​ 我们继承了HttpServlet，需要重写里面的doGet和doPost方法来接收get方式和post方式的请求。 为了实现代码的可重用性，我们只需要在doGet或者doPost方法中一个里面提供具体功能即可，而另外的那个方法只需要调用提供了功能的方法。 2.3. 1.3 Servlet使用细节 2.3.1. 1.3.1 Servlet的生命周期 对象的生命周期，就是对象从生到死的过程，即：出生——活着——死亡。用更偏向 于开发的官方说法就是对象创建到销毁的过程。 出生：请求第一次到达Servlet时，对象就创建出来，并且初始化成功。只出生一次，就放到内存中。 活着：服务器提供服务的整个过程中，该对象一直存在，每次只是执行service方法。 死亡：当服务停止时，或者服务器宕机时，对象消亡。 通过分析Servlet的生命周期我们发现，它的实例化和初始化只会在请求第一次到达Servlet时执行，而销毁只会在Tomcat服务器停止时执行，由此我们得出一个结论，Servlet对象只会创建一次，销毁一次。所以，Servlet对象只有一个实例。如果一个对象实例在应用中是唯一的存在，那么我们就说它是单实例的，即运用了单例模式。 2.3.2. 1.3.2 Servlet的线程安全 由于Servlet运用了单例模式，即整个应用中只有一个实例对象，所以我们需要分析这个唯一的实例中的类成员是否线程安全。接下来，我们来看下面的的示例： /* Servlet线程安全 */ public class ServletDemo04 extends HttpServlet{ //1.定义用户名成员变量 //private String username = null; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { String username = null; //synchronized (this) { //2.获取用户名 username = req.getParameter(\"username\"); try { Thread.sleep(3000); } catch (InterruptedException e) { e.printStackTrace(); } //3.获取输出流对象 PrintWriter pw = resp.getWriter(); //4.响应给客户端浏览器 pw.print(\"welcome:\" + username); //5.关流 pw.close(); //} } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { doGet(req,resp); } } 启动两个浏览器，输入不同的参数，访问之后发现输出的结果都是一样，所以出现线程安全问题 通过上面的测试我们发现，在Servlet中定义了类成员之后，多个浏览器都会共享类成员的数据。其实每一个浏览器端发送请求，就代表是一个线程，那么多个浏览器就是多个线程，所以测试的结果说明了多个线程会共享Servlet类成员中的数据，其中任何一个线程修改了数据，都会影响其他线程。因此，我们可以认为Servlet它不是线程安全的。 分析产生这个问题的根本原因，其实就是因为Servlet是单例，单例对象的类成员只会随类实例化时初始化一次，之后的操作都是改变，而不会重新初始化。 解决这个问题也非常简单，就是在Servlet中定义类成员要慎重。如果类成员是共用的，并且只会在初始化时赋值，其余时间都是获取的话，那么是没问题。如果类成员并非共用，或者每次使用都有可能对其赋值，那么就要考虑线程安全问题了，把它定义到doGet或者doPost方法里面去就可以了。 2.3.3. 1.3.3 Servlet的注意事项 1）映射Servlet的细节 Servlet支持三种映射方式，以达到灵活配置的目的。 首先编写一个Servlet，代码如下： /** * 演示Servlet的映射方式 * @author 黑马程序员 * @Company http://www.itheima.com */ public class ServletDemo5 extends HttpServlet { /** * doGet方法输出一句话 * @param req * @param resp * @throws ServletException * @throws IOException */ @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { System.out.println(\"ServletDemo5接收到了请求\"); } /** * 调用doGet方法 * @param req * @param resp * @throws ServletException * @throws IOException */ @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { doGet(req,resp); } } 第一种：指名道姓的方式 ​ 此种方式，只有和映射配置一模一样时，Servlet才会接收和响应来自客户端的请求。 ​ 例如：映射为：/servletDemo5 ​ 访问URL：http://localhost:8585/servlet_demo/servletDemo5 第二种：/开头+通配符的方式 ​ 此种方式，只要符合目录结构即可，不用考虑结尾是什么。 ​ 例如：映射为：/servlet/* ​ 访问URL：http://localhost:8585/servlet/itheima ​ http://localhost:8585/servlet/itcast.do ​ 这两个URL都可以。因为用的*，表示/servlet/后面的内容是什么都可以。 第三种：通配符+固定格式结尾 ​ 此种方式，只要符合固定结尾格式即可，其前面的访问URI无须关心（注意协议，主机和端口必须正确） ​ 例如：映射为：*.do ​ 访问URL：http://localhost:8585/servlet/itcast.do ​ http://localhost:8585/itheima.do ​ 这两个URL都可以方法。因为都是以.do作为结尾，而前面用*号通配符配置的映射，所有无须关心。 通过测试我们发现，Servlet支持多种配置方式，但是由此也引出了一个问题，当有两个及以上的Servlet映射都符合请求URL时，由谁来响应呢？注意：HTTP协议的特征是一请求一响应的规则。那么有一个请求，必然有且只有一个响应。所以，我们接下来明确一下，多种映射规则的优先级。 先说结论：指名道姓的方式优先级最高，带有通配符的映射方式，有/的比没/的优先级高 所以，我们前面讲解的三种映射方式的优先级为：第一种>第二种>第三种。 演示代码如下： /** * 它和ServletDemo5组合演示Servlet的访问优先级问题 * @author 黑马程序员 * @Company http://www.itheima.com */ public class ServletDemo6 extends HttpServlet { /** * doGet方法输出一句话 * @param req * @param resp * @throws ServletException * @throws IOException */ @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { System.out.println(\"ServletDemo6接收到了请求\"); } /** * 调用doGet方法 * @param req * @param resp * @throws ServletException * @throws IOException */ @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { doGet(req,resp); } } servletDemo6 com.itheima.web.servlet.ServletDemo6 servletDemo6 /* 运行结果如下： 2）多路径映射Servlet 上一小节我们讲解了Servlet的多种映射方式，这一小节我们来介绍一下，一个Servlet的多种路径配置的支持。 它其实就是给一个Servlet配置多个访问映射，从而可以根据不同请求URL实现不同的功能。 首先，创建一个Servlet： /** * 演示Servlet的多路径映射 * @author 黑马程序员 * @Company http://www.itheima.com */ public class ServletDemo7 extends HttpServlet { /** * 根据不同的请求URL，做不同的处理规则 * @param req * @param resp * @throws ServletException * @throws IOException */ @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { //1.获取当前请求的URI String uri = req.getRequestURI(); uri = uri.substring(uri.lastIndexOf(\"/\"),uri.length()); //2.判断是1号请求还是2号请求 if(\"/servletDemo7\".equals(uri)){ System.out.println(\"ServletDemo7执行1号请求的业务逻辑：商品单价7折显示\"); }else if(\"/demo7\".equals(uri)){ System.out.println(\"ServletDemo7执行2号请求的业务逻辑：商品单价8折显示\"); }else { System.out.println(\"ServletDemo7执行基本业务逻辑：商品单价原价显示\"); } } /** * 调用doGet方法 * @param req * @param resp * @throws ServletException * @throws IOException */ @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { doGet(req,resp); } } 接下来，在web.xml配置Servlet： servletDemo7 com.itheima.web.servlet.ServletDemo7 servletDemo7 /demo7 servletDemo7 /servletDemo7 servletDemo7 /servlet/* 最后，启动服务测试运行结果： 3）启动时创建Servlet 我们前面讲解了Servlet的生命周期，Servlet的创建默认情况下是请求第一次到达Servlet时创建的。但是我们都知道，Servlet是单例的，也就是说在应用中只有唯一的一个实例，所以在Tomcat启动加载应用的时候就创建也是一个很好的选择。那么两者有什么区别呢？ 第一种：应用加载时创建Servlet，它的优势是在服务器启动时，就把需要的对象都创建完成了，从而在使用的时候减少了创建对象的时间，提高了首次执行的效率。它的弊端也同样明显，因为在应用加载时就创建了Servlet对象，因此，导致内存中充斥着大量用不上的Servlet对象，造成了内存的浪费。 第二种：请求第一次访问是创建Servlet，它的优势就是减少了对服务器内存的浪费，因为那些一直没有被访问过的Servlet对象都没有创建，因此也提高了服务器的启动时间。而它的弊端就是，如果有一些要在应用加载时就做的初始化操作，它都没法完成，从而要考虑其他技术实现。 通过上面的描述，相信同学们都能分析得出何时采用第一种方式，何时采用第二种方式。就是当需要在应用加载就要完成一些工作时，就需要选择第一种方式。当有很多Servlet的使用时机并不确定是，就选择第二种方式。 在web.xml中是支持对Servlet的创建时机进行配置的，配置的方式如下：我们就以ServletDemo3为例。 servletDemo3 com.itheima.web.servlet.ServletDemo3 1 servletDemo3 /servletDemo3 4）默认Servlet 默认Servlet是由服务器提供的一个Servlet，它配置在Tomcat的conf目录下的web.xml中。如下图所示： 它的映射路径是/，我们在发送请求时，首先会在我们应用中的web.xml中查找映射配置，找到就执行，这块没有问题。但是当找不到对应的Servlet路径时，就去找默认的Servlet，由默认Servlet处理。所以，一切都是Servlet。 2.3.4. 1.4 Servlet关系总图 3. 2 ServletConfig 3.1. 2.1 ServletConfig概述 3.1.1. 2.1.1 基本概念 它是Servlet的配置参数对象，在Servlet规范中，允许为每个Servlet都提供一些初始化配置。所以，每个Servlet都一个自己的ServletConfig。它的作用是在Servlet初始化期间，把一些配置信息传递给Servlet。 3.1.2. 2.1.2 生命周期 由于它是在初始化阶段读取了web.xml中为Servlet准备的初始化配置，并把配置信息传递给Servlet，所以生命周期与Servlet相同。这里需要注意的是，如果Servlet配置了1，那么ServletConfig也会在应用加载时创建。 3.2. 2.2 ServletConfig的使用 3.2.1. 2.2.1 如何获取 首先，我们要清楚的认识到，它可以为每个Servlet都提供初始化参数，所以肯定可以在每个Servlet中都配置。那是配置在Servlet的声明部分，还是映射部分呢？我们接下来先准备一个Servlet，然后给同学们揭秘。 /** * 演示Servlet的初始化参数对象 * @author 黑马程序员 * @Company http://www.itheima.com */ public class ServletDemo8 extends HttpServlet { //定义Servlet配置对象ServletConfig private ServletConfig servletConfig; /** * 在初始化时为ServletConfig赋值 * @param config * @throws ServletException */ @Override public void init(ServletConfig config) throws ServletException { this.servletConfig = config; } /** * @param req * @param resp * @throws ServletException * @throws IOException */ @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { //输出ServletConfig System.out.println(servletConfig); } /** * 调用doGet方法 * @param req * @param resp * @throws ServletException * @throws IOException */ @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { doGet(req,resp); } } servletDemo8 com.itheima.web.servlet.ServletDemo8 servletDemo8 /servletDemo8 3.2.2. 2.2.2 如何配置 在上一小节中，我们已经准备好了Servlet，同时也获取到了它的ServletConfig对象，在本小节中我们将告诉同学们如何配置初始化参数，它需要使用标签中的标签来配置。这也就揭秘上一小节的悬念，Servlet的初始化参数都是配置在Servlet的声明部分的。并且每个Servlet都支持有多个初始化参数，并且初始化参数都是以键值对的形式存在的。接下来，我们看配置示例： servletDemo8 com.itheima.web.servlet.ServletDemo8 encoding UTF-8 servletInfo This is Demo8 servletDemo8 /servletDemo8 3.2.3. 2.2.3 常用方法 /** * 演示Servlet的初始化参数对象 * @author 黑马程序员 * @Company http://www.itheima.com */ public class ServletDemo8 extends HttpServlet { //定义Servlet配置对象ServletConfig private ServletConfig servletConfig; /** * 在初始化时为ServletConfig赋值 * @param config * @throws ServletException */ @Override public void init(ServletConfig config) throws ServletException { this.servletConfig = config; } /** * doGet方法输出一句话 * @param req * @param resp * @throws ServletException * @throws IOException */ @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { //1.输出ServletConfig System.out.println(servletConfig); //2.获取Servlet的名称 String servletName= servletConfig.getServletName(); System.out.println(servletName); //3.获取字符集编码 String encoding = servletConfig.getInitParameter(\"encoding\"); System.out.println(encoding); //4.获取所有初始化参数名称的枚举 Enumeration names = servletConfig.getInitParameterNames(); //遍历names while(names.hasMoreElements()){ //取出每个name String name = names.nextElement(); //根据key获取value String value = servletConfig.getInitParameter(name); System.out.println(\"name:\"+name+\",value:\"+value); } //5.获取ServletContext对象 ServletContext servletContext = servletConfig.getServletContext(); System.out.println(servletContext); } /** * 调用doGet方法 * @param req * @param resp * @throws ServletException * @throws IOException */ @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { doGet(req,resp); } } 4. 3 ServletContext 4.1. 3.1 ServletContext概述 4.1.1. 3.1.1 基本介绍 ServletContext对象，它是应用上下文对象。每一个应用有且只有一个ServletContext对象。它可以实现让应用中所有Servlet间的数据共享。 4.1.2. 3.1.2 生命周期 出生——活着——死亡 出生： 应用一加载，该对象就被创建出来了。一个应用只有一个实例对象。(Servlet和ServletContext都是单例的) 活着：只要应用一直提供服务，该对象就一直存在。 死亡：应用被卸载（或者服务器挂了），该对象消亡。 4.1.3. 3.1.3 域对象概念 域对象的概念，它指的是对象有作用域，即有作用范围。 域对象的作用，域对象可以实现数据共享。不同作用范围的域对象，共享数据的能力不一样。 在Servlet规范中，一共有4个域对象。今天我们讲解的ServletContext就是其中一个。它也是我们接触的第一个域对象。它是web应用中最大的作用域，叫application域。每个应用只有一个application域。它可以实现整个应用间的数据共享功能。 4.2. 3.2 ServletContext的使用 4.2.1. 3.2 1 ServletContext介绍 ServletContext 是应用上下文对象。每一个应用中只有一个 ServletContext 对象。 作用：可以获得应用的全局初始化参数和达到 Servlet 之间的数据共享。 生命周期：应用一加载则创建，应用被停止则销毁。 4.2.2. 3.2.2 域对象 域对象指的是对象有作用域。也就是有作用范围。域对象可以实现数据的共享。不同作用范围的域对象，共享数据的能力也不一样。 在 Servlet 规范中，一共有 4 个域对象。ServletContext 就是其中的一个。它也是 web 应用中最大的作用域，也叫 application 域。它可以实现整个应用之间的数据共享！ 4.2.3. 3.2.3 ServletContext配置 ServletContext既然被称之为应用上下文对象，所以它的配置是针对整个应用的配置，而非某个特定Servlet的配置。它的配置被称为应用的初始化参数配置。 配置的方式，需要在标签中使用来配置初始化参数。具体代码如下： servletContextInfo This is application scope globalEncoding UTF-8 4.2.4. 3.2.4 ServletContext常用方法 public class ServletContextDemo extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { //获取ServletContext对象 ServletContext context = getServletContext(); //获取全局配置的globalEncoding String value = context.getInitParameter(\"globalEncoding\"); System.out.println(value); //获取应用的访问虚拟目录 String contextPath = context.getContextPath(); System.out.println(contextPath); //根据虚拟目录获取应用部署的磁盘绝对路径 //获取b.txt文件的绝对路径 String b = context.getRealPath(\"/b.txt\"); System.out.println(b); //获取c.txt文件的绝对路径 String c = context.getRealPath(\"/WEB-INF/c.txt\"); System.out.println(c); //获取a.txt文件的绝对路径 String a = context.getRealPath(\"/WEB-INF/classes/a.txt\"); System.out.println(a); //向域对象中存储数据 context.setAttribute(\"username\",\"zhangsan\"); //移除域对象中username的数据 //context.removeAttribute(\"username\"); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { doGet(req,resp); } } 5. 4 注解开发Servlet 5.1. 4.1 Servlet3.0规范 首先，我们要先跟同学们明确一件事情，我们在《Tomcat和HTTP协议》课程中已经介绍了，我们使用的是Tomcat9，JavaEE规范要求是8，对应的Servlet规范规范应该是JavaEE8包含的4.x版本。 但是，同学们要知道，在企业级应用的开发中，稳定远比追新版本重要的多。所以，我们虽然用到了Tomcat9和对应的JavaEE8，但是涉及的Servlet规范我们降板使用，用的是Servlet3.1版本。关于兼容性问题，同学们也无须担心，向下兼容的特性，在这里也依然适用。 接下来，同学还有可能疑惑的地方就是，我们课程中明明使用的是Servlet3.1版本的规范，但是却总听老师提Servlet3.0规范，这两个到底有怎样的联系呢？ 现在就给同学们解惑，在大概十多年前，那会还是Servlet2.5的版本的天下，它最明显的特征就是Servlet的配置要求配在web.xml中，我们今天课程中在第4章节《注解开发Servlet》之前，全都是基于Servlet2.5规范编写的。从2007年开始到2009年底，在这个时间段，软件开发开始逐步的演变，基于注解的配置理念开始逐渐出现，大量注解配置思想开始用于各种框架的设计中，例如：Spring3.0版本的Java Based Configuration，JPA规范，apache旗下的struts2和mybatis的注解配置开发等等。 JavaEE6规范也是在这个期间设计并推出的，与之对应就是它里面包含了新的Servlet规范：Servlet3.0版本！ 5.2. 4.2 注解开发入门案例 5.2.1. 4.2.1 自动注解配置 1）配置步骤 第一步：创建JavaWeb工程，并移除web.xml 第二步：编写Servlet /** * 注解开发Servlet * @author 黑马程序员 * @Company http://www.itheima.com */ public class ServletDemo1 extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { doPost(req,resp); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { System.out.println(\"Servlet Demo1 Annotation\"); } } 第三步：使用注解配置Servlet 第四步：测试 2）注解详解 /** * WebServlet注解 * @since Servlet 3.0 (Section 8.1.1) */ @Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) @Documented public @interface WebServlet { /** * 指定Servlet的名称。 * 相当于xml配置中标签下的 */ String name() default \"\"; /** * 用于映射Servlet访问的url映射 * 相当于xml配置时的 */ String[] value() default {}; /** * 相当于xml配置时的 */ String[] urlPatterns() default {}; /** * 用于配置Servlet的启动时机 * 相当于xml配置的 */ int loadOnStartup() default -1; /** * 用于配置Servlet的初始化参数 * 相当于xml配置的 */ WebInitParam[] initParams() default {}; /** * 用于配置Servlet是否支持异步 * 相当于xml配置的 */ boolean asyncSupported() default false; /** * 用于指定Servlet的小图标 */ String smallIcon() default \"\"; /** * 用于指定Servlet的大图标 */ String largeIcon() default \"\"; /** * 用于指定Servlet的描述信息 */ String description() default \"\"; /** * 用于指定Servlet的显示名称 */ String displayName() default \"\"; } 5.2.2. 4.2.2 手动创建容器 1）前置说明 在使用Servlet3.1版本的规范时，脱离了web.xml进行注解开发，它除了支持使用注解的配置方式外，还支持纯手动创建Servlet容器的方式。要想使用的话，必须遵循它的编写规范。它是从Servlet3.0规范才开始引入的，加入了一个新的接口： package javax.servlet; import java.util.Set; /** * 初始化Servlet容器必须实现此接口 * 它是Servlet3.0规范提供的标准接口 * @since Servlet 3.0 */ public interface ServletContainerInitializer { /** * 启动容器时做一些初始化操作，例如注册Servlet,Filter,Listener等等。 * @since Servlet 3.0 */ void onStartup(Set> c, ServletContext ctx) throws ServletException; } 同时可以利用@HandlesTypes注解，把要加载到onStartup方法中的类字节码传入进来，@HandlesTypes源码如下： /** * 用于指定要加载到ServletContainerInitializer接口实现了中的字节码 * @see javax.servlet.ServletContainerInitializer * @since Servlet 3.0 */ @Target({ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME) public @interface HandlesTypes { /** * 指定要加载到ServletContainerInitializer实现类的onStartUp方法中类的字节码。 * 字节码可以是接口，抽象类或者普通类。 */ Class[] value(); } 2）编写步骤 第一步：创建工程，并移除web.xml 第二步：编写Servlet /** * 注解开发Servlet 之 手动初始化容器 * @author 黑马程序员 * @Company http://www.itheima.com */ public class ServletDemo1 extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { doPost(req,resp); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { System.out.println(\"Servlet Demo1 Annotation manual\"); } } 第三步：创建初始化容器的类，并按照要求配置 /** * 初始化容器操作 * @author 黑马程序员 * @Company http://www.itheima.com */ public class MyServletContainerInitializer implements ServletContainerInitializer { @Override public void onStartup(Set> c, ServletContext ctx) throws ServletException { } } 在脱离web.xml时，要求在src目录下包含一个META-INF目录，位置和及字母都不能改变，且严格区分大小写。在目录中创建一个名称为javax.servlet.ServletContainerInitializer的文件，里面写实现了ServletContainerInitializer接口的全限定类名。如下图所示： 第四步：编写注册Servlet的代码 第五步：测试 6. 5 Servlet应用案例-学生管理系统 6.1. 5.1 案例介绍 6.1.1. 5.1.1 案例需求 在昨天的课程讲解中，我们用Tomcat服务器替代了SE阶段的学生管理系统中自己写的服务器。今后我们进入企业肯定也会使用成型的产品，而不会自己去写服务器（除非是专门做应用服务器的公司）。 从今天开始案例正式进入了编码阶段，它是延续了JavaSE阶段课程的学生管理系统。并且分析了SE中系统的各类问题，在JavaWeb阶段学习，就是要通过每天的学习，逐步解决SE阶段学生管理系统中的遗留问题。 今天，我们将会去解决下面这个问题：保存学生。也就是让数据真正的动起来，本质就是通过html发送一个请求，把表单中填写的数据带到服务器端。因为每个使用者在表单填写的内容不一样，所有最终存起来的也就不一样了。 6.1.2. 5.1.2 技术选型 这是一个全新的案例，而不是在SE阶段的案例上进行改造。所以我们用项目的方式来去约束这个案例。 任何一个项目，在立项之初都会有技术选型，也就是定义使用的技术集，这里面包含很多。例如：表现层技术，持久层技术，数据库技术等等。 我们今天只针对表现层进行编码，所以就先来定义表现层技术。表现层技术的选型就是Servlet+HTML的组合。 由HTML中编写表单，Servlet中定义接收请求的方法，最终把表单数据输出到控制台即可。我们Servlet的配置方式仍然选择基于web.xml的配置方式。 Copyright © MISIN 2022 | 豫ICP备2021006345号-1 all right reserved，powered by Gitbook该文件修订时间： 2022-11-10 10:43:50 "},"2.JavaWeb/3.JavaWeb核心/3.Request&Response-授课.html":{"url":"2.JavaWeb/3.JavaWeb核心/3.Request&Response-授课.html","title":"3.Request&Response-授课","keywords":"","body":"1. Request&Response-授课2. 1 响应对象2.1. 1.1 响应对象概述2.1.1. 1.1.1 关于响应2.1.2. 1.1.2 常用响应对象2.2. 1.2 常用方法介绍2.3. 1.3 响应对象的使用示例2.3.1. 1.3.1 响应-字节流输出中文问题2.3.2. 1.3.2 响应-字符流输出中文问题2.3.3. 1.3.3 响应-生成验证码2.3.4. 1.3.4 设置响应消息头-控制缓存2.3.5. 1.3.5 设置响应消息头定时刷新2.3.6. 1.3.6 请求重定向：注意地址栏发生改变。2.3.7. 1.3.7 响应和消息头组合应用-文件下载2.3.8. 1.3.8 响应对象注意事项3. 2 请求对象3.1. 2.1 请求对象概述3.1.1. 2.1.1 关于请求3.1.2. 2.1.2 常用请求对象3.2. 2.2 常用方法介绍3.3. 2.3 请求对象的使用示例3.3.1. 2.3.1 请求对象常用方法1-获取各种路径3.3.2. 2.3.2 请求对象常用方法2-获取请求头信息3.3.3. 2.3.3 请求对象常用方法3-获取请求参数（非常重要）3.3.4. 2.3.4 用流的形式读取请求信息3.3.5. 2.3.5请求正文中中文编码问题3.3.6. 2.3.6 请求转发（与重定向的区别）3.3.7. 2.3.7 请求包含3.3.8. 2.3.8 细节问题4. 3 案例中的使用4.1. 3.1 案例的需求及环境4.1.1. 3.1.1 案例需求介绍1. Request&Response-授课 2. 1 响应对象 2.1. 1.1 响应对象概述 2.1.1. 1.1.1 关于响应 响应，它表示了服务器端收到请求，同时也已经处理完成，把处理的结果告知用户。简单来说，指的就是服务器把请求的处理结果告知客户端。在B/S架构中，响应就是把结果带回浏览器。 响应对象，顾名思义就是用于在JavaWeb工程中实现上述功能的对象。 2.1.2. 1.1.2 常用响应对象 响应对象也是是Servlet规范中定义的，它包括了协议无关的和协议相关的。 协议无关的对象标准是：ServletResponse接口 协议相关的对象标准是：HttpServletResponse接口 类结构图如下： 我们课程中涉及的响应对象都是和HTTP协议相关的。即使用的是HttpServletResponse接口的实现类。 这里有些同学可能会产生疑问，我们在使用Servlet时，需要定义一个类，然后实现Servlet接口（或者继承它的实现类）。现在我们想要实现响应功能，要不要定义一个类，然后实现HttpServletResponse接口呢？ 此问题的答案是否定的，我们无需这么做。我们只需要在自己写的Servlet中直接使用即可，因为这个对象的实现类是由Tomcat提供的，无须我们自定义。同时它还会帮我们把对象创建出来并传入doGet和doPost方法中。 2.2. 1.2 常用方法介绍 在HttpServletResponse接口中提供了很多方法，接下来我们通过API文档，来了解一下这些方法。 常用状态码： 状态码 说明 200 执行成功 302 它和307一样，都是用于重定向的状态码。只是307目前已不再使用 304 请求资源未改变，使用缓存。 400 请求错误。最常见的就是请求参数有问题 404 请求资源未找到 405 请求方式不被支持 500 服务器运行内部错误 状态码首位含义： 状态码 说明 1xx 消息 2xx 成功 3xx 重定向 4xx 客户端错误 5xx 服务器错误 2.3. 1.3 响应对象的使用示例 2.3.1. 1.3.1 响应-字节流输出中文问题 /** * @author 黑马程序员 * @Company http://www.itheima.com */ public class ResponseDemo1 extends HttpServlet { /** * 演示字节流输出的乱码问题 */ public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { /** * 问题： * String str = \"字节流中文乱码问题\"; * 使用字节流输出，会不会产生中文乱码？ * 答案： * 会产生乱码 * 原因： * String str = \"字节流中文乱码问题\"; 在保存时用的是IDEA创建文件使用的字符集UTF-8。 * 到浏览器上显示，chrome浏览器和ie浏览器默认的字符集是GB2312(其实就是GBK)，存和取用的不是同一个码表，就会产生乱码。 * * 引申： * 如果产生了乱码，就是存和取用的不是同一个码表 * 解决办法： * 把存和取的码表统一。 */ String str = \"字节流输出中文的乱码问题\";//UTF-8的字符集，此时浏览器显示也需要使用UTF-8的字符集。 //1.拿到字节流输出对象 ServletOutputStream sos = response.getOutputStream(); /** * 解决办法： * 第一种解决办法： * 修改浏览器的编码，使用右键——编码——改成UTF-8。(不推荐使用，我们的应用尽量不要求用户取做什么事情) * ie和火狐浏览器可以直接右键设置字符集。而chrome需要安装插件，很麻烦。 * 第二种解决办法： (不建议使用，因为不好记) * 向页面上输出一个meta标签，内容如下： * 其实它就是指挥了浏览器，使用哪个编码进行显示。 * 第三种解决办法： * 设置响应消息头，告知浏览器响应正文的MIME类型和字符集 * response.setHeader(\"Content-Type\",\"text/html;charset=UTF-8\"); * 第四种解决办法：我们推荐使用的办法 * 它的本质就是设置了一个响应消息头 * response.setContentType(\"text/html;charset=UTF-8\"); */ //第二种解决办法：sos.write(\"\".getBytes()); //第三种解决办法：response.setHeader(\"Content-Type\",\"text/html;charset=UTF-8\"); //第四种解决办法： response.setContentType(\"text/html;charset=UTF-8\"); //2.把str转换成字节数组之后输出到浏览器 sos.write(str.getBytes(\"UTF-8\")); } public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { doGet(request, response); } } 2.3.2. 1.3.2 响应-字符流输出中文问题 /** * @author 黑马程序员 * @Company http://www.itheima.com */ public class ResponseDemo2 extends HttpServlet { /** * 字符流输出中文乱码 * @param request * @param response * @throws ServletException * @throws IOException */ public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { String str = \"字符流输出中文乱码\"; //response.setCharacterEncoding(\"UTF-8\"); //设置响应正文的MIME类型和字符集 response.setContentType(\"text/html;charset=UTF-8\"); //1.获取字符输出流 PrintWriter out = response.getWriter(); //2.使用字符流输出中文 /** * 问题： * out.write(str); 直接输出，会不会产生乱码 * 答案： * 会产生乱码 * 原因： * 存用的什么码表：UTF-8 * 在浏览器取之前，字符流PrintWriter已经获取过一次了，PrintWriter它在取的时候出现了乱码。 * 浏览器取默认用的是GBK。（本地系统字符集） * * UTF-8(存)————>PrintWriter ISO-8859-1(取) 乱 * PrintWirter ISO-8859-1(存)————>浏览器 GBK(取) 乱 * * 解决办法： * 改变PrintWriter的字符集，PrintWriter是从response对象中获取的，其实设置response的字符集。 * 注意：设置response的字符集，需要在拿流之前。 * response.setCharacterEncoding(\"UTF-8\"); * * response.setContentType(\"text/html;charset=UTF-8\"); * 此方法，其实是做了两件事： * 1.设置响应对象的字符集（包括响应对象取出的字符输出流） * 2.告知浏览器响应正文的MIME类型和字符集 */ out.write(str); } public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { doGet(request, response); } } 2.3.3. 1.3.3 响应-生成验证码 /** * @author 黑马程序员 * @Company http://www.itheima.com * */ public class ResponseDemo3 extends HttpServlet { /** * 输出图片 * @param request * @param response * @throws ServletException * @throws IOException */ public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { int width = 200; int height = 35; /** * 实现步骤: * 1.创建图像内存对象 * 2.拿到画笔 * 3.设置颜色，画矩形边框 * 4.设置颜色，填充矩形 * 5.设置颜色，画干扰线 * 6.设置颜色，画验证码 * 7.把内存图像输出到浏览器上 */ //创建内存图像 BufferedImage image = new BufferedImage(width,height,BufferedImage.TYPE_INT_RGB);//参数：宽度，高度 （指的都是像素），使用的格式（RGB） Graphics g = image.getGraphics();//画笔就一根 //设置颜色 g.setColor(Color.BLUE); //画边框 g.drawRect(0, 0, width, height); //设置颜色 g.setColor(Color.GRAY); //填充矩形 g.fillRect(1, 1, width-2, height-2); //设置颜色 g.setColor(Color.WHITE); //拿随机数对象 Random r = new Random(); //画干扰线 10条 for(int i=0;i 2.3.4. 1.3.4 设置响应消息头-控制缓存 /** * 设置缓存时间 * 使用缓存的一般都是静态资源 * 动态资源一般不能缓存。 * 我们现在目前只掌握了Servlet，所以用Servlet做演示 * @author 黑马程序员 * @Company http://www.itheima.com * */ public class ResponseDemo4 extends HttpServlet { public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { String str = \"设置缓存时间\"; /* * 设置缓存时间，其实就是设置响应消息头：Expires 但是值是一个毫秒数。 * 使用的是 * response.setDateHeader(); * * 缓存1小时，是在当前时间的毫秒数上加上1小时之后的毫秒值 */ response.setDateHeader(\"Expires\",System.currentTimeMillis()+1*60*60*1000); response.setContentType(\"text/html;charset=UTF-8\"); response.getOutputStream().write(str.getBytes()); } public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { doGet(request, response); } } 2.3.5. 1.3.5 设置响应消息头定时刷新 /** * 设置响应消息头： * 通过定时刷新演示添加消息头 * @author 黑马程序员 * @Company http://www.itheima.com * */ public class ResponseDemo5 extends HttpServlet { public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { String str = \"用户名和密码不匹配，2秒后转向登录页面...\"; response.setContentType(\"text/html;charset=UTF-8\"); PrintWriter out = response.getWriter(); out.write(str); //定时刷新，其实就是设置一个响应消息头 response.setHeader(\"Refresh\", \"2;URL=/login.html\");//Refresh设置的时间单位是秒，如果刷新到其他地址，需要在时间后面拼接上地址 } public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { doGet(request, response); } } 2.3.6. 1.3.6 请求重定向：注意地址栏发生改变。 /** * 设置响应状态码，实现重定向 * 重定向的特点： * 两次请求，地址栏改变，浏览器行为，xxxx * @author 黑马程序员 * @Company http://www.itheima.com * */ public class ResponseDemo6 extends HttpServlet { public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //1.设置响应状态码 // response.setStatus(302); //2.定向到哪里去: 其实就是设置响应消息头，Location // response.setHeader(\"Location\", \"ResponseDemo7\"); //使用重定向方法 response.sendRedirect(\"ResponseDemo7\");//此行做了什么事，请看上面 } public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { doGet(request, response); } } /** * 重定向的目的地 * @author 黑马程序员 * @Company http://www.itheima.com */ public class ResponseDemo7 extends HttpServlet { public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { response.getWriter().write(\"welcome to ResponseDemo7\"); } public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { doGet(request, response); } } 2.3.7. 1.3.7 响应和消息头组合应用-文件下载 首先，在工程的web目录下新建一个目录uploads，并且拷贝一张图片到目录中，如下图所示： 文件下载的Servlet代码如下： /** * 文件下载 * @author 黑马程序员 * @Company http://www.itheima.com * */ public class ResponseDemo8 extends HttpServlet { public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { /* * 文件下载的思路： * 1.获取文件路径 * 2.把文件读到字节输入流中 * 3.告知浏览器，以下载的方式打开（告知浏览器下载文件的MIME类型） * 4.使用响应对象的字节输出流输出到浏览器上 */ //1.获取文件路径（绝对路径） ServletContext context = this.getServletContext(); String filePath = context.getRealPath(\"/uploads/6.jpg\");//通过文件的虚拟路径，获取文件的绝对路径 //2.通过文件路径构建一个字节输入流 InputStream in = new FileInputStream(filePath); //3.设置响应消息头 response.setHeader(\"Content-Type\", \"application/octet-stream\");//注意下载的时候，设置响应正文的MIME类型，用application/octet-stream response.setHeader(\"Content-Disposition\", \"attachment;filename=1.jpg\");//告知浏览器以下载的方式打开 //4.使用响应对象的字节输出流输出 OutputStream out = response.getOutputStream(); int len = 0; byte[] by = new byte[1024]; while((len = in.read(by)) != -1){ out.write(by, 0, len); } in.close(); } public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { doGet(request, response); } } 2.3.8. 1.3.8 响应对象注意事项 第一： response得到的字符流和字节流互斥，只能选其一 第二：response获取的流不用关闭，由服务器关闭即可 /** * 使用Response对象获取流时候的注意事项： * 1.我们使用response获取的流，可以不用关闭。服务器会给我们关闭。 * 2.在response对象中，字节流和字符流互斥，输出的时候，只能选择一个 * @author zhy * */ public class ResponseDemo9 extends HttpServlet { public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { String str = \"test\"; response.getOutputStream().write(str.getBytes()); //response.getWriter().write(str); // response.getOutputStream().write(\"haha\".getBytes()); } public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { doGet(request, response); } } 3. 2 请求对象 3.1. 2.1 请求对象概述 3.1.1. 2.1.1 关于请求 请求，顾明思议，就是使用者希望从服务器端索取一些资源，向服务器发出询问。在B/S架构中，就是客户浏览器向服务器发出询问。在我们的JavaEE工程中，客户浏览器发出询问，要遵循HTTP协议所规定的。 请求对象，就是在JavaEE工程中，用于发送请求的对象。我们常用的对象就是ServletRequest和HttpServletRequest，它们的区别就是是否和HTTP协议有关。 3.1.2. 2.1.2 常用请求对象 3.2. 2.2 常用方法介绍 3.3. 2.3 请求对象的使用示例 3.3.1. 2.3.1 请求对象常用方法1-获取各种路径 /** * 请求对象的各种信息获取 * @author 黑马程序员 * @Company http://www.itheima.com */ public class RequestDemo1 extends HttpServlet { public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //本机地址：服务器地址 String localAddr = request.getLocalAddr(); //本机名称：服务器名称 String localName = request.getLocalName(); //本机端口：服务器端口 int localPort = request.getLocalPort(); //来访者ip String remoteAddr = request.getRemoteAddr(); //来访者主机 String remoteHost = request.getRemoteHost(); //来访者端口 int remotePort = request.getRemotePort(); //统一资源标识符 String URI = request.getRequestURI(); //统一资源定位符 String URL = request.getRequestURL().toString(); //获取查询字符串 String queryString = request.getQueryString(); //获取Servlet映射路径 String servletPath = request.getServletPath(); //输出内容 System.out.println(\"getLocalAddr() is :\"+localAddr); System.out.println(\"getLocalName() is :\"+localName); System.out.println(\"getLocalPort() is :\"+localPort); System.out.println(\"getRemoteAddr() is :\"+remoteAddr); System.out.println(\"getRemoteHost() is :\"+remoteHost); System.out.println(\"getRemotePort() is :\"+remotePort); System.out.println(\"getRequestURI() is :\"+URI); System.out.println(\"getRequestURL() is :\"+URL); System.out.println(\"getQueryString() is :\"+queryString); System.out.println(\"getServletPath() is :\"+servletPath); } public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { doGet(request, response); } } 3.3.2. 2.3.2 请求对象常用方法2-获取请求头信息 /** * 获取请求消息头 * @author 黑马程序员 * @Company http://www.itheima.com */ public class RequestDemo2 extends HttpServlet { public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //1.根据名称获取头的值 一个消息头一个值 String value = request.getHeader(\"Accept-Encoding\"); System.out.println(\"getHeader():\"+value); //2.根据名称获取头的值 一个头多个值 Enumeration values = request.getHeaders(\"Accept\"); while(values.hasMoreElements()){ System.out.println(\"getHeaders():\"+values.nextElement()); } //3.获取请求消息头的名称的枚举 Enumeration names = request.getHeaderNames(); while(names.hasMoreElements()){ String name = names.nextElement(); String value1 = request.getHeader(name); System.out.println(name+\":\"+value1); } } public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { doGet(request, response); } } 3.3.3. 2.3.3 请求对象常用方法3-获取请求参数（非常重要） 在本小节，我们会讲解HttpServletRequest对象获取请求参数的常用方法，以及把获取到的请求参数封装到实体类中的方式。首先，我们先来创建一个Servlet对象 /** * 封装请求正文到javabean（数据模型） * @author 黑马程序员 * @Company http://www.itheima.com */ public class RequestDemo3 extends HttpServlet { public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { /* * 把下面 * 1）获取请求参数 * 2）封装请求参数到实体类中 * 中定义的test1到test8逐个添加到此处来运行即可。 */ } public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { doGet(request, response); } } 接下来，我们在来准备一个表单页面： login to request demo 3 用户名： 密码： 性别：男 女 现在，我们开始分析HttpServletRequest对象用于获取请求参数的方法： 1）获取请求参数 getParameter()方法的示例代码 /** * 获取请求正文，一个名称对应一个值。 没有使用确认密码 * @param request * @param response * @throws ServletException * @throws IOException */ private void test1(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //1.获取请求正文 String username = request.getParameter(\"username\"); String password = request.getParameter(\"password\"); String gender = request.getParameter(\"gender\"); System.out.println(username+\",\"+password+\",\"+gender); } getParameterValues()方法的示例代码 /** * 获取请求正文，一个名称可能对应多个值 使用了确认密码 * @param request * @param response * @throws ServletException * @throws IOException */ private void test2(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //1.获取请求正文 String username = request.getParameter(\"username\"); String[] password = request.getParameterValues(\"password\");//当表单中有多个名称是一样时，得到是一个字符串数组 String gender = request.getParameter(\"gender\"); System.out.println(username+\",\"+Arrays.toString(password)+\",\"+gender); } login to request demo 4 用户名： 密码： 确认密码： 性别：男 女 getParameterNames()方法的示例代码 /** * 获取请求正文，一个名称一个值。但是先要获取正文名称的枚举（key的枚举） 没有使用确认密码 * @param request * @param response * @throws ServletException * @throws IOException */ private void test3(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //1.获取请求正文名称的枚举 Enumeration names = request.getParameterNames(); //2.遍历正文名称的枚举 while(names.hasMoreElements()){ String name = names.nextElement(); String value = request.getParameter(name); System.out.println(name+\":\"+value); } } 总结： ​ 以上三个方法可以获取表单提交过来的请求参数。 ​ 参数的名称是一个字符串，参数的值可能是一个字符串，也可能是一个字符串数组。 2）封装请求参数到实体类中 我们通过上面的方法可以获取到请求参数，但是如果参数过多，在进行传递时，方法的形参定义将会变得非常难看。此时我们应该用一个对象来描述这些参数，它就是实体类。这种类的定义，从基础阶段我们就开始使用了。在基础阶段，我们做过一个学生管理系统，用到了一个Student的类，它就是用于描述一个学生的实体类。 我们现在要做的就是把表单中提交过来的数据填充到实体类中。 第一种：最简单直接的封装方式 /** * 封装请求正文到User对象中 没有使用确认密码 * @param request * @param response * @throws ServletException * @throws IOException */ private void test4(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //1.获取请求正文 String username = request.getParameter(\"username\"); String password = request.getParameter(\"password\"); String gender = request.getParameter(\"gender\"); //2.创建一个User对象 User user = new User(); System.out.println(\"封装前：\"+user.toString()); //3.把请求正文封装到user对象中 user.setUsername(username); user.setPassword(password); user.setGender(gender); System.out.println(\"封装后：\"+user.toString()); } 第二种：使用反射方式封装 此种封装的使用要求是，表单标签的name属性取值，必须和实体类中定义的属性名称一致。 /** * 封装请求正文到javabean中 没有使用确认密码 * 使用反射+内省实现数据模型的封装 * 内省：是sun公司推出的一套简化反射操作的规范。把javabean中的元素都封装成一个属性描述器。 * 属性描述器中会有字段信息，get和set方法（取值或存值） * @param request * @param response * @throws ServletException * @throws IOException */ private void test5(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //1.获取请求正文名称的枚举 Enumeration names = request.getParameterNames(); User user = new User(); System.out.println(\"封装前：\"+user.toString()); //2.遍历正文名称的枚举 while(names.hasMoreElements()){ String name = names.nextElement(); String value = request.getParameter(name); try{ //1.拿到User对象中的属性描述器。是谁的属性描述器：是由构造函数的第一个参数决定的。第二个参数是指定javabean的字节码 PropertyDescriptor pd = new PropertyDescriptor(name, User.class);//参数指的就是拿哪个类的哪个属性的描述器 //2.设置javabean属性的值 Method method = pd.getWriteMethod(); //3.执行方法 method.invoke(user, value);//第一个参数是指的给哪个对象，第二个参数指的是赋什么值 }catch(Exception e){ e.printStackTrace(); } } System.out.println(\"封装后：\"+user.toString()); } 第三种：使用反射封装，同时请求参数的值是一个数组 此种方式其实就是针对请求参数中包含name属性相同的参数，例如：密码和确认密码，还有爱好。 /** * 获取请求正文的关系映射Map 使用确认密码 * @param request * @param response * @throws ServletException * @throws IOException */ private void test6(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //1.获取请求正文的映射关系 Map map = request.getParameterMap(); //2.遍历集合 for(Map.Entry me : map.entrySet()){ String name = me.getKey(); String[] value = me.getValue(); System.out.println(name+\":\"+Arrays.toString(value)); } } 当我们把请求参数获取出来之后，就要考虑如何针对数组的反射了，具体代码如下： /** * 封装请求正文到javabean。使用的是反射+内省 使用了确认密码 * @param request * @param response * @throws ServletException * @throws IOException */ private void test7(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //1.获取请求正文的映射关系 Map map = request.getParameterMap(); Users user = new Users(); System.out.println(\"封装前：\"+user.toString()); //2.遍历集合 for(Map.Entry me : map.entrySet()){ String name = me.getKey(); String[] value = me.getValue(); try{ //1.拿到User对象中的属性描述器。是谁的属性描述器：是由构造函数的第一个参数决定的。第二个参数是指定javabean的字节码 PropertyDescriptor pd = new PropertyDescriptor(name, Users.class);//参数指的就是拿哪个类的哪个属性的描述器 //2.设置javabean属性的值 Method method = pd.getWriteMethod(); //3.执行方法 //判断参数到底是几个值 if(value.length > 1){//最少有2个元素 method.invoke(user, (Object)value);//第一个参数是指的给哪个对象，第二个参数指的是赋什么值 }else{ method.invoke(user, value);//第一个参数是指的给哪个对象，第二个参数指的是赋什么值 } }catch(Exception e){ e.printStackTrace(); } } System.out.println(\"封装后：\"+user.toString()); } 当我们写完此种封装方式之后，同学们可以发现，我们绝大多数封装都可以使用这段代码来实现。并且，无论是谁来写这段通用的封装代码，其代码内容都是大同小异的。那么，我们就可以得出一个很有趣的结论：一般遇到这种情况时，肯定有人帮我们写好了，我们只需要用就行了。我们后面还会遇到类似这样的情况。 此时，帮我们写好这段封装代码的是apache软件基金会，我们前面学习的tomcat也是它提供的。它里面有一个开源工具包集合commons，里面有很多开源工具类，今天我们就来讲解第一个：commons-beanutils。 第四种：使用apache的commons-beanutils实现封装 实现代码： /** * 终极方法：使用beanutils实现请求正文封装到javabean中 使用了确认密码 * 要想使用beanutils，需要先导包 * @param request * @param response * @throws ServletException * @throws IOException */ private void test8(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { Users user = new Users(); System.out.println(\"封装前：\"+user.toString()); try{ BeanUtils.populate(user, request.getParameterMap());//就这一句话 }catch(Exception e){ e.printStackTrace(); } System.out.println(\"封装后：\"+user.toString()); } 3.3.4. 2.3.4 用流的形式读取请求信息 我们除了使用2.3.3小节中获取请求参数之外，还可以使用下面代码中的 方式来获取： /** * 使用流的方式读取请求正文 * @author 黑马程序员 * @Company http://www.itheima.com */ public class RequestDemo4 extends HttpServlet { public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //1.获取请求正文的字节输入流 ServletInputStream sis = request.getInputStream(); //2.读取流中的数据 int len = 0; byte[] by = new byte[1024]; while((len = sis.read(by)) != -1){ System.out.println(new String(by,0,len)); } } public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { doGet(request, response); } } 3.3.5. 2.3.5请求正文中中文编码问题 关于请求中文乱码问题，我们需要分开讨论，第一是POST请求方式，第二是GET方式。 1）POST方式请求 在POST方式请求中，我们的乱码问题可以用如下代码解决： /** * 请求正文的中文乱码问题 * @author 黑马程序员 * @Company http://www.itheima.com */ public class RequestDemo5 extends HttpServlet { public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //1.获取请求正文 /*POST方式： * 问题： * 取的时候会不会有乱码 * 答案： * 获取请求正文，会有乱码问题。 * 是在获取的时候就已经乱码了。 * 解决办法： * 是request对象的编码出问题了 * 设置request对象的字符集 * request.setCharacterEncoding(\"GBK\");它只能解决POST的请求方式，GET方式解决不了 * 结论： * 请求正文的字符集和响应正文的字符集没有关系。各是各的 */ request.setCharacterEncoding(\"UTF-8\"); String username = request.getParameter(\"username\"); //输出到控制台 System.out.println(username); //输出到浏览器：注意响应的乱码问题已经解决了 response.setContentType(\"text/html;charset=UTF-8\"); PrintWriter out = response.getWriter(); out.write(username); } public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { doGet(request, response); } } 2）GET方式请求 GET方式请求的正文是在地址栏中，在Tomcat8.5版本及以后，Tomcat服务器已经帮我们解决了，所以不会有乱码问题了。 而如果我们使用的不是Tomcat服务器，或者Tomcat的版本是8.5以前，那么GET方式仍然会有乱码问题，解决方式如下：（以下代码了解即可，因为我们现在使用的是Tomcat9.0.27版本） /** * 在Servlet的doGet方法中添加如下代码 */ public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { /* * GET方式：正文在地址栏 * username=%D5%C5%C8%FD * %D5%C5%C8%FD是已经被编过一次码了 * * 解决办法： * 使用正确的码表对已经编过码的数据进行解码。 * 就是把取出的内容转成一个字节数组，但是要使用正确的码表。（ISO-8859-1） * 再使用正确的码表进行编码 * 把字节数组再转成一个字符串，需要使用正确的码表，是看浏览器当时用的是什么码表 */ String username = request.getParameter(\"username\"); byte[] by = username.getBytes(\"ISO-8859-1\"); username = new String(by,\"GBK\"); //输出到浏览器：注意响应的乱码问题已经解决了 response.setContentType(\"text/html;charset=UTF-8\"); PrintWriter out = response.getWriter(); out.write(username); } public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { doGet(request, response); } 3.3.6. 2.3.6 请求转发（与重定向的区别） 在实际开发中，重定向和请求转发都是我们要用到的响应方式，那么他们有什么区别呢？我们通过下面的示例来看一下： /** * 重定向特点： * 两次请求，浏览器行为，地址栏改变，请求域中的数据会丢失 * 请求转发： * 一次请求，服务器行为，地址栏不变，请求域中的数据不丢失 * * 请求域的作用范围： * 当前请求（一次请求）,和当前请求的转发之中 * @author 黑马程序员 * @Company http://www.itheima.com */ public class RequestDemo6 extends HttpServlet { public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //1.拿到请求调度对象 RequestDispatcher rd = request.getRequestDispatcher(\"/RequestDemo7\");//如果是给浏览器看的，/可写可不写。如果是给服务器看的，一般情况下，/都是必须的。 //放入数据到请求域中 request.setAttribute(\"CityCode\", \"bj-010\"); //2.实现真正的转发操作 rd.forward(request, response);//实现真正的转发操作 } public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { doGet(request, response); } } /** * 转发的目的地 * @author 黑马程序员 * @Company http://www.itheima.com */ public class RequestDemo7 extends HttpServlet { public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //获取请求域中的数据 String value = (String)request.getAttribute(\"CityCode\"); response.getWriter().write(\"welcome to request demo 7 \"+value); } public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { doGet(request, response); } } 3.3.7. 2.3.7 请求包含 在实际开发中，我们可能需要把两个Servlet的内容合并到一起来响应浏览器，而同学们都知道HTTP协议的特点是一请求，一响应的方式。所以绝对不可能出现有两个Servlet同时响应方式。那么我们就需要用到请求包含，把两个Servlet的响应内容合并输出。我们看具体使用示例： /** * 请求包含 * * 它是把两个Servlet的响应内容合并输出。 * 注意： * 这种包含是动态包含。 * * 动态包含的特点： * 各编译各的，只是最后合并输出。 * @author 黑马程序员 * @Company http://www.itheima.com */ public class RequestDemo8 extends HttpServlet { public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { response.getWriter().write(\"I am request demo8 \"); //1.拿到请求调度对象 RequestDispatcher rd = request.getRequestDispatcher(\"/RequestDemo9\"); //2.实现包含的操作 rd.include(request, response); } public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { doGet(request, response); } } /** * 被包含者 * @author 黑马程序员 * @Company http://www.itheima.com */ public class RequestDemo9 extends HttpServlet { public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { response.getWriter().write(\"include request demo 9 \"); } public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { doGet(request, response); } } 3.3.8. 2.3.8 细节问题 请求转发的注意事项：负责转发的Servlet，转发前后的响应正文丢失，由转发目的地来响应浏览器。 请求包含的注意事项：被包含者的响应消息头丢失。因为它被包含起来了。 4. 3 案例中的使用 4.1. 3.1 案例的需求及环境 4.1.1. 3.1.1 案例需求介绍 在昨天的课程中，我们实现了浏览器发送请求，由Servlet来接收。今天，我们继续对学生管理系统进行升级，通过Servlet来实现学生的新增，删除，修改，查询操作。 新增：Create 查询：Read 修改：Update 删除：Delete 每个单词取第一个字母，组成了CRUD。所以，同学们今后看到CRUD操作，指的就是增删改查。 今天案例的CRUD，我们只关注Servlet接收请求和处理响应，不用过多的去关注真正增删改查操作（因为，我们目前还是把学生信息写到文件中，等web5天课程结束，我们会讲解数据库，它是我们保存数据这类问题的终极解决方案，而保存文件只是个替代品，我们没必要在替代品处消耗太多精力）。 Copyright © MISIN 2022 | 豫ICP备2021006345号-1 all right reserved，powered by Gitbook该文件修订时间： 2022-11-10 10:44:36 "},"2.JavaWeb/3.JavaWeb核心/4.Cookie&SessionJsp-授课.html":{"url":"2.JavaWeb/3.JavaWeb核心/4.Cookie&SessionJsp-授课.html","title":"4.Cookie&SessionJsp-授课","keywords":"","body":"1. Cookie&SessionJsp-授课2. 1 会话技术2.1. 1.1 会话管理概述2.1.1. 1.1.1 什么是会话2.1.2. 1.1.2 会话管理作用2.1.3. 1.1.3 会话管理分类2.2. 1.2 客户端会话管理技术2.2.1. 1.2.1 Cookie概述2.2.2. 1.2.2 Cookie的Path细节：浏览器什么时候带给服务器，什么时候不带2.3. 1.3 服务端会话管理概述2.3.1. 1.3.1 HttpSession概述2.3.2. 1.3.2 HttpSession的入门案例2.3.3. 1.3.3 HttpSession的钝化和活化3. 2 页面技术3.1. 2.1 JSP基础3.1.1. 2.1.1 JSP简介3.1.2. 2.1.2 JSP和HTML以及Servlet的适用场景3.1.3. 2.1.3 JSP简单入门3.1.4. 2.1.4 JSP说明3.2. 2.2 JSP应用3.2.1. 2.2.1 JSP语法3.2.2. 2.2.2 JSP指令3.2.3. 2.2.3 JSP细节3.2.4. 2.2.4 JSP最佳实战-MVC模型4. 3 综合案例-学生管理系统升级4.1. 3.1 登录功能实现4.1.1. 3.1.1 创建一个web项目，在 web 目录下创建一个 index.jsp。4.1.2. 3.1.2 在 web 目录下创建一个 login.jsp。实现登录页面4.1.3. 3.1.3 创建 LoginStudentServlet，获取用户名和密码4.2. 3.2添加功能实现4.2.1. 3.2.1 在 web 目录下创建一个 addStudent.jsp，实现添加学生的表单项4.2.2. 3.2.2 创建 AddStudentServlet，获取学生信息并保存到文件中4.3. 3.3 查看学生功能4.3.1. 3.3.1 创建 ListStudentServlet，读取文件中的学生信息到集合中4.3.2. 3.3.2 在 web 目录下创建一个 listStudent.jsp1. Cookie&SessionJsp-授课 2. 1 会话技术 2.1. 1.1 会话管理概述 2.1.1. 1.1.1 什么是会话 这里的会话，指的是web开发中的一次通话过程，当打开浏览器，访问网站地址后，会话开始，当关闭浏览器（或者到了过期时间），会话结束。 举个例子： ​ 例如，你在给家人打电话，这时突然有送快递的配送员敲门，你放下电话去开门，收完快递回来后，通话还在保持中，继续说话就行了。 2.1.2. 1.1.2 会话管理作用 什么时候会用到会话管理呢？最常见的就是购物车，当我们登录成功后，把商品加入到购物车之中，此时我们无论再浏览什么商品，当点击购物车时，那些加入的商品都仍在购物车中。 在我们的实际开发中，还有很多地方都离不开会话管理技术。比如，我们在论坛发帖，没有登录的游客身份是不允许发帖的。所以当我们登录成功后，无论我们进入哪个版块发帖，只要权限允许的情况下，服务器都会认识我们，从而让我们发帖，因为登录成功的信息一直保留在服务器端的会话中。 通过上面的两个例子，我们可以看出，它是为我们共享数据用的，并且是在不同请求间实现数据共享。也就是说，如果我们需要在多次请求间实现数据共享，就可以考虑使用会话管理技术了。 2.1.3. 1.1.3 会话管理分类 在JavaEE的项目中，会话管理分为两类。分别是：客户端会话管理技术和服务端会话管理技术。 客户端会话管理技术 ​ 它是把要共享的数据保存到了客户端（也就是浏览器端）。每次请求时，把会话信息带到服务器，从而实现多次请求的数据共享。 服务端会话管理技术 ​ 它本质仍是采用客户端会话管理技术，只不过保存到客户端的是一个特殊的标识，并且把要共享的数据保存到了服务端的内存对象中。每次请求时，把这个标识带到服务器端，然后使用这个标识，找到对应的内存空间，从而实现数据共享。 2.2. 1.2 客户端会话管理技术 2.2.1. 1.2.1 Cookie概述 1）什么是Cookie 它是客户端浏览器的缓存文件，里面记录了客户浏览器访问网站的一些内容。同时，也是HTTP协议请求和响应消息头的一部分（在HTTP协议课程中，我们备注了它很重要）。 2）Cookie的API详解 作用 它可以保存客户浏览器访问网站的相关内容（需要客户端不禁用Cookie）。从而在每次访问需要同一个内容时，先从本地缓存获取，使资源共享，提高效率。 Cookie的属性 属性名称 属性作用 是否重要 name cookie的名称 必要属性 value cookie的值（不能是中文） 必要属性 path cookie的路径 重要 domain cookie的域名 重要 maxAge cookie的生存时间。 重要 version cookie的版本号。 不重要 comment cookie的说明。 不重要 细节 Cookie有大小，个数限制。每个网站最多只能存20个cookie，且大小不能超过4kb。同时，所有网站的cookie总数不超过300个。 当删除Cookie时，设置maxAge值为0。当不设置maxAge时，使用的是浏览器的内存，当关闭浏览器之后，cookie将丢失。设置了此值，就会保存成缓存文件（值必须是大于0的,以秒为单位）。 3）Cookie涉及的常用方法 创建Cookie /** * 通过指定的名称和值构造一个Cookie * * Cookie的名称必须遵循RFC 2109规范。这就意味着，它只能包含ASCII字母数字字符， * 不能包含逗号、分号或空格或以$字符开头。 * 创建后无法更改cookie的名称。 * * 该值可以是服务器选择发送的任何内容。 * 它的价值可能只有服务器才感兴趣。 * 创建之后，可以使用setValue方法更改cookie的值。 */ public Cookie(String name, String value) { validation.validate(name); this.name = name; this.value = value; } 向浏览器添加Cookie /** * 添加Cookie到响应中。此方法可以多次调用，用以添加多个Cookie。 */ public void addCookie(Cookie cookie); 从服务器端获取Cookie /** * 这是HttpServletRequest中的方法。 * 它返回一个Cookie的数组，包含客户端随此请求发送的所有Cookie对象。 * 如果没有符合规则的cookie，则此方法返回null。 */ public Cookie[] getCookies(); 2.2.2. 1.2.2 Cookie的Path细节：浏览器什么时候带给服务器，什么时候不带 1）需求说明 创建一个Cookie，设置Cookie的path，通过不同的路径访问，从而查看请求携带Cookie的情况。 2）案例目的 通过此案例的讲解，同学们可以清晰的描述出，客户浏览器何时带cookie到服务器端，何时不带。 3）案例步骤 第一步：创建JavaWeb工程 沿用第一个案例中的工程即可。 第二步：编写Servlet /** * Cookie的路径问题 * 前期准备： * 1.在demo1中写一个cookie到客户端 * 2.在demo2和demo3中分别去获取cookie * demo1的Servlet映射是 /servlet/PathQuestionDemo1 * demo2的Servlet映射是 /servlet/PathQuestionDemo2 * demo3的Servlet映射是 /PathQuestionDemo3 * * @author 黑马程序员 * @Company http://www.itheima.com * */ public class PathQuestionDemo1 extends HttpServlet { public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //1.创建一个Cookie Cookie cookie = new Cookie(\"pathquestion\",\"CookiePathQuestion\"); //2.设置cookie的最大存活时间 cookie.setMaxAge(Integer.MAX_VALUE); //3.把cookie发送到客户端 response.addCookie(cookie);//setHeader(\"Set-Cookie\",\"cookie的值\") } public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { doGet(request, response); } } /** * 获取Cookie，名称是pathquestion * @author 黑马程序员 * @Company http://www.itheima.com */ public class PathQuestionDemo2 extends HttpServlet { public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //1.获取所有的cookie Cookie[] cs = request.getCookies(); //2.遍历cookie的数组 for(int i=0;cs!=null && i /** * 获取Cookie，名称是pathquestion * @author 黑马程序员 * @Company http://www.itheima.com */ public class PathQuestionDemo3 extends HttpServlet { public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //1.获取所有的cookie Cookie[] cs = request.getCookies(); //2.遍历cookie的数组 for(int i=0;cs!=null && i 第三步：配置Servlet PathQuestionDemo1 com.itheima.web.servlet.pathquestion.PathQuestionDemo1 PathQuestionDemo1 /servlet/PathQuestionDemo1 PathQuestionDemo2 com.itheima.web.servlet.pathquestion.PathQuestionDemo2 PathQuestionDemo2 /servlet/PathQuestionDemo2 PathQuestionDemo3 com.itheima.web.servlet.pathquestion.PathQuestionDemo3 PathQuestionDemo3 /PathQuestionDemo3 第四步：部署工程 沿用第一个案例中的工程部署即可。 4）测试结果 通过分别运行PathQuestionDemo1，2和3这3个Servlet，我们发现由demo1写Cookie，在demo2中可以取到，但是到了demo3中就无法获取了，如下图所示： 5）路径问题的分析及总结 问题： demo2和demo3谁能取到cookie？ 答案： demo2能取到，demo3取不到 分析： 首先，我们要知道如何确定一个cookie？ 那就是使用cookie的三个属性组合：domain+path+name 这里面，同一个应用的domain是一样的，在我们的案例中都是localhost。 ​ 并且，我们取的都是同一个cookie，所以name也是一样的，都是pathquestion。 ​ 那么，不一样的只能是path了。但是我们没有设置过cookie的path属性，这就表明path是有默认值的。 接下来，我们打开这个cookie来看一看，在ie浏览器访问一次PathQuestionDemo1这个Servlet： Cookie中的内容： 我们是通过demo1写的cookie，demo1的访问路径是： http://localhost:9090/servlet/PathQuestionDemo1 通过比较两个路径：请求资源地址和cookie的path，可以看出：cookie的path默认值是：请求资源URI，没有资源的部分（在我们的案例中，就是没有PathQuestionDemo1）。 客户端什么时候带cookie到服务器，什么时候不带？ ​ 就是看请求资源URI和cookie的path比较。 ​ 请求资源URI.startWith(cookie的path) 如果返回的是true就带，如果返回的是false就不带。 ​ 简单的说： 就是看谁的地址更精细 ​ 比如：Cookie的path： /国家 /省份 /城市 请求资源URI : /国家 /省份 不带 请求资源URI ： /国家 /省份 /城市 /区县 带 在我们的案例中： 访问URL URI部分 Cookie的Path 是否携带Cookie 能否取到Cookie PathQuestionDemo2 /servlet/PathQuestionDemo2 /servlet/ 带 能取到 PathQuestionDemo3 /PathQuestionDemo3 /servlet/ 不带 不能取到 2.3. 1.3 服务端会话管理概述 2.3.1. 1.3.1 HttpSession概述 1）HttpSession对象介绍 它是Servlet规范中提供的一个接口。该接口的实现由Servlet规范的实现提供商提供。我们使用的是Tomcat服务器，它对Servlet规范进行了实现，所以HttpSession接口的实现由Tomcat提供。该对象用于提供一种通过多个页面请求或访问网站来标识用户并存储有关该用户的信息的方法。简单说它就是一个服务端会话对象，用于存储用户的会话数据。 同时，它也是Servlet规范中四大域对象之一的会话域对象。并且它也是用于实现数据共享的。但它与我们之前讲解的应用域和请求域是有区别的。 域对象 作用范围 使用场景 ServletContext 整个应用范围 当前项目中需要数据共享时，可以使用此域对象。 ServletRequest 当前请求范围 在请求或者当前请求转发时需要数据共享可以使用此域对象。 HttpSession 会话返回 在当前会话范围中实现数据共享。它可以在多次请求中实现数据共享。 2）HttpSession的获取 获取HttpSession是通过HttpServletRequest接口中的两个方法获取的，如下图所示： 这两个方法的区别： 3）HttpSession的常用方法 2.3.2. 1.3.2 HttpSession的入门案例 1）需求说明 在请求HttpSessionDemo1这个Servlet时，携带用户名信息，并且把信息保存到会话域中，然后从HttpSessionDemo2这个Servlet中获取登录信息。 2）案例目的 通过本案例的讲解，同学们可以清楚的认识到会话域的作用，即多次请求间的数据共享。因为是两次请求，请求域肯定不一样了，所以不能用请求域实现。 最终掌握HttpSession对象的获取和使用。 3）原理分析 HttpSession，它虽然是服务端会话管理技术的对象，但它本质仍是一个Cookie。是一个由服务器自动创建的特殊的Cookie，Cookie的名称就是JSESSIONID，Cookie的值是服务器分配的一个唯一的标识。 当我们使用HttpSession时，浏览器在没有禁用Cookie的情况下，都会把这个Cookie带到服务器端，然后根据唯一标识去查找对应的HttpSession对象，找到了，我们就可以直接使用了。下图就是我们入门案例中，HttpSession分配的唯一标识，同学们可以看到两次请求的JSESSIONID的值是一样的： 2.3.3. 1.3.3 HttpSession的钝化和活化 什么是持久态 ​ 把长时间不用，但还不到过期时间的HttpSession进行序列化，写到磁盘上。 ​ 我们把HttpSession持久态也叫做钝化。（与钝化相反的，我们叫活化。） 什么时候使用持久化 ​ 第一种情况：当访问量很大时，服务器会根据getLastAccessTime来进行排序，对长时间不用，但是还没到过期时间的HttpSession进行持久化。 ​ 第二种情况：当服务器进行重启的时候，为了保持客户HttpSession中的数据，也要对HttpSession进行持久化 注意 ​ HttpSession的持久化由服务器来负责管理，我们不用关心。 ​ 只有实现了序列化接口的类才能被序列化，否则不行。 3. 2 页面技术 3.1. 2.1 JSP基础 3.1.1. 2.1.1 JSP简介 JSP全称是Java Server Page，它和Servlet一样，也是sun公司推出的一套开发动态web资源的技术，称为JSP/Servlet规范。JSP的本质其实就是一个Servlet。 3.1.2. 2.1.2 JSP和HTML以及Servlet的适用场景 类别 适用场景 HTML 只能开发静态资源，不能包含java代码，无法添加动态数据。 Servlet 写java代码，可以输出页面内容，但是很不方便，开发效率极低。 JSP 它包括了HTML的展示技术，同时具备Servlet输出动态资源的能力。但是不适合作为控制器来用。 3.1.3. 2.1.3 JSP简单入门 创建JavaWeb工程 在index.jsp中填写内容 JSP的入门 这是第一个JSP页面 部署项目 沿用会话管理工程的部署方式即可。 测试运行 3.1.4. 2.1.4 JSP说明 写在之前： 明确JSP就是一个Servlet。是一个特殊的Servlet。 JSP的原理： ​ 客户端提交请求 ​ ——Tomcat服务器解析请求地址 ​ ——找到JSP页面 ​ ——Tomcat将JSP页面翻译成Servlet的java文件 ​ ——将翻译好的.java文件编译成.class文件 ​ ——返回到客户浏览器上。 1）执行过程分析图 2）JSP的.java文件内容分析 当我们打开index.jsp翻译的java文件看到的就是public final class index_jsp extends org.apache.jasper.runtime.HttpJspBase类的声明，然后我们在Tomcat的源码中找到类的声明，如下图： 这张图一出场，就表明我们写的JSP它本质就是一个HttpServlet了。 同时，我们在index_jsp.java文件中找到了输出页面的代码，并且在浏览器端查看源文件，看到的内容是一样的。这也就是说明，我们的浏览器上的内容，在通过jsp展示时，本质都是用out.write()输出出来的。 讲到这里，我们应该清楚的认识到，JSP它是一个特殊的Servlet，主要是用于展示动态数据。它展示的方式是用流把数据输出出来，而我们在使用JSP时，涉及HTML的部分，都与HTML的用法一致，这部分称为jsp中的模板元素，在开发过程中，先写好这些模板元素，因为它们决定了页面的外观。 3.2. 2.2 JSP应用 3.2.1. 2.2.1 JSP语法 1）Java代码块 在jsp中，可以使用java脚本代码。形式为： 但是，在实际开发中，极少使用此种形式编写java代码。同时需要注意的是： 示例： 2）JSP表达式 在jsp中，可以使用特定表达式语法，形式为： jsp在翻译完后是out.print(表达式内容); 所以：和是一样的。 在实际开发中，这种表达式语法用的也很少使用。 示例： 就相当于 3）JSP声明 在JSP中也可以声明一些变量，方法，静态方法，形式为： 使用JSP声明需要注意： 示例： 4）JSP注释 在使用JSP时，它有自己的注释，形式为： 需要注意的是： ​ 在Jsp中可以使用html的注释，但是只能注释html元素，不能注释java程序片段和表达式。同时，被html注释部分会参与翻译，并且会在浏览器上显示 ​ jsp的注释不仅可以注释java程序片段，也可以注释html元素，并且被jsp注释的部分不会参与翻译成.java文件，也不会在浏览器上显示。 示例： 5）语法的示例 JSP语法完整示例代码 JSP语法 就相当于 JSP语法运行结果 3.2.2. 2.2.2 JSP指令 1）page指令 language:告知引擎，脚本使用的是java，默认是java，支持java。不写也行。 extends：告知引擎，JSP对应的Servlet的父类是哪个，不需要写，也不需要改。 import：告知引擎，导入哪些包（类）。 ​ 注意：引擎会自动导入：java.lang.*,javax.servlet.*,javax.servlet.http.*,javax.servlet.jsp.* ​ 导入的形式： ​ 或者： ​ ​ 用Eclipse：Alt+/ 自动导入 session：告知引擎是否产生HttpSession对象，即是否在代码中调用request.getSession()。默认是true。 buffer：JspWriter用于输出JSP内容到页面上。告知引擎，设定他的缓存大小。默认8kb。 errorPage：告知引擎，当前页面出现异常后，应该转发到哪个页面上（路径写法：/代表当前应用） ​ 小贴士：当在errorpage上使用了isErrorPage=true之后，ie8有时候不能正常显示 ​ 配置全局错误页面：web.xml java.lang.Exception /error.jsp 404 /404.html ​ 当使用了全局错误页面，就无须再写errorPage来实现转到错误页面，而是由服务器负责跳转到错误页面。 isErrorPage：告知引擎，是否抓住异常。如果该属性为true，页面中就可以使用exception对象，打印异常的详细信息。默认值是false。 contentType：告知引擎，响应正文的MIME类型。contentType=\"text/html;charset=UTF-8\" ​ 相当于response.setContentType(\"text/html;charset=UTF-8\"); pageEncoding：告知引擎，翻译jsp时（从磁盘上读取jsp文件）所用的码表。pageEncoding=\"UTF-8\"相当于告知引擎用UTF-8读取JSP isELIgnored*：告知引擎，是否忽略EL表达式，默认值是false，不忽略。 2）include指令 语法格式：该指令是包含外部页面。 属性：file，以/开头，就代表当前应用。 使用示例 静态包含的特点 3）taglib指令 语法格式： 作用：该指令用于引入外部标签库。html标签和jsp标签不用引入。 属性： ​ uri：外部标签的URI地址。 ​ prefix：使用标签时的前缀。 3.2.3. 2.2.3 JSP细节 1）九大隐式对象 什么是隐式对象呢？它指的是在jsp中，可以不声明就直接使用的对象。它只存在于jsp中，因为java类中的变量必须要先声明再使用。其实jsp中的隐式对象也并非是未声明，只是它是在翻译成.java文件时声明的。所以我们在jsp中可以直接使用。 隐式对象名称 类型 备注 request javax.servlet.http.HttpServletRequest response javax.servlet.http.HttpServletResponse session javax.servlet.http.HttpSession Page指令可以控制开关 application javax.servlet.ServletContext page Java.lang.Object 当前jsp对应的servlet引用实例 config javax.servlet.ServletConfig exception java.lang.Throwable page指令有开关 out javax.servlet.jsp.JspWriter 字符输出流，相当于printwriter pageContext javax.servlet.jsp.PageContext 很重要 2）PageContext对象 简介 它是JSP独有的对象，Servlet中没有这个对象。本身也是一个域（作用范围）对象，但是它可以操作其他3个域对象中的属性。而且还可以获取其他8个隐式对象。 生命周期 它是一个局部变量，所以它的生命周期随着JSP的创建而诞生，随着JSP的结束而消失。每个JSP页面都有一个独立的PageContext。 常用方法 在上图中，同学们发现没有页面域操作的方法，其实是定义在了PageContext的父类JspContext中，如下图所示： 3）四大域对象 域对象名称 范围 级别 备注 PageContext 页面范围 最小，只能在当前页面用 因范围太小，开发中用的很少 ServletRequest 请求范围 一次请求或当期请求转发用 当请求转发之后，再次转发时请求域丢失 HttpSession 会话范围 多次请求数据共享时使用 多次请求共享数据，但不同的客户端不能共享 ServletContext 应用范围 最大，整个应用都可以使用 尽量少用，如果对数据有修改需要做同步处理 3.2.4. 2.2.4 JSP最佳实战-MVC模型 Servlet：擅长处理业务逻辑，不擅长输出显示界面。在web开发中多用于控制程序逻辑（流程）。所以我们称之为：控制器。 JSP：擅长显示界面，不擅长处理程序逻辑。在web开发中多用于展示动态界面。所以我们称之为：视图。 例如: M：model ，通常用于封装数据，封装的是数据模型。 V：view ，通常用于展示数据。动态展示用jsp页面，静态数据展示用html。 C：controller ，通常用于处理请求和响应。一般指的是Servlet。 4. 3 综合案例-学生管理系统升级 4.1. 3.1 登录功能实现 4.1.1. 3.1.1 创建一个web项目，在 web 目录下创建一个 index.jsp。 学生管理系统首页 请登录 添加学生 查看学生 4.1.2. 3.1.2 在 web 目录下创建一个 login.jsp。实现登录页面 学生登录 姓名： 密码： 登录 4.1.3. 3.1.3 创建 LoginStudentServlet，获取用户名和密码 package com.itheima.servlet; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; /* 学生登录 */ @WebServlet(\"/loginStudentServlet\") public class LoginStudentServlet extends HttpServlet{ @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { //1.获取用户名和密码 String username = req.getParameter(\"username\"); String password = req.getParameter(\"password\"); //2.判断用户名 if(username == null || \"\".equals(username)) { //2.1用户名为空 重定向到登录页面 resp.sendRedirect(\"/stu/login.jsp\"); return; } //2.2用户名不为空 将用户名存入会话域中 req.getSession().setAttribute(\"username\",username); //3.重定向到首页index.jsp resp.sendRedirect(\"/stu/index.jsp\"); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { doGet(req,resp); } } 4.2. 3.2添加功能实现 4.2.1. 3.2.1 在 web 目录下创建一个 addStudent.jsp，实现添加学生的表单项 添加学生 学生姓名： 学生年龄： 学生成绩： 保存 4.2.2. 3.2.2 创建 AddStudentServlet，获取学生信息并保存到文件中 package com.itheima.servlet; import com.itheima.bean.Student; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.BufferedWriter; import java.io.FileWriter; import java.io.IOException; /* 实现添加功能 */ @WebServlet(\"/addStudentServlet\") public class AddStudentServlet extends HttpServlet{ @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { //1.获取表单中的数据 String username = req.getParameter(\"username\"); String age = req.getParameter(\"age\"); String score = req.getParameter(\"score\"); //2.创建学生对象并赋值 Student stu = new Student(); stu.setUsername(username); stu.setAge(Integer.parseInt(age)); stu.setScore(Integer.parseInt(score)); //3.将学生对象的数据保存到d:\\\\stu.txt文件中 BufferedWriter bw = new BufferedWriter(new FileWriter(\"d:\\\\stu.txt\",true)); bw.write(stu.getUsername() + \",\" + stu.getAge() + \",\" + stu.getScore()); bw.newLine(); bw.close(); //4.通过定时刷新功能响应给浏览器 resp.setContentType(\"text/html;charset=UTF-8\"); resp.getWriter().write(\"添加成功。2秒后自动跳转到首页...\"); resp.setHeader(\"Refresh\",\"2;URL=/stu/index.jsp\"); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { doGet(req,resp); } } 4.3. 3.3 查看学生功能 4.3.1. 3.3.1 创建 ListStudentServlet，读取文件中的学生信息到集合中 1、将集合添加到会话域中 2、重定向到 listStudent.jsp 页面上 package com.itheima.servlet; import com.itheima.bean.Student; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.BufferedReader; import java.io.FileReader; import java.io.IOException; import java.util.ArrayList; /* 实现查看功能 */ @WebServlet(\"/listStudentServlet\") public class ListStudentServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { //1.创建字符输入流对象，关联读取的文件 BufferedReader br = new BufferedReader(new FileReader(\"d:\\\\stu.txt\")); //2.创建集合对象，用于保存Student对象 ArrayList list = new ArrayList<>(); //3.循环读取文件中的数据，将数据封装到Student对象中。再把多个学生对象添加到集合中 String line; while((line = br.readLine()) != null) { //张三,23,95 Student stu = new Student(); String[] arr = line.split(\",\"); stu.setUsername(arr[0]); stu.setAge(Integer.parseInt(arr[1])); stu.setScore(Integer.parseInt(arr[2])); list.add(stu); } //4.将集合对象存入会话域中 req.getSession().setAttribute(\"students\",list); //5.重定向到学生列表页面 resp.sendRedirect(\"/stu/listStudent.jsp\"); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { doGet(req,resp); } } 4.3.2. 3.3.2 在 web 目录下创建一个 listStudent.jsp 查看学生 学生姓名 学生年龄 学生成绩 students = (ArrayList) session.getAttribute(\"students\"); for(Student stu : students) { %> Copyright © MISIN 2022 | 豫ICP备2021006345号-1 all right reserved，powered by Gitbook该文件修订时间： 2022-12-15 18:45:13 "},"2.JavaWeb/3.JavaWeb核心/5.EL&Filter&Listener-授课.html":{"url":"2.JavaWeb/3.JavaWeb核心/5.EL&Filter&Listener-授课.html","title":"5.EL&Filter&Listener-授课","keywords":"","body":"1. 1 EL表达式和JSTL1.1. 1.1 EL表达式1.1.1. 1.1.1 EL表达式概述1.1.2. 1.1.2 EL表达式的入门案例1.1.3. 1.1.2 EL表达式基本用法1.1.4. 1.1.3 EL表达式的11个隐式对象1.2. 1.2 JSTL1.2.1. 1.2.1 JSTL概述1.2.2. 1.2.2 核心标签库1.2.3. 1.2.3 JSTL使用2. 2 Servlet规范中的过滤器-Filter2.1. 2.1 过滤器入门2.1.1. 2.1.1 过滤器概念及作用2.1.2. 2.1.2 过滤器的入门案例2.2. 2.2 过滤器的细节2.2.1. 2.2.1 过滤器API介绍2.2.2. 2.2.2 入门案例过程及生命周期2.2.3. 2.2.3 过滤器初始化参数配置2.2.4. 2.2.5 多个过滤器的执行顺序2.2.5. 2.2.6 过滤器的五种拦截行为2.2.6. 2.2.4 过滤器与Servlet的区别2.3. 2.3 过滤器的使用案例2.3.1. 2.3.1 静态资源设置缓存时间过滤器2.3.2. 2.3.2 特殊字符过滤器3. 3 Servlet规范中的监听器-Listener3.1. 3.1 观察者设计模式3.2. 3.1 Servlet规范中的8个监听器简介3.2.1. 3.1.1 监听对象创建的3.2.2. 3.1.2 监听域中属性发生变化的3.2.3. 3.1.3 和会话相关的两个感知型监听器3.3. 3.2 监听器的使用3.3.1. 3.2.1 ServletContextListener的使用3.3.2. 3.2.2 ServletContextAttributeListener的使用4. 4 综合案例-学生管理系统改造4.1. 4.1 需求说明4.1.1. 4.1.1 解决乱码问题4.1.2. 4.1.2 检查登录4.1.3. 4.1.3 页面的java代码块和jsp表达式改造4.2. 4.2 案例实现4.2.1. 4.2.1 乱码问题过滤器4.2.2. 4.2.2 检查登录过滤器4.2.3. 4.2.3 jsp页面的改造EL&Filter&Listener-授课 1. 1 EL表达式和JSTL 1.1. 1.1 EL表达式 1.1.1. 1.1.1 EL表达式概述 基本概念 EL表达式，全称是Expression Language。意为表达式语言。它是Servlet规范中的一部分，是JSP2.0规范加入的内容。其作用是用于在JSP页面中获取数据，从而让我们的JSP脱离java代码块和JSP表达式。 基本语法 EL表达式的语法格式非常简单，写为 ${表达式内容} 例如：在浏览器中输出请求域中名称为message的内容。 假定，我们在请求域中存入了一个名称为message的数据（request.setAttribute(\"message\",\"EL\");），此时在jsp中获取的方式，如下表显示： Java代码块 JSP表达式 EL表达式 String message = (String)request.getAttribute(\"message\"); out.write(message);%> ${message} 通过上面我们可以看出，都可以从请求域中获取数据，但是EL表达式写起来是最简单的方式。这也是以后我们在实际开发中，当使用JSP作为视图时，绝大多数都会采用的方式。 1.1.2. 1.1.2 EL表达式的入门案例 第一步：创建JavaWeb工程 第二步：创建jsp页面 第三步：在JSP页面中编写代码 EL表达式入门案例 Java代码块获取： JSP表达式获取： EL表达式获取：${message} 第四步：部署工程 第五步：运行测试 1.1.3. 1.1.2 EL表达式基本用法 在前面的概述介绍中，我们介绍了EL表达式的作用，它就是用于获取数据的，那么它是从哪获取数据呢？ 1）获取四大域中的数据 它只能从四大域中获取数据，调用的就是findAttribute(name,value);方法，根据名称由小到大逐个域中查找，找到就返回，找不到就什么都不显示。 它可以获取对象，可以是对象中关联其他对象，可以是一个List集合，也可以是一个Map集合。具体代码如下： 创建两个实体类，User和Address /** * 用户的实体类 * @author 黑马程序员 * @Company http://www.itheima.com */ public class User implements Serializable{ private String name = \"黑马程序员\"; private int age = 18; private Address address = new Address(); public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public Address getAddress() { return address; } public void setAddress(Address address) { this.address = address; } } /** * 地址的实体类 * @author 黑马程序员 * @Company http://www.itheima.com */ public class Address implements Serializable { private String province = \"北京\"; private String city = \"昌平区\"; public String getProvince() { return province; } public void setProvince(String province) { this.province = province; } public String getCity() { return city; } public void setCity(String city) { this.city = city; } } JSP代码 EL入门 -----------获取对象数据--------------------- ${u}===============输出的是内存地址 --%> ${u.name} --%> ${u.age} -----------获取关联对象数据------------------ ${u.address}==========输出的address对象的地址 ${u.address.province}${u.address.city} ${u[\"address\"]['province']} -----------获取数组数据--------------------- ${strs[0]}==========取的数组中下标为0的元素 ${strs[3]} ${strs[5]}===========如果超过了数组的下标，则什么都不显示 ${strs[\"2\"]}=========会自动为我们转换成下标 ${strs['1']} -----------获取List集合数据----------------- list = new ArrayList(); list.add(\"AAA\"); list.add(\"BBB\"); list.add(\"CCC\"); list.add(\"DDD\"); pageContext.setAttribute(\"list\", list); %> ${list} ${list[0] } ${list[3] } -----------获取Map集合数据------------------ map = new HashMap(); map.put(\"aaa\",new User()); pageContext.setAttribute(\"map\", map); %> ${map} ${map.aaa} ${map.aaa.name}${map.aaa.age} ${map[\"aaa\"].name } 运行结果如图： 2）EL表达式的注意事项 在使用EL表达式时，它帮我们做了一些处理，使我们在使用时可以避免一些错误。它没有空指针异常，没有数组下标越界，没有字符串拼接。 EL表达式的注意事项 第一个：没有空指针异常 ${testNull} 第二个：没有数组下标越界 取第一个元素：${strs[0]} 取第六个元素：${strs[5]} 第三个：没有字符串拼接 ${strs[0]}+${strs[1]} 运行结果图： \\ 3）EL表达式的使用细节 EL表达式除了能在四大域中获取数据，同时它可以访问其他隐式对象，并且访问对象有返回值的方法. 4）EL表达式的运算符 EL表达式中运算符如下图所示，它们都是一目了然的： 但是有两个特殊的运算符，使用方式的代码如下： EL两个特殊的运算符 slist = new ArrayList(); pageContext.setAttribute(\"str\", str); pageContext.setAttribute(\"str1\", str1); pageContext.setAttribute(\"slist\", slist); %> ${empty str}============当对象为null返回true ${empty str1 }==========当字符串为空字符串是返回true(注意：它不会调用trim()方法) ${empty slist}==========当集合中的元素是0个时，是true 男 女 运行结果图： 1.1.4. 1.1.3 EL表达式的11个隐式对象 1）隐式对象介绍 EL表达式也为我们提供隐式对象，可以让我们不声明直接来使用，十一个对象见下表，需要注意的是，它和JSP的隐式对象不是一回事： EL中的隐式对象 类型 对应JSP隐式对象 备注 PageContext Javax.serlvet.jsp.PageContext PageContext 完全一样 ApplicationScope Java.util.Map 没有 应用层范围 SessionScope Java.util.Map 没有 会话范围 RequestScope Java.util.Map 没有 请求范围 PageScope Java.util.Map 没有 页面层范围 Header Java.util.Map 没有 请求消息头key，值是value（一个） HeaderValues Java.util.Map 没有 请求消息头key，值是数组（一个头多个值） Param Java.util.Map 没有 请求参数key，值是value（一个） ParamValues Java.util.Map 没有 请求参数key，值是数组（一个名称多个值） InitParam Java.util.Map 没有 全局参数，key是参数名称，value是参数值 Cookie Java.util.Map 没有 Key是cookie的名称，value是cookie对象 1.2. 1.2 JSTL 1.2.1. 1.2.1 JSTL概述 1）简介 JSTL的全称是：JSP Standard Tag Libary。它是JSP中标准的标签库。它是由Apache实现的。 它由以下5个部分组成： 组成 作用 说明 Core 核心标签库。 通用逻辑处理 Fmt 国际化有关。 需要不同地域显示不同语言时使用 Functions EL函数 EL表达式可以使用的方法 SQL 操作数据库。 不用 XML 操作XML。 不用 2）使用要求 要想使用JSTL标签库，在javaweb工程中需要导入坐标。首先是在工程的WEB-INF目录中创建一个lib目录，接下来把jstl的jar拷贝到lib目录中，最后在jar包上点击右键，然后选择【Add as Libary】添加。如下图所示： 1.2.2. 1.2.2 核心标签库 在我们实际开发中，用到的jstl标签库主要以核心标签库为准，偶尔会用到国际化标签库的标签。下表中把我们经常可能用到的标签列在此处，其余标签库请同学们参考【JSTL标签库.doc】文档。 标签名称 功能分类 分类 作用 流程控制 核心标签库 用于判断 ,, 流程控制 核心标签库 用于多个条件判断 迭代操作 核心标签库 用于循环遍历 1.2.3. 1.2.3 JSTL使用 JSTL的常用标签 优秀 一般 AAA BBB CCC DDD 其他 list = new ArrayList(); list.add(\"AAA\"); list.add(\"BBB\"); list.add(\"CCC\"); list.add(\"DDD\"); list.add(\"EEE\"); list.add(\"FFF\"); list.add(\"GGG\"); list.add(\"HHH\"); list.add(\"III\"); list.add(\"JJJ\"); list.add(\"KKK\"); list.add(\"LLL\"); pageContext.setAttribute(\"list\",list); %> ${s} ${num} 索引 序号 信息 ${vs.index} ${vs.count} ${s} 2. 2 Servlet规范中的过滤器-Filter 2.1. 2.1 过滤器入门 2.1.1. 2.1.1 过滤器概念及作用 过滤器——Filter，它是JavaWeb三大组件之一。另外两个是Servlet和Listener。 它是在2000年发布的Servlet2.3规范中加入的一个接口。是Servlet规范中非常实用的技术。 它可以对web应用中的所有资源进行拦截，并且在拦截之后进行一些特殊的操作。 常见应用场景：URL级别的权限控制；过滤敏感词汇；中文乱码问题等等。 2.1.2. 2.1.2 过滤器的入门案例 1）前期准备 创建JavaWeb工程 编写和配置接收请求用的Servlet /** * 用于接收和处理请求的Servlet * @author 黑马程序员 * @Company http://www.itheima.com */ public class ServletDemo1 extends HttpServlet { /** * 处理请求的方法 * @param req * @param resp * @throws ServletException * @throws IOException */ @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { System.out.println(\"ServletDemo1接收到了请求\"); req.getRequestDispatcher(\"/WEB-INF/pages/success.jsp\").forward(req,resp); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { doGet(req,resp); } } ServletDemo1 com.itheima.web.servlet.ServletDemo1 ServletDemo1 /ServletDemo1 编写index.jsp 主页面 访问ServletDemo1 编写success.jsp 成功页面 执行成功！ 2）过滤器的编写步骤 编写过滤器 /** * Filter的入门案例 * @author 黑马程序员 * @Company http://www.itheima.com */ public class FilterDemo1 implements Filter { /** * 过滤器的核心方法 * @param request * @param response * @param chain * @throws IOException * @throws ServletException */ @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { /** * 如果不写此段代码，控制台会输出两次：FilterDemo1拦截到了请求。 */ HttpServletRequest req = (HttpServletRequest) request; String requestURI = req.getRequestURI(); if (requestURI.contains(\"favicon.ico\")) { return; } System.out.println(\"FilterDemo1拦截到了请求\"); } } 配置过滤器 FilterDemo1 com.itheima.web.filter.FilterDemo1 FilterDemo1 /* 3）测试部署 部署项目 测试结果 案例的问题分析及解决 当我们启动服务，在地址栏输入访问地址后，发现浏览器任何内容都没有，控制台却输出了【FilterDemo1拦截到了请求】，也就是说在访问任何资源的时候，都先经过了过滤器。 这是因为：我们在配置过滤器的拦截规则时，使用了/*,表明访问当前应用下任何资源，此过滤器都会起作用。除了这种全部过滤的规则之外，它还支持特定类型的过滤配置。我们可以稍作调整，就可以不用加上面那段过滤图标的代码了。修改的方式如下： 现在的问题是，我们拦截下来了，点击链接发送请求，运行结果是： 需要对过滤器执行放行操作，才能让他继续执行，那么如何放行的？ 我们需要使用FilterChain中的doFilter方法放行。 2.2. 2.2 过滤器的细节 2.2.1. 2.2.1 过滤器API介绍 1）Filter 2）FilterConfig 3）FilterChain 2.2.2. 2.2.2 入门案例过程及生命周期 1）生命周期 出生——活着——死亡 出生：当应用加载的时候执行实例化和初始化方法。 活着：只要应用一直提供服务，对象就一直存在。 死亡：当应用卸载时，或者服务器宕机时，对象消亡。 Filter的实例对象在内存中也只有一份。所以也是单例的。 2）过滤器核心方法的细节 在FilterDemo1的doFilter方法添加一行代码，如下： /** * 过滤器的核心方法 * @param request * @param response * @param chain * @throws IOException * @throws ServletException */ @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { /** * 如果不写此段代码，控制台会输出两次：FilterDemo1拦截到了请求。 HttpServletRequest req = (HttpServletRequest) request; String requestURI = req.getRequestURI(); if (requestURI.contains(\"favicon.ico\")) { return; }*/ System.out.println(\"FilterDemo1拦截到了请求\"); //过滤器放行 chain.doFilter(request,response); System.out.println(\"FilterDemo1放行之后，又回到了doFilter方法\"); } 测试运行结果，我们发现过滤器放行之后执行完目标资源，仍会回到过滤器中： 2.2.3. 2.2.3 过滤器初始化参数配置 1）创建过滤器FilterDemo2 /** * Filter的初始化参数配置 * @author 黑马程序员 * @Company http://www.itheima.com */ public class FilterDemo2 implements Filter { private FilterConfig filterConfig; /** * 初始化方法 * @param filterConfig * @throws ServletException */ @Override public void init(FilterConfig filterConfig) throws ServletException { System.out.println(\"FilterDemo2的初始化方法执行了\"); //给过滤器配置对象赋值 this.filterConfig = filterConfig; } /** * 过滤器的核心方法 * @param request * @param response * @param chain * @throws IOException * @throws ServletException */ @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { System.out.println(\"FilterDemo2拦截到了请求\"); //过滤器放行 chain.doFilter(request,response); } /** * 销毁方法 */ @Override public void destroy() { System.out.println(\"FilterDemo2的销毁方法执行了\"); } } 2）配置FilterDemo2 FilterDemo2 com.itheima.web.filter.FilterDemo2 filterInitParamName filterInitParamValue FilterDemo2 /ServletDemo1 3）在FilterDemo2的doFilter方法中添加下面的代码 //根据名称获取过滤器的初始化参数 String paramValue = filterConfig.getInitParameter(\"filterInitParamName\"); System.out.println(paramValue); //获取过滤器初始化参数名称的枚举 Enumeration initNames = filterConfig.getInitParameterNames(); while(initNames.hasMoreElements()){ String initName = initNames.nextElement(); String initValue = filterConfig.getInitParameter(initName); System.out.println(initName+\",\"+initValue); } //获取ServletContext对象 ServletContext servletContext = filterConfig.getServletContext(); System.out.println(servletContext); //获取过滤器名称 String filterName = filterConfig.getFilterName(); System.out.println(filterName); 4）测试运行结果 我们通过这个测试，看到了过滤器的初始化参数配置和获取的使用。但是同学们也肯定发现了，在我们的工程中两个过滤器都起作用了，这就是我们在API中说的链式调用，那么当有多个过滤器，它的执行顺序是什么样的呢？ 我们来看下一小节。 2.2.4. 2.2.5 多个过滤器的执行顺序 1）修改FilterDemo1和FilterDemo2两个过滤器的代码，删掉多余的代码 /** * Filter的入门案例 * @author 黑马程序员 * @Company http://www.itheima.com */ public class FilterDemo1 implements Filter { /** * 过滤器的核心方法 * @param request * @param response * @param chain * @throws IOException * @throws ServletException */ @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { System.out.println(\"FilterDemo1拦截到了请求\"); //过滤器放行 chain.doFilter(request,response); } /** * 初始化方法 * @param filterConfig * @throws ServletException */ @Override public void init(FilterConfig filterConfig) throws ServletException { System.out.println(\"FilterDemo1的初始化方法执行了\"); } /** * 销毁方法 */ @Override public void destroy() { System.out.println(\"FilterDemo1的销毁方法执行了\"); } } /** * Filter的初始化参数配置 * @author 黑马程序员 * @Company http://www.itheima.com */ public class FilterDemo2 implements Filter { /** * 初始化方法 * @param filterConfig * @throws ServletException */ @Override public void init(FilterConfig filterConfig) throws ServletException { System.out.println(\"FilterDemo2的初始化方法执行了\"); } /** * 过滤器的核心方法 * @param request * @param response * @param chain * @throws IOException * @throws ServletException */ @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { System.out.println(\"FilterDemo2拦截到了请求\"); //过滤器放行 chain.doFilter(request,response); } /** * 销毁方法 */ @Override public void destroy() { System.out.println(\"FilterDemo2的销毁方法执行了\"); } } 2）修改两个过滤器的配置，删掉多余的配置 FilterDemo1 com.itheima.web.filter.FilterDemo1 FilterDemo1 /ServletDemo1 FilterDemo2 com.itheima.web.filter.FilterDemo2 FilterDemo2 /ServletDemo1 3）测试运行结果 此处我们看到了多个过滤器的执行顺序，它正好和我们在web.xml中的配置顺序一致，如下图： 在过滤器的配置中，有过滤器的声明和过滤器的映射两部分，到底是声明决定顺序，还是映射决定顺序呢？ 答案是：的配置前后顺序决定过滤器的调用顺序，也就是由映射配置顺序决定。 2.2.5. 2.2.6 过滤器的五种拦截行为 我们的过滤器目前拦截的是请求，但是在实际开发中，我们还有请求转发和请求包含，以及由服务器触发调用的全局错误页面。默认情况下过滤器是不参与过滤的，要想使用，需要我们配置。配置的方式如下： FilterDemo1 com.itheima.web.filter.FilterDemo1 true FilterDemo1 /ServletDemo1 REQUEST ERROR FORWARD INCLUDE ASYNC 2.2.6. 2.2.4 过滤器与Servlet的区别 方法/类型 Servlet Filter 备注 初始化 方法 void init(ServletConfig); void init(FilterConfig); 几乎一样，都是在web.xml中配置参数，用该对象的方法可以获取到。 提供服务方法 void service(request,response); void dofilter(request,response,FilterChain); Filter比Servlet多了一个FilterChain，它不仅能完成Servlet的功能，而且还可以决定程序是否能继续执行。所以过滤器比Servlet更为强大。 在Struts2中，核心控制器就是一个过滤器。 销毁方法 void destroy(); void destroy(); 2.3. 2.3 过滤器的使用案例 2.3.1. 2.3.1 静态资源设置缓存时间过滤器 1） 需求说明 在我们访问html，js，image时，不需要每次都重新发送请求读取资源，就可以通过设置响应消息头的方式，设置缓存时间。但是如果每个Servlet都编写相同的代码，显然不符合我们统一调用和维护的理念。（此处有个非常重要的编程思想：AOP思想，在录制视频时提不提都可以） 因此，我们要采用过滤器来实现功能。 2） 编写步骤 第一步：创建JavaWeb工程 第二步：导入静态资源 第三步：编写过滤器 /** * 静态资源设置缓存时间 * html设置为1小时 * js设置为2小时 * css设置为3小时 * @author 黑马程序员 * @Company http://www.itheima.com */ public class StaticResourceNeedCacheFilter implements Filter { private FilterConfig filterConfig; public void init(FilterConfig filterConfig) throws ServletException { this.filterConfig = filterConfig; } public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) throws IOException, ServletException { //1.把doFilter的请求和响应对象转换成跟http协议有关的对象 HttpServletRequest request; HttpServletResponse response; try { request = (HttpServletRequest) req; response = (HttpServletResponse) res; } catch (ClassCastException e) { throw new ServletException(\"non-HTTP request or response\"); } //2.获取请求资源URI String uri = request.getRequestURI(); //3.得到请求资源到底是什么类型 String extend = uri.substring(uri.lastIndexOf(\".\")+1);//我们只需要判断它是不是html,css,js。其他的不管 //4.判断到底是什么类型的资源 long time = 60*60*1000; if(\"html\".equals(extend)){ //html 缓存1小时 String html = filterConfig.getInitParameter(\"html\"); time = time*Long.parseLong(html); }else if(\"js\".equals(extend)){ //js 缓存2小时 String js = filterConfig.getInitParameter(\"js\"); time = time*Long.parseLong(js); }else if(\"css\".equals(extend)){ //css 缓存3小时 String css = filterConfig.getInitParameter(\"css\"); time = time*Long.parseLong(css); } //5.设置响应消息头 response.setDateHeader(\"Expires\", System.currentTimeMillis()+time); //6.放行 chain.doFilter(request, response); } public void destroy() { } } 第四步：配置过滤器 StaticResourceNeedCacheFilter com.itheima.web.filter.StaticResourceNeedCacheFilter html 3 js 4 css 5 StaticResourceNeedCacheFilter *.html StaticResourceNeedCacheFilter *.js StaticResourceNeedCacheFilter *.css 3） 测试结果 此案例演示时需要注意一下，chrome浏览器刷新时，每次也都会发送请求，所以看不到304状态码。建议用IE浏览器，因为它在刷新时不会再次请求。 2.3.2. 2.3.2 特殊字符过滤器 1）需求说明 在实际开发中，可能会面临一个问题，就是很多输入框都会遇到特殊字符。此时，我们也可以通过过滤器来解决。 例如： ​ 我们模拟一个论坛，有人发帖问：“在HTML中表示水平线的标签是哪个？”。 如果我们在文本框中直接输入就会出现一条水平线，这个会让发帖人一脸懵。 我们接下来就用过滤器来解决一下。 2）编写步骤 第一步：创建JavaWeb工程 沿用第一个案例的工程 第二步：编写Servlet和JSP /** * @author 黑马程序员 * @Company http://www.itheima.com */ public class ServletDemo1 extends HttpServlet { public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { String content = request.getParameter(\"content\"); response.getWriter().write(content); } public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { doGet(request, response); } } ServletDemo1 com.itheima.web.servlet.ServletDemo1 ServletDemo1 /ServletDemo1 回帖： 第三步：编写过滤器 /** * @author 黑马程序员 * @Company http://www.itheima.com */ public class HTMLFilter implements Filter { public void init(FilterConfig filterConfig) throws ServletException { } public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) throws IOException, ServletException { HttpServletRequest request; HttpServletResponse response; try { request = (HttpServletRequest) req; response = (HttpServletResponse) res; } catch (ClassCastException e) { throw new ServletException(\"non-HTTP request or response\"); } //创建一个自己的Request类 MyHttpServletRequest2 myrequest = new MyHttpServletRequest2(request); //放行： chain.doFilter(myrequest, response); } public void destroy() { } } class MyHttpServletRequest2 extends HttpServletRequestWrapper { //提供一个构造方法 public MyHttpServletRequest2(HttpServletRequest request){ super(request); } //重写getParameter方法 public String getParameter(String name) { //1.获取出请求正文： 调用父类的获取方法 String value = super.getParameter(name); //2.判断value是否有值 if(value == null){ return null; } return htmlfilter(value); } private String htmlfilter(String message){ if (message == null) return (null); char content[] = new char[message.length()]; message.getChars(0, message.length(), content, 0); StringBuilder result = new StringBuilder(content.length + 50); for (int i = 0; i ': result.append(\"&gt;\"); break; case '&': result.append(\"&amp;\"); break; case '\"': result.append(\"&quot;\"); break; default: result.append(content[i]); } } return (result.toString()); } } 第四步：配置过滤器 HTMLFilter com.itheima.web.filter.HTMLFilter HTMLFilter /* 3）测试结果 3. 3 Servlet规范中的监听器-Listener 3.1. 3.1 观察者设计模式 在介绍监听器之前，先跟同学们普及一个知识，观察者设计模式。因为所有的监听器都是观察者设计模式的体现。 那什么是观察者设计模式呢？ 它是事件驱动的一种体现形式。就好比在做什么事情的时候被人盯着。当对应做到某件事时，触发事件。 观察者模式通常由以下三部分组成： ​ 事件源：触发事件的对象。 ​ 事件：触发的动作，里面封装了事件源。 ​ 监听器：当事件源触发事件时，要做的事情。一般是一个接口，由使用者来实现。（此处的思想还涉及了一个涉及模式，我们在JDBC的第二天课程中就给同学们讲解，策略模式） 下图描述了观察者设计模式组成： 3.2. 3.1 Servlet规范中的8个监听器简介 3.2.1. 3.1.1 监听对象创建的 1）ServletContextListener /** * 用于监听ServletContext对象创建和销毁的监听器 * @since v 2.3 */ public interface ServletContextListener extends EventListener { /** * 对象创建时执行此方法。该方法的参数是ServletContextEvent事件对象，事件是【创建对象】这个动作 * 事件对象中封装着触发事件的来源，即事件源，就是ServletContext */ public default void contextInitialized(ServletContextEvent sce) { } /** * 对象销毁执行此方法 */ public default void contextDestroyed(ServletContextEvent sce) { } } 2）HttpSessionListener /** * 用于监听HttpSession对象创建和销毁的监听器 * @since v 2.3 */ public interface HttpSessionListener extends EventListener { /** * 对象创建时执行此方法。 */ public default void sessionCreated(HttpSessionEvent se) { } /** * 对象销毁执行此方法 */ public default void sessionDestroyed(HttpSessionEvent se) { } } 3）ServletRequestListener /** * 用于监听ServletRequest对象创建和销毁的监听器 * @since Servlet 2.4 */ public interface ServletRequestListener extends EventListener { /** * 对象创建时执行此方法。 */ public default void requestInitialized (ServletRequestEvent sre) { } /** * 对象销毁执行此方法 */ public default void requestDestroyed (ServletRequestEvent sre) { } } 3.2.2. 3.1.2 监听域中属性发生变化的 1）ServletContextAttributeListener /** * 用于监听ServletContext域（应用域）中属性发生变化的监听器 * @since v 2.3 */ public interface ServletContextAttributeListener extends EventListener { /** * 域中添加了属性触发此方法。参数是ServletContextAttributeEvent事件对象，事件是【添加属性】。 * 事件对象中封装着事件源，即ServletContext。 * 当ServletContext执行setAttribute方法时，此方法可以知道，并执行。 */ public default void attributeAdded(ServletContextAttributeEvent scae) { } /** * 域中删除了属性触发此方法 */ public default void attributeRemoved(ServletContextAttributeEvent scae) { } /** * 域中属性发生改变触发此方法 */ public default void attributeReplaced(ServletContextAttributeEvent scae) { } } 2）HttpSessionAttributeListener /** * 用于监听HttpSession域（会话域）中属性发生变化的监听器 * @since v 2.3 */ public interface HttpSessionAttributeListener extends EventListener { /** * 域中添加了属性触发此方法。 */ public default void attributeAdded(HttpSessionBindingEvent se) { } /** * 域中删除了属性触发此方法 */ public default void attributeRemoved(HttpSessionBindingEvent se) { } /** * 域中属性发生改变触发此方法 */ public default void attributeReplaced(HttpSessionBindingEvent se) { } } 3）ServletRequestAttributeListener /** * 用于监听ServletRequest域（请求域）中属性发生变化的监听器 * @since Servlet 2.4 */ public interface ServletRequestAttributeListener extends EventListener { /** * 域中添加了属性触发此方法。 */ public default void attributeAdded(ServletRequestAttributeEvent srae) { } /** * 域中删除了属性触发此方法 */ public default void attributeRemoved(ServletRequestAttributeEvent srae) { } /** * 域中属性发生改变触发此方法 */ public default void attributeReplaced(ServletRequestAttributeEvent srae) { } } 3.2.3. 3.1.3 和会话相关的两个感知型监听器 此处要跟同学们明确一下，和会话域相关的两个感知型监听器是无需配置的，直接编写代码即可。 1）HttpSessionBinderListener /** * 用于感知对象和和会话域绑定的监听器 * 当有数据加入会话域或从会话域中移除，此监听器的两个方法会执行。 * 加入会话域即和会话域绑定 * 从会话域移除即从会话域解绑 */ public interface HttpSessionBindingListener extends EventListener { /** * 当数据加入会话域时，也就是绑定，此方法执行 */ public default void valueBound(HttpSessionBindingEvent event) { } /** * 当从会话域移除时，也就是解绑，此方法执行 */ public default void valueUnbound(HttpSessionBindingEvent event) { } } 2）HttpSessionActivationListener /** * 用于感知会话域中对象钝化和活化的监听器 */ public interface HttpSessionActivationListener extends EventListener { /** * 当会话域中的数据钝化时，此方法执行 */ public default void sessionWillPassivate(HttpSessionEvent se) { } /** * 当会话域中的数据活化时（激活），此方法执行 */ public default void sessionDidActivate(HttpSessionEvent se) { } } 3.3. 3.2 监听器的使用 在实际开发中，我们可以根据具体情况来从这8个监听器中选择使用。感知型监听器由于无需配置，只需要根据实际需求编写代码，所以此处我们就不再演示了。我们在剩余6个中分别选择一个监听对象创建销毁和对象域中属性发生变化的监听器演示一下。 3.3.1. 3.2.1 ServletContextListener的使用 第一步：创建工程 第二步：编写监听器 /** * 用于监听ServletContext对象创建和销毁的监听器 * @author 黑马程序员 * @Company http://www.itheima.com */ public class ServletContextListenerDemo implements ServletContextListener { /** * 对象创建时，执行此方法 * @param sce */ @Override public void contextInitialized(ServletContextEvent sce) { System.out.println(\"监听到了对象的创建\"); //1.获取事件源对象 ServletContext servletContext = sce.getServletContext(); System.out.println(servletContext); } /** * 对象销毁时，执行此方法 * @param sce */ @Override public void contextDestroyed(ServletContextEvent sce) { System.out.println(\"监听到了对象的销毁\"); } } 第三步：在web.xml中配置监听器 com.itheima.web.listener.ServletContextListenerDemo 第四步：测试结果 3.3.2. 3.2.2 ServletContextAttributeListener的使用 第一步：创建工程 沿用上一个案例的工程 第二步：编写监听器 /** * 监听域中属性发生变化的监听器 * @author 黑马程序员 * @Company http://www.itheima.com */ public class ServletContextAttributeListenerDemo implements ServletContextAttributeListener { /** * 域中添加了数据 * @param scae */ @Override public void attributeAdded(ServletContextAttributeEvent scae) { System.out.println(\"监听到域中加入了属性\"); /** * 由于除了我们往域中添加了数据外，应用在加载时还会自动往域中添加一些属性。 * 我们可以获取域中所有名称的枚举，从而看到域中都有哪些属性 */ //1.获取事件源对象ServletContext ServletContext servletContext = scae.getServletContext(); //2.获取域中所有名称的枚举 Enumeration names = servletContext.getAttributeNames(); //3.遍历名称的枚举 while(names.hasMoreElements()){ //4.获取每个名称 String name = names.nextElement(); //5.获取值 Object value = servletContext.getAttribute(name); //6.输出名称和值 System.out.println(\"name is \"+name+\" and value is \"+value); } } /** * 域中移除了数据 * @param scae */ @Override public void attributeRemoved(ServletContextAttributeEvent scae) { System.out.println(\"监听到域中移除了属性\"); } /** * 域中属性发生了替换 * @param scae */ @Override public void attributeReplaced(ServletContextAttributeEvent scae) { System.out.println(\"监听到域中属性发生了替换\"); } } 同时，我们还需要借助第一个ServletContextListenerDemo监听器，往域中存入数据，替换域中的数据以及从域中移除数据，代码如下： /** * 用于监听ServletContext对象创建和销毁的监听器 * @author 黑马程序员 * @Company http://www.itheima.com */ public class ServletContextListenerDemo implements ServletContextListener { /** * 对象创建时，执行此方法 * @param sce */ @Override public void contextInitialized(ServletContextEvent sce) { System.out.println(\"监听到了对象的创建\"); //1.获取事件源对象 ServletContext servletContext = sce.getServletContext(); //2.往域中加入属性 servletContext.setAttribute(\"servletContext\",\"test\"); } /** * 对象销毁时，执行此方法 * @param sce */ @Override public void contextDestroyed(ServletContextEvent sce) { //1.取出事件源对象 ServletContext servletContext = sce.getServletContext(); //2.往域中加入属性，但是名称仍采用servletContext，此时就是替换 servletContext.setAttribute(\"servletContext\",\"demo\"); System.out.println(\"监听到了对象的销毁\"); //3.移除属性 servletContext.removeAttribute(\"servletContext\"); } } 第三步：在web.xml中配置监听器 com.itheima.web.listener.ServletContextListenerDemo com.itheima.web.listener.ServletContextAttributeListenerDemo 第四步：测试结果 4. 4 综合案例-学生管理系统改造 4.1. 4.1 需求说明 4.1.1. 4.1.1 解决乱码问题 我们的学生管理系统中，肯定会有请求和响应的中文乱码问题。而乱码问题在学习Servlet的课程中已经讲解了如何解决了。只是在实际开发中，当有很多的Servlet时，肯定不能在每个Servlet中都编写一遍解决乱码的代码。因此，就可以利用我们今天学习的过滤器来实现统一解决请求和响应乱码的问题。 4.1.2. 4.1.2 检查登录 在学生管理系统中，它包含了学生信息的录入和学生列表的查询，用户（员工）信息的录入以及查询。当然，我们实际的功能可能远远不止这些。但是就已有功能来说，也不是谁都可以通过地址栏直接输入访问的，它应该有权限的控制，只是我们课程在此处没法深入展开讲解权限，但最起码的登录，身份的认证还是必要的。 由此，就引出来一个问题，是在每次访问Servlet时，在Servlet的代码中加入是否认证过身份的判断吗？显然，是不合理的。那么，既然不是在每个Servlet中编写，就应该是统一管理和维护。此时，我们的过滤器就又可以出场了。 4.1.3. 4.1.3 页面的java代码块和jsp表达式改造 我们今天除了学习了过滤器，还学习了EL表达式和JSTL标签库，它们的出现就是避免我们的JSP页面中有过多的java代码或者jsp表达式。我们要运用今天所学知识改造页面。 4.2. 4.2 案例实现 4.2.1. 4.2.1 乱码问题过滤器 创建EncodingFilter类，解决乱码 package com.itheima.filter; import javax.servlet.Filter; import javax.servlet.FilterChain; import javax.servlet.ServletRequest; import javax.servlet.ServletResponse; import javax.servlet.annotation.WebFilter; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; /* 解决全局乱码问题 */ @WebFilter(\"/*\") public class EncodingFilter implements Filter{ @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) { try{ //1.将请求和响应对象转换为和HTTP协议相关 HttpServletRequest request = (HttpServletRequest) servletRequest; HttpServletResponse response = (HttpServletResponse) servletResponse; //2.设置编码格式 request.setCharacterEncoding(\"UTF-8\"); response.setContentType(\"text/html;charset=UTF-8\"); //3.放行 filterChain.doFilter(request,response); } catch (Exception e) { e.printStackTrace(); } } } 4.2.2. 4.2.2 检查登录过滤器 检查登录，创建LoginFilter 类 package com.itheima.filter; import javax.servlet.Filter; import javax.servlet.FilterChain; import javax.servlet.ServletRequest; import javax.servlet.ServletResponse; import javax.servlet.annotation.WebFilter; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; /* 检查登录 */ @WebFilter(value = {\"/addStudent.jsp\",\"/listStudentServlet\"}) public class LoginFilter implements Filter{ @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) { try{ //1.将请求和响应对象转换为和HTTP协议相关 HttpServletRequest request = (HttpServletRequest) servletRequest; HttpServletResponse response = (HttpServletResponse) servletResponse; //2.获取会话域对象中数据 Object username = request.getSession().getAttribute(\"username\"); //3.判断用户名 if(username == null || \"\".equals(username)) { //重定向到登录页面 response.sendRedirect(request.getContextPath() + \"/login.jsp\"); return; } //4.放行 filterChain.doFilter(request,response); } catch (Exception e) { e.printStackTrace(); } } } 4.2.3. 4.2.3 jsp页面的改造 ​ 1，修改addStudent.jsp的虚拟访问路径 学生姓名： 学生年龄： 学生成绩： 保存 2，修改index.jsp 学生管理系统首页 请登录 添加学生 查看学生 3，修改listStudent.jsp 查看学生 学生姓名 学生年龄 学生成绩 ${s.username} ${s.age} ${s.score} 4，修改login.jsp 学生登录 姓名： 密码： 登录 Copyright © MISIN 2022 | 豫ICP备2021006345号-1 all right reserved，powered by Gitbook该文件修订时间： 2022-11-10 10:47:18 "},"2.JavaWeb/4.mysql/MySQL基础-01-授课笔记.html":{"url":"2.JavaWeb/4.mysql/MySQL基础-01-授课笔记.html","title":"MySQL基础-01-授课笔记","keywords":"","body":"1. MySQL基础-01-授课笔记1.1.1. 一、数据库的基本概念1.1.2. 二、MySQL数据库的介绍和安装1.1.3. 三、SQL语句1.1.4. 四、约束1. MySQL基础-01-授课笔记 1.1.1. 一、数据库的基本概念 1.为什么要学数据库？ 之前我们如果想将一些数据实现永久化存储，可以怎么做呢？没错。使用IO流的技术将数据保存到本地文件中 但是接下来我有这样一个需求：将下面的user.txt文件中的王五年龄修改为35 张三 23 男 李四 24 男 王五 25 女 赵六 26 女 周七 27 男 我们要如何实现呢？ 可以采用字符缓冲流，将每一行数据读取出来，封装为User对象。将多个User对象保存到集合中 然后遍历集合，将王五对象的年龄修改为35,再重新将集合中的对象信息写回到文件中 这一套操作太麻烦了，而现在我们有一种更加方便的方式来完成这个需求了，这种方式就是数据库！ 2.什么是数据库？ 用于存储和管理数据的仓库 英文单词为：DataBase，简称DB 3.数据库的好处？ 可以持久化存储数据 方便存储和管理数据 使用了统一的方式操作数据库 -- SQL 4.常见的数据库有哪些？ 1.1.2. 二、MySQL数据库的介绍和安装 1.MySQL数据库介绍 小型的数据库 开源免费(6版本之前免费) 所属于Oracle公司 2.MySQL数据库安装 通过secureCRT工具连接Linux系统 上传 mysql 的安装包 alt + p -------> put d:/setup/mysql-5.7.27-1.el7.x86_64.rpm-bundle.tar 解压 mysql 的安装包 mkdir mysql tar -xvf mysql-5.7.27-1.el7.x86_64.rpm-bundle.tar -C mysql/ 安装客户端 cd mysql/ rpm -ivh mysql-community-client-5.7.27-1.el7.x86_64.rpm --force --nodeps 安装服务端 rpm -ivh mysql-community-server-5.7.27-1.el7.x86_64.rpm --force --nodeps 修改mysql默认字符集 vi /etc/my.cnf 添加如下内容： [mysqld] character-set-server=utf8 collation-server=utf8_general_ci -- 需要在最下方填写 [client] default-character-set=utf8 启动mysql服务 service mysqld start 登录mysql mysql -u root -p 敲回车，输入密码 初始密码查看：cat /var/log/mysqld.log 在root@localhost: 后面的就是初始密码 修改mysql登录密码 set global validate_password_policy=0; set global validate_password_length=1; set password=password('密码'); 授予远程连接权限 //授权 grant all privileges on *.* to 'root' @'%' identified by '密码'; //刷新 flush privileges; 关闭Linux系统防火墙 systemctl stop firewalld.service 3.MySQL数据库登录 sqlyog工具登录mysql 1.1.3. 三、SQL语句 1.数据库、数据表、数据的关系介绍 数据库 用于存储和管理数据的仓库 一个库中可以包含多个数据表 数据表 数据库最重要的组成部分之一 它由纵向的列和横向的行组成(类似excel表格) 可以指定列名、数据类型、约束等 一个表中可以存储多条数据 数据 想要永久化存储的数据 2.SQL介绍 什么是SQL Structured Query Language：结构化查询语言 其实就是定义了操作所有关系型数据库的规则。每一种数据库操作的方式可能会存在一些不一样的地方，我们称为“方言”。 SQL通用语法 SQL 语句可以单行或多行书写，以分号结尾。 可使用空格和缩进来增强语句的可读性。 MySQL 数据库的 SQL 语句不区分大小写，关键字建议使用大写。 数据库的注释： 单行注释：-- 注释内容 #注释内容(mysql特有) 多行注释：/ 注释内容 / SQL分类 DDL(Data Definition Language)数据定义语言 用来定义数据库对象：数据库，表，列等。关键字：create, drop,alter 等 DML(Data Manipulation Language)数据操作语言 用来对数据库中表的数据进行增删改。关键字：insert, delete, update 等 DQL(Data Query Language)数据查询语言 用来查询数据库中表的记录(数据)。关键字：select, where 等 DCL(Data Control Language)数据控制语言(了解) 用来定义数据库的访问权限和安全级别，及创建用户。关键字：GRANT， REVOKE 等 3.DDL-操作数据库 R(Retrieve)：查询 查询所有数据库 -- 查询所有数据库 SHOW DATABASES; 查询某个数据库的创建语句 -- 标准语法 SHOW CREATE DATABASE 数据库名称; -- 查看mysql数据库的创建格式 SHOW CREATE DATABASE mysql; C(Create)：创建 创建数据库 -- 标准语法 CREATE DATABASE 数据库名称; -- 创建db1数据库 CREATE DATABASE db1; -- 创建一个已存在的数据库会报错 -- 错误代码：1007 Can't create database 'db1'; database exists CREATE DATABASE db1; 创建数据库(判断，如果不存在则创建) -- 标准语法 CREATE DATABASE IF NOT EXISTS 数据库名称; -- 创建数据库db2(判断，如果不存在则创建) CREATE DATABASE IF NOT EXISTS db2; 创建数据库、并指定字符集 -- 标准语法 CREATE DATABASE 数据库名称 CHARACTER SET 字符集名称; -- 创建数据库db3、并指定字符集utf8 CREATE DATABASE db3 CHARACTER SET utf8; -- 查看db3数据库的字符集 SHOW CREATE DATABASE db3; 练习：创建db4数据库、如果不存在则创建，指定字符集为gbk -- 创建db4数据库、如果不存在则创建，指定字符集为gbk CREATE DATABASE IF NOT EXISTS db4 CHARACTER SET gbk; -- 查看db4数据库的字符集 SHOW CREATE DATABASE db4; U(Update)：修改 修改数据库的字符集 -- 标准语法 ALTER DATABASE 数据库名称 CHARACTER SET 字符集名称; -- 修改数据库db4的字符集为utf8 ALTER DATABASE db4 CHARACTER SET utf8; -- 查看db4数据库的字符集 SHOW CREATE DATABASE db4; D(Delete)：删除 删除数据库 -- 标准语法 DROP DATABASE 数据库名称; -- 删除db1数据库 DROP DATABASE db1; -- 删除一个不存在的数据库会报错 -- 错误代码：1008 Can't drop database 'db1'; database doesn't exist DROP DATABASE db1; 删除数据库(判断，如果存在则删除) -- 标准语法 DROP DATABASE IF EXISTS 数据库名称; -- 删除数据库db2，如果存在 DROP DATABASE IF EXISTS db2; 使用数据库 查询当前正在使用的数据库名称 -- 查询当前正在使用的数据库 SELECT DATABASE(); 使用数据库 -- 标准语法 USE 数据库名称； -- 使用db4数据库 USE db4; 4.DDL-操作数据表 R(Retrieve)：查询 查询数据库中所有的数据表 -- 使用mysql数据库 USE mysql; -- 查询库中所有的表 SHOW TABLES; 查询表结构 -- 标准语法 DESC 表名; -- 查询user表结构 DESC user; 查询表字符集 -- 标准语法 SHOW TABLE STATUS FROM 库名 LIKE '表名'; -- 查看mysql数据库中user表字符集 SHOW TABLE STATUS FROM mysql LIKE 'user'; C(Create)：创建 创建数据表 标准语法 CREATE TABLE 表名( 列名1 数据类型1, 列名2 数据类型2, .... 列名n 数据类型n ); -- 注意：最后一列，不需要加逗号 数据类型 1. int：整数类型 * age int 2. double:小数类型 * score double(5,2) * price double 3. date:日期，只包含年月日 yyyy-MM-dd 4. datetime:日期，包含年月日时分秒 yyyy-MM-dd HH:mm:ss 5. timestamp:时间戳类型 包含年月日时分秒 yyyy-MM-dd HH:mm:ss * 如果将来不给这个字段赋值，或赋值为null，则默认使用当前的系统时间，来自动赋值 6. varchar：字符串 * name varchar(20):姓名最大20个字符 * zhangsan 8个字符 张三 2个字符 创建数据表 -- 使用db3数据库 USE db3; -- 创建一个product商品表 CREATE TABLE product( id INT, -- 商品编号 NAME VARCHAR(30), -- 商品名称 price DOUBLE, -- 商品价格 stock INT, -- 商品库存 insert_time DATE -- 上架时间 ); 复制表 -- 标准语法 CREATE TABLE 表名 LIKE 被复制的表名; -- 复制product表到product2表 CREATE TABLE product2 LIKE product; U(Update)：修改 修改表名 -- 标准语法 ALTER TABLE 表名 RENAME TO 新的表名; -- 修改product2表名为product3 ALTER TABLE product2 RENAME TO product3; 修改表的字符集 -- 标准语法 ALTER TABLE 表名 CHARACTER SET 字符集名称; -- 查看db3数据库中product3数据表字符集 SHOW TABLE STATUS FROM db3 LIKE 'product3'; -- 修改product3数据表字符集为gbk ALTER TABLE product3 CHARACTER SET gbk; -- 查看db3数据库中product3数据表字符集 SHOW TABLE STATUS FROM db3 LIKE 'product3'; 添加一列 -- 标准语法 ALTER TABLE 表名 ADD 列名 数据类型; -- 给product3表添加一列color ALTER TABLE product3 ADD color VARCHAR(10); 修改列名称和数据类型 ```mysql -- 修改数据类型 标准语法 ALTER TABLE 表名 MODIFY 列名 新数据类型; -- 将color数据类型修改为int ALTER TABLE product3 MODIFY color INT; -- 查看product3表详细信息 DESC product3; -- 修改列名和数据类型 标准语法 ALTER TABLE 表名 CHANGE 列名 新列名 新数据类型; -- 将color修改为address,数据类型为varchar ALTER TABLE product3 CHANGE color address VARCHAR(30); -- 查看product3表详细信息 DESC product3; - 删除列 ```mysql -- 标准语法 ALTER TABLE 表名 DROP 列名; -- 删除address列 ALTER TABLE product3 DROP address; D(Delete)：删除 删除数据表 -- 标准语法 DROP TABLE 表名; -- 删除product3表 DROP TABLE product3; -- 删除不存在的表，会报错 -- 错误代码：1051 Unknown table 'product3' DROP TABLE product3; 删除数据表(判断，如果存在则删除) -- 标准语法 DROP TABLE IF EXISTS 表名; -- 删除product3表，如果存在则删除 DROP TABLE IF EXISTS product3; 5.DML-INSERT语句 新增表数据语法 新增格式1：给指定列添加数据 -- 标准语法 INSERT INTO 表名(列名1,列名2,...) VALUES (值1,值2,...); -- 向product表添加一条数据 INSERT INTO product(id,NAME,price,stock,insert_time) VALUES (1,'手机',1999,22,'2099-09-09'); -- 向product表添加指定列数据 INSERT INTO product (id,NAME,price) VALUES (2,'电脑',4999); -- 查看表中所有数据 SELECT * FROM product; 新增格式2：默认给全部列添加数据 -- 标准语法 INSERT INTO 表名 VALUES (值1,值2,值3,...); -- 默认给全部列添加数据 INSERT INTO product VALUES (3,'电视',2999,18,'2099-06-06'); -- 查看表中所有数据 SELECT * FROM product; 新增格式3：批量添加数据 ```mysql -- 默认添加所有列数据 标准语法 INSERT INTO 表名 VALUES (值1,值2,值3,...),(值1,值2,值3,...),(值1,值2,值3,...); -- 批量添加数据 INSERT INTO product VALUES (4,'冰箱',999,26,'2099-08-08'),(5,'洗衣机',1999,32,'2099-05-10'); -- 查看表中所有数据 SELECT * FROM product; -- 给指定列添加数据 标准语法 INSERT INTO 表名(列名1,列名2,...) VALUES (值1,值2,...),(值1,值2,...),(值1,值2,...); -- 批量添加指定列数据 INSERT INTO product (id,NAME,price) VALUES (6,'微波炉',499),(7,'电磁炉',899); -- 查看表中所有数据 SELECT * FROM product; - 注意事项 - 列名和值的数量以及数据类型要对应 - 除了数字类型，其他数据类型的数据都需要加引号(单引双引都可以，推荐单引) #### 6.DML-UPDATE语句 - 修改表数据语法 ```mysql -- 标准语法 UPDATE 表名 SET 列名1 = 值1,列名2 = 值2,... [where 条件]; -- 修改手机的价格为3500 UPDATE product SET price=3500 WHERE NAME='手机'; -- 查看所有数据 SELECT * FROM product; -- 修改电视的价格为1800、库存为36 UPDATE product SET price=1800,stock=36 WHERE NAME='电视'; -- 修改电磁炉的库存为10 UPDATE product SET stock=10 WHERE id=7; 注意事项 修改语句中必须加条件 如果不加条件，则将所有数据都修改 7.DML-DELETE语句 删除表数据语法 -- 标准语法 DELETE FROM 表名 [WHERE 条件]; -- 删除product表中的微波炉信息 DELETE FROM product WHERE NAME='微波炉'; -- 删除product表中库存为10的商品信息 DELETE FROM product WHERE stock=10; -- 查看所有商品信息 SELECT * FROM product; 注意事项 删除语句中必须加条件 如果不加条件，则将所有数据删除 8.DQL-单表查询 数据准备(直接复制执行即可) -- 创建db1数据库 CREATE DATABASE db1; -- 使用db1数据库 USE db1; -- 创建数据表 CREATE TABLE product( id INT, -- 商品编号 NAME VARCHAR(20), -- 商品名称 price DOUBLE, -- 商品价格 brand VARCHAR(10), -- 商品品牌 stock INT, -- 商品库存 insert_time DATE -- 添加时间 ); -- 添加数据 INSERT INTO product VALUES (1,'华为手机',3999,'华为',23,'2088-03-10'), (2,'小米手机',2999,'小米',30,'2088-05-15'), (3,'苹果手机',5999,'苹果',18,'2088-08-20'), (4,'华为电脑',6999,'华为',14,'2088-06-16'), (5,'小米电脑',4999,'小米',26,'2088-07-08'), (6,'苹果电脑',8999,'苹果',15,'2088-10-25'), (7,'联想电脑',7999,'联想',NULL,'2088-11-11'); 查询语法 select 字段列表 from 表名列表 where 条件列表 group by 分组字段 having 分组之后的条件 order by 排序 limit 分页限定 查询全部 -- 标准语法 SELECT * FROM 表名; -- 查询product表所有数据 SELECT * FROM product; 查询部分 多个字段查询 -- 标准语法 SELECT 列名1,列名2,... FROM 表名; -- 查询名称、价格、品牌 SELECT NAME,price,brand FROM product; 去除重复查询 注意：只有全部重复的才可以去除 -- 标准语法 SELECT DISTINCT 列名1,列名2,... FROM 表名; -- 查询品牌 SELECT brand FROM product; -- 查询品牌，去除重复 SELECT DISTINCT brand FROM product; 计算列的值(四则运算) -- 标准语法 SELECT 列名1 运算符(+ - * /) 列名2 FROM 表名; /* 计算列的值 标准语法： SELECT 列名1 运算符(+ - * /) 列名2 FROM 表名; 如果某一列为null，可以进行替换 ifnull(表达式1,表达式2) 表达式1：想替换的列 表达式2：想替换的值 */ -- 查询商品名称和库存，库存数量在原有基础上加10 SELECT NAME,stock+10 FROM product; -- 查询商品名称和库存，库存数量在原有基础上加10。进行null值判断 SELECT NAME,IFNULL(stock,0)+10 FROM product; 起别名 -- 标准语法 SELECT 列名1,列名2,... AS 别名 FROM 表名; -- 查询商品名称和库存，库存数量在原有基础上加10。进行null值判断。起别名为getSum SELECT NAME,IFNULL(stock,0)+10 AS getsum FROM product; SELECT NAME,IFNULL(stock,0)+10 getsum FROM product; 条件查询 条件分类 | 符号 | 功能 | | ------------------- | -------------------------------------- | | > | 大于 | | = | 大于等于 | | 或 != | 不等于 | | BETWEEN ... AND ... | 在某个范围之内(都包含) | | IN(...) | 多选一 | | LIKE 占位符 | 模糊查询 _单个任意字符 %多个任意字符 | | IS NULL | 是NULL | | IS NOT NULL | 不是NULL | | AND 或 && | 并且 | | OR 或 || | 或者 | | NOT 或 ! | 非，不是 | 条件查询语法 -- 标准语法 SELECT 列名 FROM 表名 WHERE 条件; -- 查询库存大于20的商品信息 SELECT * FROM product WHERE stock > 20; -- 查询品牌为华为的商品信息 SELECT * FROM product WHERE brand='华为'; -- 查询金额在4000 ~ 6000之间的商品信息 SELECT * FROM product WHERE price >= 4000 AND price 聚合函数 将一列数据作为一个整体，进行纵向的计算 聚合函数分类 | 函数名 | 功能 | | ----------- | ------------------------------ | | count(列名) | 统计数量(一般选用不为null的列) | | max(列名) | 最大值 | | min(列名) | 最小值 | | sum(列名) | 求和 | | avg(列名) | 平均值 | 聚合函数语法 -- 标准语法 SELECT 函数名(列名) FROM 表名 [WHERE 条件]; -- 计算product表中总记录条数 SELECT COUNT(*) FROM product; -- 获取最高价格 SELECT MAX(price) FROM product; -- 获取最高价格的商品名称 SELECT NAME,price FROM product WHERE price = (SELECT MAX(price) FROM product); -- 获取最低库存 SELECT MIN(stock) FROM product; -- 获取最低库存的商品名称 SELECT NAME,stock FROM product WHERE stock = (SELECT MIN(stock) FROM product); -- 获取总库存数量 SELECT SUM(stock) FROM product; -- 获取品牌为苹果的总库存数量 SELECT SUM(stock) FROM product WHERE brand='苹果'; -- 获取品牌为小米的平均商品价格 SELECT AVG(price) FROM product WHERE brand='小米'; 排序查询 排序分类 注意：多个排序条件，当前边的条件值一样时，才会判断第二条件 | 关键词 | 功能 | | ---------------------------------------- | --------------------------------------- | | ORDER BY 列名1 排序方式1,列名2 排序方式2 | 对指定列排序，ASC升序(默认的) DESC降序 | 排序语法 -- 标准语法 SELECT 列名 FROM 表名 [WHERE 条件] ORDER BY 列名1 排序方式1,列名2 排序方式2; -- 按照库存升序排序 SELECT * FROM product ORDER BY stock ASC; -- 查询名称中包含手机的商品信息。按照金额降序排序 SELECT * FROM product WHERE NAME LIKE '%手机%' ORDER BY price DESC; -- 按照金额升序排序，如果金额相同，按照库存降序排列 SELECT * FROM product ORDER BY price ASC,stock DESC; 分组查询 -- 标准语法 SELECT 列名 FROM 表名 [WHERE 条件] GROUP BY 分组列名 [HAVING 分组后条件过滤] [ORDER BY 排序列名 排序方式]; -- 按照品牌分组，获取每组商品的总金额 SELECT brand,SUM(price) FROM product GROUP BY brand; -- 对金额大于4000元的商品，按照品牌分组,获取每组商品的总金额 SELECT brand,SUM(price) FROM product WHERE price > 4000 GROUP BY brand; -- 对金额大于4000元的商品，按照品牌分组，获取每组商品的总金额，只显示总金额大于7000元的 SELECT brand,SUM(price) AS getSum FROM product WHERE price > 4000 GROUP BY brand HAVING getSum > 7000; -- 对金额大于4000元的商品，按照品牌分组，获取每组商品的总金额，只显示总金额大于7000元的、并按照总金额的降序排列 SELECT brand,SUM(price) AS getSum FROM product WHERE price > 4000 GROUP BY brand HAVING getSum > 7000 ORDER BY getSum DESC; 分页查询 -- 标准语法 SELECT 列名 FROM 表名 [WHERE 条件] GROUP BY 分组列名 [HAVING 分组后条件过滤] [ORDER BY 排序列名 排序方式] LIMIT 开始索引,查询条数; -- 公式：开始索引 = (当前页码-1) * 每页显示的条数 -- 每页显示2条数据 SELECT * FROM product LIMIT 0,2; -- 第一页 开始索引=(1-1) * 2 SELECT * FROM product LIMIT 2,2; -- 第二页 开始索引=(2-1) * 2 SELECT * FROM product LIMIT 4,2; -- 第三页 开始索引=(3-1) * 2 SELECT * FROM product LIMIT 6,2; -- 第四页 开始索引=(4-1) * 2 分页查询图解 1.1.4. 四、约束 1.约束的概念和分类 约束的概念 对表中的数据进行限定，保证数据的正确性、有效性、完整性！ 约束的分类 约束 说明 PRIMARY KEY 主键约束 PRIMARY KEY AUTO_INCREMENT 主键、自动增长 UNIQUE 唯一约束 NOT NULL 非空约束 FOREIGN KEY 外键约束 FOREIGN KEY ON UPDATE CASCADE 外键级联更新 FOREIGN KEY ON DELETE CASCADE 外键级联删除 2.主键约束 主键约束特点 主键约束包含：非空和唯一两个功能 一张表只能有一个列作为主键 主键一般用于表中数据的唯一标识 建表时添加主键约束 -- 标准语法 CREATE TABLE 表名( 列名 数据类型 PRIMARY KEY, 列名 数据类型, ... ); -- 创建student表 CREATE TABLE student( id INT PRIMARY KEY -- 给id添加主键约束 ); -- 添加数据 INSERT INTO student VALUES (1),(2); -- 主键默认唯一，添加重复数据，会报错 INSERT INTO student VALUES (2); -- 主键默认非空，不能添加null的数据 INSERT INTO student VALUES (NULL); -- 查询student表 SELECT * FROM student; -- 查询student表详细 DESC student; 删除主键 -- 标准语法 ALTER TABLE 表名 DROP PRIMARY KEY; -- 删除主键 ALTER TABLE student DROP PRIMARY KEY; 建表后单独添加主键 -- 标准语法 ALTER TABLE 表名 MODIFY 列名 数据类型 PRIMARY KEY; -- 添加主键 ALTER TABLE student MODIFY id INT PRIMARY KEY; 3.主键自动增长约束 建表时添加主键自增约束 -- 标准语法 CREATE TABLE 表名( 列名 数据类型 PRIMARY KEY AUTO_INCREMENT, 列名 数据类型, ... ); -- 创建student2表 CREATE TABLE student2( id INT PRIMARY KEY AUTO_INCREMENT -- 给id添加主键自增约束 ); -- 添加数据 INSERT INTO student2 VALUES (1),(2); -- 添加null值，会自动增长 INSERT INTO student2 VALUES (NULL),(NULL); -- 查询student2表 SELECT * FROM student2; -- student2表详细 DESC student2; 删除自动增长 -- 标准语法 ALTER TABLE 表名 MODIFY 列名 数据类型; -- 删除自动增长 ALTER TABLE student2 MODIFY id INT; 建表后单独添加自动增长 -- 标准语法 ALTER TABLE 表名 MODIFY 列名 数据类型 AUTO_INCREMENT; -- 添加自动增长 ALTER TABLE student2 MODIFY id INT AUTO_INCREMENT; 4.唯一约束 建表时添加唯一约束 -- 标准语法 CREATE TABLE 表名( 列名 数据类型 UNIQUE, 列名 数据类型, ... ); -- 创建student3表 CREATE TABLE student3( id INT PRIMARY KEY AUTO_INCREMENT, tel VARCHAR(20) UNIQUE -- 给tel列添加唯一约束 ); -- 添加数据 INSERT INTO student3 VALUES (NULL,'18888888888'),(NULL,'18666666666'); -- 添加重复数据，会报错 INSERT INTO student3 VALUES (NULL,'18666666666'); -- 查询student3数据表 SELECT * FROM student3; -- student3表详细 DESC student3; 删除唯一约束 -- 标准语法 ALTER TABLE 表名 DROP INDEX 列名; -- 删除唯一约束 ALTER TABLE student3 DROP INDEX tel; 建表后单独添加唯一约束 -- 标准语法 ALTER TABLE 表名 MODIFY 列名 数据类型 UNIQUE; -- 添加唯一约束 ALTER TABLE student3 MODIFY tel VARCHAR(20) UNIQUE; 5.非空约束 建表时添加非空约束 -- 标准语法 CREATE TABLE 表名( 列名 数据类型 NOT NULL, 列名 数据类型, ... ); -- 创建student4表 CREATE TABLE student4( id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(20) NOT NULL -- 给name添加非空约束 ); -- 添加数据 INSERT INTO student4 VALUES (NULL,'张三'),(NULL,'李四'); -- 添加null值，会报错 INSERT INTO student4 VALUES (NULL,NULL); 删除非空约束 -- 标准语法 ALTER TABLE 表名 MODIFY 列名 数据类型; -- 删除非空约束 ALTER TABLE student4 MODIFY NAME VARCHAR(20); 建表后单独添加非空约束 -- 标准语法 ALTER TABLE 表名 MODIFY 列名 数据类型 NOT NULL; -- 添加非空约束 ALTER TABLE student4 MODIFY NAME VARCHAR(20) NOT NULL; Copyright © MISIN 2022 | 豫ICP备2021006345号-1 all right reserved，powered by Gitbook该文件修订时间： 2022-11-10 10:49:02 "},"2.JavaWeb/4.mysql/MySQL进阶-02-授课笔记.html":{"url":"2.JavaWeb/4.mysql/MySQL进阶-02-授课笔记.html","title":"MySQL进阶-02-授课笔记","keywords":"","body":"1. MySQL进阶-02-授课笔记1.1.1. 一、约束1.1.2. 二、多表设计1.1.3. 三、多表查询1.1.4. 四、视图1.1.5. 五、备份与还原1. MySQL进阶-02-授课笔记 1.1.1. 一、约束 1.外键约束 外键约束概念 让表和表之间产生关系，从而保证数据的准确性！ 建表时添加外键约束 为什么要有外键约束 -- 创建db2数据库 CREATE DATABASE db2; -- 使用db2数据库 USE db2; -- 创建user用户表 CREATE TABLE USER( id INT PRIMARY KEY AUTO_INCREMENT, -- id NAME VARCHAR(20) NOT NULL -- 姓名 ); -- 添加用户数据 INSERT INTO USER VALUES (NULL,'张三'),(NULL,'李四'),(NULL,'王五'); -- 创建orderlist订单表 CREATE TABLE orderlist( id INT PRIMARY KEY AUTO_INCREMENT, -- id number VARCHAR(20) NOT NULL, -- 订单编号 uid INT -- 订单所属用户 ); -- 添加订单数据 INSERT INTO orderlist VALUES (NULL,'hm001',1),(NULL,'hm002',1), (NULL,'hm003',2),(NULL,'hm004',2), (NULL,'hm005',3),(NULL,'hm006',3); -- 添加一个订单，但是没有所属用户。这合理吗？ INSERT INTO orderlist VALUES (NULL,'hm007',8); -- 删除王五这个用户，但是订单表中王五还有很多个订单呢。这合理吗？ DELETE FROM USER WHERE NAME='王五'; -- 所以我们需要添加外键约束，让两张表产生关系 外键约束格式 CONSTRAINT 外键名 FOREIGN KEY (本表外键列名) REFERENCES 主表名(主表主键列名) 创建表添加外键约束 -- 创建user用户表 CREATE TABLE USER( id INT PRIMARY KEY AUTO_INCREMENT, -- id NAME VARCHAR(20) NOT NULL -- 姓名 ); -- 添加用户数据 INSERT INTO USER VALUES (NULL,'张三'),(NULL,'李四'),(NULL,'王五'); -- 创建orderlist订单表 CREATE TABLE orderlist( id INT PRIMARY KEY AUTO_INCREMENT, -- id number VARCHAR(20) NOT NULL, -- 订单编号 uid INT, -- 订单所属用户 CONSTRAINT ou_fk1 FOREIGN KEY (uid) REFERENCES USER(id) -- 添加外键约束 ); -- 添加订单数据 INSERT INTO orderlist VALUES (NULL,'hm001',1),(NULL,'hm002',1), (NULL,'hm003',2),(NULL,'hm004',2), (NULL,'hm005',3),(NULL,'hm006',3); -- 添加一个订单，但是没有所属用户。无法添加 INSERT INTO orderlist VALUES (NULL,'hm007',8); -- 删除王五这个用户，但是订单表中王五还有很多个订单呢。无法删除 DELETE FROM USER WHERE NAME='王五'; 删除外键约束 -- 标准语法 ALTER TABLE 表名 DROP FOREIGN KEY 外键名; -- 删除外键 ALTER TABLE orderlist DROP FOREIGN KEY ou_fk1; 建表后添加外键约束 -- 标准语法 ALTER TABLE 表名 ADD CONSTRAINT 外键名 FOREIGN KEY (本表外键列名) REFERENCES 主表名(主键列名); -- 添加外键约束 ALTER TABLE orderlist ADD CONSTRAINT ou_fk1 FOREIGN KEY (uid) REFERENCES USER(id); 2.外键的级联更新和级联删除(了解) 什么是级联更新和级联删除 当我想把user用户表中的某个用户删掉，我希望该用户所有的订单也随之被删除 当我想把user用户表中的某个用户id修改，我希望订单表中该用户所属的订单用户编号也随之修改 添加级联更新和级联删除 -- 添加外键约束，同时添加级联更新 标准语法 ALTER TABLE 表名 ADD CONSTRAINT 外键名 FOREIGN KEY (本表外键列名) REFERENCES 主表名(主键列名) ON UPDATE CASCADE; -- 添加外键约束，同时添加级联删除 标准语法 ALTER TABLE 表名 ADD CONSTRAINT 外键名 FOREIGN KEY (本表外键列名) REFERENCES 主表名(主键列名) ON DELETE CASCADE; -- 添加外键约束，同时添加级联更新和级联删除 标准语法 ALTER TABLE 表名 ADD CONSTRAINT 外键名 FOREIGN KEY (本表外键列名) REFERENCES 主表名(主键列名) ON UPDATE CASCADE ON DELETE CASCADE; -- 删除外键约束 ALTER TABLE orderlist DROP FOREIGN KEY ou_fk1; -- 添加外键约束，同时添加级联更新和级联删除 ALTER TABLE orderlist ADD CONSTRAINT ou_fk1 FOREIGN KEY (uid) REFERENCES USER(id) ON UPDATE CASCADE ON DELETE CASCADE; -- 将王五用户的id修改为5 订单表中的uid也随之被修改 UPDATE USER SET id=5 WHERE id=3; -- 将王五用户删除 订单表中该用户所有订单也随之删除 DELETE FROM USER WHERE id=5; 1.1.2. 二、多表设计 1.一对一(了解) 分析 人和身份证。一个人只有一个身份证，一个身份证只能对应一个人！ 实现原则 在任意一个表建立外键，去关联另外一个表的主键 SQL演示 -- 创建db5数据库 CREATE DATABASE db5; -- 使用db5数据库 USE db5; -- 创建person表 CREATE TABLE person( id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(20) ); -- 添加数据 INSERT INTO person VALUES (NULL,'张三'),(NULL,'李四'); -- 创建card表 CREATE TABLE card( id INT PRIMARY KEY AUTO_INCREMENT, number VARCHAR(50), pid INT UNIQUE, CONSTRAINT cp_fk1 FOREIGN KEY (pid) REFERENCES person(id) -- 添加外键 ); -- 添加数据 INSERT INTO card VALUES (NULL,'12345',1),(NULL,'56789',2); 图解 2.一对多 分析 用户和订单。一个用户可以有多个订单！ 商品分类和商品。一个分类下可以有多个商品！ 实现原则 在多的一方，建立外键约束，来关联一的一方主键 SQL演示 /* 用户和订单 */ -- 创建user表 CREATE TABLE USER( id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(20) ); -- 添加数据 INSERT INTO USER VALUES (NULL,'张三'),(NULL,'李四'); -- 创建orderlist表 CREATE TABLE orderlist( id INT PRIMARY KEY AUTO_INCREMENT, number VARCHAR(20), uid INT, CONSTRAINT ou_fk1 FOREIGN KEY (uid) REFERENCES USER(id) -- 添加外键约束 ); -- 添加数据 INSERT INTO orderlist VALUES (NULL,'hm001',1),(NULL,'hm002',1),(NULL,'hm003',2),(NULL,'hm004',2); /* 商品分类和商品 */ -- 创建category表 CREATE TABLE category( id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(10) ); -- 添加数据 INSERT INTO category VALUES (NULL,'手机数码'),(NULL,'电脑办公'); -- 创建product表 CREATE TABLE product( id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(30), cid INT, CONSTRAINT pc_fk1 FOREIGN KEY (cid) REFERENCES category(id) -- 添加外键约束 ); -- 添加数据 INSERT INTO product VALUES (NULL,'华为P30',1),(NULL,'小米note3',1), (NULL,'联想电脑',2),(NULL,'苹果电脑',2); 图解 3.多对多 分析 学生和课程。一个学生可以选择多个课程，一个课程也可以被多个学生选择！ 实现原则 需要借助第三张表中间表，中间表至少包含两个列，这两个列作为中间表的外键，分别关联两张表的主键 SQL演示 -- 创建student表 CREATE TABLE student( id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(20) ); -- 添加数据 INSERT INTO student VALUES (NULL,'张三'),(NULL,'李四'); -- 创建course表 CREATE TABLE course( id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(10) ); -- 添加数据 INSERT INTO course VALUES (NULL,'语文'),(NULL,'数学'); -- 创建中间表 CREATE TABLE stu_course( id INT PRIMARY KEY AUTO_INCREMENT, sid INT, -- 用于和student表的id进行外键关联 cid INT, -- 用于和course表的id进行外键关联 CONSTRAINT sc_fk1 FOREIGN KEY (sid) REFERENCES student(id), -- 添加外键约束 CONSTRAINT sc_fk2 FOREIGN KEY (cid) REFERENCES course(id) -- 添加外键约束 ); -- 添加数据 INSERT INTO stu_course VALUES (NULL,1,1),(NULL,1,2),(NULL,2,1),(NULL,2,2); 图解 1.1.3. 三、多表查询 1.多表查询-数据准备 SQL语句 -- 创建db6数据库 CREATE DATABASE db6; -- 使用db6数据库 USE db6; -- 创建user表 CREATE TABLE USER( id INT PRIMARY KEY AUTO_INCREMENT, -- 用户id NAME VARCHAR(20), -- 用户姓名 age INT -- 用户年龄 ); -- 添加数据 INSERT INTO USER VALUES (1,'张三',23); INSERT INTO USER VALUES (2,'李四',24); INSERT INTO USER VALUES (3,'王五',25); INSERT INTO USER VALUES (4,'赵六',26); -- 订单表 CREATE TABLE orderlist( id INT PRIMARY KEY AUTO_INCREMENT, -- 订单id number VARCHAR(30), -- 订单编号 uid INT, -- 外键字段 CONSTRAINT ou_fk1 FOREIGN KEY (uid) REFERENCES USER(id) ); -- 添加数据 INSERT INTO orderlist VALUES (1,'hm001',1); INSERT INTO orderlist VALUES (2,'hm002',1); INSERT INTO orderlist VALUES (3,'hm003',2); INSERT INTO orderlist VALUES (4,'hm004',2); INSERT INTO orderlist VALUES (5,'hm005',3); INSERT INTO orderlist VALUES (6,'hm006',3); INSERT INTO orderlist VALUES (7,'hm007',NULL); -- 商品分类表 CREATE TABLE category( id INT PRIMARY KEY AUTO_INCREMENT, -- 商品分类id NAME VARCHAR(10) -- 商品分类名称 ); -- 添加数据 INSERT INTO category VALUES (1,'手机数码'); INSERT INTO category VALUES (2,'电脑办公'); INSERT INTO category VALUES (3,'烟酒茶糖'); INSERT INTO category VALUES (4,'鞋靴箱包'); -- 商品表 CREATE TABLE product( id INT PRIMARY KEY AUTO_INCREMENT, -- 商品id NAME VARCHAR(30), -- 商品名称 cid INT, -- 外键字段 CONSTRAINT cp_fk1 FOREIGN KEY (cid) REFERENCES category(id) ); -- 添加数据 INSERT INTO product VALUES (1,'华为手机',1); INSERT INTO product VALUES (2,'小米手机',1); INSERT INTO product VALUES (3,'联想电脑',2); INSERT INTO product VALUES (4,'苹果电脑',2); INSERT INTO product VALUES (5,'中华香烟',3); INSERT INTO product VALUES (6,'玉溪香烟',3); INSERT INTO product VALUES (7,'计生用品',NULL); -- 中间表 CREATE TABLE us_pro( upid INT PRIMARY KEY AUTO_INCREMENT, -- 中间表id uid INT, -- 外键字段。需要和用户表的主键产生关联 pid INT, -- 外键字段。需要和商品表的主键产生关联 CONSTRAINT up_fk1 FOREIGN KEY (uid) REFERENCES USER(id), CONSTRAINT up_fk2 FOREIGN KEY (pid) REFERENCES product(id) ); -- 添加数据 INSERT INTO us_pro VALUES (NULL,1,1); INSERT INTO us_pro VALUES (NULL,1,2); INSERT INTO us_pro VALUES (NULL,1,3); INSERT INTO us_pro VALUES (NULL,1,4); INSERT INTO us_pro VALUES (NULL,1,5); INSERT INTO us_pro VALUES (NULL,1,6); INSERT INTO us_pro VALUES (NULL,1,7); INSERT INTO us_pro VALUES (NULL,2,1); INSERT INTO us_pro VALUES (NULL,2,2); INSERT INTO us_pro VALUES (NULL,2,3); INSERT INTO us_pro VALUES (NULL,2,4); INSERT INTO us_pro VALUES (NULL,2,5); INSERT INTO us_pro VALUES (NULL,2,6); INSERT INTO us_pro VALUES (NULL,2,7); INSERT INTO us_pro VALUES (NULL,3,1); INSERT INTO us_pro VALUES (NULL,3,2); INSERT INTO us_pro VALUES (NULL,3,3); INSERT INTO us_pro VALUES (NULL,3,4); INSERT INTO us_pro VALUES (NULL,3,5); INSERT INTO us_pro VALUES (NULL,3,6); INSERT INTO us_pro VALUES (NULL,3,7); INSERT INTO us_pro VALUES (NULL,4,1); INSERT INTO us_pro VALUES (NULL,4,2); INSERT INTO us_pro VALUES (NULL,4,3); INSERT INTO us_pro VALUES (NULL,4,4); INSERT INTO us_pro VALUES (NULL,4,5); INSERT INTO us_pro VALUES (NULL,4,6); INSERT INTO us_pro VALUES (NULL,4,7); 架构器图解 2.多表查询-笛卡尔积查询(了解) 有两张表，获取这两个表的所有组合情况 要完成多表查询，需要消除这些没有用的数据 多表查询格式 SELECT 列名列表 FROM 表名列表 WHERE 条件... 笛卡尔积查询 -- 标准语法 SELECT 列名 FROM 表名1,表名2,...; -- 查询user表和orderlist表 SELECT * FROM USER,orderlist; 3.多表查询-内连接查询 查询原理 内连接查询的是两张表有交集的部分数据(有主外键关联的数据) 显式内连接 -- 标准语法 SELECT 列名 FROM 表名1 [INNER] JOIN 表名2 ON 条件; -- 查询用户信息和对应的订单信息 SELECT * FROM USER INNER JOIN orderlist ON user.id=orderlist.uid; SELECT * FROM USER JOIN orderlist ON user.id=orderlist.uid; -- 查询用户信息和对应的订单信息，起别名 SELECT * FROM USER u JOIN orderlist o ON u.id=o.uid; -- 查询用户姓名，年龄。和订单编号 SELECT u.`name`, -- 姓名 u.`age`, -- 年龄 o.`number` -- 订单编号 FROM USER u -- 用户表 JOIN orderlist o -- 订单表 ON u.`id` = o.`uid`; 隐式内连接 -- 标准语法 SELECT 列名 FROM 表名1,表名2 WHERE 条件; -- 查询用户姓名，年龄。和订单编号 SELECT u.`name`, -- 姓名 u.`age`, -- 年龄 o.`number` -- 订单编号 FROM USER u, -- 用户表 orderlist o -- 订单表 WHERE u.`id`=o.`uid`; 4.多表查询-外连接查询 左外连接 查询原理 查询左表的全部数据，和左右两张表有交集部分的数据 基本演示 -- 标准语法 SELECT 列名 FROM 表名1 LEFT [OUTER] JOIN 表名2 ON 条件; -- 查询所有用户信息，以及用户对应的订单信息 SELECT u.`name`, -- 姓名 u.`age`, -- 年龄 o.`number` -- 订单编号 FROM USER u -- 用户表 LEFT OUTER JOIN orderlist o -- 订单表 ON u.`id`=o.`uid`; 右外连接 查询原理 查询右表的全部数据，和左右两张表有交集部分的数据 基本演示 -- 基本语法 SELECT 列名 FROM 表名1 RIGHT [OUTER] JOIN 表名2 ON 条件; -- 查询所有订单信息，以及订单所属的用户信息 SELECT u.`name`, -- 姓名 u.`age`, -- 年龄 o.`number` -- 订单编号 FROM USER u -- 用户表 RIGHT OUTER JOIN orderlist o -- 订单表 ON u.`id`=o.`uid`; 5.多表查询-子查询 子查询介绍 查询语句中嵌套了查询语句。我们就将嵌套查询称为子查询！ 子查询-结果是单行单列的 可以作为条件，使用运算符进行判断！ 基本演示 -- 标准语法 SELECT 列名 FROM 表名 WHERE 列名=(SELECT 聚合函数(列名) FROM 表名 [WHERE 条件]); -- 查询年龄最高的用户姓名 SELECT MAX(age) FROM USER; -- 查询出最高年龄 SELECT NAME,age FROM USER WHERE age=26; -- 根据查询出来的最高年龄，查询姓名和年龄 SELECT NAME,age FROM USER WHERE age = (SELECT MAX(age) FROM USER); 子查询-结果是多行单列的 可以作为条件，使用运算符in或not in进行判断！ 基本演示 -- 标准语法 SELECT 列名 FROM 表名 WHERE 列名 [NOT] IN (SELECT 列名 FROM 表名 [WHERE 条件]); -- 查询张三和李四的订单信息 SELECT id FROM USER WHERE NAME='张三' OR NAME='李四'; -- 查询张三和李四用户的id SELECT number,uid FROM orderlist WHERE uid=1 OR uid=2; -- 根据id查询订单 SELECT number,uid FROM orderlist WHERE uid IN (SELECT id FROM USER WHERE NAME='张三' OR NAME='李四'); 子查询-结果是多行多列的 可以作为一张虚拟表参与查询！ 基本演示 -- 标准语法 SELECT 列名 FROM 表名 [别名],(SELECT 列名 FROM 表名 [WHERE 条件]) [别名] [WHERE 条件]; -- 查询订单表中id大于4的订单信息和所属用户信息 SELECT * FROM USER u,(SELECT * FROM orderlist WHERE id>4) o WHERE u.id=o.uid; 6.多表查询练习 查询用户的编号、姓名、年龄。订单编号 /* 分析： 用户的编号、姓名、年龄 user表 订单编号 orderlist表 条件：user.id = orderlist.uid */ SELECT t1.`id`, -- 用户编号 t1.`name`, -- 用户姓名 t1.`age`, -- 用户年龄 t2.`number` -- 订单编号 FROM USER t1, -- 用户表 orderlist t2 -- 订单表 WHERE t1.`id` = t2.`uid`; 查询所有的用户。用户的编号、姓名、年龄。订单编号 /* 分析： 用户的编号、姓名、年龄 user表 订单编号 orderlist表 条件：user.id = orderlist.uid 查询所有用户，使用左外连接 */ SELECT t1.`id`, -- 用户编号 t1.`name`, -- 用户姓名 t1.`age`, -- 用户年龄 t2.`number` -- 订单编号 FROM USER t1 -- 用户表 LEFT OUTER JOIN orderlist t2 -- 订单表 ON t1.`id` = t2.`uid`; 查询所有的订单。用户的编号、姓名、年龄。订单编号 /* 分析： 用户的编号、姓名、年龄 user表 订单编号 orderlist表 条件：user.id = orderlist.uid 查询所有订单，使用右外连接 */ SELECT t1.`id`, -- 用户编号 t1.`name`, -- 用户姓名 t1.`age`, -- 用户年龄 t2.`number` -- 订单编号 FROM USER t1 -- 用户表 RIGHT OUTER JOIN orderlist t2 -- 订单表 ON t1.`id` = t2.`uid`; 查询用户年龄大于23岁的信息。显示用户的编号、姓名、年龄。订单编号 /* 分析： 用户的编号、姓名、年龄 user表 订单编号 orderlist表 条件：user.age > 23 AND user.id = orderlist.uid */ /* select t1.`id`, -- 用户编号 t1.`name`, -- 用户姓名 t1.`age`, -- 用户年龄 t2.`number` -- 订单编号 from user t1, -- 用户表 orderlist t2 -- 订单表 where t1.`age` > 23 and t1.`id` = t2.`uid`; */ SELECT t1.`id`, -- 用户编号 t1.`name`, -- 用户姓名 t1.`age`, -- 用户年龄 t2.`number` -- 订单编号 FROM USER t1 -- 用户表 LEFT OUTER JOIN orderlist t2 -- 订单表 ON t1.`id` = t2.`uid` WHERE t1.`age` > 23; 查询张三和李四用户的信息。显示用户的编号、姓名、年龄。订单编号 /* 分析： 用户的编号、姓名、年龄 user表 订单编号 orderlist表 条件：user.id = orderlist.uid AND user.name IN ('张三','李四'); */ SELECT t1.`id`, -- 用户编号 t1.`name`, -- 用户姓名 t1.`age`, -- 用户年龄 t2.`number` -- 订单编号 FROM USER t1, -- 用户表 orderlist t2 -- 订单表 WHERE t1.`id` = t2.`uid` AND -- (t1.`name` = '张三' OR t1.`name` = '李四'); t1.`name` IN ('张三','李四'); 查询商品分类的编号、分类名称。分类下的商品名称 /* 分析： 商品分类的编号、分类名称 category表 分类下的商品名称 product表 条件：category.id = product.cid */ SELECT t1.`id`, -- 分类编号 t1.`name`, -- 分类名称 t2.`name` -- 商品名称 FROM category t1, -- 商品分类表 product t2 -- 商品表 WHERE t1.`id` = t2.`cid`; 查询所有的商品分类。商品分类的编号、分类名称。分类下的商品名称 /* 分析： 商品分类的编号、分类名称 category表 分类下的商品名称 product表 条件：category.id = product.cid 查询所有的商品分类，使用左外连接 */ SELECT t1.`id`, -- 分类编号 t1.`name`, -- 分类名称 t2.`name` -- 商品名称 FROM category t1 -- 商品分类表 LEFT OUTER JOIN product t2 -- 商品表 ON t1.`id` = t2.`cid`; 查询所有的商品信息。商品分类的编号、分类名称。分类下的商品名称 /* 分析： 商品分类的编号、分类名称 category表 分类下的商品名称 product表 条件：category.id = product.cid 查询所有的商品信息，使用右外连接 */ SELECT t1.`id`, -- 分类编号 t1.`name`, -- 分类名称 t2.`name` -- 商品名称 FROM category t1 -- 商品分类表 RIGHT OUTER JOIN product t2 -- 商品表 ON t1.`id` = t2.`cid`; 查询所有的用户和所有的商品。显示用户的编号、姓名、年龄。商品名称 /* 分析： 用户的编号、姓名、年龄 user表 商品名称 product表 中间表 us_pro 条件：us_pro.uid = user.id AND us_pro.pid = product.id */ SELECT t1.`id`, -- 用户编号 t1.`name`, -- 用户名称 t1.`age`, -- 用户年龄 t2.`name` -- 商品名称 FROM USER t1, -- 用户表 product t2, -- 商品表 us_pro t3 -- 中间表 WHERE t3.`uid` = t1.`id` AND t3.`pid` = t2.`id`; 查询张三和李四这两个用户可以看到的商品。显示用户的编号、姓名、年龄。商品名称 /* 分析： 用户的编号、姓名、年龄 user表 商品名称 product表 中间表 us_pro 条件：us_pro.uid = user.id AND us_pro.pid = product.id AND user.name IN ('张三','李四') */ SELECT t1.`id`, -- 用户编号 t1.`name`, -- 用户名称 t1.`age`, -- 用户年龄 t2.`name` -- 商品名称 FROM USER t1, -- 用户表 product t2, -- 商品表 us_pro t3 -- 中间表 WHERE (t3.`uid` = t1.`id` AND t3.`pid` = t2.`id`) AND -- (t1.`name` = '张三' or t1.`name` = '李四'); t1.`name` IN ('张三','李四'); 7.多表查询-自关联查询 自关联查询介绍 同一张表中有数据关联。可以多次查询这同一个表！ 自关联查询演示 -- 创建员工表 CREATE TABLE employee( id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(20), mgr INT, salary DOUBLE ); -- 添加数据 INSERT INTO employee VALUES (1001,'孙悟空',1005,9000.00), (1002,'猪八戒',1005,8000.00), (1003,'沙和尚',1005,8500.00), (1004,'小白龙',1005,7900.00), (1005,'唐僧',NULL,15000.00), (1006,'武松',1009,7600.00), (1007,'李逵',1009,7400.00), (1008,'林冲',1009,8100.00), (1009,'宋江',NULL,16000.00); -- 查询所有员工的姓名及其直接上级的姓名，没有上级的员工也需要查询 /* 分析： 员工姓名 employee表 直接上级姓名 employee表 条件：employee.mgr = employee.id 查询左表的全部数据，和左右两张表交集部分数据，使用左外连接 */ SELECT t1.name, -- 员工姓名 t1.mgr, -- 上级编号 t2.id, -- 员工编号 t2.name -- 员工姓名 FROM employee t1 -- 员工表 LEFT OUTER JOIN employee t2 -- 员工表 ON t1.mgr = t2.id; 1.1.4. 四、视图 1.视图的概念 视图是一种虚拟存在的数据表 这个虚拟的表并不在数据库中实际存在 作用是将一些比较复杂的查询语句的结果，封装到一个虚拟表中。后期再有相同复杂查询时，直接查询这张虚拟表即可 说白了，视图就是将一条SELECT查询语句的结果封装到了一个虚拟表中，所以我们在创建视图的时候，工作重心就要放在这条SELECT查询语句上 2.视图的好处 简单 对于使用视图的用户不需要关心表的结构、关联条件和筛选条件。因为这张虚拟表中保存的就是已经过滤好条件的结果集 安全 视图可以设置权限 , 致使访问视图的用户只能访问他们被允许查询的结果集 数据独立 一旦视图的结构确定了，可以屏蔽表结构变化对用户的影响，源表增加列对视图没有影响；源表修改列名，则可以通过修改视图来解决，不会造成对访问者的影响 3.视图数据准备 -- 创建db7数据库 CREATE DATABASE db7; -- 使用db7数据库 USE db7; -- 创建country表 CREATE TABLE country( id INT PRIMARY KEY AUTO_INCREMENT, country_name VARCHAR(30) ); -- 添加数据 INSERT INTO country VALUES (NULL,'中国'),(NULL,'美国'),(NULL,'俄罗斯'); -- 创建city表 CREATE TABLE city( id INT PRIMARY KEY AUTO_INCREMENT, city_name VARCHAR(30), cid INT, -- 外键列。关联country表的主键列id CONSTRAINT cc_fk1 FOREIGN KEY (cid) REFERENCES country(id) ); -- 添加数据 INSERT INTO city VALUES (NULL,'北京',1),(NULL,'上海',1),(NULL,'纽约',2),(NULL,'莫斯科',3); 4.视图的创建 创建视图语法 -- 标准语法 CREATE VIEW 视图名称 [(列名列表)] AS 查询语句; 普通多表查询，查询城市和所属国家 -- 普通多表查询，查询城市和所属国家 SELECT t1.*, t2.country_name FROM city t1, country t2 WHERE t1.cid = t2.id; -- 经常需要查询这样的数据，就可以创建一个视图 创建视图基本演示 -- 创建一个视图。将查询出来的结果保存到这张虚拟表中 CREATE VIEW city_country AS SELECT t1.*,t2.country_name FROM city t1,country t2 WHERE t1.cid=t2.id; 创建视图并指定列名基本演示 -- 创建一个视图，指定列名。将查询出来的结果保存到这张虚拟表中 CREATE VIEW city_country2 (city_id,city_name,cid,country_name) AS SELECT t1.*,t2.country_name FROM city t1,country t2 WHERE t1.cid=t2.id; 5.视图的查询 查询视图语法 -- 标准语法 SELECT * FROM 视图名称; 查询视图基本演示 -- 查询视图。查询这张虚拟表，就等效于查询城市和所属国家 SELECT * FROM city_country; -- 查询指定列名的视图 SELECT * FROM city_country2; -- 查询所有数据表，视图也会查询出来 SHOW TABLES; 查询视图创建语法 -- 标准语法 SHOW CREATE VIEW 视图名称; 查询视图创建语句基本演示 SHOW CREATE VIEW city_country; 6.视图的修改 修改视图表中的数据 -- 标准语法 UPDATE 视图名称 SET 列名=值 WHERE 条件; -- 修改视图表中的城市名称北京为北京市 UPDATE city_country SET city_name='北京市' WHERE city_name='北京'; -- 查询视图 SELECT * FROM city_country; -- 查询city表,北京也修改为了北京市 SELECT * FROM city; -- 注意：视图表数据修改，会自动修改源表中的数据 修改视图表结构 -- 标准语法 ALTER VIEW 视图名称 [(列名列表)] AS 查询语句; -- 查询视图2 SELECT * FROM city_country2; -- 修改视图2的列名city_id为id ALTER VIEW city_country2 (id,city_name,cid,country_name) AS SELECT t1.*,t2.country_name FROM city t1,country t2 WHERE t1.cid=t2.id; 7.视图的删除 删除视图 -- 标准语法 DROP VIEW [IF EXISTS] 视图名称; -- 删除视图 DROP VIEW city_country; -- 删除视图2，如果存在则删除 DROP VIEW IF EXISTS city_country2; 8.视图的总结 视图是一种虚拟存在的数据表 这个虚拟的表并不在数据库中实际存在 说白了，视图就是将一条SELECT查询语句的结果封装到了一个虚拟表中，所以我们在创建视图的时候，工作重心就要放在这条SELECT查询语句上 视图的好处 简单 安全 数据独立 1.1.5. 五、备份与还原 1.命令行方式 备份 使用SecureCRT工具连接到Linux系统，输入：mysqldump -u root -p 数据库名称 > 文件保存路径 进入文件保存路径，查看文件是否存在 恢复 登录mysql数据库 删除已经备份的数据库 重新创建名称相同的数据库 使用该数据库 导入文件执行：source 备份文件路径; 2.图形化界面方式 备份 恢复 Copyright © MISIN 2022 | 豫ICP备2021006345号-1 all right reserved，powered by Gitbook该文件修订时间： 2022-11-10 10:49:58 "},"2.JavaWeb/4.mysql/MySQL高级-03-授课笔记.html":{"url":"2.JavaWeb/4.mysql/MySQL高级-03-授课笔记.html","title":"MySQL高级-03-授课笔记","keywords":"","body":"1. MySQL高级-03-授课笔记1.1.1. 一、MySQL存储过程和函数1.1.2. 二、MySQL触发器1.1.3. 三、MySQL事务1. MySQL高级-03-授课笔记 1.1.1. 一、MySQL存储过程和函数 1.存储过程和函数的概念 存储过程和函数是 事先经过编译并存储在数据库中的一段 SQL 语句的集合 2.存储过程和函数的好处 存储过程和函数可以重复使用，减轻开发人员的工作量。类似于java中方法可以多次调用 减少网络流量，存储过程和函数位于服务器上，调用的时候只需要传递名称和参数即可 减少数据在数据库和应用服务器之间的传输，可以提高数据处理的效率 将一些业务逻辑在数据库层面来实现，可以减少代码层面的业务处理 3.存储过程和函数的区别 函数必须有返回值 存储过程没有返回值 4.创建存储过程 小知识 /* 该关键字用来声明sql语句的分隔符，告诉MySQL该段命令已经结束！ sql语句默认的分隔符是分号，但是有的时候我们需要一条功能sql语句中包含分号，但是并不作为结束标识。 这个时候就可以使用DELIMITER来指定分隔符了！ */ -- 标准语法 DELIMITER 分隔符 数据准备 -- 创建db8数据库 CREATE DATABASE db8; -- 使用db8数据库 USE db8; -- 创建学生表 CREATE TABLE student( id INT PRIMARY KEY AUTO_INCREMENT, -- 学生id NAME VARCHAR(20), -- 学生姓名 age INT, -- 学生年龄 gender VARCHAR(5), -- 学生性别 score INT -- 学生成绩 ); -- 添加数据 INSERT INTO student VALUES (NULL,'张三',23,'男',95),(NULL,'李四',24,'男',98), (NULL,'王五',25,'女',100),(NULL,'赵六',26,'女',90); -- 按照性别进行分组，查询每组学生的总成绩。按照总成绩的升序排序 SELECT gender,SUM(score) getSum FROM student GROUP BY gender ORDER BY getSum ASC; 创建存储过程语法 -- 修改分隔符为$ DELIMITER $ -- 标准语法 CREATE PROCEDURE 存储过程名称(参数...) BEGIN sql语句; END$ -- 修改分隔符为分号 DELIMITER ; 创建存储过程 -- 修改分隔符为$ DELIMITER $ -- 创建存储过程，封装分组查询学生总成绩的sql语句 CREATE PROCEDURE stu_group() BEGIN SELECT gender,SUM(score) getSum FROM student GROUP BY gender ORDER BY getSum ASC; END$ -- 修改分隔符为分号 DELIMITER ; 5.调用存储过程 调用存储过程语法 -- 标准语法 CALL 存储过程名称(实际参数); -- 调用stu_group存储过程 CALL stu_group(); 6.查看存储过程 查看存储过程语法 -- 查询数据库中所有的存储过程 标准语法 SELECT * FROM mysql.proc WHERE db='数据库名称'; 7.删除存储过程 删除存储过程语法 -- 标准语法 DROP PROCEDURE [IF EXISTS] 存储过程名称; -- 删除stu_group存储过程 DROP PROCEDURE stu_group; 8.存储过程语法 8.1存储过程语法介绍 存储过程是可以进行编程的。意味着可以使用变量、表达式、条件控制语句、循环语句等，来完成比较复杂的功能！ 8.2变量的使用 定义变量 -- 标准语法 DECLARE 变量名 数据类型 [DEFAULT 默认值]; -- 注意： DECLARE定义的是局部变量，只能用在BEGIN END范围之内 -- 定义一个int类型变量、并赋默认值为10 DELIMITER $ CREATE PROCEDURE pro_test1() BEGIN DECLARE num INT DEFAULT 10; -- 定义变量 SELECT num; -- 查询变量 END$ DELIMITER ; -- 调用pro_test1存储过程 CALL pro_test1(); 变量的赋值1 -- 标准语法 SET 变量名 = 变量值; -- 定义字符串类型变量，并赋值 DELIMITER $ CREATE PROCEDURE pro_test2() BEGIN DECLARE NAME VARCHAR(10); -- 定义变量 SET NAME = '存储过程'; -- 为变量赋值 SELECT NAME; -- 查询变量 END$ DELIMITER ; -- 调用pro_test2存储过程 CALL pro_test2(); 变量的赋值2 -- 标准语法 SELECT 列名 INTO 变量名 FROM 表名 [WHERE 条件]; -- 定义两个int变量，用于存储男女同学的总分数 DELIMITER $ CREATE PROCEDURE pro_test3() BEGIN DECLARE men,women INT; -- 定义变量 SELECT SUM(score) INTO men FROM student WHERE gender='男'; -- 计算男同学总分数赋值给men SELECT SUM(score) INTO women FROM student WHERE gender='女'; -- 计算女同学总分数赋值给women SELECT men,women; -- 查询变量 END$ DELIMITER ; -- 调用pro_test3存储过程 CALL pro_test3(); 8.3if语句的使用 标准语法 -- 标准语法 IF 判断条件1 THEN 执行的sql语句1; [ELSEIF 判断条件2 THEN 执行的sql语句2;] ... [ELSE 执行的sql语句n;] END IF; 案例演示 /* 定义一个int变量，用于存储班级总成绩 定义一个varchar变量，用于存储分数描述 根据总成绩判断： 380分及以上 学习优秀 320 ~ 380 学习不错 320以下 学习一般 */ DELIMITER $ CREATE PROCEDURE pro_test4() BEGIN -- 定义总分数变量 DECLARE total INT; -- 定义分数描述变量 DECLARE description VARCHAR(10); -- 为总分数变量赋值 SELECT SUM(score) INTO total FROM student; -- 判断总分数 IF total >= 380 THEN SET description = '学习优秀'; ELSEIF total >= 320 AND total 8.4参数的传递 参数传递的语法 DELIMITER $ -- 标准语法 CREATE PROCEDURE 存储过程名称([IN|OUT|INOUT] 参数名 数据类型) BEGIN 执行的sql语句; END$ /* IN:代表输入参数，需要由调用者传递实际数据。默认的 OUT:代表输出参数，该参数可以作为返回值 INOUT:代表既可以作为输入参数，也可以作为输出参数 */ DELIMITER ; 输入参数 标准语法 DELIMITER $ -- 标准语法 CREATE PROCEDURE 存储过程名称(IN 参数名 数据类型) BEGIN 执行的sql语句; END$ DELIMITER ; 案例演示 /* 输入总成绩变量，代表学生总成绩 定义一个varchar变量，用于存储分数描述 根据总成绩判断： 380分及以上 学习优秀 320 ~ 380 学习不错 320以下 学习一般 */ DELIMITER $ CREATE PROCEDURE pro_test5(IN total INT) BEGIN -- 定义分数描述变量 DECLARE description VARCHAR(10); -- 判断总分数 IF total >= 380 THEN SET description = '学习优秀'; ELSEIF total >= 320 AND total 输出参数 标准语法 DELIMITER $ -- 标准语法 CREATE PROCEDURE 存储过程名称(OUT 参数名 数据类型) BEGIN 执行的sql语句; END$ DELIMITER ; 案例演示 /* 输入总成绩变量，代表学生总成绩 输出分数描述变量，代表学生总成绩的描述 根据总成绩判断： 380分及以上 学习优秀 320 ~ 380 学习不错 320以下 学习一般 */ DELIMITER $ CREATE PROCEDURE pro_test6(IN total INT,OUT description VARCHAR(10)) BEGIN -- 判断总分数 IF total >= 380 THEN SET description = '学习优秀'; ELSEIF total >= 320 AND total 小知识 @变量名: 这种变量要在变量名称前面加上“@”符号，叫做用户会话变量，代表整个会话过程他都是有作用的，这个类似于全局变量一样。 @@变量名: 这种在变量前加上 \"@@\" 符号, 叫做系统变量 8.5case语句的使用 标准语法1 -- 标准语法 CASE 表达式 WHEN 值1 THEN 执行sql语句1; [WHEN 值2 THEN 执行sql语句2;] ... [ELSE 执行sql语句n;] END CASE; 标准语法2 -- 标准语法 CASE WHEN 判断条件1 THEN 执行sql语句1; [WHEN 判断条件2 THEN 执行sql语句2;] ... [ELSE 执行sql语句n;] END CASE; 案例演示 /* 输入总成绩变量，代表学生总成绩 定义一个varchar变量，用于存储分数描述 根据总成绩判断： 380分及以上 学习优秀 320 ~ 380 学习不错 320以下 学习一般 */ DELIMITER $ CREATE PROCEDURE pro_test7(IN total INT) BEGIN -- 定义变量 DECLARE description VARCHAR(10); -- 使用case判断 CASE WHEN total >= 380 THEN SET description = '学习优秀'; WHEN total >= 320 AND total 8.6while循环 标准语法 -- 标准语法 初始化语句; WHILE 条件判断语句 DO 循环体语句; 条件控制语句; END WHILE; 案例演示 /* 计算1~100之间的偶数和 */ DELIMITER $ CREATE PROCEDURE pro_test8() BEGIN -- 定义求和变量 DECLARE result INT DEFAULT 0; -- 定义初始化变量 DECLARE num INT DEFAULT 1; -- while循环 WHILE num 8.7repeat循环 标准语法 -- 标准语法 初始化语句; REPEAT 循环体语句; 条件控制语句; UNTIL 条件判断语句 END REPEAT; -- 注意：repeat循环是条件满足则停止。while循环是条件满足则执行 案例演示 /* 计算1~10之间的和 */ DELIMITER $ CREATE PROCEDURE pro_test9() BEGIN -- 定义求和变量 DECLARE result INT DEFAULT 0; -- 定义初始化变量 DECLARE num INT DEFAULT 1; -- repeat循环 REPEAT -- 累加 SET result = result + num; -- 让num+1 SET num = num + 1; -- 停止循环 UNTIL num>10 END REPEAT; -- 查询求和结果 SELECT result; END$ DELIMITER ; -- 调用pro_test9存储过程 CALL pro_test9(); 8.8loop循环 标准语法 -- 标准语法 初始化语句; [循环名称:] LOOP 条件判断语句 [LEAVE 循环名称;] 循环体语句; 条件控制语句; END LOOP 循环名称; -- 注意：loop可以实现简单的循环，但是退出循环需要使用其他的语句来定义。我们可以使用leave语句完成！ -- 如果不加退出循环的语句，那么就变成了死循环。 案例演示 /* 计算1~10之间的和 */ DELIMITER $ CREATE PROCEDURE pro_test10() BEGIN -- 定义求和变量 DECLARE result INT DEFAULT 0; -- 定义初始化变量 DECLARE num INT DEFAULT 1; -- loop循环 l:LOOP -- 条件成立，停止循环 IF num > 10 THEN LEAVE l; END IF; -- 累加 SET result = result + num; -- 让num+1 SET num = num + 1; END LOOP l; -- 查询求和结果 SELECT result; END$ DELIMITER ; -- 调用pro_test10存储过程 CALL pro_test10(); 8.9游标 游标的概念 游标可以遍历返回的多行结果，每次拿到一整行数据 在存储过程和函数中可以使用游标对结果集进行循环的处理 简单来说游标就类似于集合的迭代器遍历 MySQL中的游标只能用在存储过程和函数中 游标的语法 创建游标 -- 标准语法 DECLARE 游标名称 CURSOR FOR 查询sql语句; 打开游标 -- 标准语法 OPEN 游标名称; 使用游标获取数据 -- 标准语法 FETCH 游标名称 INTO 变量名1,变量名2,...; 关闭游标 -- 标准语法 CLOSE 游标名称; 游标的基本使用 -- 创建stu_score表 CREATE TABLE stu_score( id INT PRIMARY KEY AUTO_INCREMENT, score INT ); /* 将student表中所有的成绩保存到stu_score表中 */ DELIMITER $ CREATE PROCEDURE pro_test11() BEGIN -- 定义成绩变量 DECLARE s_score INT; -- 创建游标,查询所有学生成绩数据 DECLARE stu_result CURSOR FOR SELECT score FROM student; -- 开启游标 OPEN stu_result; -- 使用游标，遍历结果,拿到第1行数据 FETCH stu_result INTO s_score; -- 将数据保存到stu_score表中 INSERT INTO stu_score VALUES (NULL,s_score); -- 使用游标，遍历结果,拿到第2行数据 FETCH stu_result INTO s_score; -- 将数据保存到stu_score表中 INSERT INTO stu_score VALUES (NULL,s_score); -- 使用游标，遍历结果,拿到第3行数据 FETCH stu_result INTO s_score; -- 将数据保存到stu_score表中 INSERT INTO stu_score VALUES (NULL,s_score); -- 使用游标，遍历结果,拿到第4行数据 FETCH stu_result INTO s_score; -- 将数据保存到stu_score表中 INSERT INTO stu_score VALUES (NULL,s_score); -- 关闭游标 CLOSE stu_result; END$ DELIMITER ; -- 调用pro_test11存储过程 CALL pro_test11(); -- 查询stu_score表 SELECT * FROM stu_score; -- =========================================================== /* 出现的问题： student表中一共有4条数据，我们在游标遍历了4次，没有问题！ 但是在游标中多遍历几次呢？就会出现问题 */ DELIMITER $ CREATE PROCEDURE pro_test11() BEGIN -- 定义成绩变量 DECLARE s_score INT; -- 创建游标,查询所有学生成绩数据 DECLARE stu_result CURSOR FOR SELECT score FROM student; -- 开启游标 OPEN stu_result; -- 使用游标，遍历结果,拿到第1行数据 FETCH stu_result INTO s_score; -- 将数据保存到stu_score表中 INSERT INTO stu_score VALUES (NULL,s_score); -- 使用游标，遍历结果,拿到第2行数据 FETCH stu_result INTO s_score; -- 将数据保存到stu_score表中 INSERT INTO stu_score VALUES (NULL,s_score); -- 使用游标，遍历结果,拿到第3行数据 FETCH stu_result INTO s_score; -- 将数据保存到stu_score表中 INSERT INTO stu_score VALUES (NULL,s_score); -- 使用游标，遍历结果,拿到第4行数据 FETCH stu_result INTO s_score; -- 将数据保存到stu_score表中 INSERT INTO stu_score VALUES (NULL,s_score); -- 使用游标，遍历结果,拿到第5行数据 FETCH stu_result INTO s_score; -- 将数据保存到stu_score表中 INSERT INTO stu_score VALUES (NULL,s_score); -- 关闭游标 CLOSE stu_result; END$ DELIMITER ; -- 调用pro_test11存储过程 CALL pro_test11(); -- 查询stu_score表,虽然数据正确，但是在执行存储过程时会报错 SELECT * FROM stu_score; 游标的优化使用(配合循环使用) /* 当游标结束后，会触发游标结束事件。我们可以通过这一特性来完成循环操作 加标记思想： 1.定义一个变量，默认值为0(意味着有数据) 2.当游标结束后，将变量值改为1(意味着没有数据了) */ -- 1.定义一个变量，默认值为0(意味着有数据) DECLARE flag INT DEFAULT 0; -- 2.当游标结束后，将变量值改为1(意味着没有数据了) DECLARE EXIT HANDLER FOR NOT FOUND SET flag = 1; /* 将student表中所有的成绩保存到stu_score表中 */ DELIMITER $ CREATE PROCEDURE pro_test12() BEGIN -- 定义成绩变量 DECLARE s_score INT; -- 定义标记变量 DECLARE flag INT DEFAULT 0; -- 创建游标，查询所有学生成绩数据 DECLARE stu_result CURSOR FOR SELECT score FROM student; -- 游标结束后，将标记变量改为1 DECLARE EXIT HANDLER FOR NOT FOUND SET flag = 1; -- 开启游标 OPEN stu_result; -- 循环使用游标 REPEAT -- 使用游标，遍历结果,拿到数据 FETCH stu_result INTO s_score; -- 将数据保存到stu_score表中 INSERT INTO stu_score VALUES (NULL,s_score); UNTIL flag=1 END REPEAT; -- 关闭游标 CLOSE stu_result; END$ DELIMITER ; -- 调用pro_test12存储过程 CALL pro_test12(); -- 查询stu_score表 SELECT * FROM stu_score; 9.存储过程的总结 存储过程是 事先经过编译并存储在数据库中的一段 SQL 语句的集合。可以在数据库层面做一些业务处理 说白了存储过程其实就是将sql语句封装为方法，然后可以调用方法执行sql语句而已 存储过程的好处 安全 高效 复用性强 10.存储函数 存储函数和存储过程是非常相似的。存储函数可以做的事情，存储过程也可以做到！ 存储函数有返回值，存储过程没有返回值(参数的out其实也相当于是返回数据了) 标准语法 创建存储函数 DELIMITER $ -- 标准语法 CREATE FUNCTION 函数名称([参数 数据类型]) RETURNS 返回值类型 BEGIN 执行的sql语句; RETURN 结果; END$ DELIMITER ; 调用存储函数 -- 标准语法 SELECT 函数名称(实际参数); 删除存储函数 -- 标准语法 DROP FUNCTION 函数名称; 案例演示 /* 定义存储函数，获取学生表中成绩大于95分的学生数量 */ DELIMITER $ CREATE FUNCTION fun_test1() RETURNS INT BEGIN -- 定义统计变量 DECLARE result INT; -- 查询成绩大于95分的学生数量，给统计变量赋值 SELECT COUNT(*) INTO result FROM student WHERE score > 95; -- 返回统计结果 RETURN result; END$ DELIMITER ; -- 调用fun_test1存储函数 SELECT fun_test1(); 1.1.2. 二、MySQL触发器 1.触发器的概念 触发器是与表有关的数据库对象，可以在 insert/update/delete 之前或之后，触发并执行触发器中定义的SQL语句。触发器的这种特性可以协助应用在数据库端确保数据的完整性 、日志记录 、数据校验等操作 。 使用别名 NEW 和 OLD 来引用触发器中发生变化的记录内容，这与其他的数据库是相似的。现在触发器还只支持行级触发，不支持语句级触发。 触发器类型 OLD的含义 NEW的含义 INSERT 型触发器 无 (因为插入前状态无数据) NEW 表示将要或者已经新增的数据 UPDATE 型触发器 OLD 表示修改之前的数据 NEW 表示将要或已经修改后的数据 DELETE 型触发器 OLD 表示将要或者已经删除的数据 无 (因为删除后状态无数据) 2.创建触发器 标准语法 DELIMITER $ CREATE TRIGGER 触发器名称 BEFORE|AFTER INSERT|UPDATE|DELETE ON 表名 [FOR EACH ROW] -- 行级触发器 BEGIN 触发器要执行的功能; END$ DELIMITER ; 触发器演示。通过触发器记录账户表的数据变更日志。包含：增加、修改、删除 创建账户表 -- 创建db9数据库 CREATE DATABASE db9; -- 使用db9数据库 USE db9; -- 创建账户表account CREATE TABLE account( id INT PRIMARY KEY AUTO_INCREMENT, -- 账户id NAME VARCHAR(20), -- 姓名 money DOUBLE -- 余额 ); -- 添加数据 INSERT INTO account VALUES (NULL,'张三',1000),(NULL,'李四',2000); 创建日志表 -- 创建日志表account_log CREATE TABLE account_log( id INT PRIMARY KEY AUTO_INCREMENT, -- 日志id operation VARCHAR(20), -- 操作类型 (insert update delete) operation_time DATETIME, -- 操作时间 operation_id INT, -- 操作表的id operation_params VARCHAR(200) -- 操作参数 ); 创建INSERT触发器 -- 创建INSERT触发器 DELIMITER $ CREATE TRIGGER account_insert AFTER INSERT ON account FOR EACH ROW BEGIN INSERT INTO account_log VALUES (NULL,'INSERT',NOW(),new.id,CONCAT('插入后{id=',new.id,',name=',new.name,',money=',new.money,'}')); END$ DELIMITER ; -- 向account表添加记录 INSERT INTO account VALUES (NULL,'王五',3000); -- 查询account表 SELECT * FROM account; -- 查询日志表 SELECT * FROM account_log; 创建UPDATE触发器 -- 创建UPDATE触发器 DELIMITER $ CREATE TRIGGER account_update AFTER UPDATE ON account FOR EACH ROW BEGIN INSERT INTO account_log VALUES (NULL,'UPDATE',NOW(),new.id,CONCAT('修改前{id=',old.id,',name=',old.name,',money=',old.money,'}','修改后{id=',new.id,',name=',new.name,',money=',new.money,'}')); END$ DELIMITER ; -- 修改account表 UPDATE account SET money=3500 WHERE id=3; -- 查询account表 SELECT * FROM account; -- 查询日志表 SELECT * FROM account_log; 创建DELETE触发器 -- 创建DELETE触发器 DELIMITER $ CREATE TRIGGER account_delete AFTER DELETE ON account FOR EACH ROW BEGIN INSERT INTO account_log VALUES (NULL,'DELETE',NOW(),old.id,CONCAT('删除前{id=',old.id,',name=',old.name,',money=',old.money,'}')); END$ DELIMITER ; -- 删除account表数据 DELETE FROM account WHERE id=3; -- 查询account表 SELECT * FROM account; -- 查询日志表 SELECT * FROM account_log; 3.查看触发器 -- 标准语法 SHOW TRIGGERS; -- 查看触发器 SHOW TRIGGERS; 4.删除触发器 -- 标准语法 DROP TRIGGER 触发器名称; -- 删除DELETE触发器 DROP TRIGGER account_delete; 5.触发器的总结 触发器是与表有关的数据库对象 可以在 insert/update/delete 之前或之后，触发并执行触发器中定义的SQL语句 触发器的这种特性可以协助应用在数据库端确保数据的完整性 、日志记录 、数据校验等操作 使用别名 NEW 和 OLD 来引用触发器中发生变化的记录内容 1.1.3. 三、MySQL事务 1.事务的概念 一条或多条 SQL 语句组成一个执行单元，其特点是这个单元要么同时成功要么同时失败，单元中的每条 SQL 语句都相互依赖，形成一个整体，如果某条 SQL 语句执行失败或者出现错误，那么整个单元就会回滚，撤回到事务最初的状态，如果单元中所有的 SQL 语句都执行成功，则事务就顺利执行。 2.事务的数据准备 -- 创建db10数据库 CREATE DATABASE db10; -- 使用db10数据库 USE db10; -- 创建账户表 CREATE TABLE account( id INT PRIMARY KEY AUTO_INCREMENT, -- 账户id NAME VARCHAR(20), -- 账户名称 money DOUBLE -- 账户余额 ); -- 添加数据 INSERT INTO account VALUES (NULL,'张三',1000),(NULL,'李四',1000); 3.未管理事务演示 -- 张三给李四转账500元 -- 1.张三账户-500 UPDATE account SET money=money-500 WHERE NAME='张三'; -- 2.李四账户+500 出错了... UPDATE account SET money=money+500 WHERE NAME='李四'; -- 该场景下，这两条sql语句要么同时成功，要么同时失败。就需要被事务所管理！ 4.管理事务演示 操作事务的三个步骤 开启事务：记录回滚点，并通知服务器，将要执行一组操作，要么同时成功、要么同时失败 执行sql语句：执行具体的一条或多条sql语句 结束事务(提交|回滚) 提交：没出现问题，数据进行更新 回滚：出现问题，数据恢复到开启事务时的状态 开启事务 -- 标准语法 START TRANSACTION; 回滚事务 -- 标准语法 ROLLBACK; 提交事务 -- 标准语法 COMMIT; 管理事务演示 -- 开启事务 START TRANSACTION; -- 张三给李四转账500元 -- 1.张三账户-500 UPDATE account SET money=money-500 WHERE NAME='张三'; -- 2.李四账户+500 -- 出错了... UPDATE account SET money=money+500 WHERE NAME='李四'; -- 回滚事务(出现问题) ROLLBACK; -- 提交事务(没出现问题) COMMIT; 5.事务的提交方式 提交方式 自动提交(MySQL默认为自动提交) 手动提交 修改提交方式 查看提交方式 -- 标准语法 SELECT @@AUTOCOMMIT; -- 1代表自动提交 0代表手动提交 修改提交方式 -- 标准语法 SET @@AUTOCOMMIT=数字; -- 修改为手动提交 SET @@AUTOCOMMIT=0; -- 查看提交方式 SELECT @@AUTOCOMMIT; 6.事务的四大特征(ACID) 原子性(atomicity) 原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚，因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响 一致性(consistency) 一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态 拿转账来说，假设张三和李四两者的钱加起来一共是2000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是2000，这就是事务的一致性 隔离性(isolcation) 隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离 持久性(durability) 持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作 7.事务的隔离级别 隔离级别的概念 多个客户端操作时 ,各个客户端的事务之间应该是隔离的，相互独立的 , 不受影响的。 而如果多个事务操作同一批数据时，则需要设置不同的隔离级别 , 否则就会产生问题 。 我们先来了解一下四种隔离级别的名称 , 再来看看可能出现的问题 四种隔离级别 1 读未提交 read uncommitted 2 读已提交 read committed 3 可重复读 repeatable read 4 串行化 serializable 可能引发的问题 问题 现象 脏读 是指在一个事务处理过程中读取了另一个未提交的事务中的数据 , 导致两次查询结果不一致 不可重复读 是指在一个事务处理过程中读取了另一个事务中修改并已提交的数据, 导致两次查询结果不一致 幻读 select 某记录是否存在，不存在，准备插入此记录，但执行 insert 时发现此记录已存在，无法插入。或不存在执行delete删除，却发现删除成功 查询数据库隔离级别 -- 标准语法 SELECT @@TX_ISOLATION; 修改数据库隔离级别 -- 标准语法 SET GLOBAL TRANSACTION ISOLATION LEVEL 级别字符串; -- 修改数据库隔离级别为read uncommitted SET GLOBAL TRANSACTION ISOLATION LEVEL read uncommitted; -- 查看隔离级别 SELECT @@TX_ISOLATION; -- 修改后需要断开连接重新开 8.事务隔离级别演示 脏读的问题 窗口1 -- 查询账户表 select * from account; -- 设置隔离级别为read uncommitted set global transaction isolation level read uncommitted; -- 开启事务 start transaction; -- 转账 update account set money = money - 500 where id = 1; update account set money = money + 500 where id = 2; -- 窗口2查询转账结果 ,出现脏读(查询到其他事务未提交的数据) -- 窗口2查看转账结果后，执行回滚 rollback; 窗口2 -- 查询隔离级别 select @@tx_isolation; -- 开启事务 start transaction; -- 查询账户表 select * from account; 解决脏读的问题和演示不可重复读的问题 窗口1 -- 设置隔离级别为read committed set global transaction isolation level read committed; -- 开启事务 start transaction; -- 转账 update account set money = money - 500 where id = 1; update account set money = money + 500 where id = 2; -- 窗口2查看转账结果，并没有发生变化(脏读问题被解决了) -- 执行提交事务。 commit; -- 窗口2查看转账结果，数据发生了变化(出现了不可重复读的问题，读取到其他事务已提交的数据) 窗口2 -- 查询隔离级别 select @@tx_isolation; -- 开启事务 start transaction; -- 查询账户表 select * from account; 解决不可重复读的问题 窗口1 -- 设置隔离级别为repeatable read set global transaction isolation level repeatable read; -- 开启事务 start transaction; -- 转账 update account set money = money - 500 where id = 1; update account set money = money + 500 where id = 2; -- 窗口2查看转账结果，并没有发生变化 -- 执行提交事务 commit; -- 这个时候窗口2只要还在上次事务中，看到的结果都是相同的。只有窗口2结束事务，才能看到变化(不可重复读的问题被解决) 窗口2 -- 查询隔离级别 select @@tx_isolation; -- 开启事务 start transaction; -- 查询账户表 select * from account; -- 提交事务 commit; -- 查询账户表 select * from account; 幻读的问题和解决 窗口1 -- 设置隔离级别为repeatable read set global transaction isolation level repeatable read; -- 开启事务 start transaction; -- 添加一条记录 INSERT INTO account VALUES (3,'王五',1500); -- 查询账户表，本窗口可以查看到id为3的结果 SELECT * FROM account; -- 提交事务 COMMIT; 窗口2 -- 查询隔离级别 select @@tx_isolation; -- 开启事务 start transaction; -- 查询账户表，查询不到新添加的id为3的记录 select * from account; -- 添加id为3的一条数据，发现添加失败。出现了幻读 INSERT INTO account VALUES (3,'测试',200); -- 提交事务 COMMIT; -- 查询账户表，查询到了新添加的id为3的记录 select * from account; 解决幻读的问题 ```mysql /* 窗口1 */ -- 设置隔离级别为serializable set global transaction isolation level serializable; -- 开启事务 start transaction; -- 添加一条记录 INSERT INTO account VALUES (4,'赵六',1600); -- 查询账户表，本窗口可以查看到id为4的结果 SELECT * FROM account; -- 提交事务 COMMIT; / 窗口2 / -- 查询隔离级别 select @@tx_isolation; -- 开启事务 start transaction; -- 查询账户表，发现查询语句无法执行，数据表被锁住！只有窗口1提交事务后，才可以继续操作 select * from account; -- 添加id为4的一条数据，发现已经存在了，就不会再添加了！幻读的问题被解决 INSERT INTO account VALUES (4,'测试',200); -- 提交事务 COMMIT; ``` 9.隔离级别总结 隔离级别 名称 出现脏读 出现不可重复读 出现幻读 数据库默认隔离级别 1 read uncommitted 读未提交 是 是 是 2 read committed 读已提交 否 是 是 Oracle / SQL Server 3 repeatable read 可重复读 否 否 是 MySQL 4 serializable 串行化 否 否 否 注意：隔离级别从小到大安全性越来越高，但是效率越来越低 , 所以不建议使用READ UNCOMMITTED 和 SERIALIZABLE 隔离级别. 10.事务的总结 一条或多条 SQL 语句组成一个执行单元，其特点是这个单元要么同时成功要么同时失败。例如转账操作 开启事务：start transaction; 回滚事务：rollback; 提交事务：commit; 事务四大特征 原子性 持久性 隔离性 一致性 事务的隔离级别 read uncommitted(读未提交) read committed (读已提交) repeatable read (可重复读) serializable (串行化) Copyright © MISIN 2022 | 豫ICP备2021006345号-1 all right reserved，powered by Gitbook该文件修订时间： 2020-06-21 11:12:10 "},"2.JavaWeb/4.mysql/MySQL高级-04-授课笔记.html":{"url":"2.JavaWeb/4.mysql/MySQL高级-04-授课笔记.html","title":"MySQL高级-04-授课笔记","keywords":"","body":"1. MySQL高级-04-授课笔记1.1.1. 一、MySQL存储引擎1.1.2. 二、MySQL索引1.1.3. 三、MySQL锁1.1.4. 四、集群1. MySQL高级-04-授课笔记 1.1.1. 一、MySQL存储引擎 1.MySQL体系结构 体系结构的概念 任何一套系统当中，每个部件都能起到一定的作用！ MySQL的体系结构 体系结构详解 客户端连接 支持接口：支持的客户端连接，例如C、Java、PHP等语言来连接MySQL数据库 第一层：网络连接层 连接池：管理、缓冲用户的连接，线程处理等需要缓存的需求。 例如：当客户端发送一个请求连接，会从连接池中获取一个连接进行使用。 第二层：核心服务层 管理服务和工具：系统的管理和控制工具，例如备份恢复、复制、集群等。 SQL接口：接受SQL命令，并且返回查询结果。 查询解析器：验证和解析SQL命令，例如过滤条件、语法结构等。 查询优化器：在执行查询之前，使用默认的一套优化机制进行优化sql语句 缓存：如果缓存当中有想查询的数据，则直接将缓存中的数据返回。没有的话再重新查询！ 第三层：存储引擎层 插件式存储引擎：管理和操作数据的一种机制，包括(存储数据、如何更新、查询数据等) 第四层：系统文件层 文件系统：配置文件、数据文件、日志文件、错误文件、二进制文件等等的保存 2.MySQL存储引擎 引擎的概念 生活中，引擎就是整个机器运行的核心，不同的引擎具备不同的功能。 MySQL存储引擎的概念 MySQL数据库使用不同的机制存取表文件 , 机制的差别在于不同的存储方式、索引技巧、锁定水平以及广泛的不同的功能和能力，在MySQL中 , 将这些不同的技术及配套的功能称为存储引擎 在关系型数据库中数据的存储是以表的形式存进行储的，所以存储引擎也可以称为表类型（即存储和操作此表的类型）。 Oracle , SqlServer等数据库只有一种存储引擎 , 而MySQL针对不同的需求, 配置MySQL的不同的存储引擎 , 就会让数据库采取了不同的处理数据的方式和扩展功能。 通过选择不同的引擎 ,能够获取最佳的方案 , 也能够获得额外的速度或者功能，提高程序的整体效果。所以了解引擎的特性 , 才能贴合我们的需求 , 更好的发挥数据库的性能。 MySQL支持的存储引擎 MySQL5.7支持的引擎包括：InnoDB、MyISAM、MEMORY、Archive、Federate、CSV、BLACKHOLE等 其中较为常用的有三种：InnoDB、MyISAM、MEMORY 3.常用引擎的特性对比 常用的存储引擎 MyISAM存储引擎 访问快,不支持事务和外键。表结构保存在.frm文件中，表数据保存在.MYD文件中，索引保存在.MYI文件中。 InnoDB存储引擎(MySQL5.5版本后默认的存储引擎) 支持事务 ,占用磁盘空间大 ,支持并发控制。表结构保存在.frm文件中，如果是共享表空间，数据和索引保存在 innodb_data_home_dir 和 innodb_data_file_path定义的表空间中，可以是多个文件。如果是多表空间存储，每个表的数据和索引单独保存在 .ibd 中。 MEMORY存储引擎 内存存储 , 速度快 ,不安全 ,适合小量快速访问的数据。表结构保存在.frm中。 特性对比 特性 MyISAM InnoDB MEMORY 存储限制 有(平台对文件系统大小的限制) 64TB 有(平台的内存限制) 事务安全 不支持 支持 不支持 锁机制 表锁 表锁/行锁 表锁 B+Tree索引 支持 支持 支持 哈希索引 不支持 不支持 支持 全文索引 支持 支持 不支持 集群索引 不支持 支持 不支持 数据索引 不支持 支持 支持 数据缓存 不支持 支持 N/A 索引缓存 支持 支持 N/A 数据可压缩 支持 不支持 不支持 空间使用 低 高 N/A 内存使用 低 高 中等 批量插入速度 高 低 高 外键 不支持 支持 不支持 4.引擎的操作 查询数据库支持的引擎 -- 标准语法 SHOW ENGINES; -- 查询数据库支持的存储引擎 SHOW ENGINES; -- 表含义: - support : 指服务器是否支持该存储引擎 - transactions : 指存储引擎是否支持事务 - XA : 指存储引擎是否支持分布式事务处理 - Savepoints : 指存储引擎是否支持保存点 查询某个数据库中所有数据表的引擎 -- 标准语法 SHOW TABLE STATUS FROM 数据库名称; -- 查看db9数据库所有表的存储引擎 SHOW TABLE STATUS FROM db9; 查询某个数据库中某个数据表的引擎 -- 标准语法 SHOW TABLE STATUS FROM 数据库名称 WHERE NAME = '数据表名称'; -- 查看db9数据库中stu_score表的存储引擎 SHOW TABLE STATUS FROM db9 WHERE NAME = 'stu_score'; 创建数据表，指定存储引擎 -- 标准语法 CREATE TABLE 表名( 列名,数据类型, ... )ENGINE = 引擎名称; -- 创建db11数据库 CREATE DATABASE db11; -- 使用db11数据库 USE db11; -- 创建engine_test表，指定存储引擎为MyISAM CREATE TABLE engine_test( id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(10) )ENGINE = MYISAM; -- 查询engine_test表的引擎 SHOW TABLE STATUS FROM db11 WHERE NAME = 'engine_test'; 修改表的存储引擎 -- 标准语法 ALTER TABLE 表名 ENGINE = 引擎名称; -- 修改engine_test表的引擎为InnoDB ALTER TABLE engine_test ENGINE = INNODB; -- 查询engine_test表的引擎 SHOW TABLE STATUS FROM db11 WHERE NAME = 'engine_test'; 5.总结：引擎的选择 MyISAM ：由于MyISAM不支持事务、不支持外键、支持全文检索和表级锁定，读写相互阻塞，读取速度快，节约资源，所以如果应用是以查询操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完整性、并发性要求不是很高，那么选择这个存储引擎是非常合适的。 InnoDB : 是MySQL的默认存储引擎， 由于InnoDB支持事务、支持外键、行级锁定 ，支持所有辅助索引(5.5.5后不支持全文检索)，高缓存，所以用于对事务的完整性有比较高的要求，在并发条件下要求数据的一致性，读写频繁的操作，那么InnoDB存储引擎是比较合适的选择，比如BBS、计费系统、充值转账等 MEMORY：将所有数据保存在RAM中，在需要快速定位记录和其他类似数据环境下，可以提供更快的访问。MEMORY的缺陷就是对表的大小有限制，太大的表无法缓存在内存中，其次是要确保表的数据可以恢复，数据库异常终止后表中的数据是可以恢复的。MEMORY表通常用于更新不太频繁的小表，用以快速得到访问结果。 总结：针对不同的需求场景，来选择最适合的存储引擎即可！如果不确定、则使用数据库默认的存储引擎！ 1.1.2. 二、MySQL索引 1.索引的概念 我们之前学习过集合，其中的ArrayList集合的特点之一就是有索引。那么有索引会带来哪些好处呢？ 没错，查询数据快！我们可以通过索引来快速查找到想要的数据。那么对于我们的MySQL数据库中的索引功能也是类似的！ MySQL数据库中的索引：是帮助MySQL高效获取数据的一种数据结构！所以，索引的本质就是数据结构。 在表数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式指向数据， 这样就可以在这些数据结构上实现高级查找算法，这种数据结构就是索引。 一张数据表，用于保存数据。 一个索引配置文件，用于保存索引，每个索引都去指向了某一个数据(表格演示) 举例，无索引和有索引的查找原理 2.索引的分类 功能分类 普通索引： 最基本的索引，它没有任何限制。 唯一索引：索引列的值必须唯一，但允许有空值。如果是组合索引，则列值组合必须唯一。 主键索引：一种特殊的唯一索引，不允许有空值。一般在建表时同时创建主键索引。 组合索引：顾名思义，就是将单列索引进行组合。 外键索引：只有InnoDB引擎支持外键索引，用来保证数据的一致性、完整性和实现级联操作。 全文索引：快速匹配全部文档的方式。InnoDB引擎5.6版本后才支持全文索引。MEMORY引擎不支持。 结构分类 B+Tree索引 ：MySQL使用最频繁的一个索引数据结构，是InnoDB和MyISAM存储引擎默认的索引类型。 Hash索引 : MySQL中Memory存储引擎默认支持的索引类型。 3.索引的操作 数据准备 -- 创建db12数据库 CREATE DATABASE db12; -- 使用db12数据库 USE db12; -- 创建student表 CREATE TABLE student( id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(10), age INT, score INT ); -- 添加数据 INSERT INTO student VALUES (NULL,'张三',23,98),(NULL,'李四',24,95), (NULL,'王五',25,96),(NULL,'赵六',26,94),(NULL,'周七',27,99); 创建索引 注意：如果一个表中有一列是主键，那么就会默认为其创建主键索引！(主键列不需要单独创建索引) -- 标准语法 CREATE [UNIQUE|FULLTEXT] INDEX 索引名称 [USING 索引类型] -- 默认是B+TREE ON 表名(列名...); -- 为student表中姓名列创建一个普通索引 CREATE INDEX idx_name ON student(NAME); -- 为student表中年龄列创建一个唯一索引 CREATE UNIQUE INDEX idx_age ON student(age); 查看索引 -- 标准语法 SHOW INDEX FROM 表名; -- 查看student表中的索引 SHOW INDEX FROM student; alter语句添加索引 -- 普通索引 ALTER TABLE 表名 ADD INDEX 索引名称(列名); -- 组合索引 ALTER TABLE 表名 ADD INDEX 索引名称(列名1,列名2,...); -- 主键索引 ALTER TABLE 表名 ADD PRIMARY KEY(主键列名); -- 外键索引(添加外键约束，就是外键索引) ALTER TABLE 表名 ADD CONSTRAINT 外键名 FOREIGN KEY (本表外键列名) REFERENCES 主表名(主键列名); -- 唯一索引 ALTER TABLE 表名 ADD UNIQUE 索引名称(列名); -- 全文索引(mysql只支持文本类型) ALTER TABLE 表名 ADD FULLTEXT 索引名称(列名); -- 为student表中name列添加全文索引 ALTER TABLE student ADD FULLTEXT idx_fulltext_name(name); -- 查看student表中的索引 SHOW INDEX FROM student; 删除索引 -- 标准语法 DROP INDEX 索引名称 ON 表名; -- 删除student表中的idx_score索引 DROP INDEX idx_score ON student; -- 查看student表中的索引 SHOW INDEX FROM student; 4.索引效率的测试 -- 创建product商品表 CREATE TABLE product( id INT PRIMARY KEY AUTO_INCREMENT, -- 商品id NAME VARCHAR(10), -- 商品名称 price INT -- 商品价格 ); -- 定义存储函数，生成长度为10的随机字符串并返回 DELIMITER $ CREATE FUNCTION rand_string() RETURNS VARCHAR(255) BEGIN DECLARE big_str VARCHAR(100) DEFAULT 'abcdefghijklmnopqrstuvwxyzABCDEFGHIGKLMNOPQRSTUVWXYZ'; DECLARE small_str VARCHAR(255) DEFAULT ''; DECLARE i INT DEFAULT 1; WHILE i 5.索引的实现原则 索引是在MySQL的存储引擎中实现的，所以每种存储引擎的索引不一定完全相同，也不是所有的引擎支持所有的索引类型。这里我们主要介绍InnoDB引擎的实现的B+Tree索引。 B+Tree是一种树型数据结构，是B-Tree的变种。通常使用在数据库和操作系统中的文件系统，特点是能够保持数据稳定有序。我们逐步的来了解一下。 5.1磁盘存储 系统从磁盘读取数据到内存时是以磁盘块（block）为基本单位的 位于同一个磁盘块中的数据会被一次性读取出来，而不是需要什么取什么。 InnoDB存储引擎中有页（Page）的概念，页是其磁盘管理的最小单位。InnoDB存储引擎中默认每个页的大小为16KB。 InnoDB引擎将若干个地址连接磁盘块，以此来达到页的大小16KB，在查询数据时如果一个页中的每条数据都能有助于定位数据记录的位置，这将会减少磁盘I/O次数，提高查询效率。 5.2BTree BTree结构的数据可以让系统高效的找到数据所在的磁盘块。为了描述BTree，首先定义一条记录为一个二元组[key, data] ，key为记录的键值，对应表中的主键值，data为一行记录中除主键外的数据。对于不同的记录，key值互不相同。BTree中的每个节点根据实际情况可以包含大量的关键字信息和分支，如下图所示为一个3阶的BTree： 根据图中结构显示，每个节点占用一个盘块的磁盘空间，一个节点上有两个升序排序的关键字和三个指向子树根节点的指针，指针存储的是子节点所在磁盘块的地址。两个关键词划分成的三个范围域对应三个指针指向的子树的数据的范围域。以根节点为例，关键字为17和35，P1指针指向的子树的数据范围为小于17，P2指针指向的子树的数据范围为17~35，P3指针指向的子树的数据范围为大于35。 查找顺序： 模拟查找15的过程 : 1.根节点找到磁盘块1，读入内存。【磁盘I/O操作第1次】 比较关键字15在区间（12），找到磁盘块2的指针P3。 3.P3指针找到磁盘块7，读入内存。【磁盘I/O操作第3次】 在磁盘块7中找到关键字15。 -- 分析上面过程，发现需要3次磁盘I/O操作，和3次内存查找操作。 -- 由于内存中的关键字是一个有序表结构，可以利用二分法查找提高效率。而3次磁盘I/O操作是影响整个BTree查找效率的决定因素。BTree使用较少的节点个数，使每次磁盘I/O取到内存的数据都发挥了作用，从而提高了查询效率。 5.3B+Tree B+Tree是在BTree基础上的一种优化，使其更适合实现外存储索引结构，InnoDB存储引擎就是用B+Tree实现其索引结构。 从上一节中的BTree结构图中可以看到每个节点中不仅包含数据的key值，还有data值。而每一个页的存储空间是有限的，如果data数据较大时将会导致每个节点（即一个页）能存储的key的数量很小，当存储的数据量很大时同样会导致B-Tree的深度较大，增大查询时的磁盘I/O次数，进而影响查询效率。在B+Tree中，所有数据记录节点都是按照键值大小顺序存放在同一层的叶子节点上，而非叶子节点上只存储key值信息，这样可以大大加大每个节点存储的key值数量，降低B+Tree的高度。 B+Tree相对于BTree区别： 非叶子节点只存储键值信息。 所有叶子节点之间都有一个连接指针。 数据记录都存放在叶子节点中。 将上一节中的BTree优化，由于B+Tree的非叶子节点只存储键值信息，假设每个磁盘块能存储4个键值及指针信息，则变成B+Tree后其结构如下图所示： 通常在B+Tree上有两个头指针，一个指向根节点，另一个指向关键字最小的叶子节点，而且所有叶子节点（即数据节点）之间是一种链式环结构。因此可以对B+Tree进行两种查找运算： 【有范围】对于主键的范围查找和分页查找 【有顺序】从根节点开始，进行随机查找 实际情况中每个节点可能不能填充满，因此在数据库中，B+Tree的高度一般都在2~4层。MySQL的InnoDB存储引擎在设计时是将根节点常驻内存的，也就是说查找某一键值的行记录时最多只需要1~3次磁盘I/O操作。 6.总结：索引的设计原则 索引的设计可以遵循一些已有的原则，创建索引的时候请尽量考虑符合这些原则，便于提升索引的使用效率，更高效的使用索引。 创建索引时的原则 对查询频次较高，且数据量比较大的表建立索引。 使用唯一索引，区分度越高，使用索引的效率越高。 索引字段的选择，最佳候选列应当从where子句的条件中提取，如果where子句中的组合比较多，那么应当挑选最常用、过滤效果最好的列的组合。 使用短索引，索引创建之后也是使用硬盘来存储的，因此提升索引访问的I/O效率，也可以提升总体的访问效率。假如构成索引的字段总长度比较短，那么在给定大小的存储块内可以存储更多的索引值，相应的可以有效的提升MySQL访问索引的I/O效率。 索引可以有效的提升查询数据的效率，但索引数量不是多多益善，索引越多，维护索引的代价自然也就水涨船高。对于插入、更新、删除等DML操作比较频繁的表来说，索引过多，会引入相当高的维护代价，降低DML操作的效率，增加相应操作的时间消耗。另外索引过多的话，MySQL也会犯选择困难病，虽然最终仍然会找到一个可用的索引，但无疑提高了选择的代价。 联合索引的特点 在mysql建立联合索引时会遵循最左前缀匹配的原则，即最左优先，在检索数据时从联合索引的最左边开始匹配， 对列name列、address和列phone列建一个联合索引 ALTER TABLE user ADD INDEX index_three(name,address,phone); 联合索引index_three实际建立了(name)、(name,address)、(name,address,phone)三个索引。所以下面的三个SQL语句都可以命中索引。 SELECT * FROM user WHERE address = '北京' AND phone = '12345' AND name = '张三'; SELECT * FROM user WHERE name = '张三' AND address = '北京'; SELECT * FROM user WHERE name = '张三'; 上面三个查询语句执行时会依照最左前缀匹配原则，检索时分别会使用索引 (name,address,phone) (name,address) (name) 进行数据匹配。 索引的字段可以是任意顺序的，如： -- 优化器会帮助我们调整顺序，下面的SQL语句都可以命中索引 SELECT * FROM user WHERE address = '北京' AND phone = '12345' AND name = '张三'; Mysql的优化器会帮助我们调整where条件中的顺序，以匹配我们建立的索引。 联合索引中最左边的列不包含在条件查询中，所以根据上面的原则，下面的SQL语句就不会命中索引。 -- 联合索引中最左边的列不包含在条件查询中，下面的SQL语句就不会命中索引 SELECT * FROM user WHERE address = '北京' AND phone = '12345'; 1.1.3. 三、MySQL锁 1.锁的概念 之前我们学习过多线程，多线程当中如果想保证数据的准确性是如何实现的呢？没错，通过同步实现。同步就相当于是加锁。加了锁以后有什么好处呢？当一个线程真正在操作数据的时候，其他线程只能等待。当一个线程执行完毕后，释放锁。其他线程才能进行操作！ 那么我们的MySQL数据库中的锁的功能也是类似的。在我们学习事务的时候，讲解过事务的隔离性，可能会出现脏读、不可重复读、幻读的问题，当时我们的解决方式是通过修改事务的隔离级别来控制，但是数据库的隔离级别呢我们并不推荐修改。所以，锁的作用也可以解决掉之前的问题！ 锁机制 : 数据库为了保证数据的一致性，而使用各种共享的资源在被并发访问时变得有序所设计的一种规则。 举例，在电商网站购买商品时，商品表中只存有1个商品，而此时又有两个人同时购买，那么谁能买到就是一个关键的问题。 这里会用到事务进行一系列的操作： 先从商品表中取出物品的数据 然后插入订单 付款后，再插入付款表信息 更新商品表中商品的数量 以上过程中，使用锁可以对商品数量数据信息进行保护，实现隔离，即只允许第一位用户完成整套购买流程，而其他用户只能等待，这样就解决了并发中的矛盾问题。 在数据库中，数据是一种供许多用户共享访问的资源，如何保证数据并发访问的一致性、有效性，是所有数据库必须解决的一个问题，MySQL由于自身架构的特点，在不同的存储引擎中，都设计了面对特定场景的锁定机制，所以引擎的差别，导致锁机制也是有很大差别的。 2.锁的分类 按操作分类： 共享锁：也叫读锁。针对同一份数据，多个事务读取操作可以同时加锁而不互相影响 ，但是不能修改数据记录。 排他锁：也叫写锁。当前的操作没有完成前,会阻断其他操作的读取和写入 按粒度分类： 表级锁：操作时，会锁定整个表。开销小，加锁快；不会出现死锁；锁定力度大，发生锁冲突概率高，并发度最低。偏向于MyISAM存储引擎！ 行级锁：操作时，会锁定当前操作行。开销大，加锁慢；会出现死锁；锁定粒度小，发生锁冲突的概率低，并发度高。偏向于InnoDB存储引擎！ 页级锁：锁的粒度、发生冲突的概率和加锁的开销介于表锁和行锁之间，会出现死锁，并发性能一般。 按使用方式分类： 悲观锁：每次查询数据时都认为别人会修改，很悲观，所以查询时加锁。 乐观锁：每次查询数据时都认为别人不会修改，很乐观，但是更新时会判断一下在此期间别人有没有去更新这个数据 不同存储引擎支持的锁 存储引擎 表级锁 行级锁 页级锁 MyISAM 支持 不支持 不支持 InnoDB 支持 支持 不支持 MEMORY 支持 不支持 不支持 BDB 支持 不支持 支持 3.演示InnoDB锁 数据准备 -- 创建db13数据库 CREATE DATABASE db13; -- 使用db13数据库 USE db13; -- 创建student表 CREATE TABLE student( id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(10), age INT, score INT ); -- 添加数据 INSERT INTO student VALUES (NULL,'张三',23,99),(NULL,'李四',24,95), (NULL,'王五',25,98),(NULL,'赵六',26,97); 共享锁 -- 标准语法 SELECT语句 LOCK IN SHARE MODE; -- 窗口1 /* 共享锁：数据可以被多个事务查询，但是不能修改 */ -- 开启事务 START TRANSACTION; -- 查询id为1的数据记录。加入共享锁 SELECT * FROM student WHERE id=1 LOCK IN SHARE MODE; -- 查询分数为99分的数据记录。加入共享锁 SELECT * FROM student WHERE score=99 LOCK IN SHARE MODE; -- 提交事务 COMMIT; -- 窗口2 -- 开启事务 START TRANSACTION; -- 查询id为1的数据记录(普通查询，可以查询) SELECT * FROM student WHERE id=1; -- 查询id为1的数据记录，并加入共享锁(可以查询。共享锁和共享锁兼容) SELECT * FROM student WHERE id=1 LOCK IN SHARE MODE; -- 修改id为1的姓名为张三三(不能修改，会出现锁的情况。只有窗口1提交事务后，才能修改成功) UPDATE student SET NAME='张三三' WHERE id = 1; -- 修改id为2的姓名为李四四(修改成功，InnoDB引擎默认是行锁) UPDATE student SET NAME='李四四' WHERE id = 2; -- 修改id为3的姓名为王五五(注意：InnoDB引擎如果不采用带索引的列。则会提升为表锁) UPDATE student SET NAME='王五五' WHERE id = 3; -- 提交事务 COMMIT; 排他锁 -- 标准语法 SELECT语句 FOR UPDATE; -- 窗口1 /* 排他锁：加锁的数据，不能被其他事务加锁查询或修改 */ -- 开启事务 START TRANSACTION; -- 查询id为1的数据记录，并加入排他锁 SELECT * FROM student WHERE id=1 FOR UPDATE; -- 提交事务 COMMIT; -- 窗口2 -- 开启事务 START TRANSACTION; -- 查询id为1的数据记录(普通查询没问题) SELECT * FROM student WHERE id=1; -- 查询id为1的数据记录，并加入共享锁(不能查询。因为排他锁不能和其他锁共存) SELECT * FROM student WHERE id=1 LOCK IN SHARE MODE; -- 查询id为1的数据记录，并加入排他锁(不能查询。因为排他锁不能和其他锁共存) SELECT * FROM student WHERE id=1 FOR UPDATE; -- 修改id为1的姓名为张三(不能修改，会出现锁的情况。只有窗口1提交事务后，才能修改成功) UPDATE student SET NAME='张三' WHERE id=1; -- 提交事务 COMMIT; 注意：锁的兼容性 共享锁和共享锁 兼容 共享锁和排他锁 冲突 排他锁和排他锁 冲突 排他锁和共享锁 冲突 4.演示MyISAM锁 数据准备 -- 创建product表 CREATE TABLE product( id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(20), price INT )ENGINE = MYISAM; -- 指定存储引擎为MyISAM -- 添加数据 INSERT INTO product VALUES (NULL,'华为手机',4999),(NULL,'小米手机',2999), (NULL,'苹果',8999),(NULL,'中兴',1999); 读锁 -- 标准语法 -- 加锁 LOCK TABLE 表名 READ; -- 解锁(将当前会话所有的表进行解锁) UNLOCK TABLES; -- 窗口1 /* 读锁：所有连接只能读取数据，不能修改 */ -- 为product表加入读锁 LOCK TABLE product READ; -- 查询product表(查询成功) SELECT * FROM product; -- 修改华为手机的价格为5999(修改失败) UPDATE product SET price=5999 WHERE id=1; -- 解锁 UNLOCK TABLES; -- 窗口2 -- 查询product表(查询成功) SELECT * FROM product; -- 修改华为手机的价格为5999(不能修改，窗口1解锁后才能修改成功) UPDATE product SET price=5999 WHERE id=1; 写锁 -- 标准语法 -- 加锁 LOCK TABLE 表名 WRITE; -- 解锁(将当前会话所有的表进行解锁) UNLOCK TABLES; -- 窗口1 /* 写锁：其他连接不能查询和修改数据 */ -- 为product表添加写锁 LOCK TABLE product WRITE; -- 查询product表(查询成功) SELECT * FROM product; -- 修改小米手机的金额为3999(修改成功) UPDATE product SET price=3999 WHERE id=2; -- 解锁 UNLOCK TABLES; -- 窗口2 -- 查询product表(不能查询。只有窗口1解锁后才能查询成功) SELECT * FROM product; -- 修改小米手机的金额为2999(不能修改。只有窗口1解锁后才能修改成功) UPDATE product SET price=2999 WHERE id=2; 5.演示悲观锁和乐观锁 悲观锁的概念 就是很悲观，它对于数据被外界修改的操作持保守态度，认为数据随时会修改。 整个数据处理中需要将数据加锁。悲观锁一般都是依靠关系型数据库提供的锁机制。 我们之前所学的行锁，表锁不论是读写锁都是悲观锁。 乐观锁的概念 就是很乐观，每次自己操作数据的时候认为没有人会来修改它，所以不去加锁。 但是在更新的时候会去判断在此期间数据有没有被修改。 需要用户自己去实现，不会发生并发抢占资源，只有在提交操作的时候检查是否违反数据完整性。 悲观锁和乐观锁使用前提 对于读的操作远多于写的操作的时候，这时候一个更新操作加锁会阻塞所有的读取操作，降低了吞吐量。最后还要释放锁，锁是需要一些开销的，这时候可以选择乐观锁。 如果是读写比例差距不是非常大或者系统没有响应不及时，吞吐量瓶颈的问题，那就不要去使用乐观锁，它增加了复杂度，也带来了业务额外的风险。这时候可以选择悲观锁。 乐观锁的实现方式 版本号 给数据表中添加一个version列，每次更新后都将这个列的值加1。 读取数据时，将版本号读取出来，在执行更新的时候，比较版本号。 如果相同则执行更新，如果不相同，说明此条数据已经发生了变化。 用户自行根据这个通知来决定怎么处理，比如重新开始一遍，或者放弃本次更新。 -- 创建city表 CREATE TABLE city( id INT PRIMARY KEY AUTO_INCREMENT, -- 城市id NAME VARCHAR(20), -- 城市名称 VERSION INT -- 版本号 ); -- 添加数据 INSERT INTO city VALUES (NULL,'北京',1),(NULL,'上海',1),(NULL,'广州',1),(NULL,'深圳',1); -- 修改北京为北京市 -- 1.查询北京的version SELECT VERSION FROM city WHERE NAME='北京'; -- 2.修改北京为北京市，版本号+1。并对比版本号 UPDATE city SET NAME='北京市',VERSION=VERSION+1 WHERE NAME='北京' AND VERSION=1; 时间戳 和版本号方式基本一样，给数据表中添加一个列，名称无所谓，数据类型需要是timestamp 每次更新后都将最新时间插入到此列。 读取数据时，将时间读取出来，在执行更新的时候，比较时间。 如果相同则执行更新，如果不相同，说明此条数据已经发生了变化。 6.锁的总结 表锁和行锁 行锁：锁的粒度更细，加行锁的性能损耗较大。并发处理能力较高。InnoDB引擎默认支持！ 表锁：锁的粒度较粗，加表锁的性能损耗较小。并发处理能力较低。InnoDB、MyISAM引擎支持！ InnoDB锁优化建议 尽量通过带索引的列来完成数据查询，从而避免InnoDB无法加行锁而升级为表锁。 合理设计索引，索引要尽可能准确，尽可能的缩小锁定范围，避免造成不必要的锁定。 尽可能减少基于范围的数据检索过滤条件。 尽量控制事务的大小，减少锁定的资源量和锁定时间长度。 在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁产生概率。 对于非常容易产生死锁的业务部分，可以尝试使用升级锁定颗粒度，通过表级锁定来减少死锁的产生。 1.1.4. 四、集群 1.集群的概念 如今随着互联网的发展，数据的量级也是成指数的增长，从GB到TB到PB。对数据的各种操作也是愈加的困难，传统的关系型数据库已经无法满足快速查询与插入数据的需求。一台数据库服务器已经无法满足海量数据的存储需求，所以由多台数据库构成的数据库集群成了必然的方式。不过，为了保证数据的一致性，查询效率等，同时又要解决多台服务器间的通信、负载均衡等问题。 MyCat是一款数据库集群软件，是阿里曾经开源的知名产品——Cobar，简单的说，MyCAT就是：一个新颖的数据库中间件产品支持MySQL集群，提供高可用性数据分片集群。你可以像使用mysql一样使用mycat。对于开发人员来说根本感觉不到mycat的存在。MyCat不单单是支持MySQL，像常用的关系型数据库Oracle、SqlServer都支持。 2.集群的原理 我们来说个例子，大海捞针和一个水瓶里捞针，毋庸置疑水瓶里一定能更快找到针，因为它需要检索的范围更小。数据库集群也是如此原理，我们可以将一个数据量为300G的数据库数据平均拆分成3部分，每个数据库中只存储100G数据，此时用户搜索，先经过我们中间代理层，中间代理层同时发出3个请求执行查询，比如第1台返回100条数据，耗时3秒，第2台返回200条数据，耗时3秒，第3台返回500条数据，耗时3秒，此时中间件只需要在800条记录中进行筛选，即可检索出用户要的结果，此时耗时其实一共只有3秒，因为每台机器做运算的时候，都是同时执行。如果我们此时直接在300G的数据库查询，耗时10秒，那使用中间件进行集群的效率就非常明显 MyCat的实现流程和这个流程大致相似。MyCat自身不存储数据，但用户每次链接数据库的时候，直接连接MyCat即可.所以我们MyCat自身其实就是个逻辑数据库，它自身还有表结构，表结构叫逻辑表。 3.Mycat环境搭建 3.1 Mycat下载和安装 官网：http://www.mycat.io/ 下载地址 : http://dl.mycat.io/ 选择1.6.7.1的版本，下载到D盘，安装包入下图： 上传：使用SecureCRT的SFTP命令，将文件发送到Linux虚拟机root目录下： sftp> put D:\\Mycat-server-1.6.7.1-release-20190627191042-linux.tar.gz 解压：解压mycat.tar.gz并查看 tar -zxvf mycat.tar.gz cd mycat ll 授权：设置mycat权限 chmod -R 777 mycat 环境变量：配置环境变量 vi /etc/profile // 添加 export MYCAT_HOME=/root/mycat // 使环境变量生效 source /etc/profile 启动mycat // 进入bin目录 [root@localhost]# cd /root/mycat/bin // 执行启动命令 [root@localhost bin]# ./mycat start 查看：检测端口监听状况，Mycat的端口号是8066 [root@localhost bin]# netstat -ant|grep 8066 连接：使用SQLYog连接Mycat 连接后显示： 3.2 环境准备 配置模型 克隆虚拟机 修改配置网卡 在第二个虚拟机中，生成全新mac地址 重启网络 // 重启网络 service network restart //查看ip地址 ip addr 修改mysql配置文件,更改uuid 在第二个服务器上，修改mysql的uuid // 编辑配置文件 vi /var/lib/mysql/auto.cnf // 将server-uuid更改 启动MySQL并查看 //将两台服务器的防火墙关闭 systemctl stop firewalld //启动两台服务器的mysql service mysqld restart //启动两台服务器的mycat cd /root/mycat/bin ./mycat restart //查看监听端口 netstat -ant|grep 3306 netstat -ant|grep 8066 //使用sqlyog测试连接 4.主从复制 主从复制的概念 为了使用Mycat进行读写分离，我们先要配置MySQL数据库的主从复制。 从服务器自动同步主服务器的数据，从而达到数据一致。 进而，我们可以写操作时，只操作主服务器，而读操作，就可以操作从服务器了。 原理：主服务器在处理数据时，生成binlog日志，通过对日志的备份，实现从服务器的数据同步。 主服务器的配置 在第一个服务器上，编辑mysql配置文件 // 编辑mysql配置文件 vi /etc/my.cnf //在[mysqld]下面加上： log-bin=mysql-bin # 开启复制操作 server-id=1 # master is 1 innodb_flush_log_at_trx_commit=1 sync_binlog=1 登录mysql，创建用户并授权 // 登录mysql mysql -u root -p // 去除密码权限 SET GLOBAL validate_password_policy=0; SET GLOBAL validate_password_length=1; // 创建用户 CREATE USER 'hm'@'%' IDENTIFIED BY 'itheima'; // 授权 GRANT ALL ON *.* TO 'hm'@'%'; 重启mysql服务，登录mysql服务 // 重启mysql service mysqld restart // 登录mysql mysql -u root -p 查看主服务器的配置 // 查看主服务器配置 show master status; 从服务器的配置 在第二个服务器上，编辑mysql配置文件 // 编辑mysql配置文件 vi /etc/my.cnf // 在[mysqld]下面加上： server-id=2 登录mysql // 登录mysql mysql -u root -p // 执行 use mysql; drop table slave_master_info; drop table slave_relay_log_info; drop table slave_worker_info; drop table innodb_index_stats; drop table innodb_table_stats; source /usr/share/mysql/mysql_system_tables.sql; 重启mysql，重新登录，配置从节点 // 重启mysql service mysqld restart // 重新登录mysql mysql -u root -p // 执行 change master to master_host='主服务器ip地址',master_port=3306,master_user='hm',master_password='itheima',master_log_file='mysql-bin.000001',master_log_pos=4642; 重启mysql，重新登录，开启从节点 // 重启mysql service mysqld restart // 重新登录mysql mysql -u root -p // 开启从节点 start slave; // 查询结果 show slave status\\G; //Slave_IO_Running和Slave_SQL_Running都为yes才表示同步成功。 测试 sqlyog连接主服务器 -- 主服务器创建db1数据库,从服务器会自动同步 CREATE DATABASE db1; sqlyog连接从服务器 -- 从服务器创建db2数据库,主服务器不会自动同步 CREATE DATABASE db2; 启动失败的解决方案 启动失败：Slave_IO_Running为 NO 方法一:重置slave slave stop; reset slave; start slave ; 方法二:重设同步日志文件及读取位置 slave stop; change master to master_log_file=’mysql-bin.000001’, master_log_pos=1; start slave ; 5.读写分离 读写分离的概念 写操作只写入主服务器，读操作读取从服务器。 在主服务器上修改server.xml user标签主要用于定义登录mycat的用户和权限。如上面定义用户名mycat和密码123456，该用户可以访问的schema的HEIMADB逻辑库。 123456 HEIMADB --> 在主服务器上修改schema.xml select user() 配置详解 schema标签逻辑库的概念和mysql数据库中Datebase的概念相同，我们在查询这两个逻辑库中的表的时候，需要切换到该逻辑库下才可以查到所需要的表。 dataNode属性：该属性用于绑定逻辑库到某个具体的database上。 dataNode标签： dataNode标签定义了mycat中的数据节点，也就是数据分片。一个dataNode标签就是一个独立的数据分片。 name属性：定义数据节点的名字，这个名字需要是唯一的，我们需要在table标签上应用这个名字，来建立表与分片对应的关系。 dataHost属性：该属性用于定义该分片属于那个数据库实例，属性值是引用datahost标签定义的name属性。 database属性：该属性用于定义该分片属于那个具体数据库实例上的具体库，因为这里使用两个纬度来定义分片，就是：实例+具体的库。因为每个库上建立的表和表结构是一样的。所以这样做就可以轻松的对表进行水平拆分。 dataHost标签：该标签在mycat逻辑库中也是作为最底层的标签存在，直接定义了具体的数据库实例、读写分离配置和心跳语句。 balance属性： 负载均衡类型 ​ balance=0: 不开启读写分离，所有读操作都发送到当前可用的writeHost上。 ​ balance=1: 全部的readHost与Stand by writeHost都参与select语句的负载均衡 ​ balance=2: 所有的读操作都随机在writeHost，readHost上分发。 ​ balance=3: 所有的读请求都随机分配到writeHost对应的readHost上执行，writeHost不负担读压力。 switchType属性： ​ -1：表示不自动切换。 ​ 1 ：默认值，表示自动切换 ​ 2：表示基于MySQL主从同步状态决定是否切换，心跳语句： show slave status. ​ 3:表示基于mysql galary cluster的切换机制，适合mycat1.4之上的版本，心跳语句show status like \"%esrep%\"; writeHost标签，readHost标签：这两个标签指定后端数据库的相关配置给mycat，用于实例化后端连接池。唯一不同的是，writeHost指定写实例、readHost指定读实例，组合这些读写实例来满足系统的要求。 host属性：用于标识不同的实例，对于writehost，一般使用M1；对于readhost一般使用S1. url属性：后端实例连接地址，如果使用native的dbDriver，则一般为address:port这种形式，用JDBC或其他的dbDriver，则需要特殊指定。当使用JDBC时则可以这么写：jdbc:mysql://localhost:3306/。 user属性：后端存储实例的用户名。 password属性：后端存储实例的密码 测试 重启主服务器的mycat // 重启mycat cd /root/mycat/bin ./mycat restart // 查看端口监听 netstat -ant|grep 8066 sqlyog连接mycat -- 创建学生表 CREATE TABLE student( id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(10) ); -- 查询学生表 SELECT * FROM student; -- 添加两条记录 INSERT INTO student VALUES (NULL,'张三'),(NULL,'李四'); -- 停止主从复制后，添加的数据只会保存到主服务器上。 INSERT INTO student VALUES (NULL,'王五'); sqlyog连接主服务器 -- 主服务器：查询学生表，可以看到数据 SELECT * FROM student; sqlyog连接从服务器 -- 从服务器：查询学生表，可以看到数据(因为有主从复制) SELECT * FROM student; -- 从服务器：删除一条记录。(主服务器并没有删除，mycat中间件查询的结果是从服务器的数据) DELETE FROM student WHERE id=2; 6.分库分表 分库分表的概念 将庞大的数据进行拆分 水平拆分：根据表的数据逻辑关系，将同一表中的数据按照某种条件，拆分到多台数据库服务器上，也叫做横向拆分。例如：一张1000万的大表，按照一模一样的结构，拆分成4个250万的小表，分别保存到4个数据库中。 垂直拆分：根据业务的维度，将不同的表切分到不同的数据库之上，也叫做纵向拆分。例如：所有的订单都保存到订单库中，所有的用户都保存到用户库中，同类型的表保存在同一库，不同的表分散在不同的库中。 Mycat水平拆分 修改主服务器的server.xml 0：本地文件方式 在mycat/conf/sequence_conf.properties文件中： GLOBAL.MINDI=10000最小值 GLOBAL.MAXID=20000最大值，建议修改到9999999999 1：数据库方式 分库分表中保证全局主键自增唯一，但是需要执行mycat函数，配置sequence_db_conf.properties 2：时间戳方式 mycat实现的时间戳，建议varchar类型，要注意id的长度 0 修改主服务器的sequence_conf.properties #default global sequence GLOBAL.HISIDS= # 可以自定义关键字 GLOBAL.MINID=10001 # 最小值 GLOBAL.MAXID=20000 # 最大值 GLOBAL.CURID=10000 修改主服务器的schema.xml table标签定义了逻辑表，所有需要拆分的表都需要在这个标签中定义。 rule属性：拆分规则。mod-long是拆分规则之一，主键根据服务器数量取模，在rule.xml中指定。如果是3个数据库，那么数据取模后，平均分配到三个库中。 name属性：定义逻辑表的表名，这个名字就如同在数据库中执行create table命令指定的名字一样，同一个schema标签中定义的表名必须是唯一的。 dataNode属性： 定义这个逻辑表所属的dataNode，该属性的值需要和dataNode标签中name属性的值相互对应。 select user() 修改主服务器的rule.xml 3 测试 mycat操作 -- 创建product表 CREATE TABLE product( id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(20), price INT ); -- 添加6条数据 INSERT INTO product(id,NAME,price) VALUES (NEXT VALUE FOR MYCATSEQ_GLOBAL,'苹果手机',6999); INSERT INTO product(id,NAME,price) VALUES (NEXT VALUE FOR MYCATSEQ_GLOBAL,'华为手机',5999); INSERT INTO product(id,NAME,price) VALUES (NEXT VALUE FOR MYCATSEQ_GLOBAL,'三星手机',4999); INSERT INTO product(id,NAME,price) VALUES (NEXT VALUE FOR MYCATSEQ_GLOBAL,'小米手机',3999); INSERT INTO product(id,NAME,price) VALUES (NEXT VALUE FOR MYCATSEQ_GLOBAL,'中兴手机',2999); INSERT INTO product(id,NAME,price) VALUES (NEXT VALUE FOR MYCATSEQ_GLOBAL,'OOPO手机',1999); -- 查询product表 SELECT * FROM product; 主服务器操作 -- 在不同数据库中查询product表 SELECT * FROM product; 从服务器操作 -- 在不同数据库中查询product表 SELECT * FROM product; Mycat垂直拆分 修改主服务器的schema select user() 测试 sqlyog连接mycat ```mysql -- 创建dog表 CREATE TABLE dog( id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(10) ); -- 添加数据 INSERT INTO dog(id,NAME) VALUES (NEXT VALUE FOR MYCATSEQ_GLOBAL,'哈士奇'); -- 查询dog表 SELECT * FROM dog; -- 创建cat表 CREATE TABLE cat( id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(10) ); -- 添加数据 INSERT INTO cat(id,NAME) VALUES (NEXT VALUE FOR MYCATSEQ_GLOBAL,'波斯猫'); -- 查询cat表 SELECT * FROM cat; -- 创建apple表 CREATE TABLE apple( id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(10) ); -- 添加数据 INSERT INTO apple(id,NAME) VALUES (NEXT VALUE FOR MYCATSEQ_GLOBAL,'红富士'); -- 查询apple表 SELECT * FROM apple; -- 创建banana表 CREATE TABLE banana( id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(10) ); -- 添加数据 INSERT INTO banana(id,NAME) VALUES (NEXT VALUE FOR MYCATSEQ_GLOBAL,'香蕉'); -- 查询banana表 SELECT * FROM banana; ``` - sqlyog连接主服务器 ```mysql -- 查询dog表 SELECT * FROM dog; -- 查询cat表 SELECT * FROM cat; -- 查询apple表 SELECT * FROM apple; -- 查询banana表 SELECT * FROM banana; ``` - sqlyog连接从服务器 ```mysql -- 查询dog表 SELECT * FROM dog; -- 查询cat表 SELECT * FROM cat; -- 查询apple表 SELECT * FROM apple; -- 查询banana表 SELECT * FROM banana; ``` Copyright © MISIN 2022 | 豫ICP备2021006345号-1 all right reserved，powered by Gitbook该文件修订时间： 2022-11-10 10:51:16 "},"2.JavaWeb/5.JDBC/JDBC-01-授课笔记.html":{"url":"2.JavaWeb/5.JDBC/JDBC-01-授课笔记.html","title":"JDBC-01-授课笔记","keywords":"","body":"1. JDBC-01-授课笔记1.1.1. 一、JDBC快速入门1.1.2. 二、JDBC各个功能类详解1.1.3. 三、JDBC案例student学生表的CRUD1.1.4. 四、JDBC工具类1.1.5. 五、SQL注入攻击1.1.6. 六、综合案例-课程表批量新增加事务管理1. JDBC-01-授课笔记 1.1.1. 一、JDBC快速入门 1.jdbc的概念 JDBC（Java DataBase Connectivity,java数据库连接）是一种用于执行SQL语句的Java API，可以为多种关系型数据库提供统一访问，它是由一组用Java语言编写的类和接口组成的。 2.jdbc的本质 其实就是java官方提供的一套规范(接口)。用于帮助开发人员快速实现不同关系型数据库的连接！ 3.jdbc的快速入门程序 导入jar包 注册驱动 Class.forName(\"com.mysql.jdbc.Driver\"); 获取连接 Connection con = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/db2\", \"root\", \"root\"); 获取执行者对象 Statement stat = con.createStatement(); 执行sql语句，并接收返回结果 String sql = \"SELECT * FROM user\"; ResultSet rs = stat.executeQuery(sql); 处理结果 while(rs.next()) { System.out.println(rs.getInt(\"id\") + \"\\t\" + rs.getString(\"name\")); } 释放资源 con.close(); stat.close(); rs.close(); 1.1.2. 二、JDBC各个功能类详解 1.DriverManager DriverManager：驱动管理对象 注册驱动(告诉程序该使用哪一个数据库驱动) static void registerDriver(Driver driver)：注册与给定的驱动程序 DriverManager 写代码使用：Class.forName(\"com.mysql.jdbc.Driver\"); 通过查看源码发现：在com.mysql.jdbc.Driver类中存在静态代码块 static { try { java.sql.DriverManager.registerDriver(new Driver()); } catch (SQLException E) { throw new RuntimeException(\"Can't register driver!\"); } } 注意：mysql5之后的驱动jar包可以省略注册驱动的步骤。在jar包中，存在一个java.sql.Driver配置文件，文件中指定了com.mysql.jdbc.Driver 获取数据库连接(获取到数据库的连接并返回连接对象) static Connection getConnection(String url, String user, String password); 返回值：Connection数据库连接对象 参数 url：指定连接的路径。语法：jdbc:mysql://ip地址(域名):端口号/数据库名称 user：用户名 password：密码 2.Connection Connection：数据库连接对象 获取执行者对象 获取普通执行者对象：Statement createStatement(); 获取预编译执行者对象：PreparedStatement prepareStatement(String sql); 管理事务 开启事务：setAutoCommit(boolean autoCommit); 参数为false，则开启事务。 提交事务：commit(); 回滚事务：rollback(); 释放资源 立即将数据库连接对象释放：void close(); 3.Statement Statement：执行sql语句的对象 执行DML语句：int executeUpdate(String sql); 返回值int：返回影响的行数。 参数sql：可以执行insert、update、delete语句。 执行DQL语句：ResultSet executeQuery(String sql); 返回值ResultSet：封装查询的结果。 参数sql：可以执行select语句。 释放资源 立即将执行者对象释放：void close(); 4.ResultSet ResultSet：结果集对象 判断结果集中是否还有数据：boolean next(); 有数据返回true，并将索引向下移动一行 没有数据返回false 获取结果集中的数据：XXX getXxx(\"列名\"); XXX代表数据类型(要获取某列数据，这一列的数据类型) 例如：String getString(\"name\"); int getInt(\"age\"); 释放资源 立即将结果集对象释放：void close(); 1.1.3. 三、JDBC案例student学生表的CRUD 1.数据准备 数据库和数据表 -- 创建db14数据库 CREATE DATABASE db14; -- 使用db14数据库 USE db14; -- 创建student表 CREATE TABLE student( sid INT PRIMARY KEY AUTO_INCREMENT, -- 学生id NAME VARCHAR(20), -- 学生姓名 age INT, -- 学生年龄 birthday DATE -- 学生生日 ); -- 添加数据 INSERT INTO student VALUES (NULL,'张三',23,'1999-09-23'),(NULL,'李四',24,'1998-08-10'),(NULL,'王五',25,'1996-06-06'),(NULL,'赵六',26,'1994-10-20'); 实体类 Student类，成员变量对应表中的列 注意：所有的基本数据类型需要使用包装类，以防null值无法赋值 package com.itheima02.domain; import java.util.Date; public class Student { private Integer sid; private String name; private Integer age; private Date birthday; public Student() { } public Student(Integer sid, String name, Integer age, Date birthday) { this.sid = sid; this.name = name; this.age = age; this.birthday = birthday; } public Integer getSid() { return sid; } public void setSid(Integer sid) { this.sid = sid; } public String getName() { return name; } public void setName(String name) { this.name = name; } public Integer getAge() { return age; } public void setAge(Integer age) { this.age = age; } public Date getBirthday() { return birthday; } public void setBirthday(Date birthday) { this.birthday = birthday; } @Override public String toString() { return \"Student{\" + \"sid=\" + sid + \", name='\" + name + '\\'' + \", age=\" + age + \", birthday=\" + birthday + '}'; } } 2.需求一：查询全部 持久层 /* 查询所有学生信息 */ @Override public ArrayList findAll() { ArrayList list = new ArrayList<>(); Connection con = null; Statement stat = null; ResultSet rs = null; try{ //1.注册驱动 Class.forName(\"com.mysql.jdbc.Driver\"); //2.获取数据库连接 con = DriverManager.getConnection(\"jdbc:mysql://192.168.59.129:3306/db14\", \"root\", \"itheima\"); //3.获取执行者对象 stat = con.createStatement(); //4.执行sql语句，并且接收返回的结果集 String sql = \"SELECT * FROM student\"; rs = stat.executeQuery(sql); //5.处理结果集 while(rs.next()) { Integer sid = rs.getInt(\"sid\"); String name = rs.getString(\"name\"); Integer age = rs.getInt(\"age\"); Date birthday = rs.getDate(\"birthday\"); //封装Student对象 Student stu = new Student(sid,name,age,birthday); //将student对象保存到集合中 list.add(stu); } } catch(Exception e) { e.printStackTrace(); } finally { //6.释放资源 if(con != null) { try { con.close(); } catch (SQLException e) { e.printStackTrace(); } } if(stat != null) { try { stat.close(); } catch (SQLException e) { e.printStackTrace(); } } if(rs != null) { try { rs.close(); } catch (SQLException e) { e.printStackTrace(); } } } //将集合对象返回 return list; } 业务层 /* 查询所有学生信息 */ @Override public ArrayList findAll() { return dao.findAll(); } 控制层 /* 查询所有学生信息 */ @Test public void findAll() { ArrayList list = service.findAll(); for(Student stu : list) { System.out.println(stu); } } 3.需求二：条件查询 持久层 /* 条件查询，根据id查询学生信息 */ @Override public Student findById(Integer id) { Student stu = new Student(); Connection con = null; Statement stat = null; ResultSet rs = null; try{ //1.注册驱动 Class.forName(\"com.mysql.jdbc.Driver\"); //2.获取数据库连接 con = DriverManager.getConnection(\"jdbc:mysql://192.168.59.129:3306/db14\", \"root\", \"itheima\"); //3.获取执行者对象 stat = con.createStatement(); //4.执行sql语句，并且接收返回的结果集 String sql = \"SELECT * FROM student WHERE sid='\"+id+\"'\"; rs = stat.executeQuery(sql); //5.处理结果集 while(rs.next()) { Integer sid = rs.getInt(\"sid\"); String name = rs.getString(\"name\"); Integer age = rs.getInt(\"age\"); Date birthday = rs.getDate(\"birthday\"); //封装Student对象 stu.setSid(sid); stu.setName(name); stu.setAge(age); stu.setBirthday(birthday); } } catch(Exception e) { e.printStackTrace(); } finally { //6.释放资源 if(con != null) { try { con.close(); } catch (SQLException e) { e.printStackTrace(); } } if(stat != null) { try { stat.close(); } catch (SQLException e) { e.printStackTrace(); } } if(rs != null) { try { rs.close(); } catch (SQLException e) { e.printStackTrace(); } } } //将对象返回 return stu; } 业务层 /* 条件查询，根据id查询学生信息 */ @Override public Student findById(Integer id) { return dao.findById(id); } 控制层 /* 条件查询，根据id查询学生信息 */ @Test public void findById() { Student stu = service.findById(3); System.out.println(stu); } 4.需求三：新增数据 持久层 /* 添加学生信息 */ @Override public int insert(Student stu) { Connection con = null; Statement stat = null; int result = 0; try{ //1.注册驱动 Class.forName(\"com.mysql.jdbc.Driver\"); //2.获取数据库连接 con = DriverManager.getConnection(\"jdbc:mysql://192.168.59.129:3306/db14\", \"root\", \"itheima\"); //3.获取执行者对象 stat = con.createStatement(); //4.执行sql语句，并且接收返回的结果集 Date d = stu.getBirthday(); SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd\"); String birthday = sdf.format(d); String sql = \"INSERT INTO student VALUES ('\"+stu.getSid()+\"','\"+stu.getName()+\"','\"+stu.getAge()+\"','\"+birthday+\"')\"; result = stat.executeUpdate(sql); } catch(Exception e) { e.printStackTrace(); } finally { //6.释放资源 if(con != null) { try { con.close(); } catch (SQLException e) { e.printStackTrace(); } } if(stat != null) { try { stat.close(); } catch (SQLException e) { e.printStackTrace(); } } } //将结果返回 return result; } 业务层 /* 新增学生信息 */ @Override public int insert(Student stu) { return dao.insert(stu); } 控制层 /* 新增学生信息 */ @Test public void insert() { Student stu = new Student(5,\"周七\",27,new Date()); int result = service.insert(stu); if(result != 0) { System.out.println(\"新增成功\"); }else { System.out.println(\"新增失败\"); } } 5.需求四：修改数据 持久层 /* 修改学生信息 */ @Override public int update(Student stu) { Connection con = null; Statement stat = null; int result = 0; try{ //1.注册驱动 Class.forName(\"com.mysql.jdbc.Driver\"); //2.获取数据库连接 con = DriverManager.getConnection(\"jdbc:mysql://192.168.59.129:3306/db14\", \"root\", \"itheima\"); //3.获取执行者对象 stat = con.createStatement(); //4.执行sql语句，并且接收返回的结果集 Date d = stu.getBirthday(); SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd\"); String birthday = sdf.format(d); String sql = \"UPDATE student SET sid='\"+stu.getSid()+\"',name='\"+stu.getName()+\"',age='\"+stu.getAge()+\"',birthday='\"+birthday+\"' WHERE sid='\"+stu.getSid()+\"'\"; result = stat.executeUpdate(sql); } catch(Exception e) { e.printStackTrace(); } finally { //6.释放资源 if(con != null) { try { con.close(); } catch (SQLException e) { e.printStackTrace(); } } if(stat != null) { try { stat.close(); } catch (SQLException e) { e.printStackTrace(); } } } //将结果返回 return result; } 业务层 /* 修改学生信息 */ @Override public int update(Student stu) { return dao.update(stu); } 控制层 /* 修改学生信息 */ @Test public void update() { Student stu = service.findById(5); stu.setName(\"周七七\"); int result = service.update(stu); if(result != 0) { System.out.println(\"修改成功\"); }else { System.out.println(\"修改失败\"); } } 6.需求五：删除数据 持久层 /* 删除学生信息 */ @Override public int delete(Integer id) { Connection con = null; Statement stat = null; int result = 0; try{ //1.注册驱动 Class.forName(\"com.mysql.jdbc.Driver\"); //2.获取数据库连接 con = DriverManager.getConnection(\"jdbc:mysql://192.168.59.129:3306/db14\", \"root\", \"itheima\"); //3.获取执行者对象 stat = con.createStatement(); //4.执行sql语句，并且接收返回的结果集 String sql = \"DELETE FROM student WHERE sid='\"+id+\"'\"; result = stat.executeUpdate(sql); } catch(Exception e) { e.printStackTrace(); } finally { //6.释放资源 if(con != null) { try { con.close(); } catch (SQLException e) { e.printStackTrace(); } } if(stat != null) { try { stat.close(); } catch (SQLException e) { e.printStackTrace(); } } } //将结果返回 return result; } 业务层 /* 删除学生信息 */ @Override public int delete(Integer id) { return dao.delete(id); } 控制层 /* 删除学生信息 */ @Test public void delete() { int result = service.delete(5); if(result != 0) { System.out.println(\"删除成功\"); }else { System.out.println(\"删除失败\"); } } 1.1.4. 四、JDBC工具类 1.工具类的抽取 配置文件(在src下创建config.properties) driverClass=com.mysql.jdbc.Driver url=jdbc:mysql://localhost:3306/db14 username=root password=itheima 工具类 /* JDBC工具类 */ public class JDBCUtils { //1.私有构造方法 private JDBCUtils(){}; //2.声明配置信息变量 private static String driverClass; private static String url; private static String username; private static String password; private static Connection con; //3.静态代码块中实现加载配置文件和注册驱动 static{ try{ //通过类加载器返回配置文件的字节流 InputStream is = JDBCUtils.class.getClassLoader().getResourceAsStream(\"config.properties\"); //创建Properties集合，加载流对象的信息 Properties prop = new Properties(); prop.load(is); //获取信息为变量赋值 driverClass = prop.getProperty(\"driverClass\"); url = prop.getProperty(\"url\"); username = prop.getProperty(\"username\"); password = prop.getProperty(\"password\"); //注册驱动 Class.forName(driverClass); } catch (Exception e) { e.printStackTrace(); } } //4.获取数据库连接的方法 public static Connection getConnection() { try { con = DriverManager.getConnection(url,username,password); } catch (SQLException e) { e.printStackTrace(); } return con; } //5.释放资源的方法 public static void close(Connection con, Statement stat, ResultSet rs) { if(con != null) { try { con.close(); } catch (SQLException e) { e.printStackTrace(); } } if(stat != null) { try { stat.close(); } catch (SQLException e) { e.printStackTrace(); } } if(rs != null) { try { rs.close(); } catch (SQLException e) { e.printStackTrace(); } } } public static void close(Connection con, Statement stat) { close(con,stat,null); } } 2.使用工具类优化student表的CRUD 查询全部 /* 查询所有学生信息 */ @Override public ArrayList findAll() { ArrayList list = new ArrayList<>(); Connection con = null; Statement stat = null; ResultSet rs = null; try{ con = JDBCUtils.getConnection(); //3.获取执行者对象 stat = con.createStatement(); //4.执行sql语句，并且接收返回的结果集 String sql = \"SELECT * FROM student\"; rs = stat.executeQuery(sql); //5.处理结果集 while(rs.next()) { Integer sid = rs.getInt(\"sid\"); String name = rs.getString(\"name\"); Integer age = rs.getInt(\"age\"); Date birthday = rs.getDate(\"birthday\"); //封装Student对象 Student stu = new Student(sid,name,age,birthday); //将student对象保存到集合中 list.add(stu); } } catch(Exception e) { e.printStackTrace(); } finally { //6.释放资源 JDBCUtils.close(con,stat,rs); } //将集合对象返回 return list; } 条件查询 /* 条件查询，根据id查询学生信息 */ @Override public Student findById(Integer id) { Student stu = new Student(); Connection con = null; Statement stat = null; ResultSet rs = null; try{ con = JDBCUtils.getConnection(); //3.获取执行者对象 stat = con.createStatement(); //4.执行sql语句，并且接收返回的结果集 String sql = \"SELECT * FROM student WHERE sid='\"+id+\"'\"; rs = stat.executeQuery(sql); //5.处理结果集 while(rs.next()) { Integer sid = rs.getInt(\"sid\"); String name = rs.getString(\"name\"); Integer age = rs.getInt(\"age\"); Date birthday = rs.getDate(\"birthday\"); //封装Student对象 stu.setSid(sid); stu.setName(name); stu.setAge(age); stu.setBirthday(birthday); } } catch(Exception e) { e.printStackTrace(); } finally { //6.释放资源 JDBCUtils.close(con,stat,rs); } //将对象返回 return stu; } 新增数据 /* 添加学生信息 */ @Override public int insert(Student stu) { Connection con = null; Statement stat = null; int result = 0; try{ con = JDBCUtils.getConnection(); //3.获取执行者对象 stat = con.createStatement(); //4.执行sql语句，并且接收返回的结果集 Date d = stu.getBirthday(); SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd\"); String birthday = sdf.format(d); String sql = \"INSERT INTO student VALUES ('\"+stu.getSid()+\"','\"+stu.getName()+\"','\"+stu.getAge()+\"','\"+birthday+\"')\"; result = stat.executeUpdate(sql); } catch(Exception e) { e.printStackTrace(); } finally { //6.释放资源 JDBCUtils.close(con,stat); } //将结果返回 return result; } 修改数据 /* 修改学生信息 */ @Override public int update(Student stu) { Connection con = null; Statement stat = null; int result = 0; try{ con = JDBCUtils.getConnection(); //3.获取执行者对象 stat = con.createStatement(); //4.执行sql语句，并且接收返回的结果集 Date d = stu.getBirthday(); SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd\"); String birthday = sdf.format(d); String sql = \"UPDATE student SET sid='\"+stu.getSid()+\"',name='\"+stu.getName()+\"',age='\"+stu.getAge()+\"',birthday='\"+birthday+\"' WHERE sid='\"+stu.getSid()+\"'\"; result = stat.executeUpdate(sql); } catch(Exception e) { e.printStackTrace(); } finally { //6.释放资源 JDBCUtils.close(con,stat); } //将结果返回 return result; } 删除数据 /* 删除学生信息 */ @Override public int delete(Integer id) { Connection con = null; Statement stat = null; int result = 0; try{ con = JDBCUtils.getConnection(); //3.获取执行者对象 stat = con.createStatement(); //4.执行sql语句，并且接收返回的结果集 String sql = \"DELETE FROM student WHERE sid='\"+id+\"'\"; result = stat.executeUpdate(sql); } catch(Exception e) { e.printStackTrace(); } finally { //6.释放资源 JDBCUtils.close(con,stat); } //将结果返回 return result; } 3.student表的CRUD整合页面 用户表的数据准备 -- 创建用户表 CREATE TABLE USER( uid VARCHAR(50) PRIMARY KEY, -- 用户id ucode VARCHAR(50), -- 用户标识 loginname VARCHAR(100), -- 登录用户名 PASSWORD VARCHAR(100), -- 登录密码 username VARCHAR(100), -- 用户名 gender VARCHAR(10), -- 用户性别 birthday DATE, -- 出生日期 dutydate DATE -- 入职日期 ); -- 添加一条测试数据 INSERT INTO `user` VALUES ('11111111', 'zhangsan001', 'zhangsan', '1234', '张三', '男', '2008-10-28', '2018-10-28'); 将student表的dao层操作复制到项目中的dao层即可 public class StudentDaoImpl implements StudentDao { /* 查询所有学生信息 */ @Override public ArrayList findAll() { Connection con = null; Statement stat = null; ResultSet rs = null; ArrayList list = new ArrayList<>(); try { //1.获取连接 con = JDBCUtils.getConnection(); //2.获取执行者对象 stat = con.createStatement(); //3.执行sql语句，并接收结果 String sql = \"SELECT * FROM student\"; rs = stat.executeQuery(sql); //4.处理结果，将每条记录封装成一个Student对象。将多个Student对象保存到集合中 while(rs.next()) { Integer sid = rs.getInt(\"sid\"); String name = rs.getString(\"name\"); Integer age = rs.getInt(\"age\"); Date birthday = rs.getDate(\"birthday\"); Student stu = new Student(sid,name,age,birthday); list.add(stu); } } catch (SQLException e) { e.printStackTrace(); } finally { //5.释放资源 JDBCUtils.close(con,stat,rs); } return list; } /* 条件查询，根据id查询学生信息 */ @Override public Student findById(Integer id) { Connection con = null; Statement stat = null; ResultSet rs = null; Student stu = new Student(); try { //1.获取连接 con = JDBCUtils.getConnection(); //2.获取执行者对象 stat = con.createStatement(); //3.执行sql语句，并接收结果 String sql = \"SELECT * FROM student WHERE sid='\"+id+\"'\"; rs = stat.executeQuery(sql); //4.处理结果，将记录封装成一个Student对象。 if(rs.next()) { Integer sid = rs.getInt(\"sid\"); String name = rs.getString(\"name\"); Integer age = rs.getInt(\"age\"); Date birthday = rs.getDate(\"birthday\"); stu.setSid(sid); stu.setName(name); stu.setAge(age); stu.setBirthday(birthday); } } catch (SQLException e) { e.printStackTrace(); } finally { //5.释放资源 JDBCUtils.close(con,stat,rs); } return stu; } /* 新增学生信息 */ @Override public int insert(Student stu) { Connection con = null; Statement stat = null; int result = 0; try{ //1.获取连接 con = JDBCUtils.getConnection(); //2.获取执行者对象 stat = con.createStatement(); //3.执行sql语句，并接收结果 Date date = stu.getBirthday(); SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd\"); String birthday = sdf.format(date); String sql = \"INSERT INTO student VALUES (null,'\"+stu.getName()+\"','\"+stu.getAge()+\"','\"+birthday+\"')\"; result = stat.executeUpdate(sql); } catch (SQLException e) { e.printStackTrace(); } finally { //4.释放资源 JDBCUtils.close(con,stat); } return result; } /* 修改学生信息 */ @Override public int update(Student stu) { Connection con = null; Statement stat = null; int result = 0; try{ //1.获取连接 con = JDBCUtils.getConnection(); //2.获取执行者对象 stat = con.createStatement(); //3.执行sql语句，并接收结果 Date date = stu.getBirthday(); SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd\"); String birthday = sdf.format(date); String sql = \"UPDATE student SET sid='\"+stu.getSid()+\"',name='\"+stu.getName()+\"',age='\"+stu.getAge()+\"',birthday='\"+birthday+\"' WHERE sid='\"+stu.getSid()+\"'\"; result = stat.executeUpdate(sql); } catch (SQLException e) { e.printStackTrace(); } finally { //4.释放资源 JDBCUtils.close(con,stat); } return result; } /* 删除学生信息 */ @Override public int delete(Integer id) { Connection con = null; Statement stat = null; int result = 0; try{ //1.获取连接 con = JDBCUtils.getConnection(); //2.获取执行者对象 stat = con.createStatement(); //3.执行sql语句，并接收结果 String sql = \"DELETE FROM student WHERE sid='\"+id+\"'\"; result = stat.executeUpdate(sql); } catch (SQLException e) { e.printStackTrace(); } finally { //4.释放资源 JDBCUtils.close(con,stat); } return result; } } 1.1.5. 五、SQL注入攻击 1.sql注入攻击的演示 在登录界面，输入一个错误的用户名或密码，也可以登录成功 2.sql注入攻击的原理 按照正常道理来说，我们在密码处输入的所有内容，都应该认为是密码的组成 但是现在Statement对象在执行sql语句时，将一部分内容当做查询条件来执行了 3.PreparedStatement的介绍 预编译sql语句的执行者对象。在执行sql语句之前，将sql语句进行提前编译。明确sql语句的格式后，就不会改变了。剩余的内容都会认为是参数！参数使用?作为占位符 为参数赋值的方法：setXxx(参数1,参数2); 参数1：?的位置编号(编号从1开始) 参数2：?的实际参数 执行sql语句的方法 执行insert、update、delete语句：int executeUpdate(); 执行select语句：ResultSet executeQuery(); 4.PreparedStatement的使用 /* 使用PreparedStatement的登录方法，解决注入攻击 */ @Override public User findByLoginNameAndPassword(String loginName, String password) { //定义必要信息 Connection conn = null; PreparedStatement pstm = null; ResultSet rs = null; User user = null; try { //1.获取连接 conn = JDBCUtils.getConnection(); //2.创建操作SQL对象 String sql = \"SELECT * FROM user WHERE loginname=? AND password=?\"; pstm = conn.prepareStatement(sql); //3.设置参数 pstm.setString(1,loginName); pstm.setString(2,password); System.out.println(sql); //4.执行sql语句，获取结果集 rs = pstm.executeQuery(); //5.获取结果集 if (rs.next()) { //6.封装 user = new User(); user.setUid(rs.getString(\"uid\")); user.setUcode(rs.getString(\"ucode\")); user.setUsername(rs.getString(\"username\")); user.setPassword(rs.getString(\"password\")); user.setGender(rs.getString(\"gender\")); user.setDutydate(rs.getDate(\"dutydate\")); user.setBirthday(rs.getDate(\"birthday\")); user.setLoginname(rs.getString(\"loginname\")); } //7.返回 return user; }catch (Exception e){ throw new RuntimeException(e); }finally { JDBCUtils.close(conn,pstm,rs); } } 5.使用PreparedStatement优化student表的CRUD（作业） public class StudentDaoImpl implements StudentDao { @Override public ArrayList findAll() { //定义必要信息 Connection conn = null; PreparedStatement pstm = null; ResultSet rs = null; ArrayList students = null; try { //1.获取连接 conn = JDBCUtils.getConnection(); //2.获取操作对象 pstm = conn.prepareStatement(\"select * from student\"); //3.执行sql语句，获取结果集 rs = pstm.executeQuery(); //4.遍历结果集 students = new ArrayList(); while (rs.next()) { //5.封装 Student student = new Student(); student.setSid(rs.getInt(\"sid\")); student.setName(rs.getString(\"name\")); student.setAge(rs.getInt(\"age\")); student.setBirthday(rs.getDate(\"birthday\")); //加入到集合中 students.add(student); } //6.返回 return students; }catch (Exception e){ throw new RuntimeException(e); }finally { JDBCUtils.close(conn,pstm,rs); } } @Override public Student findById(Integer sid) { //定义必要信息 Connection conn = null; PreparedStatement pstm = null; ResultSet rs = null; Student student = null; try { //1.获取连接 conn = JDBCUtils.getConnection(); //2.获取操作对象 pstm = conn.prepareStatement(\"select * from student where sid = ? \"); pstm.setInt(1,sid); //3.执行sql语句，获取结果集 rs = pstm.executeQuery(); //4.遍历结果集 if (rs.next()) { //5.封装 student = new Student(); student.setSid(rs.getInt(\"sid\")); student.setName(rs.getString(\"name\")); student.setAge(rs.getInt(\"age\")); student.setBirthday(rs.getDate(\"birthday\")); } //6.返回 return student; }catch (Exception e){ throw new RuntimeException(e); }finally { JDBCUtils.close(conn,pstm,rs); } } @Override public int insert(Student student) { //定义必要信息 Connection conn = null; PreparedStatement pstm = null; int result = 0; try { //1.获取连接 conn = JDBCUtils.getConnection(); //2.获取操作对象 pstm = conn.prepareStatement(\"insert into student(sid,name,age,birthday)values(null,?,?,?)\"); //3.设置参数 //pstm.setInt(1,null); pstm.setString(1,student.getName()); pstm.setInt(2,student.getAge()); pstm.setDate(3,new Date(student.getBirthday().getTime())); //4.执行sql语句 result = pstm.executeUpdate(); }catch (Exception e){ throw new RuntimeException(e); }finally { JDBCUtils.close(conn,pstm); } return result; } @Override public int update(Student student) { //定义必要信息 Connection conn = null; PreparedStatement pstm = null; int result = 0; try { //1.获取连接 conn = JDBCUtils.getConnection(); //2.获取操作对象 pstm = conn.prepareStatement(\"update student set name=?,age=?,birthday=? where sid=? \"); //3.设置参数 pstm.setString(1,student.getName()); pstm.setInt(2,student.getAge()); pstm.setDate(3,new Date(student.getBirthday().getTime())); pstm.setInt(4,student.getSid()); //4.执行sql语句 result = pstm.executeUpdate(); }catch (Exception e){ throw new RuntimeException(e); }finally { JDBCUtils.close(conn,pstm); } return result; } @Override public int delete(Integer sid) { //定义必要信息 Connection conn = null; PreparedStatement pstm = null; int result = 0; try { //1.获取连接 conn = JDBCUtils.getConnection(); //2.获取操作对象 pstm = conn.prepareStatement(\"delete from student where sid=? \"); //3.设置参数 pstm.setInt(1,sid); //4.执行sql语句 result = pstm.executeUpdate(); }catch (Exception e){ throw new RuntimeException(e); }finally { JDBCUtils.close(conn,pstm); } return result; } } 1.1.6. 六、综合案例-课程表批量新增加事务管理 1.service层 接口 /* 批量添加 */ void batchAdd(List users); 实现类 /* 事务要控制在此处 */ @Override public void batchAdd(List users) { //获取数据库连接 Connection connection = JDBCUtils.getConnection(); try { //开启事务 connection.setAutoCommit(false); for (User user : users) { //1.创建ID,并把UUID中的-替换 String uid = UUID.randomUUID().toString().replace(\"-\", \"\").toUpperCase(); //2.给user的uid赋值 user.setUid(uid); //3.生成员工编号 user.setUcode(uid); //模拟异常 //int n = 1 / 0; //4.保存 userDao.save(connection,user); } //提交事务 connection.commit(); }catch (Exception e){ try { //回滚事务 connection.rollback(); }catch (Exception ex){ ex.printStackTrace(); } e.printStackTrace(); }finally { JDBCUtils.close(connection,null,null); } } 2.dao层 接口 /** 支持事务的添加 */ void save(Connection connection,User user); 实现类 /* 支持事务的添加 */ @Override public void save(Connection connection, User user) { //定义必要信息 PreparedStatement pstm = null; try { //1.获取连接 connection = JDBCUtils.getConnection(); //2.获取操作对象 pstm = connection.prepareStatement(\"insert into user(uid,ucode,loginname,password,username,gender,birthday,dutydate)values(?,?,?,?,?,?,?,?)\"); //3.设置参数 pstm.setString(1,user.getUid()); pstm.setString(2,user.getUcode()); pstm.setString(3,user.getLoginname()); pstm.setString(4,user.getPassword()); pstm.setString(5,user.getUsername()); pstm.setString(6,user.getGender()); pstm.setDate(7,new Date(user.getBirthday().getTime())); pstm.setDate(8,new Date(user.getDutydate().getTime())); //4.执行sql语句，获取结果集 pstm.executeUpdate(); }catch (Exception e){ throw new RuntimeException(e); }finally { JDBCUtils.close(null,pstm,null); } } Copyright © MISIN 2022 | 豫ICP备2021006345号-1 all right reserved，powered by Gitbook该文件修订时间： 2022-11-10 10:52:12 "},"2.JavaWeb/5.JDBC/JDBC-02-授课笔记.html":{"url":"2.JavaWeb/5.JDBC/JDBC-02-授课笔记.html","title":"JDBC-02-授课笔记","keywords":"","body":"1. JDBC-02-授课笔记1.1.1. 一、数据库连接池1.1.2. 二、JDBC框架(JDBCTemplate)1. JDBC-02-授课笔记 1.1.1. 一、数据库连接池 1.数据库连接池的概念 数据库连接背景 数据库连接是一种关键的、有限的、昂贵的资源，这一点在多用户的网页应用程序中体现得尤为突出。对数据库连接的管理能显著影响到整个应用程序的伸缩性和健壮性，影响到程序的性能指标。数据库连接池正是针对这个问题提出来的。 数据库连接池 数据库连接池负责分配、管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个。这项技术能明显提高对数据库操作的性能。 数据库连接池原理 2.自定义连接池 java.sql.DataSource接口：数据源(数据库连接池)。java官方提供的数据库连接池规范(接口) 获取数据库连接对象：Connection getConnection(); 自定义连接池 /* 自定义连接池类 */ public class MyDataSource implements DataSource{ //定义集合容器，用于保存多个数据库连接对象 private static List pool = Collections.synchronizedList(new ArrayList()); //静态代码块，生成10个数据库连接保存到集合中 static { for (int i = 0; i 0) { //从池中获取数据库连接 return pool.remove(0); }else { throw new RuntimeException(\"连接数量已用尽\"); } } @Override public Connection getConnection(String username, String password) throws SQLException { return null; } @Override public T unwrap(Class iface) throws SQLException { return null; } @Override public boolean isWrapperFor(Class iface) throws SQLException { return false; } @Override public PrintWriter getLogWriter() throws SQLException { return null; } @Override public void setLogWriter(PrintWriter out) throws SQLException { } @Override public void setLoginTimeout(int seconds) throws SQLException { } @Override public int getLoginTimeout() throws SQLException { return 0; } @Override public Logger getParentLogger() throws SQLFeatureNotSupportedException { return null; } } 3.自定义连接池测试 public class MyDataSourceTest { public static void main(String[] args) throws Exception{ //创建数据库连接池对象 MyDataSource dataSource = new MyDataSource(); System.out.println(\"使用之前连接池数量：\" + dataSource.getSize()); //获取数据库连接对象 Connection con = dataSource.getConnection(); System.out.println(con.getClass());// JDBC4Connection //查询学生表全部信息 String sql = \"SELECT * FROM student\"; PreparedStatement pst = con.prepareStatement(sql); ResultSet rs = pst.executeQuery(); while(rs.next()) { System.out.println(rs.getInt(\"sid\") + \"\\t\" + rs.getString(\"name\") + \"\\t\" + rs.getInt(\"age\") + \"\\t\" + rs.getDate(\"birthday\")); } //释放资源 rs.close(); pst.close(); //目前的连接对象close方法，是直接关闭连接，而不是将连接归还池中 con.close(); System.out.println(\"使用之后连接池数量：\" + dataSource.getSize()); } } 4.归还连接 继承(无法解决) 通过打印连接对象，发现DriverManager获取的连接实现类是JDBC4Connection。 自定义一个类，继承JDBC4Connection这个类，重写close()方法。 /* 自定义Connection类 */ public class MyConnection1 extends JDBC4Connection { //声明连接对象和连接池集合对象 private Connection con; private List pool; //通过构造方法给成员变量赋值 public MyConnection1(String hostToConnectTo, int portToConnectTo, Properties info, String databaseToConnectTo, String url,Connection con,List pool) throws SQLException { super(hostToConnectTo, portToConnectTo, info, databaseToConnectTo, url); this.con = con; this.pool = pool; } //重写close()方法，将连接归还给池中 @Override public void close() throws SQLException { pool.add(con); } } 但是这种方式行不通，通过查看JDBC工具类获取连接的方法我们发现：我们虽然自定义了一个子类，完成了归还连接的操作。但是DriverManager获取的还是JDBC4Connection这个对象，并不是我们的子类对象。而我们又不能整体去修改驱动包中类的功能！ //将之前的连接对象换成自定义的子类对象 private static MyConnection1 con; //4.获取数据库连接的方法 public static Connection getConnection() { try { //等效于：MyConnection1 con = new JDBC4Connection(); 语法错误！ con = DriverManager.getConnection(url,username,password); } catch (SQLException e) { e.printStackTrace(); } return con; } 装饰设计模式 自定义连接类 ```java /* 自定义Connection类。通过装饰设计模式，实现和mysql驱动包中的Connection实现类相同的功能！ 实现步骤： 1.定义一个类，实现Connection接口 2.定义Connection连接对象和连接池容器对象的变量 3.提供有参构造方法，接收连接对象和连接池对象，对变量赋值 4.在close()方法中，完成连接的归还 5.剩余方法，只需要调用mysql驱动包的连接对象完成即可 */ public class MyConnection2 implements Connection { //2.定义Connection连接对象和连接池容器对象的变量 private Connection con; private List pool; //3.提供有参构造方法，接收连接对象和连接池对象，对变量赋值 public MyConnection2(Connection con,List pool) { this.con = con; this.pool = pool; } //4.在close()方法中，完成连接的归还 @Override public void close() throws SQLException { pool.add(con); } @Override public Statement createStatement() throws SQLException { return con.createStatement(); } @Override public PreparedStatement prepareStatement(String sql) throws SQLException { return con.prepareStatement(sql); } @Override public CallableStatement prepareCall(String sql) throws SQLException { return con.prepareCall(sql); } @Override public String nativeSQL(String sql) throws SQLException { return con.nativeSQL(sql); } @Override public void setAutoCommit(boolean autoCommit) throws SQLException { con.setAutoCommit(autoCommit); } @Override public boolean getAutoCommit() throws SQLException { return con.getAutoCommit(); } @Override public void commit() throws SQLException { con.commit(); } @Override public void rollback() throws SQLException { con.rollback(); } @Override public boolean isClosed() throws SQLException { return con.isClosed(); } @Override public DatabaseMetaData getMetaData() throws SQLException { return con.getMetaData(); } @Override public void setReadOnly(boolean readOnly) throws SQLException { con.setReadOnly(readOnly); } @Override public boolean isReadOnly() throws SQLException { return con.isReadOnly(); } @Override public void setCatalog(String catalog) throws SQLException { con.setCatalog(catalog); } @Override public String getCatalog() throws SQLException { return con.getCatalog(); } @Override public void setTransactionIsolation(int level) throws SQLException { con.setTransactionIsolation(level); } @Override public int getTransactionIsolation() throws SQLException { return con.getTransactionIsolation(); } @Override public SQLWarning getWarnings() throws SQLException { return con.getWarnings(); } @Override public void clearWarnings() throws SQLException { con.clearWarnings(); } @Override public Statement createStatement(int resultSetType, int resultSetConcurrency) throws SQLException { return con.createStatement(resultSetType,resultSetConcurrency); } @Override public PreparedStatement prepareStatement(String sql, int resultSetType, int resultSetConcurrency) throws SQLException { return con.prepareStatement(sql,resultSetType,resultSetConcurrency); } @Override public CallableStatement prepareCall(String sql, int resultSetType, int resultSetConcurrency) throws SQLException { return con.prepareCall(sql,resultSetType,resultSetConcurrency); } @Override public Map> getTypeMap() throws SQLException { return con.getTypeMap(); } @Override public void setTypeMap(Map> map) throws SQLException { con.setTypeMap(map); } @Override public void setHoldability(int holdability) throws SQLException { con.setHoldability(holdability); } @Override public int getHoldability() throws SQLException { return con.getHoldability(); } @Override public Savepoint setSavepoint() throws SQLException { return con.setSavepoint(); } @Override public Savepoint setSavepoint(String name) throws SQLException { return con.setSavepoint(name); } @Override public void rollback(Savepoint savepoint) throws SQLException { con.rollback(savepoint); } @Override public void releaseSavepoint(Savepoint savepoint) throws SQLException { con.releaseSavepoint(savepoint); } @Override public Statement createStatement(int resultSetType, int resultSetConcurrency, int resultSetHoldability) throws SQLException { return con.createStatement(resultSetType,resultSetConcurrency,resultSetHoldability); } @Override public PreparedStatement prepareStatement(String sql, int resultSetType, int resultSetConcurrency, int resultSetHoldability) throws SQLException { return con.prepareStatement(sql,resultSetType,resultSetConcurrency,resultSetHoldability); } @Override public CallableStatement prepareCall(String sql, int resultSetType, int resultSetConcurrency, int resultSetHoldability) throws SQLException { return con.prepareCall(sql,resultSetType,resultSetConcurrency,resultSetHoldability); } @Override public PreparedStatement prepareStatement(String sql, int autoGeneratedKeys) throws SQLException { return con.prepareStatement(sql,autoGeneratedKeys); } @Override public PreparedStatement prepareStatement(String sql, int[] columnIndexes) throws SQLException { return con.prepareStatement(sql,columnIndexes); } @Override public PreparedStatement prepareStatement(String sql, String[] columnNames) throws SQLException { return con.prepareStatement(sql,columnNames); } @Override public Clob createClob() throws SQLException { return con.createClob(); } @Override public Blob createBlob() throws SQLException { return con.createBlob(); } @Override public NClob createNClob() throws SQLException { return con.createNClob(); } @Override public SQLXML createSQLXML() throws SQLException { return con.createSQLXML(); } @Override public boolean isValid(int timeout) throws SQLException { return con.isValid(timeout); } @Override public void setClientInfo(String name, String value) throws SQLClientInfoException { con.setClientInfo(name,value); } @Override public void setClientInfo(Properties properties) throws SQLClientInfoException { con.setClientInfo(properties); } @Override public String getClientInfo(String name) throws SQLException { return con.getClientInfo(name); } @Override public Properties getClientInfo() throws SQLException { return con.getClientInfo(); } @Override public Array createArrayOf(String typeName, Object[] elements) throws SQLException { return con.createArrayOf(typeName,elements); } @Override public Struct createStruct(String typeName, Object[] attributes) throws SQLException { return con.createStruct(typeName,attributes); } @Override public void setSchema(String schema) throws SQLException { con.setSchema(schema); } @Override public String getSchema() throws SQLException { return con.getSchema(); } @Override public void abort(Executor executor) throws SQLException { con.abort(executor); } @Override public void setNetworkTimeout(Executor executor, int milliseconds) throws SQLException { con.setNetworkTimeout(executor,milliseconds); } @Override public int getNetworkTimeout() throws SQLException { return con.getNetworkTimeout(); } @Override public T unwrap(Class iface) throws SQLException { return con.unwrap(iface); } @Override public boolean isWrapperFor(Class iface) throws SQLException { return con.isWrapperFor(iface); } } - 自定义连接池类 ```java public class MyDataSource implements DataSource{ //定义集合容器，用于保存多个数据库连接对象 private static List pool = Collections.synchronizedList(new ArrayList()); //静态代码块，生成10个数据库连接保存到集合中 static { for (int i = 0; i 0) { //从池中获取数据库连接 Connection con = pool.remove(0); //通过自定义连接对象进行包装 MyConnection2 mycon = new MyConnection2(con,pool); //返回包装后的连接对象 return mycon; }else { throw new RuntimeException(\"连接数量已用尽\"); } } } 适配器设计模式 通过之前MyConnection2连接类我们发现，有很多个需要实现的方法。这个时候我们就可以使用适配器设计模式了。提供一个适配器类，实现Connection接口，将所有功能进行实现(除了close方法)。自定义连接类只需要继承这个适配器类，重写需要改进的close()方法即可！ 适配器类 /* 适配器抽象类。实现Connection接口。 实现所有的方法，调用mysql驱动包中Connection连接对象的方法 */ public abstract class MyAdapter implements Connection { // 定义数据库连接对象的变量 private Connection con; // 通过构造方法赋值 public MyAdapter(Connection con) { this.con = con; } // 所有的方法，均调用mysql的连接对象实现 @Override public Statement createStatement() throws SQLException { return con.createStatement(); } @Override public PreparedStatement prepareStatement(String sql) throws SQLException { return con.prepareStatement(sql); } @Override public CallableStatement prepareCall(String sql) throws SQLException { return con.prepareCall(sql); } @Override public String nativeSQL(String sql) throws SQLException { return con.nativeSQL(sql); } @Override public void setAutoCommit(boolean autoCommit) throws SQLException { con.setAutoCommit(autoCommit); } @Override public boolean getAutoCommit() throws SQLException { return con.getAutoCommit(); } @Override public void commit() throws SQLException { con.commit(); } @Override public void rollback() throws SQLException { con.rollback(); } @Override public boolean isClosed() throws SQLException { return con.isClosed(); } @Override public DatabaseMetaData getMetaData() throws SQLException { return con.getMetaData(); } @Override public void setReadOnly(boolean readOnly) throws SQLException { con.setReadOnly(readOnly); } @Override public boolean isReadOnly() throws SQLException { return con.isReadOnly(); } @Override public void setCatalog(String catalog) throws SQLException { con.setCatalog(catalog); } @Override public String getCatalog() throws SQLException { return con.getCatalog(); } @Override public void setTransactionIsolation(int level) throws SQLException { con.setTransactionIsolation(level); } @Override public int getTransactionIsolation() throws SQLException { return con.getTransactionIsolation(); } @Override public SQLWarning getWarnings() throws SQLException { return con.getWarnings(); } @Override public void clearWarnings() throws SQLException { con.clearWarnings(); } @Override public Statement createStatement(int resultSetType, int resultSetConcurrency) throws SQLException { return con.createStatement(resultSetType,resultSetConcurrency); } @Override public PreparedStatement prepareStatement(String sql, int resultSetType, int resultSetConcurrency) throws SQLException { return con.prepareStatement(sql,resultSetType,resultSetConcurrency); } @Override public CallableStatement prepareCall(String sql, int resultSetType, int resultSetConcurrency) throws SQLException { return con.prepareCall(sql,resultSetType,resultSetConcurrency); } @Override public Map> getTypeMap() throws SQLException { return con.getTypeMap(); } @Override public void setTypeMap(Map> map) throws SQLException { con.setTypeMap(map); } @Override public void setHoldability(int holdability) throws SQLException { con.setHoldability(holdability); } @Override public int getHoldability() throws SQLException { return con.getHoldability(); } @Override public Savepoint setSavepoint() throws SQLException { return con.setSavepoint(); } @Override public Savepoint setSavepoint(String name) throws SQLException { return con.setSavepoint(name); } @Override public void rollback(Savepoint savepoint) throws SQLException { con.rollback(savepoint); } @Override public void releaseSavepoint(Savepoint savepoint) throws SQLException { con.releaseSavepoint(savepoint); } @Override public Statement createStatement(int resultSetType, int resultSetConcurrency, int resultSetHoldability) throws SQLException { return con.createStatement(resultSetType,resultSetConcurrency,resultSetHoldability); } @Override public PreparedStatement prepareStatement(String sql, int resultSetType, int resultSetConcurrency, int resultSetHoldability) throws SQLException { return con.prepareStatement(sql,resultSetType,resultSetConcurrency,resultSetHoldability); } @Override public CallableStatement prepareCall(String sql, int resultSetType, int resultSetConcurrency, int resultSetHoldability) throws SQLException { return con.prepareCall(sql,resultSetType,resultSetConcurrency,resultSetHoldability); } @Override public PreparedStatement prepareStatement(String sql, int autoGeneratedKeys) throws SQLException { return con.prepareStatement(sql,autoGeneratedKeys); } @Override public PreparedStatement prepareStatement(String sql, int[] columnIndexes) throws SQLException { return con.prepareStatement(sql,columnIndexes); } @Override public PreparedStatement prepareStatement(String sql, String[] columnNames) throws SQLException { return con.prepareStatement(sql,columnNames); } @Override public Clob createClob() throws SQLException { return con.createClob(); } @Override public Blob createBlob() throws SQLException { return con.createBlob(); } @Override public NClob createNClob() throws SQLException { return con.createNClob(); } @Override public SQLXML createSQLXML() throws SQLException { return con.createSQLXML(); } @Override public boolean isValid(int timeout) throws SQLException { return con.isValid(timeout); } @Override public void setClientInfo(String name, String value) throws SQLClientInfoException { con.setClientInfo(name,value); } @Override public void setClientInfo(Properties properties) throws SQLClientInfoException { con.setClientInfo(properties); } @Override public String getClientInfo(String name) throws SQLException { return con.getClientInfo(name); } @Override public Properties getClientInfo() throws SQLException { return con.getClientInfo(); } @Override public Array createArrayOf(String typeName, Object[] elements) throws SQLException { return con.createArrayOf(typeName,elements); } @Override public Struct createStruct(String typeName, Object[] attributes) throws SQLException { return con.createStruct(typeName,attributes); } @Override public void setSchema(String schema) throws SQLException { con.setSchema(schema); } @Override public String getSchema() throws SQLException { return con.getSchema(); } @Override public void abort(Executor executor) throws SQLException { con.abort(executor); } @Override public void setNetworkTimeout(Executor executor, int milliseconds) throws SQLException { con.setNetworkTimeout(executor,milliseconds); } @Override public int getNetworkTimeout() throws SQLException { return con.getNetworkTimeout(); } @Override public T unwrap(Class iface) throws SQLException { return con.unwrap(iface); } @Override public boolean isWrapperFor(Class iface) throws SQLException { return con.isWrapperFor(iface); } } 自定义连接类 /* 自定义Connection连接类。通过适配器设计模式。完成close()方法的重写 1.定义一个类，继承适配器父类 2.定义Connection连接对象和连接池容器对象的变量 3.提供有参构造方法，接收连接对象和连接池对象，对变量赋值 4.在close()方法中，完成连接的归还 */ public class MyConnection3 extends MyAdapter { //2.定义Connection连接对象和连接池容器对象的变量 private Connection con; private List pool; //3.提供有参构造方法，接收连接对象和连接池对象，对变量赋值 public MyConnection3(Connection con,List pool) { super(con); // 将接收的数据库连接对象给适配器父类传递 this.con = con; this.pool = pool; } //4.在close()方法中，完成连接的归还 @Override public void close() throws SQLException { pool.add(con); } } 自定义连接池类 public class MyDataSource implements DataSource{ //定义集合容器，用于保存多个数据库连接对象 private static List pool = Collections.synchronizedList(new ArrayList()); //静态代码块，生成10个数据库连接保存到集合中 static { for (int i = 0; i 0) { //从池中获取数据库连接 Connection con = pool.remove(0); //通过自定义连接对象进行包装 //MyConnection2 mycon = new MyConnection2(con,pool); MyConnection3 mycon = new MyConnection3(con,pool); //返回包装后的连接对象 return mycon; }else { throw new RuntimeException(\"连接数量已用尽\"); } } } 动态代理 经过我们适配器模式的改进，自定义连接类中的方法已经很简洁了。剩余所有的方法已经抽取到了适配器类中。但是适配器这个类还是我们自己编写的，也比较麻烦！所以可以使用动态代理的方式来改进。 自定义数据库连接池类 ```java public class MyDataSource implements DataSource{ //定义集合容器，用于保存多个数据库连接对象 private static List pool = Collections.synchronizedList(new ArrayList()); //静态代码块，生成10个数据库连接保存到集合中 static { for (int i = 0; i 0) { //从池中获取数据库连接 Connection con = pool.remove(0); Connection proxyCon = (Connection)Proxy.newProxyInstance(con.getClass().getClassLoader(), new Class[]{Connection.class}, new InvocationHandler() { /* 执行Connection实现类所有方法都会经过invoke 如果是close方法，则将连接还回池中 如果不是，直接执行实现类的原有方法 */ @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { if(method.getName().equals(\"close\")) { pool.add(con); return null; }else { return method.invoke(con,args); } } }); return proxyCon; }else { throw new RuntimeException(\"连接数量已用尽\"); } } //从池中返回一个数据库连接 /*@Override public Connection getConnection() { if(pool.size() > 0) { //从池中获取数据库连接 Connection con = pool.remove(0); //通过自定义连接对象进行包装 //MyConnection2 mycon = new MyConnection2(con,pool); MyConnection3 mycon = new MyConnection3(con,pool); //返回包装后的连接对象 return mycon; }else { throw new RuntimeException(\"连接数量已用尽\"); } }*/ } #### 5.开源连接池的使用 - C3P0 - 基本使用 ```java /* 使用C3P0连接池 1.导入jar包 2.导入配置文件到src目录下 3.创建c3p0连接池对象 4.获取数据库连接进行使用 */ public class C3P0Demo1 { public static void main(String[] args) throws Exception{ //创建c3p0连接池对象 DataSource dataSource = new ComboPooledDataSource(); //获取数据库连接进行使用 Connection con = dataSource.getConnection(); //查询全部学生信息 String sql = \"SELECT * FROM student\"; PreparedStatement pst = con.prepareStatement(sql); ResultSet rs = pst.executeQuery(); while(rs.next()) { System.out.println(rs.getInt(\"sid\") + \"\\t\" + rs.getString(\"name\") + \"\\t\" + rs.getInt(\"age\") + \"\\t\" + rs.getDate(\"birthday\")); } //释放资源 rs.close(); pst.close(); con.close(); // 将连接对象归还池中 } } 配置演示 public class C3P0Demo2 { public static void main(String[] args) throws Exception{ //创建c3p0连接池对象 DataSource dataSource = new ComboPooledDataSource(); //获取数据库连接进行使用 for(int i = 1; i Druid 基本使用 /* Druid连接池 1.导入jar包 2.编写配置文件，放在src目录下 3.通过Properties集合加载配置文件 4.通过Druid连接池工厂类获取数据库连接池对象 5.获取数据库连接，进行使用 */ public class DruidDemo1 { public static void main(String[] args) throws Exception{ //通过Properties集合加载配置文件 InputStream is = DruidDemo1.class.getClassLoader().getResourceAsStream(\"druid.properties\"); Properties prop = new Properties(); prop.load(is); //通过Druid连接池工厂类获取数据库连接池对象 DataSource dataSource = DruidDataSourceFactory.createDataSource(prop); //获取数据库连接，进行使用 Connection con = dataSource.getConnection(); //查询全部学生信息 String sql = \"SELECT * FROM student\"; PreparedStatement pst = con.prepareStatement(sql); ResultSet rs = pst.executeQuery(); while(rs.next()) { System.out.println(rs.getInt(\"sid\") + \"\\t\" + rs.getString(\"name\") + \"\\t\" + rs.getInt(\"age\") + \"\\t\" + rs.getDate(\"birthday\")); } //释放资源 rs.close(); pst.close(); con.close(); // 将连接对象归还池中 } } 抽取工具类 /* 数据库连接池工具类 */ public class DataSourceUtils { //1.私有构造方法 private DataSourceUtils(){} //2.定义DataSource数据源变量 private static DataSource dataSource; //3.提供静态代码块，完成配置文件的加载和获取连接池对象 static { try{ //加载配置文件 InputStream is = DruidDemo1.class.getClassLoader().getResourceAsStream(\"druid.properties\"); Properties prop = new Properties(); prop.load(is); //获取数据库连接池对象 dataSource = DruidDataSourceFactory.createDataSource(prop); } catch(Exception e) { e.printStackTrace(); } } //4.提供获取数据库连接的方法 public static Connection getConnection() { Connection con = null; try { con = dataSource.getConnection(); } catch (SQLException e) { e.printStackTrace(); } return con; } //5.提供获取数据库连接池的方法 public static DataSource getDataSource() { return dataSource; } //6.提供释放资源的方法 public static void close(Connection con, Statement stat, ResultSet rs) { if(con != null) { try { con.close(); } catch (SQLException e) { e.printStackTrace(); } } if(stat != null) { try { stat.close(); } catch (SQLException e) { e.printStackTrace(); } } if(rs != null) { try { rs.close(); } catch (SQLException e) { e.printStackTrace(); } } } public static void close(Connection con, Statement stat) { close(con,stat,null); } } 1.1.2. 二、JDBC框架(JDBCTemplate) 1.分析前一天案例中的重复代码 dao层的重复代码 定义必要的信息、获取数据库的连接、释放资源都是重复的代码！ 而我们最终的核心功能仅仅只是执行一条sql语句而已啊！ 所以我们可以抽取出一个JDBC模板类，来封装一些方法(update、query)，专门帮我们执行增删改查的sql语句！ 将之前那些重复的操作，都抽取到模板类中的方法里。就能大大简化我们的使用步骤！ 2.自定义JDBC框架 2.1数据库的源信息 DataBaseMetaData(了解)：数据库的源信息 java.sql.DataBaseMetaData：封装了整个数据库的综合信息 例如： String getDatabaseProductName()：获取数据库产品的名称 int getDatabaseProductVersion()：获取数据库产品的版本号 ParameterMetaData：参数的源信息 java.sql.ParameterMetaData：封装的是预编译执行者对象中每个参数的类型和属性 这个对象可以通过预编译执行者对象中的getParameterMetaData()方法来获取 核心功能： int getParameterCount()：获取sql语句中参数的个数 ResultSetMetaData：结果集的源信息 java.sql.ResultSetMetaData：封装的是结果集对象中列的类型和属性 这个对象可以通过结果集对象中的getMetaData()方法来获取 核心功能： int getColumnCount()：获取列的总数 String getColumnName(int i)：获取列名 2.2JDBCTemplate类增删改功能的编写 public class JDBCTemplate { private DataSource dataSource; private Connection con; private PreparedStatement pst; private ResultSet rs; public JDBCTemplate(DataSource dataSource) { this.dataSource = dataSource; } //专用于执行增删改sql语句的方法 public int update(String sql,Object...objs) { int result = 0; try{ con = dataSource.getConnection(); pst = con.prepareStatement(sql); //获取sql语句中的参数源信息 ParameterMetaData pData = pst.getParameterMetaData(); //获取sql语句中参数的个数 int parameterCount = pData.getParameterCount(); //判断参数个数是否一致 if(parameterCount != objs.length) { throw new RuntimeException(\"参数个数不匹配\"); } //为sql语句中的?占位符赋值 for (int i = 0; i 2.3JDBCTemplate类查询功能的编写 实体类 /* 学生实体类 */ public class Student { private Integer sid; private String name; private Integer age; private Date birthday; public Student() { } public Student(Integer sid, String name, Integer age, Date birthday) { this.sid = sid; this.name = name; this.age = age; this.birthday = birthday; } public Integer getSid() { return sid; } public void setSid(Integer sid) { this.sid = sid; } public String getName() { return name; } public void setName(String name) { this.name = name; } public Integer getAge() { return age; } public void setAge(Integer age) { this.age = age; } public Date getBirthday() { return birthday; } public void setBirthday(Date birthday) { this.birthday = birthday; } @Override public String toString() { return \"Student{\" + \"sid=\" + sid + \", name='\" + name + '\\'' + \", age=\" + age + \", birthday=\" + birthday + '}'; } } ResultSetHandler接口 /* 用于处理结果集的接口 */ public interface ResultSetHandler { //处理结果集的抽象方法。 T handler(ResultSet rs); } BeanHandler实现类 /* 实现类1：用于完成将查询出来的一条记录，封装到Student对象中 */ public class BeanHandler implements ResultSetHandler { //1.声明对象类型变量 private Class beanClass; //2.有参构造对变量赋值 public BeanHandler(Class beanClass) { this.beanClass = beanClass; } /* 将ResultSet结果集中的数据封装到beanClass类型对象中 */ @Override public T handler(ResultSet rs) { //3.声明对象 T bean = null; try{ //4.创建传递参数的对象 bean = beanClass.newInstance(); //5.判断是否有结果集 if(rs.next()) { //6.得到所有的列名 //6.1先得到结果集的源信息 ResultSetMetaData rsmd = rs.getMetaData(); //6.2还要得到有多少列 int columnCount = rsmd.getColumnCount(); //6.3遍历列数 for(int i = 1; i BeanListHandler实现类 /* 实现类2：用于将结果集封装到集合中 */ public class BeanListHandler implements ResultSetHandler { //1.声明对象变量 private Class beanClass; //2.有参构造为变量赋值 public BeanListHandler(Class beanClass) { this.beanClass = beanClass; } @Override public List handler(ResultSet rs) { //3.创建集合对象 List list = new ArrayList<>(); try{ //4.遍历结果集对象 while(rs.next()) { //5.创建传递参数的对象 T bean = beanClass.newInstance(); //6.得到所有的列名 //6.1先得到结果集的源信息 ResultSetMetaData rsmd = rs.getMetaData(); //6.2还要得到有多少列 int columnCount = rsmd.getColumnCount(); //6.3遍历列数 for(int i = 1; i ScalarHandler实现类 /* 实现类3：用于返回一个聚合函数的查询结果 */ public class ScalarHandler implements ResultSetHandler { @Override public Long handler(ResultSet rs) { //1.声明一个变量 Long value = null; try{ //2.判断是否有结果 if(rs.next()) { //3.获取结果集的源信息 ResultSetMetaData rsmd = rs.getMetaData(); //4.获取第一列的列名 String columnName = rsmd.getColumnName(1); //5.根据列名获取值 value = rs.getLong(columnName); } } catch(Exception e) { e.printStackTrace(); } //6.将结果返回 return value; } } JDBCTemplate类 public class JDBCTemplate { private DataSource dataSource; private Connection con; private PreparedStatement pst; private ResultSet rs; public JDBCTemplate(DataSource dataSource) { this.dataSource = dataSource; } /* 专用于执行聚合函数sql语句的方法 */ public Long queryForScalar(String sql, ResultSetHandler rsh, Object...objs) { Long result = null; try{ con = dataSource.getConnection(); pst = con.prepareStatement(sql); //获取sql语句中的参数源信息 ParameterMetaData pData = pst.getParameterMetaData(); int parameterCount = pData.getParameterCount(); //判断参数个数是否一致 if(parameterCount != objs.length) { throw new RuntimeException(\"参数个数不匹配\"); } //为sql语句中的?占位符赋值 for (int i = 0; i List queryForList(String sql, ResultSetHandler rsh, Object...objs) { List list = new ArrayList<>(); try{ con = dataSource.getConnection(); pst = con.prepareStatement(sql); //获取sql语句中的参数源信息 ParameterMetaData pData = pst.getParameterMetaData(); int parameterCount = pData.getParameterCount(); //判断参数个数是否一致 if(parameterCount != objs.length) { throw new RuntimeException(\"参数个数不匹配\"); } //为sql语句中的?占位符赋值 for (int i = 0; i T queryForObject(String sql, ResultSetHandler rsh, Object...objs) { T obj = null; try{ con = dataSource.getConnection(); pst = con.prepareStatement(sql); //获取sql语句中的参数源信息 ParameterMetaData pData = pst.getParameterMetaData(); int parameterCount = pData.getParameterCount(); //判断参数个数是否一致 if(parameterCount != objs.length) { throw new RuntimeException(\"参数个数不匹配\"); } //为sql语句中的?占位符赋值 for (int i = 0; i 2.4测试自定义JDBC框架的使用 public class JDBCTemplateTest { //创建JDBCTemplate对象 JDBCTemplate template = new JDBCTemplate(DataSourceUtils.getDataSource()); @Test public void selectScalar() { //查询student表的记录条数 String sql = \"SELECT COUNT(*) FROM student\"; Long count = template.queryForScalar(sql, new ScalarHandler()); System.out.println(count); } @Test public void selectAll() { //查询所有学生信息 String sql = \"SELECT * FROM student\"; List list = template.queryForList(sql, new BeanListHandler(Student.class)); for(Student stu : list) { System.out.println(stu); } } @Test public void selectOne() { //查询张三这条记录 String sql = \"SELECT * FROM student WHERE sid=?\"; //通过BeanHandler将结果封装成一个Student对象 Student stu = template.queryForObject(sql, new BeanHandler(Student.class), 1); System.out.println(stu); } @Test public void insert() { //新增周七记录 String sql = \"INSERT INTO student VALUES (?,?,?,?)\"; Object[] params = {5,\"周七\",27,\"2007-07-07\"}; int result = template.update(sql, params); System.out.println(result); } @Test public void delete() { //删除周七这条记录 String sql = \"DELETE FROM student WHERE sid=?\"; int result = template.update(sql, 5); System.out.println(result); } @Test public void update() { //修改张三的年龄为33 String sql = \"UPDATE student SET age=? WHERE name=?\"; Object[] params = {33,\"张三\"}; int result = template.update(sql,params); System.out.println(result); } } Copyright © MISIN 2022 | 豫ICP备2021006345号-1 all right reserved，powered by Gitbook该文件修订时间： 2022-11-10 10:52:46 "},"2.JavaWeb/6.Mybatis/mybatis-day01.html":{"url":"2.JavaWeb/6.Mybatis/mybatis-day01.html","title":"Mybatis Day 01","keywords":"","body":"1.1.1. 一.Mybatis快速入门1.1.2. 二. MyBatis的相关api1.1.3. 三.MyBatis 映射配置文件1.1.4. 四.Mybatis核心配置文件介绍1.1.5. 五.Mybatis传统方式开发1.1.1. 一.Mybatis快速入门 1.1 框架介绍 框架是一款半成品软件，我们可以基于这个半成品软件继续开发，来完成我们个性化的需求！ 如图: 1.2 ORM介绍 ORM(Object Relational Mapping)： 对象关系映射 指的是持久化数据和实体对象的映射模式，为了解决面向对象与关系型数据库存在的互不匹配的现象的技术。 如图: 具体映射关系如下图: 1.3 原始jdbc操作（查询数据） 1.4原始jdbc操作（插入数据） 1.5 原始jdbc操作的分析 原始 JDBC 的操作问题分析 ​ 1.频繁创建和销毁数据库的连接会造成系统资源浪费从而影响系统性能。 sql 语句在代码中硬编码，如果要修改 sql 语句，就需要修改 java 代码，造成代码不易维护。 查询操作时，需要手动将结果集中的数据封装到实体对象中。 增删改查操作需要参数时，需要手动将实体对象的数据设置到 sql 语句的占位符。  原始 JDBC 的操作问题解决方案 ​ 1.使用数据库连接池初始化连接资源。 将 sql 语句抽取到配置文件中。 使用反射、内省等底层技术，将实体与表进行属性与字段的自动映射 1.6 什么是Mybatis mybatis 是一个优秀的基于java的持久层框架，它内部封装了jdbc，使开发者只需要关注sql语句本身，而不需要花费精力去处理加载驱动、创建连接、创建statement等繁杂的过程。 mybatis通过xml或注解的方式将要执行的各种 statement配置起来，并通过java对象和statement中sql的动态参数进行映射生成最终执行的sql语句。 最后mybatis框架执行sql并将结果映射为java对象并返回。采用ORM思想解决了实体和数据库映射的问题，对jdbc 进行了封装，屏蔽了jdbc api 底层访问细节，使我们不用与jdbc api 打交道，就可以完成对数据库的持久化操作。 MyBatis官网地址：http://www.mybatis.org/mybatis-3/ 1.7 Mybatis的快速入门 MyBatis开发步骤： ①添加MyBatis的jar包 ②创建Student数据表 ③编写Studentr实体类 ④编写映射文件StudentMapper.xml ⑤编写核心文件MyBatisConfig.xml ⑥编写测试类 1.7.1 环境搭建 1)导入MyBatis的jar包 mysql-connector-java-5.1.37-bin.jar mybatis-3.5.3.jar log4j-1.2.17.jar 2) 创建student数据表 3) 编写Student实体 public class Student { private Integer id; private String name; private Integer age; //省略get个set方法 } 4)编写StudentMapper.xml映射文件 SELECT * FROM student 5) 编写MyBatis核心文件 --> 1.7.2编写测试代码 /* 控制层测试类 */ public class StudentController { //创建业务层对象 private StudentService service = new StudentServiceImpl(); //查询全部功能测试 @Test public void selectAll() { List students = service.selectAll(); for (Student stu : students) { System.out.println(stu); } } } 1.8 知识小结 框架 框架是一款半成品软件，我们可以基于框架继续开发，从而完成一些个性化的需求。 ORM 对象关系映射，数据和实体对象的映射。 MyBatis 是一个优秀的基于 Java 的持久层框架，它内部封装了 JDBC。 1.1.2. 二. MyBatis的相关api 2.1 Resources org.apache.ibatis.io.Resources：加载资源的工具类。 核心方法 2.2 构建器SqlSessionFactoryBuilder org.apache.ibatis.session.SqlSessionFactoryBuilder：获取 SqlSessionFactory 工厂对象的功能类 核心方法 通过加载mybatis的核心文件的输入流的形式构建一个SqlSessionFactory对象 String resource = \"org/mybatis/builder/mybatis-config.xml\"; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder(); SqlSessionFactory factory = builder.build(inputStream); 其中， Resources 工具类，这个类在 org.apache.ibatis.io 包中。Resources 类帮助你从类路径下、文件系统或一个 web URL 中加载资源文件。 2.3 工厂对象SqlSessionFactory org.apache.ibatis.session.SqlSessionFactory：获取 SqlSession 构建者对象的工厂接口。 核心api 2.4 SqlSession会话对象 org.apache.ibatis.session.SqlSession：构建者对象接口。用于执行 SQL、管理事务、接口代理。 核心api SqlSession 实例在 MyBatis 中是非常强大的一个类。在这里你会看到所有执行语句、提交或回滚事务和获取映射器实例的方法。 1.1.3. 三.MyBatis 映射配置文件 3.1 映射配置文件介绍 映射配置文件包含了数据和对象之间的映射关系以及要执行的 SQL 语句 3.2 查询功能 ：查询功能标签。 属性 id：唯一标识， 配合名称空间使用。 parameterType：指定参数映射的对象类型。 resultType：指定结果映射的对象类型。 SQL 获取参数: #{属性名} 示例 3.3 新增功能 ：新增功能标签。 属性 id：唯一标识， 配合名称空间使用。 parameterType：指定参数映射的对象类型。 resultType：指定结果映射的对象类型。 SQL 获取参数: #{属性名} 示例 3.4 修改功能 ：修改功能标签。 属性 id：唯一标识， 配合名称空间使用。 parameterType：指定参数映射的对象类型。 resultType：指定结果映射的对象类型。 SQL 获取参数: #{属性名} 示例 3.5 删除功能 ：查询功能标签。 属性 id：唯一标识， 配合名称空间使用。 parameterType：指定参数映射的对象类型。 resultType：指定结果映射的对象类型。 SQL 获取参数: #{属性名} 示例 总结： 大家可以发现crud操作，除了标签名称以及sql语句不一样之外，其他属性参数基本一致。 3.6 映射配置文件小结 1.1.4. 四.Mybatis核心配置文件介绍 4.1 核心配置文件介绍 核心配置文件包含了 MyBatis 最核心的设置和属性信息。如数据库的连接、事务、连接池信息等。 如下图: 4.2 数据库连接配置文件引入 properties标签引入外部文件 具体使用，如下配置 4.3 起别名 ：为全类名起别名的父标签。 ：为全类名起别名的子标签。 属性 type：指定全类名 alias：指定别名 ：为指定包下所有类起别名的子标签。(别名就是类名) 如下图： 具体如下配置 --> 4.4 总结 1.1.5. 五.Mybatis传统方式开发 5.1 Dao 层传统实现方式 分层思想：控制层(controller)、业务层(service)、持久层(dao)。 调用流程 5.2 LOG4J的配置和使用 在日常开发过程中，排查问题时难免需要输出 MyBatis 真正执行的 SQL 语句、参数、结果等信息，我们就可以借助 LOG4J 的功能来实现执行信息的输出。 使用步骤： Copyright © MISIN 2022 | 豫ICP备2021006345号-1 all right reserved，powered by Gitbook该文件修订时间： 2022-11-10 10:54:42 "},"2.JavaWeb/6.Mybatis/mybatis-day02.html":{"url":"2.JavaWeb/6.Mybatis/mybatis-day02.html","title":"Mybatis Day 02","keywords":"","body":"1.1.1. 一.接口代理方式实现Dao1.1.2. 二. 动态sql语句1.1.3. 三. 分页插件1.1.4. 四.MyBatis的多表操作1.1.1. 一.接口代理方式实现Dao 1.1 代理开发方式介绍 ​ 采用 Mybatis 的代理开发方式实现 DAO 层的开发，这种方式是我们后面进入企业的主流。 Mapper 接口开发方法只需要程序员编写Mapper 接口（相当于Dao 接口），由Mybatis 框架根据接口定义创建接口的动态代理对象，代理对象的方法体同上边Dao接口实现类方法。 Mapper 接口开发需要遵循以下规范： 1) Mapper.xml文件中的namespace与mapper接口的全限定名相同 2) Mapper接口方法名和Mapper.xml中定义的每个statement的id相同 3) Mapper接口方法的输入参数类型和mapper.xml中定义的每个sql的parameterType的类型相同 4) Mapper接口方法的输出参数类型和mapper.xml中定义的每个sql的resultType的类型相同 总结: 接口开发的方式: 程序员只需定义接口,就可以对数据库进行操作,那么具体的对象怎么创建? 1.程序员负责定义接口 2.在操作数据库,mybatis框架根据接口,通过动态代理的方式生成代理对象,负责数据库的crud操作 1.2.编写StudentMapper接口 1.3 测试代理方式 public Student selectById(Integer id) { Student stu = null; SqlSession sqlSession = null; InputStream is = null; try{ //1.加载核心配置文件 is = Resources.getResourceAsStream(\"MyBatisConfig.xml\"); //2.获取SqlSession工厂对象 SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is); //3.通过工厂对象获取SqlSession对象 sqlSession = sqlSessionFactory.openSession(true); //4.获取StudentMapper接口的实现类对象 StudentMapper mapper = sqlSession.getMapper(StudentMapper.class); // StudentMapper mapper = new StudentMapperImpl(); //5.通过实现类对象调用方法，接收结果 stu = mapper.selectById(id); } catch (Exception e) { } finally { //6.释放资源 if(sqlSession != null) { sqlSession.close(); } if(is != null) { try { is.close(); } catch (IOException e) { e.printStackTrace(); } } } //7.返回结果 return stu; } 1.4 源码分析 分析动态代理对象如何生成的？ 通过动态代理开发模式，我们只编写一个接口，不写实现类，我们通过 getMapper() 方法最终获取到 org.apache.ibatis.binding.MapperProxy 代理对象，然后执行功能，而这个代理对象正是 MyBatis 使用了 JDK 的动态代理技术，帮助我们生成了代理实现类对象。从而可以进行相关持久化操作。 分析方法是如何执行的？ 动态代理实现类对象在执行方法的时候最终调用了 mapperMethod.execute() 方法，这个方法中通过 switch 语句根据操作类型来判断是新增、修改、删除、查询操作，最后一步回到了 MyBatis 最原生的 SqlSession 方式来执行增删改查。 1.5 知识小结 接口代理方式可以让我们只编写接口即可，而实现类对象由 MyBatis 生成。 实现规则 ： 映射配置文件中的名称空间必须和 Dao 层接口的全类名相同。 映射配置文件中的增删改查标签的 id 属性必须和 Dao 层接口的方法名相同。 映射配置文件中的增删改查标签的 parameterType 属性必须和 Dao 层接口方法的参数相同。 映射配置文件中的增删改查标签的 resultType 属性必须和 Dao 层接口方法的返回值相同。  获取动态代理对象 SqlSession 功能类中的 getMapper() 方法。 1.1.2. 二. 动态sql语句 2.1 动态sql语句概述 ​ Mybatis 的映射文件中，前面我们的 SQL 都是比较简单的，有些时候业务逻辑复杂时，我们的 SQL是动态变化的，此时在前面的学习中我们的 SQL 就不能满足要求了。 参考的官方文档，描述如下： 2.2 动态 SQL 之if> 我们根据实体类的不同取值，使用不同的 SQL语句来进行查询。比如在 id如果不为空时可以根据id查询，如果username 不同空时还要加入用户名作为条件。这种情况在我们的多条件组合查询中经常会碰到。 如下图： select * from student and id=#{id} and username=#{username} 当查询条件id和username都存在时，控制台打印的sql语句如下： … … … //获得MyBatis框架生成的StudentMapper接口的实现类 StudentMapper mapper = sqlSession.getMapper( StudentMapper.class); Student condition = new Student(); condition.setId(1); condition.setUsername(\"lucy\"); Student student = mapper.findByCondition(condition); … … … 当查询条件只有id存在时，控制台打印的sql语句如下： … … … //获得MyBatis框架生成的UserMapper接口的实现类 StudentMapper mapper = sqlSession.getMapper( StudentMapper.class); Student condition = new Student(); condition.setId(1); Student student = mapper.findByCondition(condition); … … … 总结语法: ：条件标签。如果有动态条件，则使用该标签代替 where 关键字。 ：条件判断标签。 查询条件拼接 2.3 动态 SQL 之foreach> 循环执行sql的拼接操作，例如：SELECT * FROM student WHERE id IN (1,2,5)。 select * from student #{id} 测试代码片段如下： … … … //获得MyBatis框架生成的UserMapper接口的实现类 StudentMapper mapper = sqlSession.getMapper(StudentMapper.class); int[] ids = new int[]{2,5}; List sList = mapper.findByIds(ids); System.out.println(sList); … … … 总结语法: ：循环遍历标签。适用于多个参数或者的关系。 获取参数 属性 collection：参数容器类型， (list-集合， array-数组)。 open：开始的 SQL 语句。 close：结束的 SQL 语句。 item：参数变量名。 separator：分隔符。 2.4 SQL片段抽取 Sql 中可将重复的 sql 提取出来，使用时用 include 引用即可，最终达到 sql 重用的目的 where id=#{id} #{id} 总结语法: 我们可以将一些重复性的 SQL 语句进行抽取，以达到复用的效果。 - ：抽取 SQL 语句标签。 - ：引入 SQL 片段标签。 抽取的 SQL 语句 2.5 知识小结 MyBatis映射文件配置： ：查询 ：插入 ：修改 ：删除 ：where条件 ：if判断 ：循环 ：sql片段抽取 1.1.3. 三. 分页插件 3.1 分页插件介绍 分页可以将很多条结果进行分页显示。 如果当前在第一页，则没有上一页。如果当前在最后一页，则没有下一页。 需要明确当前是第几页，这一页中显示多少条结果。 MyBatis分页插件总结 在企业级开发中，分页也是一种常见的技术。而目前使用的 MyBatis 是不带分页功能的，如果想实现分页的 功能，需要我们手动编写 LIMIT 语句。但是不同的数据库实现分页的 SQL 语句也是不同的，所以手写分页 成本较高。这个时候就可以借助分页插件来帮助我们实现分页功能。 PageHelper：第三方分页助手。将复杂的分页操作进行封装，从而让分页功能变得非常简单。 3.2 分页插件的使用 MyBatis可以使用第三方的插件来对功能进行扩展，分页助手PageHelper是将分页的复杂操作进行封装，使用简单的方式即可获得分页的相关数据 开发步骤： ①导入与PageHelper的jar包 ②在mybatis核心配置文件中配置PageHelper插件 ③测试分页数据获取 @Test public void testPageHelper(){ //设置分页参数 PageHelper.startPage(1,2); List select = userMapper2.select(null); for(User user : select){ System.out.println(user); } } 3.3 分页插件的参数获取 获得分页相关的其他参数： //其他分页的数据 PageInfo pageInfo = new PageInfo(select); System.out.println(\"总条数：\"+pageInfo.getTotal()); System.out.println(\"总页数：\"+pageInfo.getPages()); System.out.println(\"当前页：\"+pageInfo.getPageNum()); System.out.println(\"每页显示长度：\"+pageInfo.getPageSize()); System.out.println(\"是否第一页：\"+pageInfo.isIsFirstPage()); System.out.println(\"是否最后一页：\"+pageInfo.isIsLastPage()); 3.4 分页插件知识小结 ​ 分页：可以将很多条结果进行分页显示。 分页插件 jar 包： pagehelper-5.1.10.jar jsqlparser-3.1.jar ：集成插件标签。 分页助手相关 API ​ 1.PageHelper：分页助手功能类。 startPage()：设置分页参数 PageInfo：分页相关参数功能类。 getTotal()：获取总条数 getPages()：获取总页数 getPageNum()：获取当前页 getPageSize()：获取每页显示条数 getPrePage()：获取上一页 getNextPage()：获取下一页 isIsFirstPage()：获取是否是第一页 isIsLastPage()：获取是否是最后一页 1.1.4. 四.MyBatis的多表操作 4.1 多表模型介绍 我们之前学习的都是基于单表操作的，而实际开发中，随着业务难度的加深，肯定需要多表操作的。 多表模型分类 一对一：在任意一方建立外键，关联对方的主键。 一对多：在多的一方建立外键，关联一的一方的主键。 多对多：借助中间表，中间表至少两个字段，分别关联两张表的主键。 4.2 多表模型一对一操作 一对一模型： 人和身份证，一个人只有一个身份证 代码实现 步骤一: sql语句准备 CREATE TABLE person( id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(20), age INT ); INSERT INTO person VALUES (NULL,'张三',23); INSERT INTO person VALUES (NULL,'李四',24); INSERT INTO person VALUES (NULL,'王五',25); CREATE TABLE card( id INT PRIMARY KEY AUTO_INCREMENT, number VARCHAR(30), pid INT, CONSTRAINT cp_fk FOREIGN KEY (pid) REFERENCES person(id) ); INSERT INTO card VALUES (NULL,'12345',1); INSERT INTO card VALUES (NULL,'23456',2); INSERT INTO card VALUES (NULL,'34567',3); 步骤二:配置文件 SELECT c.id cid,number,pid,NAME,age FROM card c,person p WHERE c.pid=p.id 步骤三：测试类 @Test public void selectAll() throws Exception{ //1.加载核心配置文件 InputStream is = Resources.getResourceAsStream(\"MyBatisConfig.xml\"); //2.获取SqlSession工厂对象 SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is); //3.通过工厂对象获取SqlSession对象 SqlSession sqlSession = sqlSessionFactory.openSession(true); //4.获取OneToOneMapper接口的实现类对象 OneToOneMapper mapper = sqlSession.getMapper(OneToOneMapper.class); //5.调用实现类的方法，接收结果 List list = mapper.selectAll(); //6.处理结果 for (Card c : list) { System.out.println(c); } //7.释放资源 sqlSession.close(); is.close(); } 3.一对一配置总结: ：配置字段和对象属性的映射关系标签。 id 属性：唯一标识 type 属性：实体对象类型 ：配置主键映射关系标签。 ：配置非主键映射关系标签。 column 属性：表中字段名称 property 属性： 实体对象变量名称 ：配置被包含对象的映射关系标签。 property 属性：被包含对象的变量名 javaType 属性：被包含对象的数据类型 4.3 多表模型一对多操作 一对多模型： 一对多模型：班级和学生，一个班级可以有多个学生。 代码实现 步骤一: sql语句准备 ```sql CREATE TABLE classes( id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(20) ); INSERT INTO classes VALUES (NULL,'黑马一班'); INSERT INTO classes VALUES (NULL,'黑马二班'); CREATE TABLE student( id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(30), age INT, cid INT, CONSTRAINT cs_fk FOREIGN KEY (cid) REFERENCES classes(id) ); INSERT INTO student VALUES (NULL,'张三',23,1); INSERT INTO student VALUES (NULL,'李四',24,1); INSERT INTO student VALUES (NULL,'王五',25,2); INSERT INTO student VALUES (NULL,'赵六',26,2); ``` 步骤二:配置文件 SELECT c.id cid,c.name cname,s.id sid,s.name sname,s.age sage FROM classes c,student s WHERE c.id=s.cid 步骤三：测试类 @Test public void selectAll() throws Exception{ //1.加载核心配置文件 InputStream is = Resources.getResourceAsStream(\"MyBatisConfig.xml\"); //2.获取SqlSession工厂对象 SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is); //3.通过工厂对象获取SqlSession对象 SqlSession sqlSession = sqlSessionFactory.openSession(true); //4.获取OneToManyMapper接口的实现类对象 OneToManyMapper mapper = sqlSession.getMapper(OneToManyMapper.class); //5.调用实现类的方法，接收结果 List classes = mapper.selectAll(); //6.处理结果 for (Classes cls : classes) { System.out.println(cls.getId() + \",\" + cls.getName()); List students = cls.getStudents(); for (Student student : students) { System.out.println(\"\\t\" + student); } } //7.释放资源 sqlSession.close(); is.close(); } 3.一对多配置文件总结： ：配置字段和对象属性的映射关系标签。 id 属性：唯一标识 type 属性：实体对象类型 ：配置主键映射关系标签。 ：配置非主键映射关系标签。 column 属性：表中字段名称 property 属性： 实体对象变量名称 ：配置被包含集合对象的映射关系标签。 property 属性：被包含集合对象的变量名 ofType 属性：集合中保存的对象数据类型 4.4 多表模型多对多操作 多对多模型：学生和课程，一个学生可以选择多门课程、一个课程也可以被多个学生所选择。 代码实现 步骤一: sql语句准备 ```sql CREATE TABLE course( id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(20) ); INSERT INTO course VALUES (NULL,'语文'); INSERT INTO course VALUES (NULL,'数学'); CREATE TABLE stu_cr( id INT PRIMARY KEY AUTO_INCREMENT, sid INT, cid INT, CONSTRAINT sc_fk1 FOREIGN KEY (sid) REFERENCES student(id), CONSTRAINT sc_fk2 FOREIGN KEY (cid) REFERENCES course(id) ); INSERT INTO stu_cr VALUES (NULL,1,1); INSERT INTO stu_cr VALUES (NULL,1,2); INSERT INTO stu_cr VALUES (NULL,2,1); INSERT INTO stu_cr VALUES (NULL,2,2); ``` 步骤二:配置文件 SELECT sc.sid,s.name sname,s.age sage,sc.cid,c.name cname FROM student s,course c,stu_cr sc WHERE sc.sid=s.id AND sc.cid=c.id 步骤三：测试类 @Test public void selectAll() throws Exception{ //1.加载核心配置文件 InputStream is = Resources.getResourceAsStream(\"MyBatisConfig.xml\"); //2.获取SqlSession工厂对象 SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is); //3.通过工厂对象获取SqlSession对象 SqlSession sqlSession = sqlSessionFactory.openSession(true); //4.获取ManyToManyMapper接口的实现类对象 ManyToManyMapper mapper = sqlSession.getMapper(ManyToManyMapper.class); //5.调用实现类的方法，接收结果 List students = mapper.selectAll(); //6.处理结果 for (Student student : students) { System.out.println(student.getId() + \",\" + student.getName() + \",\" + student.getAge()); List courses = student.getCourses(); for (Course cours : courses) { System.out.println(\"\\t\" + cours); } } //7.释放资源 sqlSession.close(); is.close(); } 3.多对多配置文件总结： ：配置字段和对象属性的映射关系标签。 id 属性：唯一标识 type 属性：实体对象类型 ：配置主键映射关系标签。 ：配置非主键映射关系标签。 column 属性：表中字段名称 property 属性： 实体对象变量名称 ：配置被包含集合对象的映射关系标签。 property 属性：被包含集合对象的变量名 ofType 属性：集合中保存的对象数据类型 4.5 多表模型操作总结 ：配置字段和对象属性的映射关系标签。 id 属性：唯一标识 type 属性：实体对象类型 ：配置主键映射关系标签。 ：配置非主键映射关系标签。 column 属性：表中字段名称 property 属性： 实体对象变量名称 ：配置被包含对象的映射关系标签。 property 属性：被包含对象的变量名 javaType 属性：被包含对象的数据类型 ：配置被包含集合对象的映射关系标签。 property 属性：被包含集合对象的变量名 ofType 属性：集合中保存的对象数据类型 Copyright © MISIN 2022 | 豫ICP备2021006345号-1 all right reserved，powered by Gitbook该文件修订时间： 2022-11-10 10:55:50 "},"2.JavaWeb/6.Mybatis/mybatis-day03.html":{"url":"2.JavaWeb/6.Mybatis/mybatis-day03.html","title":"Mybatis Day 03","keywords":"","body":"1.1.1. 一.Mybatis注解开发单表操作1.1.2. 二.MyBatis注解开发的多表操作1.1.3. 三.构建sql1.1.4. 四.综合案例1.1.1. 一.Mybatis注解开发单表操作 1.1 MyBatis的常用注解 这几年来注解开发越来越流行，Mybatis也可以使用注解开发方式，这样我们就可以减少编写Mapper 映射文件了。我们先围绕一些基本的CRUD来学习，再学习复杂映射多表操作。 @Insert：实现新增 @Update：实现更新 @Delete：实现删除 @Select：实现查询 @Result：实现结果集封装 @Results：可以与@Result 一起使用，封装多个结果集 @One：实现一对一结果集封装 @Many：实现一对多结果集封装 1.2 MyBatis的增删改查 我们完成简单的student表的增删改查的操作 步骤一:创建mapper接口 public interface StudentMapper { //查询全部 @Select(\"SELECT * FROM student\") public abstract List selectAll(); //新增操作 @Insert(\"INSERT INTO student VALUES (#{id},#{name},#{age})\") public abstract Integer insert(Student stu); //修改操作 @Update(\"UPDATE student SET name=#{name},age=#{age} WHERE id=#{id}\") public abstract Integer update(Student stu); //删除操作 @Delete(\"DELETE FROM student WHERE id=#{id}\") public abstract Integer delete(Integer id); } 步骤二：测试类 public class Test01 { @Test public void selectAll() throws Exception{ //1.加载核心配置文件 InputStream is = Resources.getResourceAsStream(\"MyBatisConfig.xml\"); //2.获取SqlSession工厂对象 SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is); //3.通过工厂对象获取SqlSession对象 SqlSession sqlSession = sqlSessionFactory.openSession(true); //4.获取StudentMapper接口的实现类对象 StudentMapper mapper = sqlSession.getMapper(StudentMapper.class); //5.调用实现类对象中的方法，接收结果 List list = mapper.selectAll(); //6.处理结果 for (Student student : list) { System.out.println(student); } //7.释放资源 sqlSession.close(); is.close(); } @Test public void insert() throws Exception{ //1.加载核心配置文件 InputStream is = Resources.getResourceAsStream(\"MyBatisConfig.xml\"); //2.获取SqlSession工厂对象 SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is); //3.通过工厂对象获取SqlSession对象 SqlSession sqlSession = sqlSessionFactory.openSession(true); //4.获取StudentMapper接口的实现类对象 StudentMapper mapper = sqlSession.getMapper(StudentMapper.class); //5.调用实现类对象中的方法，接收结果 Student stu = new Student(4,\"赵六\",26); Integer result = mapper.insert(stu); //6.处理结果 System.out.println(result); //7.释放资源 sqlSession.close(); is.close(); } @Test public void update() throws Exception{ //1.加载核心配置文件 InputStream is = Resources.getResourceAsStream(\"MyBatisConfig.xml\"); //2.获取SqlSession工厂对象 SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is); //3.通过工厂对象获取SqlSession对象 SqlSession sqlSession = sqlSessionFactory.openSession(true); //4.获取StudentMapper接口的实现类对象 StudentMapper mapper = sqlSession.getMapper(StudentMapper.class); //5.调用实现类对象中的方法，接收结果 Student stu = new Student(4,\"赵六\",36); Integer result = mapper.update(stu); //6.处理结果 System.out.println(result); //7.释放资源 sqlSession.close(); is.close(); } @Test public void delete() throws Exception{ //1.加载核心配置文件 InputStream is = Resources.getResourceAsStream(\"MyBatisConfig.xml\"); //2.获取SqlSession工厂对象 SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is); //3.通过工厂对象获取SqlSession对象 SqlSession sqlSession = sqlSessionFactory.openSession(true); //4.获取StudentMapper接口的实现类对象 StudentMapper mapper = sqlSession.getMapper(StudentMapper.class); //5.调用实现类对象中的方法，接收结果 Integer result = mapper.delete(4); //6.处理结果 System.out.println(result); //7.释放资源 sqlSession.close(); is.close(); } } 注意： 修改MyBatis的核心配置文件，我们使用了注解替代的映射文件，所以我们只需要加载使用了注解的Mapper接口即可 ​ 或者指定扫描包含映射关系的接口所在的包也可以 1.3 注解开发总结 注解可以简化开发操作，省略映射配置文件的编写。 常用注解 @Select(“查询的 SQL 语句”)：执行查询操作注解 @Insert(“查询的 SQL 语句”)：执行新增操作注解 @Update(“查询的 SQL 语句”)：执行修改操作注解 @Delete(“查询的 SQL 语句”)：执行删除操作注解 配置映射关系 1.1.2. 二.MyBatis注解开发的多表操作 2.1 MyBatis的注解实现复杂映射开发 实现复杂关系映射之前我们可以在映射文件中通过配置来实现，使用注解开发后，我们可以使用@Results注解，@Result注解，@One注解，@Many注解组合完成复杂关系的配置 2.2 一对一查询 2.2.1 一对一查询的模型 一对一查询的需求：查询一个用户信息，与此同时查询出该用户对应的身份证信息 2.2.2 一对一查询的语句 对应的sql语句： SELECT * FROM card； SELECT * FROM person WHERE id=#{id}; 2.2.3 创建PersonMapper接口 public interface PersonMapper { //根据id查询 @Select(\"SELECT * FROM person WHERE id=#{id}\") public abstract Person selectById(Integer id); } 2.2.4 使用注解配置Mapper public interface CardMapper { //查询全部 @Select(\"SELECT * FROM card\") @Results({ @Result(column = \"id\",property = \"id\"), @Result(column = \"number\",property = \"number\"), @Result( property = \"p\", // 被包含对象的变量名 javaType = Person.class, // 被包含对象的实际数据类型 column = \"pid\", // 根据查询出的card表中的pid字段来查询person表 /* one、@One 一对一固定写法 select属性：指定调用哪个接口中的哪个方法 */ one = @One(select = \"com.itheima.one_to_one.PersonMapper.selectById\") ) }) public abstract List selectAll(); } 2.2.5 测试类 public class Test01 { @Test public void selectAll() throws Exception{ //1.加载核心配置文件 InputStream is = Resources.getResourceAsStream(\"MyBatisConfig.xml\"); //2.获取SqlSession工厂对象 SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is); //3.通过工厂对象获取SqlSession对象 SqlSession sqlSession = sqlSessionFactory.openSession(true); //4.获取CardMapper接口的实现类对象 CardMapper mapper = sqlSession.getMapper(CardMapper.class); //5.调用实现类对象中的方法，接收结果 List list = mapper.selectAll(); //6.处理结果 for (Card card : list) { System.out.println(card); } //7.释放资源 sqlSession.close(); is.close(); } } 2.2.6 一对一配置总结 @Results：封装映射关系的父注解。 Result[] value()：定义了 Result 数组 @Result：封装映射关系的子注解。 column 属性：查询出的表中字段名称 property 属性：实体对象中的属性名称 javaType 属性：被包含对象的数据类型 one 属性：一对一查询固定属性 @One：一对一查询的注解。 select 属性：指定调用某个接口中的方法 2.3 一对多查询 2.3.1 一对多查询的模型 一对多查询的需求：查询一个课程，与此同时查询出该该课程对应的学生信息 2.3.2 一对多查询的语句 对应的sql语句： SELECT * FROM classes SELECT * FROM student WHERE cid=#{cid} 2.3.3 创建StudentMapper接口 public interface StudentMapper { //根据cid查询student表 @Select(\"SELECT * FROM student WHERE cid=#{cid}\") public abstract List selectByCid(Integer cid); } 2.3.4 使用注解配置Mapper public interface ClassesMapper { //查询全部 @Select(\"SELECT * FROM classes\") @Results({ @Result(column = \"id\",property = \"id\"), @Result(column = \"name\",property = \"name\"), @Result( property = \"students\", // 被包含对象的变量名 javaType = List.class, // 被包含对象的实际数据类型 column = \"id\", // 根据查询出的classes表的id字段来查询student表 /* many、@Many 一对多查询的固定写法 select属性：指定调用哪个接口中的哪个查询方法 */ many = @Many(select = \"com.itheima.one_to_many.StudentMapper.selectByCid\") ) }) public abstract List selectAll(); } 2.3.5 测试类 public class Test01 { @Test public void selectAll() throws Exception{ //1.加载核心配置文件 InputStream is = Resources.getResourceAsStream(\"MyBatisConfig.xml\"); //2.获取SqlSession工厂对象 SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is); //3.通过工厂对象获取SqlSession对象 SqlSession sqlSession = sqlSessionFactory.openSession(true); //4.获取ClassesMapper接口的实现类对象 ClassesMapper mapper = sqlSession.getMapper(ClassesMapper.class); //5.调用实现类对象中的方法，接收结果 List list = mapper.selectAll(); //6.处理结果 for (Classes cls : list) { System.out.println(cls.getId() + \",\" + cls.getName()); List students = cls.getStudents(); for (Student student : students) { System.out.println(\"\\t\" + student); } } //7.释放资源 sqlSession.close(); is.close(); } } 2.3.6 一对多配置总结 @Results：封装映射关系的父注解。 Result[] value()：定义了 Result 数组 @Result：封装映射关系的子注解。 column 属性：查询出的表中字段名称 property 属性：实体对象中的属性名称 javaType 属性：被包含对象的数据类型 many 属性：一对多查询固定属性 @Many：一对多查询的注解。 select 属性：指定调用某个接口中的方法 2.4 多对多查询 2.4.1 多对多查询的模型 多对多查询的需求：查询学生以及所对应的课程信息 2.4.2 多对多查询的语句 对应的sql语句： SELECT DISTINCT s.id,s.name,s.age FROM student s,stu_cr sc WHERE sc.sid=s.id SELECT c.id,c.name FROM stu_cr sc,course c WHERE sc.cid=c.id AND sc.sid=#{id} 2.4.3 添加CourseMapper 接口方法 public interface CourseMapper { //根据学生id查询所选课程 @Select(\"SELECT c.id,c.name FROM stu_cr sc,course c WHERE sc.cid=c.id AND sc.sid=#{id}\") public abstract List selectBySid(Integer id); } 2.4.4 使用注解配置Mapper public interface StudentMapper { //查询全部 @Select(\"SELECT DISTINCT s.id,s.name,s.age FROM student s,stu_cr sc WHERE sc.sid=s.id\") @Results({ @Result(column = \"id\",property = \"id\"), @Result(column = \"name\",property = \"name\"), @Result(column = \"age\",property = \"age\"), @Result( property = \"courses\", // 被包含对象的变量名 javaType = List.class, // 被包含对象的实际数据类型 column = \"id\", // 根据查询出student表的id来作为关联条件，去查询中间表和课程表 /* many、@Many 一对多查询的固定写法 select属性：指定调用哪个接口中的哪个查询方法 */ many = @Many(select = \"com.itheima.many_to_many.CourseMapper.selectBySid\") ) }) public abstract List selectAll(); } 2.4.5 测试类 public class Test01 { @Test public void selectAll() throws Exception{ //1.加载核心配置文件 InputStream is = Resources.getResourceAsStream(\"MyBatisConfig.xml\"); //2.获取SqlSession工厂对象 SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is); //3.通过工厂对象获取SqlSession对象 SqlSession sqlSession = sqlSessionFactory.openSession(true); //4.获取StudentMapper接口的实现类对象 StudentMapper mapper = sqlSession.getMapper(StudentMapper.class); //5.调用实现类对象中的方法，接收结果 List list = mapper.selectAll(); //6.处理结果 for (Student student : list) { System.out.println(student.getId() + \",\" + student.getName() + \",\" + student.getAge()); List courses = student.getCourses(); for (Course cours : courses) { System.out.println(\"\\t\" + cours); } } //7.释放资源 sqlSession.close(); is.close(); } } 2.4.6 多对多配置总结 @Results：封装映射关系的父注解。 Result[] value()：定义了 Result 数组 @Result：封装映射关系的子注解。 column 属性：查询出的表中字段名称 property 属性：实体对象中的属性名称 javaType 属性：被包含对象的数据类型 many 属性：一对多查询固定属性 @Many：一对多查询的注解。 select 属性：指定调用某个接口中的方法 1.1.3. 三.构建sql 3.1 SQL 构建对象介绍 我们之前通过注解开发时，相关 SQL 语句都是自己直接拼写的。一些关键字写起来比较麻烦、而且容易出错。 MyBatis 给我们提供了 org.apache.ibatis.jdbc.SQL 功能类，专门用于构建 SQL 语句 3.2 查询功能的实现 定义功能类并提供获取查询的 SQL 语句的方法。  @SelectProvider：生成查询用的 SQL 语句注解。 type 属性：生成 SQL 语句功能类对象 method 属性：指定调用方法 3.3 新增功能的实现 定义功能类并提供获取新增的 SQL 语句的方法。 @InsertProvider：生成新增用的 SQL 语句注解。 type 属性：生成 SQL 语句功能类对象 method 属性：指定调用方法 3.4 修改功能的实现 定义功能类并提供获取修改的 SQL 语句的方法。 @UpdateProvider：生成修改用的 SQL 语句注解。 type 属性：生成 SQL 语句功能类对象 method 属性：指定调用方法 3.5 删除功能的实现 定义功能类并提供获取删除的 SQL 语句的方法。 @DeleteProvider：生成删除用的 SQL 语句注解。 type 属性：生成 SQL 语句功能类对象 method 属性：指定调用方法 1.1.4. 四.综合案例 4.1 系统介绍 ​ 我们之前在做学生管理系统时，使用的是原始JDBC操作数据库的，操作非常麻烦，现在我们使用MyBatis操作数据库，简化Dao的开发。 4.2 环境搭建（略） 4.3 代码改造 步骤一：新增MyBatis配置文件 MyBatisConfig.xml 步骤二: 删除StudentDaoImpl，修改StudentDao package com.itheima.dao; import com.itheima.domain.Student; import org.apache.ibatis.annotations.Delete; import org.apache.ibatis.annotations.Insert; import org.apache.ibatis.annotations.Select; import org.apache.ibatis.annotations.Update; import java.util.ArrayList; / Dao层接口 / public interface StudentDao { //查询所有学生信息 @Select(\"SELECT * FROM student\") public abstract ArrayList findAll(); //条件查询，根据id获取学生信息 @Select(\"SELECT * FROM student WHERE sid=#{sid}\") public abstract Student findById(Integer sid); //新增学生信息 @Insert(\"INSERT INTO student VALUES (#{sid},#{name},#{age},#{birthday})\") public abstract int insert(Student stu); //修改学生信息 @Update(\"UPDATE student SET name=#{name},age=#{age},birthday=#{birthday} WHERE sid=#{sid}\") public abstract int update(Student stu); //删除学生信息 @Delete(\"DELETE FROM student WHERE sid=#{sid}\") public abstract int delete(Integer sid); } * 步骤三：修改`StudentServiceImpl` ~~~java package com.itheima.service.impl; import com.itheima.dao.StudentDao; import com.itheima.domain.Student; import com.itheima.service.StudentService; import org.apache.ibatis.io.Resources; import org.apache.ibatis.session.SqlSession; import org.apache.ibatis.session.SqlSessionFactory; import org.apache.ibatis.session.SqlSessionFactoryBuilder; import java.io.IOException; import java.io.InputStream; import java.util.ArrayList; import java.util.List; /** * 学生的业务层实现类 * @author 黑马程序员 * @Company http://www.itheima.com */ public class StudentServiceImpl implements StudentService { @Override public List findAll() { ArrayList list = null; SqlSession sqlSession = null; InputStream is = null; try{ //1.加载核心配置文件 is = Resources.getResourceAsStream(\"MyBatisConfig.xml\"); //2.获取SqlSession工厂对象 SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is); //3.通过工厂对象获取SqlSession对象 sqlSession = sqlSessionFactory.openSession(true); //4.获取StudentDao接口的实现类对象 StudentDao mapper = sqlSession.getMapper(StudentDao.class); //5.调用实现类对象的方法，接收结果 list = mapper.findAll(); } catch (Exception e) { e.printStackTrace(); } finally { //6.释放资源 if(sqlSession != null) { sqlSession.close(); } if(is != null) { try { is.close(); } catch (IOException e) { e.printStackTrace(); } } } //7.返回结果 return list; } @Override public Student findById(Integer sid) { Student stu = null; SqlSession sqlSession = null; InputStream is = null; try{ //1.加载核心配置文件 is = Resources.getResourceAsStream(\"MyBatisConfig.xml\"); //2.获取SqlSession工厂对象 SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is); //3.通过工厂对象获取SqlSession对象 sqlSession = sqlSessionFactory.openSession(true); //4.获取StudentDao接口的实现类对象 StudentDao mapper = sqlSession.getMapper(StudentDao.class); //5.调用实现类对象的方法，接收结果 stu = mapper.findById(sid); } catch (Exception e) { e.printStackTrace(); } finally { //6.释放资源 if(sqlSession != null) { sqlSession.close(); } if(is != null) { try { is.close(); } catch (IOException e) { e.printStackTrace(); } } } //7.返回结果 return stu; } @Override public void save(Student student) { SqlSession sqlSession = null; InputStream is = null; try{ //1.加载核心配置文件 is = Resources.getResourceAsStream(\"MyBatisConfig.xml\"); //2.获取SqlSession工厂对象 SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is); //3.通过工厂对象获取SqlSession对象 sqlSession = sqlSessionFactory.openSession(true); //4.获取StudentDao接口的实现类对象 StudentDao mapper = sqlSession.getMapper(StudentDao.class); //5.调用实现类对象的方法，接收结果 mapper.insert(student); } catch (Exception e) { e.printStackTrace(); } finally { //6.释放资源 if(sqlSession != null) { sqlSession.close(); } if(is != null) { try { is.close(); } catch (IOException e) { e.printStackTrace(); } } } } @Override public void update(Student student) { SqlSession sqlSession = null; InputStream is = null; try{ //1.加载核心配置文件 is = Resources.getResourceAsStream(\"MyBatisConfig.xml\"); //2.获取SqlSession工厂对象 SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is); //3.通过工厂对象获取SqlSession对象 sqlSession = sqlSessionFactory.openSession(true); //4.获取StudentDao接口的实现类对象 StudentDao mapper = sqlSession.getMapper(StudentDao.class); //5.调用实现类对象的方法，接收结果 mapper.update(student); } catch (Exception e) { e.printStackTrace(); } finally { //6.释放资源 if(sqlSession != null) { sqlSession.close(); } if(is != null) { try { is.close(); } catch (IOException e) { e.printStackTrace(); } } } } @Override public void delete(Integer sid) { SqlSession sqlSession = null; InputStream is = null; try{ //1.加载核心配置文件 is = Resources.getResourceAsStream(\"MyBatisConfig.xml\"); //2.获取SqlSession工厂对象 SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is); //3.通过工厂对象获取SqlSession对象 sqlSession = sqlSessionFactory.openSession(true); //4.获取StudentDao接口的实现类对象 StudentDao mapper = sqlSession.getMapper(StudentDao.class); //5.调用实现类对象的方法，接收结果 mapper.delete(sid); } catch (Exception e) { e.printStackTrace(); } finally { //6.释放资源 if(sqlSession != null) { sqlSession.close(); } if(is != null) { try { is.close(); } catch (IOException e) { e.printStackTrace(); } } } } } ~~~ ##### ##### ##### ##### ##### ##### ##### Copyright © MISIN 2022 | 豫ICP备2021006345号-1 all right reserved，powered by Gitbook该文件修订时间： 2022-11-10 10:58:20 "},"2.JavaWeb/7.JavaScript/JavaScript基础.html":{"url":"2.JavaWeb/7.JavaScript/JavaScript基础.html","title":"JavaScript基础","keywords":"","body":"1. 1、JavaScript快速入门1.1. 1.1、JavaScript介绍1.2. 1.2、快速入门1. 1、JavaScript快速入门 1.1. 1.1、JavaScript介绍 JavaScript 是一种客户端脚本语言。运行在客户端浏览器中，每一个浏览器都具备解析 JavaScript 的引擎。 脚本语言：不需要编译，就可以被浏览器直接解析执行了。 核心功能就是增强用户和 HTML 页面的交互过程，让页面有一些动态效果。以此来增强用户的体验！ 1995 年，NetScape (网景)公司，开发的一门客户端脚本语言：LiveScript。后来，请来 SUN 公司的专家来 进行修改，后命名为：JavaScript。 1996 年，微软抄袭 JavaScript 开发出 JScript 脚本语言。 1997 年，ECMA (欧洲计算机制造商协会)，制定出客户端脚本语言的标准：ECMAScript，统一了所有客户 端脚本语言的编码方式。 1.2. 1.2、快速入门 实现步骤 创建一个 HTML。 在标签下面编写一个标签。 在标签中编写代码。 通过浏览器查看 具体实现 JS快速入门 点我呀 引入js的方式一：内部方式 document.getElementById(“btn”).onclick=function () { alert(“点我干嘛？”); } 引入js的方式一：外部方式 创建js文件 document.getElementById(“btn”).onclick=function () { alert(“点我干嘛？”); } 在html中引用外部js文件 1.3、开发环境搭建 Node.js:JavaScript 运行环境 VSCode：编写前端技术的开发工具 根据《安装工具.pdf》文档安装Node.js和VSCode。相关资料都在“资料”文件夹中。 1.4、快速入门总结 JavaScript 是一种客户端脚本语言。 组成部分 ECMAScript、DOM、BOM 和 HTML 结合方式 内部方式： 外部方式： 2、JavaScript基本语法 2.1、注释 单行注释 // 注释的内容 多行注释 /* 注释的内容 */ 2.2、输入输出语句 输入框 prompt(“提示内容”); 弹出警告框 alert(“提示内容”); 控制台输出 console.log(“显示内容”); 页面内容输出 document.write(“显示内容”); 2.3、变量和常量 ​ JavaScript 属于弱类型的语言，定义变量时不区分具体的数据类型。 定义局部变量 let 变量名 = 值; //1.定义局部变量 let name = “张三”; let age = 23; document.write(name + “,” + age +””); 定义全局变量 变量名 = 值; //2.定义全局变量 { let l1 = “aa”; l2 = “bb”; } //document.write(l1); document.write(l2 + “”); 定义常量 const 常量名 = 值; //3.定义常量 const PI = 3.1415926; //PI = 3.15; document.write(PI); 2.4、原始数据类型和typeof方法 2.4.1、原始数据类型 2.4.2、typeof typeof 用于判断变量的数据类型 let age = 18; document.write(typeof(age)); // number 2.5、运算符 算数运算符 赋值运算符 比较运算符 逻辑运算符 三元运算符 三元运算符格式 (比较表达式) ? 表达式1 : 表达式2; 执行流程 如果比较表达式为true，则取表达式1 如果比较表达式为false，则取表达式2 2.6、流程控制和循环语句 if 语句 //if语句 let month = 3; if(month >= 3 && month = 6 && month = 9 && month ”); switch 语句 //switch语句 switch(month){ case 3: case 4: case 5: document.write(“春季”); break; case 6: case 7: case 8: document.write(“夏季”); break; case 9: case 10: case 11: document.write(“秋季”); break; case 12: case 1: case 2: document.write(“冬季”); break; default: document.write(“月份有误”); break; } document.write(“”);**for 循环** for循环 //for循环 for(let i = 1; i ”); } while 循环 //while循环 let n = 6; while(n ”); n++; } 2.7、数组 数组的使用和 java 中的数组基本一致，但是在 JavaScript 中的数组更加灵活，数据类型和长度都没有限制。 定义格式 let 数组名 = [元素1,元素2,…]; let arr = [10,20,30]; 索引范围 从 0 开始，最大到数组长度-1 数组长度 数组名.length for(let i = 0; i ”); } document.write(“==============”); 数组高级运算符… 数组复制 //复制数组 let arr2 = [...arr]; //遍历数组 for(let i = 0; i ”); } document.write(“==============”); 合并数组 //合并数组 let arr3 = [40,50,60]; let arr4 = [...arr2 , ...arr3]; //遍历数组 for(let i = 0; i ”); } document.write(“==============”); 字符串转数组 //将字符串转成数组 let arr5 = [...”heima”]; //遍历数组 for(let i = 0; i ”); } 2.8、函数 函数类似于 java 中的方法，可以将一些代码进行抽取，达到复用的效果 定义格式 function 方法名(参数列表) { 方法体; return 返回值; } 可变参数 function 方法名(…参数名) { 方法体; return 返回值; } 匿名函数 function(参数列表) { 方法体; } 2.9、小结 注释：单行// 多行/**/ 输入输出语句：prompt()、alert()、console.log()、document.write() 变量和常量：let、const 数据类型：boolean、null、undefined、number、string、bigint typeof 关键字：用于判断变量的数据类型 运算符：算数、赋值、逻辑、比较、三元运算符 流程控制和循环语句：if、switch、for、while 数组：数据类型和长度没有限制，let 数组名 = [长度/元素] 函数：类似方法，抽取代码，提高复用性 3、JavaScript DOM 3.1、DOM介绍 DOM(Document Object Model)：文档对象模型。 将 HTML 文档的各个组成部分，封装为对象。借助这些对象，可以对 HTML 文档进行增删改查的动态操作。 3.2、Element元素的获取操作 具体方法 代码实现 元素的获取 div1 div2 div3 div4 //1. getElementById() 根据id属性值获取元素对象 let div1 = document.getElementById(“div1”); //alert(div1); //2. getElementsByTagName() 根据元素名称获取元素对象们，返回数组 let divs = document.getElementsByTagName(“div”); //alert(divs.length); //3. getElementsByClassName() 根据class属性值获取元素对象们，返回数组 let cls = document.getElementsByClassName(“cls”); //alert(cls.length); //4. getElementsByName() 根据name属性值获取元素对象们，返回数组 let username = document.getElementsByName(“username”); //alert(username.length); //5. 子元素对象.parentElement属性 获取当前元素的父元素 let body = div1.parentElement; alert(body); 3.3、Element元素的增删改操作 具体方法 代码实现 元素的增删改 —请选择— 北京 上海 广州 //1. createElement() 创建新的元素 let option = document.createElement(“option”); //为option添加文本内容 option.innerText = “深圳”; //2. appendChild() 将子元素添加到父元素中 let select = document.getElementById(“s”); select.appendChild(option); //3. removeChild() 通过父元素删除子元素 //select.removeChild(option); //4. replaceChild() 用新元素替换老元素 let option2 = document.createElement(“option”); option2.innerText = “杭州”; select.replaceChild(option2,option); 3.4、Attribute属性的操作 具体方法 代码实现 属性的操作 .aColor{ color: blue; } 点我呀 //1. setAttribute() 添加属性 let a = document.getElementsByTagName(“a”)[0]; a.setAttribute(“href”,”https://www.baidu.com”); //2. getAttribute() 获取属性 let value = a.getAttribute(“href”); //alert(value); //3. removeAttribute() 删除属性 //a.removeAttribute(“href”); //4. style属性 添加样式 //a.style.color = “red”; //5. className属性 添加指定样式 a.className = “aColor”; 3.5、Text文本的操作 具体方法 代码实现 文本的操作 //1. innerText 添加文本内容，不解析标签 let div = document.getElementById(“div”); div.innerText = “我是div”; //div.innerText = “我是div”; //2. innerHTML 添加文本内容，解析标签 div.innerHTML = “我是div”; 3.6、DOM小结 DOM(Document Object Model)：文档对象模型 Document：文档对象 Element：元素对象 Attribute：属性对象 Text：文本对象 元素的操作 getElementById() getElementsByTagName() getElementsByName() getElementsByClassName() 子元素对象.parentElement属性 createElement() appendChild() removeChild() replaceChild() 属性的操作 setAtrribute() getAtrribute() removeAtrribute() style属性 文本的操作 innerText innerHTML 4、JavaScript 事件 4.1、事件介绍 事件指的就是当某些组件执行了某些操作后，会触发某些代码的执行。 常用的事件 了解的事件 4.2、事件操作 绑定事件 方式一 通过标签中的事件属性进行绑定。 方式二 通过 DOM 元素属性绑定。 document.getElementById(“btn”).onclick = 执行的功能 4.3、事件小结 事件指的就是当某些组件执行了某些操作后，会触发某些代码的执行。 常用的事件 onload onsubmit onclick ondblclick onblur onfocus onchange 绑定事件方式 方式一：通过标签中的事件属性进行绑定。 方式二：通过 DOM 元素属性绑定。 5、JavaScript综合案例 5.1、案例效果介绍 在“姓名、年龄、性别”三个文本框中填写信息后，添加到“学生信息表”列表（表格）中。 5.2、添加功能的分析 为添加按钮绑定单击事件。 创建 tr 元素。 创建 4 个 td 元素。 将 td 添加到 tr 中。 获取文本框输入的信息。 创建 3 个文本元素。 将文本元素添加到对应的 td 中。 创建 a 元素。 将 a 元素添加到对应的 td 中。 将 tr 添加到 table 中。 5.3、添加功能的实现 动态表格 table{ border: 1px solid; margin: auto; width: 500px; } td,th{ text-align: center; border: 1px solid; } div{ text-align: center; margin: 50px; } 学生信息表 姓名 年龄 性别 操作 张三 23 男 删除 李四 24 男 删除 //一、添加功能 //1.为添加按钮绑定单击事件 document.getElementById(“add”).onclick = function(){ //2.创建行元素 let tr = document.createElement(“tr”); //3.创建4个单元格元素 let nameTd = document.createElement(“td”); let ageTd = document.createElement(“td”); let genderTd = document.createElement(“td”); let deleteTd = document.createElement(“td”); //4.将td添加到tr中 tr.appendChild(nameTd); tr.appendChild(ageTd); tr.appendChild(genderTd); tr.appendChild(deleteTd); //5.获取输入框的文本信息 let name = document.getElementById(“name”).value; let age = document.getElementById(“age”).value; let gender = document.getElementById(“gender”).value; //6.根据获取到的信息创建3个文本元素 let nameText = document.createTextNode(name); let ageText = document.createTextNode(age); let genderText = document.createTextNode(gender); //7.将3个文本元素添加到td中 nameTd.appendChild(nameText); ageTd.appendChild(ageText); genderTd.appendChild(genderText); //8.创建超链接元素和显示的文本以及添加href属性 let a = document.createElement(“a”); let aText = document.createTextNode(“删除”); a.setAttribute(“href”,”JavaScript:void(0);”); a.setAttribute(“onclick”,”drop(this)”); a.appendChild(aText); //9.将超链接元素添加到td中 deleteTd.appendChild(a); //10.获取table元素，将tr添加到table中 let table = document.getElementById(“tb”); table.appendChild(tr); } 5.4、删除功能的分析 删除功能介绍 删除功能分析 为每个删除超链接添加单击事件属性。 定义删除的方法。 获取 table 元素。 获取 tr 元素。 通过 table 删除 tr。 5.5、删除功能的实现 //二、删除的功能 //1.为每个删除超链接标签添加单击事件的属性 //2.定义删除的方法 function drop(obj){ //3.获取table元素 let table = obj.parentElement.parentElement.parentElement; //4.获取tr元素 let tr = obj.parentElement.parentElement; //5.通过table删除tr table.removeChild(tr); } Copyright © MISIN 2022 | 豫ICP备2021006345号-1 all right reserved，powered by Gitbook该文件修订时间： 2022-11-10 13:50:50 "},"2.JavaWeb/7.JavaScript/JavaScript高级.html":{"url":"2.JavaWeb/7.JavaScript/JavaScript高级.html","title":"JavaScript高级","keywords":"","body":"1. 1、JavaScript面向对象1.1. 1.1、面向对象介绍1.2. 1.2、类的定义和使用1.3. 1.3、字面量类的定义和使用1.4. 1.3、继承1.5. 1.4、小结2. 2、JavaScript内置对象2.1. 2.1、Number2.2. 2.2、Math2.3. 2.3、Date2.4. 2.4、String2.5. 2.5、RegExp2.6. 2.6、Array2.7. 2.7、Set2.8. 2.8、Map2.9. 2.9、Json2.10. 2.10、表单校验2.11. 2.11、小结3. 3、JavaScript BOM3.1. 3.1、Windows窗口对象3.2. 3.2、Location地址栏对象3.3. 3.3、案例-动态广告3.4. 3.4、小结4. 4、JavaScript封装1. 1、JavaScript面向对象 1.1. 1.1、面向对象介绍 ​ 在 Java 中我们学习过面向对象，核心思想是万物皆对象。在 JavaScript 中同样也有面向对象。思想类似。 ​ 1.2. 1.2、类的定义和使用 结构说明 代码实现 类的定义和使用 //定义Person类 class Person{ //构造方法 constructor(name,age){ this.name = name; this.age = age; } //show方法 show(){ document.write(this.name + “,” + this.age + “”); } //eat方法 eat(){ document.write(“吃饭...”); } } //使用Person类 let p = new Person(“张三”,23); p.show(); p.eat(); 1.3. 1.3、字面量类的定义和使用 结构说明 代码实现 字面量定义类和使用 //定义person let person = { name : “张三”, age : 23, hobby : [“听课”,”学习”], eat : function() { document.write(“吃饭...”); } }; //使用person document.write(person.name + “,” + person.age + “,” + person.hobby[0] + “,” + person.hobby[1] + “”); person.eat(); 1.4. 1.3、继承 继承：让类与类产生子父类的关系，子类可以使用父类有权限的成员。 继承关键字：extends 顶级父类：Object 继承 //定义Person类 class Person{ //构造方法 constructor(name,age){ this.name = name; this.age = age; } //eat方法 eat(){ document.write(“吃饭...”); } } //定义Worker类继承Person class Worker extends Person{ constructor(name,age,salary){ super(name,age); this.salary = salary; } show(){ document.write(this.name + “,” + this.age + “,” + this.salary + “”); } } //使用Worker let w = new Worker(“张三”,23,10000); w.show(); w.eat(); 1.5. 1.4、小结 面向对象 把相关的数据和方法组织为一个整体来看待，从更高的层次来进行系统建模，更贴近事物的自然运行模式。 类的定义 class 类{} 字面量定义 类的使用 let 对象名 = new 类名(); 对象名.变量名 对象名.方法名() 继承 让类和类产生子父类关系，提高代码的复用性和维护性。 子类 extends 父类 Object 顶级父类 2. 2、JavaScript内置对象 2.1. 2.1、Number 方法介绍 代码实现 Number //1. parseFloat() 将传入的字符串浮点数转为浮点数 document.write(Number.parseFloat(“3.14”) + “”); //2. parseInt() 将传入的字符串整数转为整数 document.write(Number.parseInt(“100”) + “”); document.write(Number.parseInt(“200abc”) + “”); // 从数字开始转换，直到不是数字为止 2.2. 2.2、Math 方法介绍 代码实现 Math //1. ceil(x) 向上取整 document.write(Math.ceil(4.4) + “”); // 5 //2. floor(x) 向下取整 document.write(Math.floor(4.4) + “”); // 4 //3. round(x) 把数四舍五入为最接近的整数 document.write(Math.round(4.1) + “”); // 4 document.write(Math.round(4.6) + “”); // 5 //4. random() 随机数,返回的是0.0-1.0之间范围(含头不含尾) document.write(Math.random() + “”); // 随机数 //5. pow(x,y) 幂运算 x的y次方 document.write(Math.pow(2,3) + “”); // 8 2.3. 2.3、Date 方法说明 构造方法 成员方法 代码实现 Date //构造方法 //1. Date() 根据当前时间创建对象 let d1 = new Date(); document.write(d1 + “”); //2. Date(value) 根据指定毫秒值创建对象 let d2 = new Date(10000); document.write(d2 + “”); //3. Date(year,month,[day,hours,minutes,seconds,milliseconds]) 根据指定字段创建对象(月份是0~11) let d3 = new Date(2222,2,2,20,20,20); document.write(d3 + “”); //成员方法 //1. getFullYear() 获取年份 document.write(d3.getFullYear() + “”); //2. getMonth() 获取月份 document.write(d3.getMonth() + “”); //3. getDate() 获取天数 document.write(d3.getDate() + “”); //4. toLocaleString() 返回本地日期格式的字符串 document.write(d3.toLocaleString()); 2.4. 2.4、String 方法说明 构造方法 成员方法 代码实现 String //1. 构造方法创建字符串对象 let s1 = new String(“hello”); document.write(s1 + “”); //2. 直接赋值 let s2 = “hello”; document.write(s2 + “”); //属性 //1. length 获取字符串的长度 document.write(s2.length + “”); //成员方法 //1. charAt(index) 获取指定索引处的字符 document.write(s2.charAt(1) + “”); //2. indexOf(value) 获取指定字符串出现的索引位置 document.write(s2.indexOf(“l”) + “”); //3. substring(start,end) 根据指定索引范围截取字符串(含头不含尾) document.write(s2.substring(2,4) + “”); //4. split(value) 根据指定规则切割字符串，返回数组 let s3 = “张三,23,男”; let arr = s3.split(“,”); for(let i = 0; i ”); } //5. replace(old,new) 使用新字符串替换老字符串 let s4 = “你会不会跳伞啊？让我落地成盒。你妹的。”; let s5 = s4.replace(“你妹的”,”***”); document.write(s5 + “”); 2.5. 2.5、RegExp 正则表达式：是一种对字符串进行匹配的规则。 方法说明 构造方法&成员方法 规则 代码实现 RegExp //1.验证手机号 //规则：第一位1，第二位358，第三到十一位必须是数字。总长度11 let reg1 = /^[1][358][0-9]{9}$/; document.write(reg1.test(“18688888888”) + “”); //2.验证用户名 //规则：字母、数字、下划线组成。总长度4~16 let reg2 = /^[a-zA-Z_0-9]{4,16}$/; document.write(reg2.test(“zhang_san123”)); 2.6. 2.6、Array 成员方法 代码实现 Array let arr = [1,2,3,4,5]; //1. push(元素) 添加元素到数组的末尾 arr.push(6); document.write(arr + “”); //2. pop() 删除数组末尾的元素 arr.pop(); document.write(arr + “”); //3. shift() 删除数组最前面的元素 arr.shift(); document.write(arr + “”); //4. includes(元素) 判断数组中是否包含指定的元素 document.write(arr.includes(2) + “”); //5. reverse() 反转数组元素 arr.reverse(); document.write(arr + “”); //6. sort() 对数组元素排序 arr.sort(); document.write(arr + “”); 2.7. 2.7、Set JavaScript 中的 Set 集合，元素唯一，存取顺序一致。 方法说明 代码实现 Set // Set() 创建集合对象 let s = new Set(); // add(元素) 添加元素 s.add(“a”); s.add(“b”); s.add(“c”); s.add(“c”); // size属性 获取集合的长度 document.write(s.size + “”); // 3 // keys() 获取迭代器对象 let st = s.keys(); for(let i = 0; i ”); } // delete(元素) 删除指定元素 document.write(s.delete(“c”) + “”); let st2 = s.keys(); for(let i = 0; i ”); } 2.8. 2.8、Map JavaScript 中的 Map 集合，key 唯一，存取顺序一致。 方法说明 代码实现 Map // Map() 创建Map集合对象 let map = new Map(); // set(key,value) 添加元素 map.set(“张三”,23); map.set(“李四”,24); map.set(“李四”,25); // size属性 获取集合的长度 document.write(map.size + “”); // get(key) 根据key获取value document.write(map.get(“李四”) + “”); // entries() 获取迭代器对象 let et = map.entries(); for(let i = 0; i ”); } // delete(key) 根据key删除键值对 document.write(map.delete(“李四”) + “”); let et2 = map.entries(); for(let i = 0; i ”); } 2.9. 2.9、Json JSON(JavaScript Object Notation)：是一种轻量级的数据交换格式。 它是基于 ECMAScript 规范的一个子集，采用完全独立于编程语言的文本格式来存储和表示数据。 简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。易于人阅读和编写，同时也易于计算机解析和 生成，并有效的提升网络传输效率。 方法说明 代码实现 JSON //定义天气对象 let weather = { city : “北京”, date : “2088-08-08”, wendu : “10° ~ 23°”, shidu : “22%” }; //1.将天气对象转换为JSON格式的字符串 let str = JSON.stringify(weather); document.write(str + “”); //2.将JSON格式字符串解析成JS对象 let weather2 = JSON.parse(str); document.write(“城市：” + weather2.city + “”); document.write(“日期：” + weather2.date + “”); document.write(“温度：” + weather2.wendu + “”); document.write(“湿度：” + weather2.shidu + “”); 2.10. 2.10、表单校验 案例说明 代码实现 表单校验 黑马程序员 //1.为表单绑定提交事件 document.getElementById(“regist”).onsubmit = function() { //2.获取填写的用户名和密码 let username = document.getElementById(“username”).value; let password = document.getElementById(“password”).value; //3.判断用户名是否符合规则 4~16位纯字母 let reg1 = /^[a-zA-Z]{4,16}$/; if(!reg1.test(username)) { alert(“用户名不符合规则，请输入4到16位的纯字母！”); return false; } //4.判断密码是否符合规则 6位纯数字 let reg2 = /^[\\d]{6}$/; if(!reg2.test(password)) { alert(“密码不符合规则，请输入6位纯数字的密码！”); return false; } //5.如果所有条件都不满足，则提交表单 return true; } 2.11. 2.11、小结 内置对象是 JavaScript 提供的带有属性和方法的特殊数据类型。 数字日期 Number Math Date 字符串 String RegExp 数组集合 Array Set Map 结构化数据 JSON 3. 3、JavaScript BOM BOM(Browser Object Model)：浏览器对象模型。 将浏览器的各个组成部分封装成不同的对象，方便我们进行操作。 3.1. 3.1、Windows窗口对象 定时器 唯一标识 setTimeout(功能，毫秒值)：设置一次性定时器。 clearTimeout(标识)：取消一次性定时器。 唯一标识 setInterval(功能，毫秒值)：设置循环定时器。 clearInterval(标识)：取消循环定时器。 加载事件 window.onload：在页面加载完毕后触发此事件的功能。 代码实现 window窗口对象 //一、定时器 function fun(){ alert(“该起床了！”); } //设置一次性定时器 //let d1 = setTimeout(“fun()”,3000); //取消一次性定时器 //clearTimeout(d1); //设置循环定时器 //let d2 = setInterval(“fun()”,3000); //取消循环定时器 //clearInterval(d2); //加载事件 window.onload = function(){ let div = document.getElementById(“div”); alert(div); } dddd //一、定时器 function fun(){ alert(“该起床了！”); } //设置一次性定时器 //let d1 = setTimeout(“fun()”,3000); //取消一次性定时器 //clearTimeout(d1); //设置循环定时器 //let d2 = setInterval(“fun()”,3000); //取消循环定时器 //clearInterval(d2); //加载事件 let div = document.getElementById(“div”); alert(div); —> 3.2. 3.2、Location地址栏对象 href 属性 就是浏览器的地址栏。我们可以通过为该属性设置新的 URL，使浏览器读取并显示新的 URL 的内容。 代码实现 location地址栏对象 p{ text-align: center; } span{ color: red; } 注册成功！5秒之后自动跳转到首页... //1.定义方法。改变秒数，跳转页面 let num = 5; function showTime() { num--; if(num 3.3. 3.3、案例-动态广告 案例分析和实现 在 css 样式中，display 属性可以控制元素是否显示 style=\"display: none;\" 设置定时器，3 秒后显示广告图片 //1.设置定时器，3秒后显示广告图片 setTimeout(function(){ let 2img = document.getElementById(\"ad_big\"); 2img.style.display = \"block\"; },3000); 设置定时器，3 秒后隐藏广告图片 //2.设置定时器，3秒后隐藏广告图片 setTimeout(function(){ let 2img = document.getElementById(\"ad_big\"); 2img.style.display = \"none\"; },6000); 3.4. 3.4、小结 BOM(Browser Object Model)：浏览器对象模型。 将浏览器的各个组成部分封装成不同的对象，方便我们进行操作。 Window：窗口对象 Location：地址栏对象 Navigator：浏览器对象 History：当前窗口历史记录对象 Screen：显示器屏幕对象 Window 窗口对象 setTimeout()、clearTimeout()：一次性定时器 setInterval()、clearInterval()：循环定时器 onload 事件：页面加载完毕触发执行功能 Location 地址栏对象 href 属性：跳转到指定的 URL 地址 4. 4、JavaScript封装 封装思想 封装：将复杂的操作进行封装隐藏，对外提供更加简单的操作。 获取元素的方法 document.getElementById(id值)：根据 id 值获取元素 document.getElementsByName(name值)：根据 name 属性值获取元素们 document.getElementsByTagName(标签名)：根据标签名获取元素们 代码实现 封装 div1 div2 let div1 = getById(\"div1\"); alert(div1); // let div1 = document.getElementById(\"div1\"); // alert(div1); // let divs = document.getElementsByName(\"div2\"); // alert(divs.length); // let divs2 = document.getElementsByTagName(\"div\"); // alert(divs2.length); js封装 function getById(id){ return document.getElementById(id); } function getByName(name) { return document.getElementsByName(name); } function getByTag(tag) { return document.getElementsByTagName(tag); } 我们之前的操作都是基于原生 JavaScript 的，比较繁琐。 JQuery 是一个前端框架技术，针对 JavaScript 进行了一系列的封装，使得操作变得非常简单！ 期待吧…… Copyright © MISIN 2022 | 豫ICP备2021006345号-1 all right reserved，powered by Gitbook该文件修订时间： 2022-11-10 13:53:16 "},"2.JavaWeb/7.JavaScript/尚硅谷_陈鑫_第二章_JavaScript&正则表达式.html":{"url":"2.JavaWeb/7.JavaScript/尚硅谷_陈鑫_第二章_JavaScript&正则表达式.html","title":"尚硅谷陈鑫第二章_JavaScript&正则表达式","keywords":"","body":"1. 第二章 JavaScript1.1. 学习目标1.2. 1. JavaScript1.2.1. 1.1 JavaScript的起源1.2.2. 1.2 JavaScript的特性1.2.3. 1.3 HelloWorld1.2.4. 1.4 JavaScript的基本语法1.2.5. 1.5 JavaScript的DOM(最重点)1.3. 2. 正则表达式1.3.1. 2.1 正则表达式的概念1.3.2. 2.2 正则表达式的用途1.3.3. 2.3 正则表达式的语法1.3.4. 2.4 常用正则表达式1. 第二章 JavaScript 1.1. 学习目标 了解JavaScript的起源与特性 掌握JavaScript的基本语法 掌握JavaScript的DOM 掌握JavaScript的事件绑定 掌握正则表达式的作用 掌握正则表达式的语法 了解常见的正则表达式 1.2. 1. JavaScript 1.2.1. 1.1 JavaScript的起源 在1995年时，由Netscape公司的Brendan Eich，在网景导航者浏览器上首次设计实现而成。Netscape在最初将其脚本语言命名为LiveScript，因为Netscape与Sun合作，网景公司管理层希望蹭Java的热度，因此取名为JavaScript。 JavaScript总共分成三部分: ECMAScript(基本语法)、BOM(浏览器对象模型)、DOM(文档对象模型) 1.2.2. 1.2 JavaScript的特性 1.2.1 脚本语言 JavaScript是一种解释型的脚本语言。不同于C、C++、Java等语言先编译后执行, JavaScript不会产生编译出来的字节码文件，而是在程序的运行过程中对源文件逐行进行解释。 1.2.2 基于对象 JavaScript是一种基于对象的脚本语言，它不仅可以创建对象，也能使用现有的对象。但是面向对象的三大特性：『封装』、『继承』、『多态』中，JavaScript能够实现封装，可以模拟继承，不支持多态，所以它不是一门面向对象的编程语言。 1.2.3 弱类型 JavaScript中也有明确的数据类型，但是声明一个变量后它可以接收任何类型的数据，并且会在程序执行过程中根据上下文自动转换类型。 1.2.4 事件驱动 JavaScript是一种采用事件驱动的脚本语言，它不需要经过Web服务器就可以对用户的输入做出响应。 1.2.5 跨平台性 JavaScript脚本语言不依赖于操作系统，仅需要浏览器的支持。因此一个JavaScript脚本在编写后可以带到任意机器上使用，前提是机器上的浏览器支持JavaScript脚本语言。目前JavaScript已被大多数的浏览器所支持。 1.2.3. 1.3 HelloWorld 1.3.1 功能效果图 1.3.2 代码实现 JS的入门程序 SayHello //1. 通过js代码获取到按钮对象 //document代表当前HTML文档 var btn = document.getElementById(\"helloBtn\"); //2. 给获取到的btn对象绑定点击事件 btn.onclick = function () { //弹出警告框 alert(\"hello world\"); } 1.2.4. 1.4 JavaScript的基本语法 1.4.1 JavaScript的引入方式 ① 内部脚本方式 JavaScript代码要写在script标签内 script标签可以写在文档内的任意位置 为了能够方便查询或操作HTML标签（元素）script标签可以写在body标签后面 在我们的入门程序中使用的就是内部脚本方式引入的JavaScript ② 外部脚本方式 在script标签内通过src属性指定外部xxx.js文件的路径即可。但是要注意以下两点： 引用外部JavaScript文件的script标签里面不能写JavaScript代码 先引入，再使用 script标签不能写成单标签 引入方式如下： JS的引入方式 //调用外部js文件中的方法 showMessage(); alert(\"hello world\"); 1.4.2 声明和使用变量 ① JavaScript数据类型 基本数据类型 数值型number：JavaScript不区分整数、小数 字符串string：JavaScript不区分字符、字符串；单引号、双引号意思一样。 布尔型boolean：true、false 在JavaScript中，其他类型和布尔类型的自动转换。 true：非零的数值，非空字符串，非空对象 false：零，空字符串，null，undefined 例如：\"false\"放在if判断中 // \"false\"是一个非空字符串，直接放在if判断中会被当作『真』处理 if(\"false\"){ alert(\"true\"); }else{ alert(\"false\"); } 引用类型(后面详细讲解) 所有new出来的对象 用[]声明的数组 用{}声明的对象 ② 变量 关键字：var,其实ECMAScript6之后建议使用let 数据类型：JavaScript变量是弱类型的，可以接收任意类型的数据 标识符：严格区分大小写 变量使用规则 如果使用了一个没有声明的变量，那么会在运行时报错 Uncaught ReferenceError: b is not defined 如果声明一个变量没有初始化，那么这个变量的值就是undefined 1.4.3 函数(重点) ① 内置函数 内置函数就是JavaScript中内置好的函数，我们可以直接使用 弹出警告框 alert(\"警告框内容\"); 弹出确认框 var result = confirm(\"确定要删除吗？\"); if(result) { // 执行删除 } 用户点击『确定』返回true，点击『取消』返回false var result = confirm(\"老板，你真的不加个钟吗？\"); if(result) { console.log(\"老板点了确定，表示要加钟\"); }else{ console.log(\"老板点了确定，表示不加钟\"); } 在控制台打印日志 console.log(\"日志内容\"); ② 声明函数 声明函数就是使用者自己定义一个函数，它有两种写法: 写法1： function sum(a, b) { return a+b; } 写法2： var total = function() { return a+b; }; 写法2可以这样解读：声明一个函数，相当于创建了一个『函数对象』，将这个对象的『引用』赋值给变量total。如果不给这个对象赋值，我们可以将其作为匿名函数使用(在后续学习内容中会用到) ③ 调用函数 JavaScript中函数本身就是一种对象，函数名就是这个『对象』的『引用』。而调用函数的格式是：函数引用()。 //函数的声明 function sum(a, b) { return a+b; } //调用函数并接收返回值 var result = sum(2, 3); //控制台打印返回值内容 console.log(\"result=\"+result); 或： //函数的声明 var total = function() { return a+b; } //调用函数并接收返回值 var totalResult = total(3,6); //控制台打印返回值内容 console.log(\"totalResult=\"+totalResult); 1.4.4 对象(重点) JavaScript中没有『类』的概念，对于系统内置的对象可以直接创建使用。 ① 使用new关键字创建对象 // 创建对象 var obj01 = new Object(); // 给对象设置属性和属性值 obj01.stuName = \"tom\"; obj01.stuAge = 20; obj01.stuSubject = \"java\"; // 在控制台输出对象 console.log(obj01); ② 使用{}创建对象(常用) // 创建对象 var obj02 = { \"soldierName\":\"john\", \"soldierAge\":35, \"soldierWeapon\":\"gun\" }; // 在控制台输出对象 console.log(obj02); ③ 给对象设置函数属性 // 创建对象 var obj01 = new Object(); // 给对象设置属性和属性值 obj01.stuName = \"tom\"; obj01.stuAge = 20; obj01.stuSubject = \"java\"; obj01.study = function() { console.log(this.stuName + \" is studying\"); }; // 在控制台输出对象 console.log(obj01); // 调用函数 obj01.study(); 或者 // 创建对象 var obj02 = { \"soldierName\":\"john\", \"soldierAge\":35, \"soldierWeapon\":\"gun\", \"soldierShoot\":function(){ console.log(this.soldierName + \" is using \" + this.soldierWeapon); } }; // 在控制台输出对象 console.log(obj02); // 调用函数 obj02.soldierShoot(); ④ this关键字 this关键字只有两种情况： 在函数外面：this关键字指向window对象（代表当前浏览器窗口） 在函数里面：this关键字指向调用函数的对象 // 直接打印this console.log(this); // 函数中的this // 1.声明函数 function getName() { console.log(this.name); } // 2.创建对象 var obj01 = { \"name\":\"tom\", \"getName\":getName }; var obj02 = { \"name\":\"jerry\", \"getName\":getName }; // 3.调用函数 obj01.getName(); obj02.getName(); 1.4.5 数组(重点) ① 使用new关键字创建数组 // 1.创建数组对象 var arr01 = new Array(); // 2.压入数据 arr01.push(\"apple\"); arr01.push(\"orange\"); arr01.push(\"banana\"); arr01.push(\"grape\"); // 3.遍历数组 for (var i = 0; i ② 使用[]创建数组(常用) // 8.使用[]创建数组 var arr03 = [\"cat\",\"dog\",\"tiger\"]; console.log(arr03); //后续操作和上述一致 1.4.6 JSON(最重点) ① JSON格式的用途 在开发中凡是涉及到『跨平台数据传输』，JSON格式一定是首选。 ② JSON格式的说明 JSON数据两端要么是{}，要么是[] {}定义JSON对象 []定义JSON数组 JSON对象的格式是： {key:value,key:value,...,key:value} JOSN数组的格式是： [value,value,...,value] key的类型固定是字符串 value的类型可以是： 基本数据类型 引用类型：JSON对象或JSON数组 正因为JSON格式中value部分还可以继续使用JSON对象或JSON数组，所以JSON格式是可以『多层嵌套』的，所以JSON格式不论多么复杂的数据类型都可以表达。 //json的格式: {key:value,key:value} var person1 = { \"name\":\"张三疯\", \"age\":189, \"address\":\"武当山\" } //其实JSON对于前端而言，就是一个对象 console.log(person1.name) var person2 = { \"name\":\"张三疯\", \"age\":189, \"address\":\"武当山\", \"wife\":{ \"name\":\"小花\", \"age\":18, \"address\":\"武当山下的小村庄\" } } //console.log(person2.wife.name) var person3 = { \"name\":\"张三疯\", \"age\":189, \"address\":\"武当山\", \"wife\":{ \"name\":\"小花\", \"age\":18, \"address\":\"武当山下的小村庄\" }, \"sons\":[ { \"name\":\"奥巴马\", \"age\":1, \"address\":\"武当山\" }, { \"name\":\"奥拉夫\", \"age\":2, \"address\":\"少林寺\" } ] } //json数组的格式: [{key:value,key:value},{key:value,key:value}] //var personList = [person1,person2] ③ JSON对象和JSON字符串互转 JSON对象转JSON字符串 var jsonObj = {\"stuName\":\"tom\",\"stuAge\":20}; var jsonStr = JSON.stringify(jsonObj); console.log(typeof jsonObj); // object console.log(typeof jsonStr); // string JSON字符串转JSON对象 jsonObj = JSON.parse(jsonStr); console.log(jsonObj); // {stuName: \"tom\", stuAge: 20} 1.2.5. 1.5 JavaScript的DOM(最重点) 1.5.1 DOM的概念 DOM是Document Object Model的缩写，意思是『文档对象模型』——将HTML文档抽象成模型，再封装成对象方便用程序操作。 这是一种非常常用的编程思想：将现实世界的事物抽象成模型，这样就非常容易使用对象来量化的描述现实事物，从而把生活中的问题转化成一个程序问题，最终实现用应用软件协助解决现实问题。而在这其中『模型』就是那个连通现实世界和代码世界的桥梁。 1.5.2 DOM树的概念 浏览器把HTML文档从服务器上下载下来之后就开始按照『从上到下』的顺序『读取HTML标签』。每一个标签都会被封装成一个『对象』。 而第一个读取到的肯定是根标签html，然后是它的子标签head，再然后是head标签里的子标签……所以从html标签开始，整个文档中的所有标签都会根据它们之间的『父子关系』被放到一个『树形结构』的对象中。 这个包含了所有标签对象的整个树形结构对象就是JavaScript中的一个可以直接使用的内置对象：document。 例如，下面的标签结构： 会被解析为： 1.5.3 各个组成部分的类型 整个文档中的一切都可以看做Node。各个具体组成部分的具体类型可以看做Node类型的子类。 其实严格来说，JavaScript并不支持真正意义上的『继承』，这里我们借用Java中的『继承』概念，从逻辑上来帮助我们理解各个类型之间的关系。 组成部分 节点类型 具体类型 整个文档 文档节点 Document HTML标签 元素节点 Element HTML标签内的文本 文本节点 Text HTML标签内的属性 属性节点 Attr 注释 注释节点 Comment 1.5.4 父子关系 1.5.5 先辈后代关系 1.5.6 DOM操作 由于实际开发时基本上都是使用JavaScript的各种框架来操作，而框架中的操作方式和我们现在看到的原生操作完全不同，所以下面罗列的API仅供参考，不做要求。 ① 在整个文档范围内查询元素节点 功能 API 返回值 根据id值查询 document.getElementById(“id值”) 一个具体的元素节 根据标签名查询 document.getElementsByTagName(“标签名”) 元素节点数组 根据name属性值查询 document.getElementsByName(“name值”) 元素节点数组 根据类名查询 document.getElementsByClassName(\"类名\") 元素节点数组 ② 在具体元素节点范围内查找子节点 功能 API 返回值 查找子标签 element.children 返回子标签数组 查找第一个子标签 element.firstElementChild 标签对象 查找最后一个子标签 element.lastElementChild 节点对象 ③ 查找指定元素节点的父节点 功能 API 返回值 查找指定元素节点的父标签 element.parentElement 标签对象 ④ 查找指定元素节点的兄弟节点 功能 API 返回值 查找前一个兄弟标签 node.previousElementSibling 标签对象 查找后一个兄弟标签 node.nextElementSibling 标签对象 ⑤ DOM操作之查找元素案例 DOM查找节点 //根据id查询标签 var elementById = document.getElementById(\"username\"); //console.log(elementById) //根据类名查询标签 var elementsByClassName = document.getElementsByClassName(\"c1\"); //console.log(elementsByClassName) //根据标签名查询标签 var elementsByTagName = document.getElementsByTagName(\"input\"); //console.log(elementsByTagName) //查找子节点: 查找body的所有子标签,要注意文本也属于子节点 /*var childNodes = document.getElementsByTagName(\"body\")[0].childNodes; console.log(childNodes)*/ //查找子标签: children var children = document.getElementsByTagName(\"body\")[0].children; //console.log(children) //查找id为username的标签的父节点 var parentNode = document.getElementById(\"username\").parentNode; //console.log(parentNode) //查找id为username的标签的前一个兄弟标签 var previousElementSibling = document.getElementById(\"username\").previousElementSibling; //console.log(previousElementSibling) //查找id为username的标签的后一个兄弟标签 var nextElementSibling = document.getElementById(\"username\").nextElementSibling; //console.log(nextElementSibling) ⑥ 属性操作 需求 操作方式 读取属性值 元素对象.属性名 修改属性值 元素对象.属性名=新的属性值 ⑦ 标签体的操作 需求 操作方式 获取或者设置标签体的文本内容 element.innerText 获取或者设置标签体的内容 element.innerHTML ⑧ DOM操作之属性标签体操作案例 操作标签的属性和文本 你好世界 //目标: 获取id为username的输入框的value //1. 找到要操作的标签 var ipt = document.getElementById(\"username\"); //2. 设置标签的value属性值 ipt.value = \"张三\" //3. 获取标签的value属性的值 var value = ipt.value; console.log(value) //获取id为d1的div中的文本内容 //获取标签的文本: element.innerText,获取文本的时候会将左右两端的空格去掉 var innerText = document.getElementById(\"d1\").innerText; console.log(innerText) //获取标签体的内容: element.innerHTML,获取标签体的内容 var innerHTML = document.getElementById(\"d1\").innerHTML; console.log(innerHTML) //设置标签体的内容:建议使用innerHTML，如果是使用innerText的话它会将标签当做普通文本处理 document.getElementById(\"d1\").innerHTML = \"hello world\" ⑨ DOM增删改操作 API 功能 document.createElement(“标签名”) 创建元素节点并返回，但不会自动添加到文档中 document.createTextNode(“文本值”) 创建文本节点并返回，但不会自动添加到文档中 element.appendChild(ele) 将ele添加到element所有子节点后面 parentEle.insertBefore(newEle,targetEle) 将newEle插入到targetEle前面 parentEle.replaceChild(newEle, oldEle) 用新节点替换原有的旧子节点 element.remove() 删除某个标签 ⑩DOM操作之增删改案例 创建和删除标签 北京 上海 深圳 广州 //目标1: 在城市列表的最后添加一个子标签 长沙 //1. 创建一个li标签 var liElement = document.createElement(\"li\"); //2. 给创建的li标签设置id属性和文本 长沙 liElement.id = \"cs\" liElement.innerText = \"长沙\" //3. 将创建的li标签添加到城市列表中（ul） var cityUl = document.getElementById(\"city\"); //父.appendChild(子)将子标签添加到父标签的最后面 //cityUl.appendChild(liElement) //目标2:在城市列表的深圳之前添加一个子标签 长沙 //获取到深圳这个标签 var szElement = document.getElementById(\"sz\"); //父.insertBefore(新标签,参照标签) //cityUl.insertBefore(liElement,szElement) //目标3: 在城市列表中添加一个子标签替换深圳 长沙 //父.replaceChild(新标签,被替换的标签) //cityUl.replaceChild(liElement,szElement) //目标4: 在城市列表中删除深圳 //szElement.remove() //目标5: 清除城市列表中的所有城市,保留城市列表标签ul cityUl.innerHTML = \"\" 1.5.7 JavaScript的事件驱动(很重要) ① 事件的概念 HTML 事件是发生在 HTML 元素上的“事情”， 是浏览器或用户做的某些事情 事件通常与函数配合使用，这样就可以通过发生的事件来驱动函数执行。 ② 常见事件 属性 此事件发生在何时... onclick 当用户点击某个对象时调用的事件句柄。 ondblclick 当用户双击某个对象时调用的事件句柄。 onchange 域的内容被改变。 onblur 元素失去焦点。 onfocus 元素获得焦点。 onload 一张页面或一幅图像完成加载。 onsubmit 确认按钮被点击；表单被提交。 onkeydown 某个键盘按键被按下。 onkeyup 某个键盘按键被松开。 onmousedown 鼠标按钮被按下。 onmouseup 鼠标按键被松开。 onmouseout 鼠标从某元素移开。 omouseover 鼠标移到某元素之上。 onmousemove 鼠标被移动。 ③ 事件绑定的方式 ​ a. 普通函数方式(设置标签的属性) ​ b. 匿名函数方式 标签对象.事件属性 = function(){ //执行一段代码 } ④ 事件的使用介绍 点击事件 需求: 没点击一次按钮 弹出hello... //当点击的时候要调用的函数 function fn1() { alert(\"我被点击了...\") } //给另外一个按钮，绑定点击事件: //1.先根据id获取标签 var btn = document.getElementById(\"btn\"); //2. 设置btn的onclick属性(绑定事件) //绑定命名函数 //btn.onclick = fn1 //绑定匿名函数 btn.onclick = function () { console.log(\"点击了另外一个按钮\") } 获得焦点(onfocus)和失去焦点(onblur) 需求:给输入框设置获得和失去焦点 var ipt = document.getElementById(\"ipt\"); //绑定获取焦点事件 ipt.onfocus = function () { console.log(\"获取焦点了...\") } //绑定失去焦点事件 ipt.onblur = function () { console.log(\"失去焦点了...\") } 内容改变(onchange) 需求: 给select设置内容改变事件 北京 上海 深圳 function changeCity(obj) { console.log(\"城市改变了\"+obj.value); } 键盘相关的, 键盘按下(onkeydown) 键盘抬起(onkeyup) //给输入框绑定键盘按键按下和抬起事件 ipt.onkeydown = function () { //当按键按下的时候，数据并没有到达输入框 //输出输入框里面的内容 //console.log(ipt.value) } ipt.onkeyup = function () { //输出输入框的内容:当键盘按键抬起的时候，数据已经到达了输入框 console.log(ipt.value) } 鼠标相关的, 鼠标在xx之上(onmouseover ), 鼠标按下(onmousedown),鼠标离开(onmouseout) //给输入框绑定鼠标移入事件 ipt.onmouseover = function () { console.log(\"鼠标移入了...\") } //给输入框绑定鼠标移出事件 ipt.onmouseout = function () { console.log(\"鼠标移出了...\") } 1.3. 2. 正则表达式 1.3.1. 2.1 正则表达式的概念 正则表达式是对字符串操作的一种逻辑公式，就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对字符串的一种过滤逻辑。用我们自己的话来说: 正则表达式用来校验字符串是否满足一定的规则的公式 1.3.2. 2.2 正则表达式的用途 模式验证: 检测某个字符串是否符合规则，例如检测手机号、身份证号等等是否符合规范 匹配读取:读取字符串中符合规则的内容 匹配替换:替换字符串中符合规则的内容 1.3.3. 2.3 正则表达式的语法 对象形式：var reg = new RegExp(\"正则表达式\")当正则表达式中有\"/\"那么就使用这种 // 类似创建数组可以new Array()、创建对象可以使用new Object() var reg = new RegExp(\"a\"); 直接量形式：var reg = /正则表达式/一般使用这种声明方式 // 类似创建数组时可以使用[]、创建对象可以使用{} var reg = /a/; 2.3.1 正则表达式的组成 正则表达式本身也是一个字符串，它由两种字符组成： 普通字符，例如大、小写英文字母；数字等。 元字符：被系统赋予特殊含义的字符。例如：^表示以某个字符串开始，$表示以某个字符串结束 2.3.2 字符集合 语法格式 示例 说明 [字符列表] 正则表达式：[abc] 含义：目标字符串包含abc中的任何一个字符 目标字符串：plain 是否匹配：是 原因：plain中的“a”在列表“abc”中 目标字符串中任何一个字符出现在字符列表中就算匹配。 字符列表 abc 含义：目标字符串包含abc以外的任何一个字符 目标字符串：plain 是否匹配：是 原因：plain中包含“p”、“l”、“i”、“n” 匹配字符列表中未包含的任意字符。 [字符范围] 正则表达式：[a-z] 含义：所有小写英文字符组成的字符列表 正则表达式：[A-Z] 含义：所有大写英文字符组成的字符列表 匹配指定范围内的任意字符。 2.3.3 元字符 在正则表达式中被赋予特殊含义的字符，不能被直接当做普通字符使用。如果要匹配元字符本身，需要对元字符进行转义，转义的方式是在元字符前面加上“\\”，例如：\\^ 代码 说明 . 匹配除换行字符以外的任意字符。 \\w 匹配字母或数字或下划线等价于[a-zA-Z0-9_] \\W 匹配任何非单词字符。等价于A-Za-z0-9_ \\s 匹配任意的空白符，包括空格、制表符、换页符等等。等价于[\\f\\n\\r\\t\\v]。 \\S 匹配任何非空白字符。等价于\\f\\n\\r\\t\\v。 \\d 匹配数字。等价于[0-9]。 \\D 匹配一个非数字字符。等价于0-9 \\b 匹配单词的开始或结束 ^ 匹配字符串的开始，但在[]中使用表示取反 $ 匹配字符串的结束 2.3.4 出现次数 代码 说明 * 出现零次或多次 + 出现一次或多次 ? 出现零次或一次 {n} 出现n次 {n,} 出现n次或多次 {n,m} 出现n到m次 2.3.5 正则表达式使用体验 ① 模式验证 注意：这里是使用正则表达式对象来调用方法。 // 创建一个最简单的正则表达式对象 var reg = /o/; // 创建一个字符串对象作为目标字符串 var str = 'Hello World!'; // 调用正则表达式对象的test()方法验证目标字符串是否满足我们指定的这个模式，返回结果true console.log(\"/o/.test('Hello World!')=\"+reg.test(str)); ② 匹配读取 注意：这里是使用字符串对象来调用方法。 // 在目标字符串中查找匹配的字符，返回匹配结果组成的数组 var resultArr = str.match(reg); // 数组长度为1 console.log(\"resultArr.length=\"+resultArr.length); // 数组内容是o console.log(\"resultArr[0]=\"+resultArr[0]); ③ 替换 注意：这里是使用字符串对象来调用方法。 var newStr = str.replace(reg,'@'); // 只有第一个o被替换了，说明我们这个正则表达式只能匹配第一个满足的字符串 console.log(\"str.replace(reg)=\"+newStr);//Hell@ World! // 原字符串并没有变化，只是返回了一个新字符串 console.log(\"str=\"+str);//str=Hello World! ④ 全文查找 如果不使用g对正则表达式对象进行修饰，则使用正则表达式进行查找时，仅返回第一个匹配；使用g后，返回所有匹配。 // 目标字符串 var targetStr = 'Hello World!'; // 没有使用全局匹配的正则表达式 var reg = /[A-Z]/; // 获取全部匹配 var resultArr = targetStr.match(reg); // 数组长度为1 console.log(\"resultArr.length=\"+resultArr.length); // 遍历数组，发现只能得到'H' for(var i = 0; i 对比 // 目标字符串 var targetStr = 'Hello World!'; // 使用了全局匹配的正则表达式 var reg = /[A-Z]/g; // 获取全部匹配 var resultArr = targetStr.match(reg); // 数组长度为2 console.log(\"resultArr.length=\"+resultArr.length); // 遍历数组，发现可以获取到“H”和“W” for(var i = 0; i ⑤ 忽略大小写 //目标字符串 var targetStr = 'Hello WORLD!'; //没有使用忽略大小写的正则表达式 var reg = /o/g; //获取全部匹配 var resultArr = targetStr.match(reg); //数组长度为1 console.log(\"resultArr.length=\"+resultArr.length); //遍历数组，仅得到'o' for(var i = 0; i 对比 //目标字符串 var targetStr = 'Hello WORLD!'; //使用了忽略大小写的正则表达式 var reg = /o/gi; //获取全部匹配 var resultArr = targetStr.match(reg); //数组长度为2 console.log(\"resultArr.length=\"+resultArr.length); //遍历数组，得到'o'和'O' for(var i = 0; i ⑥ 元字符使用 var str01 = 'I love Java'; var str02 = 'Java love me'; // 匹配以Java开头 var reg = /^Java/g; console.log('reg.test(str01)='+reg.test(str01)); // flase console.log(\"\"); console.log('reg.test(str02)='+reg.test(str02)); // true var str01 = 'I love Java'; var str02 = 'Java love me'; // 匹配以Java结尾 var reg = /Java$/g; console.log('reg.test(str01)='+reg.test(str01)); // true console.log(\"\"); console.log('reg.test(str02)='+reg.test(str02)); // flase ⑦ 字符集合的使用 //n位数字的正则 var targetStr=\"123456789\"; var reg=/^[0-9]{0,}$/; //或者 ： var reg=/^\\d*$/; var b = reg.test(targetStr);//true //数字+字母+下划线，6-16位 var targetStr=\"HelloWorld\"; var reg=/^[a-z0-9A-Z_]{6,16}$/; var b = reg.test(targetStr);//true 1.3.4. 2.4 常用正则表达式 需求 正则表达式 用户名 /^[a-zA-Z_][a-zA-Z_-0-9]{5,9}$/ 密码 /^[a-zA-Z0-9_-\\@#\\&*]{6,12}$/ 前后空格 /^\\s+\\ \\s+$/g 电子邮箱 /^[a-zA-Z0-9_.-]+@([a-zA-Z0-9-]+[.]{1})+[a-zA-Z]+$/ Copyright © MISIN 2022 | 豫ICP备2021006345号-1 all right reserved，powered by Gitbook该文件修订时间： 2022-11-11 15:30:43 "},"2.JavaWeb/8.Jquery/JQuery.html":{"url":"2.JavaWeb/8.Jquery/JQuery.html","title":"J Query","keywords":"","body":"1.1. 1.1、JQuery介绍1.2. 1.2、JQuery快速入门1.3. 1.3、小结2. 2、JQuery基本语法2.1. 2.1、JS对象和JQuery对象转换2.2. 2.2、事件的基本使用2.3. 2.3、时间的绑定和解绑2.4. 2.4、时间的切换2.5. 2.5、遍历操作2.6. 2.6、小结3. 3、JQuery选择器3.1. 3.1、基本选择器3.2. 3.2、层级选择器3.3. 3.3、属性选择器1、JQuery快速入门 1.1. 1.1、JQuery介绍 jQuery 是一个 JavaScript 库。 所谓的库，就是一个 JS 文件，里面封装了很多预定义的函数，比如获取元素，执行隐藏、移动等，目的就 是在使用时直接调用，不需要再重复定义，这样就可以极大地简化了 JavaScript 编程。 jQuery 官网：https://www.jquery.com 1.2. 1.2、JQuery快速入门 开发思路 编写 HTML 文档。 引入 jQuery 文件。 使用 jQuery 获取元素。 使用浏览器测试。 代码实现 快速入门 我是div // JS方式，通过id属性值来获取div元素 let jsDiv = document.getElementById(“div”); //alert(jsDiv); //alert(jsDiv.innerHTML); // jQuery方式，通过id属性值来获取div元素 let jqDiv = $(“#div”); alert(jqDiv); alert(jqDiv.html()); 1.3. 1.3、小结 jQuery 是一个 JavaScript 库。 说白了就是定义好的一个 JS 文件，内部封装了很多功能，可以大大简化我们的 JS 操作步骤。 jQuery 官网：https://www.jquery.com。 要想使用，必须要引入该文件。 jQuery 的核心语法 $(); 2. 2、JQuery基本语法 2.1. 2.1、JS对象和JQuery对象转换 jQuery 本质上虽然也是 JS，但如果想使用 jQuery 的属性和方法那么必须保证对象是 jQuery 对象，而不是 JS 方式获得的 DOM 对象，二者的 API 方法不能混合使用，若想使用对方的 API，需要进行对象的转换。 JS 的 DOM 对象转换成 jQuery 对象 //$(JS 的 DOM 对象); // JS方式，通过id属性值获取div元素 let jsDiv = document.getElementById(“div”); alert(jsDiv.innerHTML); //alert(jsDiv.html()); JS对象无法使用jQuery里面的功能 // 将 JS 对象转换为jQuery对象 let jq = $(jsDiv); alert(jq.html()); jQuery 对象转换成 JS 对象 /*jQuery 对象[索引]; jQuery 对象.get(索引);*/ // jQuery方式，通过id属性值获取div元素 let jqDiv = $(“#div”); alert(jqDiv.html()); // alert(jqDiv.innerHTML); jQuery对象无法使用JS里面的功能 // 将 jQuery对象转换为JS对象 let js = jqDiv[0]; alert(js.innerHTML); 2.2. 2.2、事件的基本使用 常用的事件 在 jQuery 中将事件封装成了对应的方法。去掉了 JS 中的 .on 语法。 代码实现 事件的使用 //单击事件 $(“#btn”).click(function(){ alert(“点我干嘛?”); }); //获取焦点事件 // $(“#input”).focus(function(){ // alert(“你要输入数据啦...”); // }); //失去焦点事件 $(“#input”).blur(function(){ alert(“你输入完成啦...”); }); 2.3. 2.3、时间的绑定和解绑 绑定事件 //jQuery 对象.on(事件名称,执行的功能); //给btn1按钮绑定单击事件 $(“#btn1”).on(“click”,function(){ alert(“点我干嘛?”); }); 解绑事件 如果不指定事件名称，则会把该对象绑定的所有事件都解绑 //jQuery 对象.off(事件名称); //通过btn2解绑btn1的单击事件 $(“#btn2”).on(“click”,function(){ $(“#btn1”).off(“click”); }); 2.4. 2.4、时间的切换 事件的切换：需要给同一个对象绑定多个事件，而且多个事件还有先后顺序关系。 方式一：单独定义 $(元素).事件方法名1(要执行的功能); $(元素).事件方法名2(要执行的功能); //方式一 单独定义 $(“#div”).mouseover(function(){ //背景色：红色 //$(“#div”).css(“background”,”red”); $(this).css(“background”,”red”); }); $(“#div”).mouseout(function(){ //背景色：蓝色 //$(“#div”).css(“background”,”blue”); $(this).css(“background”,”blue”); }); 方式二：链式定义 $(元素).事件方法名1(要执行的功能) .事件方法名2(要执行的功能); //方式二 链式定义 $(“#div”).mouseover(function(){ $(this).css(“background”,”red”); }).mouseout(function(){ $(this).css(“background”,”blue”); }); 2.5. 2.5、遍历操作 方式一：传统方式 for(let i = 0; i //方式一：传统方式 $(“#btn”).click(function(){ let lis = $(“li”); for(let i = 0 ; i 方式二：对象.each()方法 容器对象.each(function(index,ele){ 执行功能; }); //方式二：对象.each()方法 $(“#btn”).click(function(){ let lis = $(“li”); lis.each(function(index,ele){ alert(index + “:” + ele.innerHTML); }); }); 方式三：$.each()方法 $.each(容器对象,function(index,ele){ 执行功能; }); //方式三：$.each()方法 $(“#btn”).click(function(){ let lis = $(“li”); $.each(lis,function(index,ele){ alert(index + “:” + ele.innerHTML); }); }); 方式四：for of语句 for(ele of 容器对象){ 执行功能; } //方式四：for of 语句遍历 $(“#btn”).click(function(){ let lis = $(“li”); for(ele of lis){ alert(ele.innerHTML); } }); 2.6. 2.6、小结 JS 对象和 jQuery 对象相互转换 $(JS 的 DOM 对象)：将 JS 对象转为 jQuery 对象。 jQuery 对象[索引] jQuery 对象.get(索引)：将 jQuery 对象转为 JS 对象。 事件 在 jQuery 中将事件封装成了对应的方法。去掉了 JS 中的 .on 语法。 on(事件名称,执行的功能)：绑定事件。 off(事件名称)：解绑事件。 遍历 传统方式。 对象.each() 方法。 $.each() 方法。 for of 语句。 3. 3、JQuery选择器 3.1. 3.1、基本选择器 选择器：类似于 CSS 的选择器，可以帮助我们获取元素。 例如：id 选择器、类选择器、元素选择器、属性选择器等等。 jQuery 中选择器的语法：$(); 代码实现 基本选择器 div1 div2 div3 //1.元素选择器 $(“元素的名称”) let divs = $(“div”); //alert(divs.length); //2.id选择器 $(“#id的属性值”) let div1 = $(“#div1”); //alert(div1); //3.类选择器 $(“.class的属性值”) let cls = $(“.cls”); alert(cls.length); 3.2. 3.2、层级选择器 代码实现 层级选择器 s1 s1-1 s1-2 s2 p1 p2 // 1. 后代选择器 $(“A B”); A下的所有B(包括B的子级) let spans1 = $(“div span”); //alert(spans1.length); // 2. 子选择器 $(“A > B”); A下的所有B(不包括B的子级) let spans2 = $(“div > span”); //alert(spans2.length); // 3. 兄弟选择器 $(“A + B”); A相邻的下一个B let ps1 = $(“div + p”); //alert(ps1.length); // 4. 兄弟选择器 $(“A ~ B”); A相邻的所有B let ps2 = $(“div ~ p”); alert(ps2.length); 3.3. 3.3、属性选择器 代码实现 ```html 属性选择器 //1.属性名选择器 $(“元素[属性名]”) let in1 = $(“input[type]”); //alert(in1.length); //2.属性值选择器 $(“元素[属性名=属性值]”) let in2 = $(“input[type=‘password’]”); alert(in2.length); ## 3.4、过滤器选择器 ![](./img/过滤器选择器.png) - **代码实现** ```html 过滤器选择器 div1 div2 div3 div4 // 1.首元素选择器 $(“A:first”); let div1 = $(“div:first”); //alert(div1.html()); // 2.尾元素选择器 $(“A:last”); let div4 = $(“div:last”); //alert(div4.html()); // 3.非元素选择器 $(“A:not(B)”); let divs1 = $(“div:not(#div2)”); //alert(divs1.length); // 4.偶数选择器 $(“A:even”); let divs2 = $(“div:even”); //alert(divs2.length); //alert(divs2[0].innerHTML); //alert(divs2[1].innerHTML); // 5.奇数选择器 $(“A:odd”); let divs3 = $(“div:odd”); //alert(divs3.length); //alert(divs3[0].innerHTML); //alert(divs3[1].innerHTML); // 6.等于索引选择器 $(“A:eq(index)”); let div3 = $(“div:eq(2)”); //alert(div3.html()); // 7.大于索引选择器 $(“A:gt(index)”); let divs4 = $(“div:gt(1)”); //alert(divs4.length); //alert(divs4[0].innerHTML); //alert(divs4[1].innerHTML); // 8.小于索引选择器 $(“A:lt(index)”); let divs5 = $(“div:lt(2)”); alert(divs5.length); alert(divs5[0].innerHTML); alert(divs5[1].innerHTML); 3.5、表单属性选择器 代码实现 表单属性选择器 男 女 学习 睡觉 —请选择— 本科 专科 // 1.可用元素选择器 $(“A:enabled”); let ins1 = $(“input:enabled”); //alert(ins1.length); // 2.不可用元素选择器 $(“A:disabled”); let ins2 = $(“input:disabled”); //alert(ins2.length); // 3.单选/复选框被选中的元素 $(“A:checked”); let ins3 = $(“input:checked”); //alert(ins3.length); //alert(ins3[0].value); //alert(ins3[1].value); //alert(ins3[2].value); // 4.下拉框被选中的元素 $(“A:selected”); let select = $(“select option:selected”); alert(select.html()); 3.6、小结 选择器：类似于 CSS 的选择器，可以帮助我们获取元素。 jQuery 中选择器的语法：$(); 基本选择器 $(“元素的名称”); $(“#id的属性值”); $(“.class的属性值”); 层级选择器 $(“A B”); $(“A > B”); 属性选择器 $(“A[属性名]”); $(“A[属性名=属性值]”); 过滤器选择器 $(“A:even”); $(“A:odd”); 表单属性选择器 $(“A:disabled”); $(“A:checked”); $(“A:selected”); 4、JQuery DOM 4.1、操作文本 常用方法 代码实现 操作文本 我是div //1. html() 获取标签的文本内容 $(“#btn1”).click(function(){ //获取div标签的文本内容 let value = $(“#div”).html(); alert(value); }); //2. html(value) 设置标签的文本内容，解析标签 $(“#btn2”).click(function(){ //设置div标签的文本内容 //$(“#div”).html(“我真的是div”); $(“#div”).html(“我真的是div”); }); 4.2、操作对象 常用方法 代码实现 ```html 操作对象 &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; 北京 上海 广州 深圳 加油 雄起 &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; /* 1. $(“元素”) 创建指定元素 2. append(element) 添加成最后一个子元素，由添加者对象调用 3. appendTo(element) 添加成最后一个子元素，由被添加者对象调用 4. prepend(element) 添加成第一个子元素，由添加者对象调用 5. prependTo(element) 添加成第一个子元素，由被添加者对象调用 6. before(element) 添加到当前元素的前面，两者之间是兄弟关系，由添加者对象调用 7. after(element) 添加到当前元素的后面，两者之间是兄弟关系，由添加者对象调用 8. remove() 删除指定元素(自己移除自己) 9. empty() 清空指定元素的所有子元素 */ // 按钮一：添加一个span到div $(“#btn1”).click(function(){ let span = $(“span”); $(“#div”).append(span); }); //按钮二：将加油添加到城市列表最下方 $(“#btn2”).click(function(){ //$(“#city”).append($(“#jy”)); $(“#jy”).appendTo($(“#city”)); }); //按钮三：将加油添加到城市列表最上方 $(“#btn3”).click(function(){ //$(“#city”).prepend($(“#jy”)); $(“#jy”).prependTo($(“#city”)); }); //按钮四：将雄起添加到上海下方 $(“#btn4”).click(function(){ $(“#sh”).after($(“#xq”)); }); //按钮五：将雄起添加到上海上方 $(“#btn5”).click(function(){ $(“#sh”).before($(“#xq”)); }); //按钮六：将雄起删除 $(“#btn6”).click(function(){ $(“#xq”).remove(); }); //按钮七：将描述列表全部删除 $(“#btn7”).click(function(){ $(“#desc”).empty(); }); ## 4.3、操作样式 - **常用方法** ![](./img/操作样式.png) - **代码实现** ```html 操作样式 .cls1{ background: pink; height: 30px; } 我是div &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; // 1.css(name) 获取css样式 $(“#btn1”).click(function(){ alert($(“#div”).css(“border”)); }); // 2.css(name,value) 设置CSS样式 $(“#btn2”).click(function(){ $(“#div”).css(“background”,”blue”); }); // 3.addClass(value) 给指定的对象添加样式类名 $(“#btn3”).click(function(){ $(“#div”).addClass(“cls1”); }); // 4.removeClass(value) 给指定的对象删除样式类名 $(“#btn4”).click(function(){ $(“#div”).removeClass(“cls1”); }); // 5.toggleClass(value) 如果没有样式类名，则添加。如果有，则删除 $(“#btn5”).click(function(){ $(“#div”).toggleClass(“cls1”); }); 4.4、操作属性 常用方法 代码实现 ```html 操作属性 &nbsp;&nbsp; 男 女 —请选择— 本科 专科 // 1.attr(name,[value]) 获得/设置属性的值 //按钮一：获取输入框的id属性 $(“#btn1”).click(function(){ alert($(“#username”).attr(“id”)); }); //按钮二：给输入框设置value属性 $(“#btn2”).click(function(){ $(“#username”).attr(“value”,”hello...”); }); // 2.prop(name,[value]) 获得/设置属性的值(checked，selected) //按钮三：选中女 $(“#btn3”).click(function(){ $(“#gender2”).prop(“checked”,true); }); //按钮四：选中本科 $(“#btn4”).click(function(){ $(“#bk”).prop(“selected”,true); }); ## 4.5、小结 - 操作文本 - html() html(…)：获取或设置标签的文本，解析标签。 - 操作对象 - $(“元素”)：创建指定元素。 - append(element)：添加成最后一个子元素，由添加者对象调用。 - prepend(element)：添加成第一个子元素，由添加者对象调用。 - before(element)：添加到当前元素的前面，两者之间是兄弟关系，由添加者对象调用。 - after(element)：添加到当前元素的后面，两者之间是兄弟关系，由添加者对象调用。 - remove()：删除指定元素(自己移除自己)。 - 操作样式 - addClass(value)：给指定的对象添加样式类名。 - removeClass(value)：给指定的对象删除样式类名。 - 操作属性 - attr(name,[value])：获得/设置属性的值。 - prop(name,[value])：获得/设置属性的值(checked，selected)。 # 5、综合案例 复选框 ## 5.1、案例效果 ![](./img/复选框-案例效果.png) ## 5.2、分析和实现 **功能分析** - 全选 - 1. 为全选按钮绑定单击事件。 2. 获取所有的商品项复选框元素，为其添加 checked 属性，属性值为 true。 - 全不选 - 1. 为全不选按钮绑定单击事件。 2. 获取所有的商品项复选框元素，为其添加 checked 属性，属性值为 false。 - 反选 - 1. 为反选按钮绑定单击事件 2. 获取所有的商品项复选框元素，为其添加 checked 属性，属性值是目前相反的状态。 **代码实现** ```html 复选框 分类ID 分类名称 分类描述 操作 1 手机数码 手机数码类商品 修改|删除 2 电脑办公 电脑办公类商品 修改|删除 3 鞋靴箱包 鞋靴箱包类商品 修改|删除 4 家居饰品 家居饰品类商品 修改|删除 //全选 //1.为全选按钮添加单击事件 $(“#selectAll”).click(function(){ //2.获取所有的商品复选框元素，为其添加checked属性，属性值true $(“.item”).prop(“checked”,true); }); //全不选 //1.为全不选按钮添加单击事件 $(“#selectNone”).click(function(){ //2.获取所有的商品复选框元素，为其添加checked属性，属性值false $(“.item”).prop(“checked”,false); }); //反选 //1.为反选按钮添加单击事件 $(“#reverse”).click(function(){ //2.获取所有的商品复选框元素，为其添加checked属性，属性值是目前相反的状态 let items = $(“.item”); items.each(function(){ $(this).prop(“checked”,!$(this).prop(“checked”)); }); }); 6、综合案例 随机图片 6.1、案例效果 6.2、动态切换小图的分析和实现 功能分析 准备一个数组 定义计数器 定义定时器对象 定义图片路径变量 为开始按钮绑定单击事件 设置按钮状态 设置定时器，循环显示图片 循环获取图片路径 将当前图片显示到小图片上 计数器自增 代码实现 随机图片 //1.准备一个数组 let imgs = [ \"img/01.jpg\", \"img/02.jpg\", \"img/03.jpg\", \"img/04.jpg\", \"img/05.jpg\", \"img/06.jpg\", \"img/07.jpg\", \"img/08.jpg\", \"img/09.jpg\", \"img/10.jpg\"]; //2.定义计数器变量 let count = 0; //3.声明定时器对象 let time = null; //4.声明图片路径变量 let imgSrc = \"\"; //5.为开始按钮绑定单击事件 $(\"#startBtn\").click(function(){ //6.设置按钮状态 //禁用开始按钮 $(\"#startBtn\").prop(\"disabled\",true); //启用停止按钮 $(\"#stopBtn\").prop(\"disabled\",false); //7.设置定时器，循环显示图片 time = setInterval(function(){ //8.循环获取图片路径 let index = count % imgs.length; // 0%10=0 1%10=1 2%10=2 .. 9%10=9 10%10=0 //9.将当前图片显示到小图片上 imgSrc = imgs[index]; $(\"#small\").prop(\"src\",imgSrc); //10.计数器自增 count++; },10); }); 6.3、显示大图的分析和实现 功能分析 为停止按钮绑定单击事件 取消定时器 设置按钮状态 将图片显示到大图片上 代码实现 //11.为停止按钮绑定单击事件 $(\"#stopBtn\").click(function(){ //12.取消定时器 clearInterval(time); //13.设置按钮状态 //启用开始按钮 $(\"#startBtn\").prop(\"disabled\",false); //禁用停止按钮 $(\"#stopBtn\").prop(\"disabled\",true); //14.将图片显示到大图片上 $(\"#big\").prop(\"src\",imgSrc); $(\"#big\").prop(\"style\",\"width: 400px; height: 400px;\"); }); Copyright © MISIN 2022 | 豫ICP备2021006345号-1 all right reserved，powered by Gitbook该文件修订时间： 2022-11-10 13:53:40 "},"2.JavaWeb/9.AJAX/AJAX.html":{"url":"2.JavaWeb/9.AJAX/AJAX.html","title":"AJAX","keywords":"","body":"1. 1、Ajax快速入门1.1. 1.1、AJAX介绍1.2. 1.2、原生JS实现AJAX1.3. 1.3、原生JS实现AJAX详解1.4. 1.4、JQuery的GET方式实现AJAX1.5. 1.5、JQuery的POST方式实现AJAX1.6. 1.6、JQuery的通用方式实现AJAX1.7. 1.7、小结2. 2、JSON的处理2.1. 2.1、JSON回顾2.2. 2.2、JSON转换工具的介绍2.3. 2.3、JSON转换练习2.4. 2.4、小结3. 3、综合案例 搜索联想1. 1、Ajax快速入门 1.1. 1.1、AJAX介绍 AJAX(Asynchronous JavaScript And XML)：异步的 JavaScript 和 XML。 本身不是一种新技术，而是多个技术综合。用于快速创建动态网页的技术。 一般的网页如果需要更新内容，必需重新加载个页面。 而 AJAX 通过浏览器与服务器进行少量数据交换，就可以使网页实现异步更新。也就是在不重新加载整个页 面的情况下，对网页的部分内容进行局部更新。 ​ ​ 1.2. 1.2、原生JS实现AJAX 代码实现 import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; @WebServlet(“/userServlet”) public class UserServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { //设置请求和响应的乱码 req.setCharacterEncoding(“UTF-8”); resp.setContentType(“text/html;charset=UTF-8”); //1.获取请求参数 String username = req.getParameter(“username”); //模拟服务器处理请求需要5秒钟 /*try { Thread.sleep(5000); } catch (InterruptedException e) { e.printStackTrace(); }*/ //2.判断姓名是否已注册 if(“zhangsan”.equals(username)) { resp.getWriter().write(“用户名已注册”); }else { resp.getWriter().write(“用户名可用”); } } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { doGet(req,resp); } } html代码 用户注册 姓名： 密码： //1.为姓名绑定失去焦点事件 document.getElementById(“username”).onblur = function() { //2.创建XMLHttpRequest核心对象 let xmlHttp = new XMLHttpRequest(); //3.打开链接 let username = document.getElementById(“username”).value; xmlHttp.open(“GET”,”userServlet?username=“+username,true); //xmlHttp.open(“GET”,”userServlet?username=“+username,false); //4.发送请求 xmlHttp.send(); //5.处理响应 xmlHttp.onreadystatechange = function() { //判断请求和响应是否成功 if(xmlHttp.readyState == 4 && xmlHttp.status == 200) { //将响应的数据显示到span标签 document.getElementById(“uSpan”).innerHTML = xmlHttp.responseText; } } } 1.3. 1.3、原生JS实现AJAX详解 核心对象：XMLHttpRequest ​ 用于在后台与服务器交换数据。可以在不重新加载整个网页的情况下，对网页的某部分进行更新。 打开链接：open(method,url,async) ​ method：请求的类型 GET 或 POST。 ​ url：请求资源的路径。 ​ async：true(异步) 或 false(同步)。 发送请求：send(String params) ​ params：请求的参数(POST 专用)。 处理响应：onreadystatechange ​ readyState：0-请求未初始化，1-服务器连接已建立，2-请求已接收，3-请求处理中，4-请求已完成，且响应已就绪。 ​ status：200-响应已全部 OK。 获得响应数据形式 ​ responseText：获得字符串形式的响应数据。 ​ responseXML：获得 XML 形式的响应数据。 1.4. 1.4、JQuery的GET方式实现AJAX 核心语法：$.get(url,[data],[callback],[type]); url：请求的资源路径。 data：发送给服务器端的请求参数，格式可以是key=value，也可以是 js 对象。 callback：当请求成功后的回调函数，可以在函数中编写我们的逻辑代码。 type：预期的返回数据的类型，取值可以是 xml, html, js, json, text等。 代码实现 用户注册 姓名： 密码： //1.为用户名绑定失去焦点事件 $(“#username”).blur(function () { let username = $(“#username”).val(); //2.jQuery的GET方式实现AJAX $.get( //请求的资源路径 “userServlet”, //请求参数 “username=“ + username, //回调函数 function (data) { //将响应的数据显示到span标签 $(“#uSpan”).html(data); }, //响应数据形式 “text” ); }); 1.5. 1.5、JQuery的POST方式实现AJAX 核心语法：$.post(url,[data],[callback],[type]); url：请求的资源路径。 data：发送给服务器端的请求参数，格式可以是key=value，也可以是 js 对象。 callback：当请求成功后的回调函数，可以在函数中编写我们的逻辑代码。 type：预期的返回数据的类型，取值可以是 xml, html, js, json, text等。 代码实现 用户注册 姓名： 密码： //1.为用户名绑定失去焦点事件 $(“#username”).blur(function () { let username = $(“#username”).val(); //2.jQuery的POST方式实现AJAX $.post( //请求的资源路径 “userServlet”, //请求参数 “username=“ + username, //回调函数 function (data) { //将响应的数据显示到span标签 $(“#uSpan”).html(data); }, //响应数据形式 “text” ); }); 1.6. 1.6、JQuery的通用方式实现AJAX 核心语法：$.ajax({name:value,name:value,…}); url：请求的资源路径。 async：是否异步请求，true-是，false-否 (默认是 true)。 data：发送到服务器的数据，可以是键值对形式，也可以是 js 对象形式。 type：请求方式，POST 或 GET (默认是 GET)。 dataType：预期的返回数据的类型，取值可以是 xml, html, js, json, text等。 success：请求成功时调用的回调函数。 error：请求失败时调用的回调函数。 代码实现 用户注册 姓名： 密码： //1.为用户名绑定失去焦点事件 $(“#username”).blur(function () { let username = $(“#username”).val(); //2.jQuery的通用方式实现AJAX $.ajax({ //请求资源路径 url:”userServletxxx”, //是否异步 async:true, //请求参数 data:”username=“+username, //请求方式 type:”POST”, //数据形式 dataType:”text”, //请求成功后调用的回调函数 success:function (data) { //将响应的数据显示到span标签 $(“#uSpan”).html(data); }, //请求失败后调用的回调函数 error:function () { alert(“操作失败...”); } }); }); 1.7. 1.7、小结 AJAX(Asynchronous JavaScript And XML)：异步的 JavaScript 和 XML。 通过浏览器与服务器进行少量数据交换，就可以使网页实现异步更新。也就是在不重新加载整个页面的情况下，对网页的部 分内容进行局部更新。 同步和异步 同步：服务器端在处理过程中，无法进行其他操作。 异步：服务器端在处理过程中，可以进行其他操作。 GET 方式实现：$.get(); POST 方式实现：$.post(); url：请求的资源路径。 data：发送给服务器端的请求参数，格式可以是key=value，也可以是 js 对象。 callback：当请求成功后的回调函数，可以在函数中编写我们的逻辑代码。 type：预期的返回数据的类型，取值可以是 xml, html, js, json, text等。 通用方式实现：$.ajax(); url：请求的资源路径。 async：是否异步请求，true-是，false-否 (默认是 true)。 data：发送到服务器的数据，可以是键值对形式，也可以是 js 对象形式。 type：请求方式，POST 或 GET (默认是 GET)。 dataType：预期的返回数据的类型，取值可以是 xml, html, js, json, text等。 success：请求成功时调用的回调函数。 error：请求失败时调用的回调函数。 2. 2、JSON的处理 2.1. 2.1、JSON回顾 JSON(JavaScript Object Notation)：是一种轻量级的数据交换格式。 它是基于 ECMAScript 规范的一个子集，采用完全独立于编程语言的文本格式来存储和表示数据。 简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。易于人阅读和编写，同时也易于计算机解析和生成，并有效的 提升网络传输效率。 创建格式 常用方法 2.2. 2.2、JSON转换工具的介绍 我们除了可以在 JavaScript 中来使用 JSON 以外，在 JAVA 中同样也可以使用 JSON。 JSON 的转换工具是通过 JAVA 封装好的一些 JAR 工具包。 可以将 JAVA 对象或集合转换成 JSON 格式的字符串，也可以将 JSON 格式的字符串转成 JAVA 对象。 Jackson：开源免费的 JSON 转换工具，SpringMVC 转换默认使用 Jackson。 导入 jar 包。 创建核心对象。 调用方法完成转换。 常用类 ObjectMapper常用方法 2.3. 2.3、JSON转换练习 对象转 JSON, JSON 转对象。 /* JSON转换工具的使用 */ public class ObjectMapperTest { private ObjectMapper mapper = new ObjectMapper(); /* 1.User对象转json, json转User对象 json字符串 = {“name”:”张三”,”age”:23} user对象 = User{name=‘张三’, age=23} */ @Test public void test01() throws Exception{ //User对象转json User user = new User(“张三”,23); String json = mapper.writeValueAsString(user); System.out.println(“json字符串：” + json); //json转User对象 User user2 = mapper.readValue(json, User.class); System.out.println(“java对象：” + user2); } } Map转 JSON, JSON 转 Map。 /* 2.map转json, json转map json字符串 = {“姓名”:”张三”,”性别”:”男”} map对象 = {姓名=张三, 性别=男} */ @Test public void test02() throws Exception{ //map转json HashMap map = new HashMap<>(); map.put(“姓名”,”张三”); map.put(“性别”,”男”); String json = mapper.writeValueAsString(map); System.out.println(“json字符串：” + json); //json转map HashMap map2 = mapper.readValue(json, HashMap.class); System.out.println(“java对象：” + map2); } Map转 JSON, JSON 转 Map。 /* 3.map转json, json转map json字符串 = {“黑马一班”:{“name”:”张三”,”age”:23},”黑马二班”:{“name”:”李四”,”age”:24}} map对象 = {黑马一班=User{name=‘张三’, age=23}, 黑马二班=User{name=‘李四’, age=24}} */ @Test public void test03() throws Exception{ //map转json HashMap map = new HashMap<>(); map.put(“黑马一班”,new User(“张三”,23)); map.put(“黑马二班”,new User(“李四”,24)); String json = mapper.writeValueAsString(map); System.out.println(“json字符串：” + json); //json转map HashMap map2 = mapper.readValue(json,new TypeReference>(){}); System.out.println(“java对象：” + map2); } List转 JSON, JSON 转 List。 /* 4.List转json, json转 List json字符串 = [“张三”,”李四”] list对象 = [张三, 李四] */ @Test public void test04() throws Exception{ //List转json ArrayList list = new ArrayList<>(); list.add(“张三”); list.add(“李四”); String json = mapper.writeValueAsString(list); System.out.println(“json字符串：” + json); //json转 List ArrayList list2 = mapper.readValue(json,ArrayList.class); System.out.println(“java对象：” + list2); } List转 JSON, JSON 转 List。 /* 5.List转json, json转List json字符串 = [{“name”:”张三”,”age”:23},{“name”:”李四”,”age”:24}] list对象 = [User{name=‘张三’, age=23}, User{name=‘李四’, age=24}] */ @Test public void test05() throws Exception{ //List转json ArrayList list = new ArrayList<>(); list.add(new User(“张三”,23)); list.add(new User(“李四”,24)); String json = mapper.writeValueAsString(list); System.out.println(“json字符串：” + json); //json转List ArrayList list2 = mapper.readValue(json,new TypeReference>(){}); System.out.println(“java对象：” + list2); } 2.4. 2.4、小结 Jackson：开源免费的 JSON 转换工具，SpringMVC 转换默认使用 Jackson。 可以将 JAVA 对象或集合转换成 JSON 格式的字符串，也可以将 JSON 格式的字符串转成 JAVA 对象。 常用类 3. 3、综合案例 搜索联想 案例效果和环境介绍 案例分析 页面 为用户名输入框绑定鼠标点击事件。 获取输入的用户名数据。 判断用户名是否为空。 如果为空，则将联想提示框隐藏。 如果不为空，则发送 AJAX 请求，并将响应的数据显示到联想框。 控制层 获取请求参数。 调用业务层的模糊查询方法。 将返回的数据转成 JSON，并响应给客户端。 代码实现 html页面 ```html 用户搜索 .content { width: 643px; margin: 100px auto; text-align: center; } input[type=‘text’] { width: 530px; height: 40px; font-size: 14px; } input[type=‘button’] { width: 100px; height: 46px; background: #38f; border: 0; color: #fff; font-size: 15px } .show { position: absolute; width: 535px; height: 100px; border: 1px solid #999; border-top: 0; display: none; } //1.为用户名输入框绑定鼠标点击事件 $(“#username”).mousedown(function () { //2.获取输入的用户名 let username = $(“#username”).val(); //3.判断用户名是否为空 if(username == null || username == “”) { //4.如果为空，将联想框隐藏 $(“#show”).hide(); return; } //5.如果不为空，发送AJAX请求。并将数据显示到联想框 $.ajax({ //请求的资源路径 url:”userServlet”, //请求参数 data:{“username”:username}, //请求方式 type:”POST”, //响应数据形式 dataType:”json”, //请求成功后的回调函数 success:function (data) { //将返回的数据显示到show的div let names = “”; for(let i = 0; i ”+data[i].name+””; } $(“#show”).html(names); $(“#show”).show(); } }); }); ``` 控制层-Java代码 @WebServlet(“/userServlet”) public class UserServlet extends HttpServlet { @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { //设置请求和响应的编码 req.setCharacterEncoding(“UTF-8”); resp.setContentType(“text/html;charset=UTF-8”); //1.获取请求参数 String username = req.getParameter(“username”); //2.调用业务层的模糊查询方法得到数据 UserService service = new UserServiceImpl(); List users = service.selectLike(username); //3.将数据转成JSON，响应到客户端 ObjectMapper mapper = new ObjectMapper(); String json = mapper.writeValueAsString(users); resp.getWriter().write(json); } @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { doPost(req,resp); } } 4、综合案例 分页 ​ 瀑布流无限加载数据分页 4.1、案例效果和环境准备 案例效果 环境准备 1.导入“案例二的sql语句.sql”文件（已在当天的SQL语句中提供） 2.导入“分页案例原始环境”中的ajax03项目（已在当天的资料中提供） 4.2、案例的分析 如何确定当前显示的数据已经浏览完毕？ 公式：(滚动条距底部的距离 + 滚动条上下滚动的距离 + 当前窗口的高度) >= 当前文档的高度 当前文档高度：存储10条数据，100px。 滚动条距底部的距离：1px。 当前窗口的高度：80px。 滚动条上下滚动的距离：>=19px。 前置知识 4.3、案例的实现 实现思路 页面 定义发送请求标记。 定义当前页码和每页显示的条数。 定义滚动条距底部的距离。 设置页面加载事件。 为当前窗口绑定滚动条滚动事件。 获取必要信息(当前窗口的高度,滚动条上下滚动的距离,当前文档的高度)。 计算当前展示数据是否浏览完毕。 判断请求标记是否为 true。 将请求标记置为 false，当前异步操作完成前，不能重新发起请求。 根据当前页和每页显示的条数来请求查询分页数据。 当前页码+1。 服务器 获取请求参数(当前页,每页显示的条数)。 根据当前页码和每页显示的条数，调用业务层的方法，得到分页 Page 对象。 将得到的数据转为 json。 将数据响应给客户端。 —— 代码实现 html页面 //1.定义发送请求标记 let send = true; //2.定义当前页码和每页显示的条数 let start = 1; let pageSize = 10; //3.定义滚动条距底部的距离 let bottom = 1; //4.设置页面加载事件 $(function () { //5.为当前窗口绑定滚动条滚动事件 $(window).scroll(function () { //6.获取必要信息，用于计算当前展示数据是否浏览完毕 //当前窗口的高度 let windowHeight = $(window).height(); //滚动条从上到下滚动距离 let scrollTop = $(window).scrollTop(); //当前文档的高度 let docHeight = $(document).height(); //7.计算当前展示数据是否浏览完毕 //当 滚动条距底部的距离 + 当前滚动条滚动的距离 + 当前窗口的高度 >= 当前文档的高度 if((bottom + scrollTop + windowHeight) >= docHeight) { //8.判断请求标记是否为true if(send == true) { //9.将请求标记置为false，当前异步操作完成前，不能重新发起请求。 send = false; //10.根据当前页和每页显示的条数来 请求查询分页数据 queryByPage(start,pageSize); //11.当前页码+1 start++; } } }); }); //定义查询分页数据的函数 function queryByPage(start,pageSize){ //加载动图显示 $(“.loading”).show(); //发起AJAX请求 $.ajax({ //请求的资源路径 url:”newsServlet”, //请求的参数 data:{“start”:start,”pageSize”:pageSize}, //请求的方式 type:”POST”, //响应数据形式 dataType:”json”, //请求成功后的回调函数 success:function (data) { if(data.length == 0) { $(“.loading”).hide(); $(“#no”).html(“我也是有底线的...”); return; } //加载动图隐藏 $(“.loading”).hide(); //将数据显示 let titles = “”; for(let i = 0; i \\n” + “ \\n” + “ \\n” + data[i].title + “ \\n” + “ \\n” + “ \\n” + “ ”; } //显示到页面 $(“.news_list”).append(titles); //将请求标记设置为true send = true; } }); } java代码 import com.fasterxml.jackson.databind.ObjectMapper; import com.github.pagehelper.Page; import com.itheima.service.NewsService; import com.itheima.service.impl.NewsServiceImpl; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; @WebServlet(“/newsServlet”) public class NewsServlet extends HttpServlet { @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { //设置请求和响应的编码 req.setCharacterEncoding(“UTF-8”); resp.setContentType(“text/html;charset=UTF-8”); //1.获取请求参数 String start = req.getParameter(“start”); String pageSize = req.getParameter(“pageSize”); //2.根据当前页码和每页显示的条数来调用业务层的查询方法，得到分页Page对象 NewsService service = new NewsServiceImpl(); Page page = service.pageQuery(Integer.parseInt(start), Integer.parseInt(pageSize)); //3.将得到的数据转为JSON String json = new ObjectMapper().writeValueAsString(page); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } //4.将数据响应给客户端 resp.getWriter().write(json); } @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { doPost(req,resp); } } 4.4、点击按钮分页 案例效果和环境准备 按钮效果 环境准备 使用已完善的ajax3项目 复制index.html更名为index2.html，并去掉原js中的方法 案例的分析 页面 1.引入分页插件的样式文件和 js 文件。 定义当前页码和每页显示的条数。 调用查询数据的函数。 定义请求查询分页数据的函数，发起 AJAX 异步请求。 为分页按钮区域设置页数参数(总页数和当前页)。 为分页按钮绑定单击事件,完成上一页下一页查询功能。 服务器 获取请求参数。 根据当前页码和每页显示的条数，调用业务层的方法，得到分页 Page 对象 封装 PageInfo 对象。 将得到的数据转为 json。 将数据响应给客户端。 案例的实现 html页面 //1.定义当前页码和每页显示的条数 let start = 1; let pageSize = 10; //2.调用查询数据的方法 queryByPage(start,pageSize); //3.定义请求查询分页数据的函数，发起AJAX异步请求，将数据显示到页面 function queryByPage(start,pageSize) { $.ajax({ //请求的资源路径 url:\"newsServlet2\", //请求的参数 data:{\"start\":start,\"pageSize\":pageSize}, //请求的方式 type:\"POST\", //响应数据形式 dataType:\"json\", //请求成功后的回调函数 success:function (pageInfo) { //将数据显示到页面 let titles = \"\"; for(let i = 0; i \\n\" + \" \\n\" + \" \\n\" + pageInfo.list[i].title + \" \\n\" + \" \\n\" + \" \\n\" + \" \"; } $(\".news_list\").html(titles); //4.为分页按钮区域设置页数参数（总页数和当前页） $(\"#light-pagination\").pagination({ pages:pageInfo.pages, currentPage:pageInfo.pageNum }); //5.为分页按钮绑定单击事件,完成上一页下一页查询功能 $(\"#light-pagination .page-link\").click(function () { //获取点击按钮的文本内容 let page = $(this).html(); //如果点击的是Prev，调用查询方法，查询当前页的上一页数据 if(page == \"Prev\") { queryByPage(pageInfo.pageNum - 1,pageSize); }else if (page == \"Next\") { //如果点击的是Next，调用查询方法，查询当前页的下一页数据 queryByPage(pageInfo.pageNum + 1,pageSize); } else { //调用查询方法，查询当前页的数据 queryByPage(page,pageSize); } }); } }); } Java代码 import com.fasterxml.jackson.databind.ObjectMapper; import com.github.pagehelper.Page; import com.github.pagehelper.PageInfo; import com.itheima.bean.News; import com.itheima.service.NewsService; import com.itheima.service.impl.NewsServiceImpl; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; import java.util.List; @WebServlet(\"/newsServlet2\") public class NewsServlet2 extends HttpServlet { @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { //设置请求和响应的编码 req.setCharacterEncoding(\"UTF-8\"); resp.setContentType(\"text/html;charset=UTF-8\"); //1.获取请求参数 String start = req.getParameter(\"start\"); String pageSize = req.getParameter(\"pageSize\"); //2.根据当前页码和每页显示的条数来调用业务层的查询方法，得到分页Page对象 NewsService service = new NewsServiceImpl(); Page page = service.pageQuery(Integer.parseInt(start), Integer.parseInt(pageSize)); //3.封装PageInfo对象 PageInfo> info = new PageInfo<>(page); //4.将得到的数据转为JSON String json = new ObjectMapper().writeValueAsString(info); //5.将数据响应给客户端 resp.getWriter().write(json); } @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { doPost(req,resp); } } Copyright © MISIN 2022 | 豫ICP备2021006345号-1 all right reserved，powered by Gitbook该文件修订时间： 2022-11-10 13:54:14 "},"2.JavaWeb/Web综合案例/web综合案例-day01.html":{"url":"2.JavaWeb/Web综合案例/web综合案例-day01.html","title":"web综合案例-day01","keywords":"","body":"1. WEB综合案例1.1. 学习目标：1.2. 1. 概述1.2.1. 1.1 案例介绍1.2.2. 1.2系统架构1.2.3. 1.3 技术架构1.2.4. 1.4 需求分析1.2.5. 1.5 课程计划安排1.3. 2. 环境搭建1.3.1. 2.1 工程结构搭建1.3.2. 2.2 页面结构搭建1.4. 3. 企业模块1.4.1. 3.1 数据层开发1.4.2. 3.2 业务层开发1.4.3. 3.3 表现层列表功能1.4.4. 3.4 表现层添加功能1.4.5. 3.5 表现层删除修改功能1.5. 4. 部门模块1.5.1. 4.1 部门模块单表开发1.5.2. 4.2 部门自连接1.6. 5. 用户模块1. WEB综合案例 1.1. 学习目标： 目标1：能够说出案例的系统架构和技术架构 目标2：能够说出案例的大致需求 目标3：完成案例工程结构和页面结构的搭建 目标4：完成企业模块相关功能的业务开发 目标5：完成部门模块相关功能的业务开发 目标6：完成用户模块相关功能的业务的开发 1.2. 1. 概述 1.2.1. 1.1 案例介绍 黑马面面是一款面向程序员的面试刷题系统，服务于学员培训学习完毕后的复习问题，通过大量刷题，提高企业面试题的熟知度，辅助学员顺利完成求职面试。 注意：我们在本课程中只做黑马面面系统的一部分，对有些功能进行了微缩改造， 黑马面面本原始系统又分为三个子系统：后台系统，前台系统，手机端（在本课程中不涉及），以下是各子系统核心的功能介绍 后台系统：试题的录入 前台系统：会员刷题 手机端：会员刷题（常用/主流） 1.2.2. 1.2系统架构 接下来在做之前，我们就要说说这套案例制作的时候应该采用怎样的一种结构进行搭建？同时采用什么样的技术进行实现。那么首先我们先聊一聊整个项目的系统架构。 对于整个系统来说，它分成两块，一个是后台系统，一个是前台系统。那么我们在访问后台系统的时候，是通过浏览器来进行访问，最终把我们的数据存入到我们的数据库端。记得一点，我们从后台系统录入的题目数据，最终会被前台系统使用，所以说前后台系统，他们在数据这一端上来说是进行共享的。也就是前后台系统用的基础数据是同一组。那么前台系统是通过手机端来进行刷这个题，那么我们在这里边呢，不做手机端的，我们也做浏览器的，这就是它的一个整体的结构，你要先了解。 那么对于后台系统来说，开发的时候，我们采用三层架构的形式开发，分为表现、业务、数据。表现层负责数据的收集以及回显，业务层负责业务逻辑处理，数据层负责与数据库打交道。那么对于前台系统来说呢，它仍然是这样的，只不过他们之间用的技术有差别。那么都有哪些差别呢？接下来咱们就要来说一下技术架构！ 1.2.3. 1.3 技术架构 对于后台系统与前台系统，我们分成五个层面来介绍他们的产品。分别是页面端的技术，也就是我们的前端技术了，以及controller、service、Dao、DB。 详情见下图： AdminLTE：一个前端框架，提供了很多友好的主题样式，动态功能效果，可直接使用，非常方便 POI：数据报表工具，可用于报表导出 1.2.4. 1.4 需求分析 刷题是整个项目的核心功能，那么试题一定是我们的核心。对一道题来说，体型会多种多样，这次我们以最复杂的选择题来演示。选择题一般由题目与选项构成，题目与选项是一对多的关系。在下图中，我们以线和圆点来表述它们之间的关系。没有圆点的是“一”方，有圆点的是“多”方。 继续看，试题一定有归属的学科，比如你Java的同学做python的题，其实意义不大对吧。题目和学科能直产生一对多的关系吗？一个学科下其实分了很多的东西，比如Java下分Java基础、JavaWeb等等，所以在学科和试题建，需要有个目录。 假如你现在想去一个企业，是不想想看看这个企业以前都出些什么面试题呀。那就需要一个企业的模块了。一个企业与试题之间，也是一对多的关系。 试题是谁录入系统呢？需要有用户模块，那肯定是操作系统的人，对于这个用户来说，并不是所有人都能录入，所以需要约定一个部门。然后，那是部门中所有人都需要录入么？这样就涉及到了一个权限的问题了，我们说你这个用户有一种角色，就能拥有录入试题的权限！所以在用户与角色之间形成一个多对多的关系。 这个人分配角色了就能录试题了吗？不，还需要一个叫模块的东西。就是这个系统中一共有多少种操作？在我们系统中有一个模块叫做录入试题的模块，有一个模块叫审核试题的模块，是这个角色能操作这个模块儿，所以这个用户才能执行这项操作。模块与角色之间也是一个多对多的关系。 录入完了就能直接用么？不能，万一你录的题有问题呢？所以一定要有一个审核机制。对于所有的操作，我们都需要有一个日志来记录了，所以还要有一个日志的东西。 接下来要开始答题 ，那谁来答题呢？，会员。所以我们要有一个会员的模块。会员就直接做题吗？，做题应该是以试卷的形式呈现。作为一个会员，登录以后，你要去做一套卷子，而不是做一道题，当然你说能不能做单个题，可以，可以把单个题理解为这个试卷就一道题。会员与试卷是一对多的关系。 那试卷就与我们的试题直接产生关系么，不需要。我们每一个试卷生成以后。都需要把这个题给做出来，你做出来以后，除了有题目以外，试卷中还得有你做题的答案。所以说试卷中会保存一个试卷的答题明细，这个地方试卷对答题明细是一个一对多的关系。其实答题明细中本身就有试题的ID，因此我们这里用试卷与答题明细对试题进行关联。 总结一下，左边这块是属于后台系统，负责保障录入试题的。右边这块属于前台系统，负责学员的刷题功能。 1.2.5. 1.5 课程计划安排 1.3. 2. 环境搭建 1.3.1. 2.1 工程结构搭建 创建工程的要求，及注意点： 创建maven工程（web工程） 导入项目依赖的坐标（资源） 补全目录结构 web ​ |-----src ​ |-------main ​ |------------java ​ |------------resources ​ |------------webapp ​ |-------test ​ |-------------java ​ |-------------resources 创建三层架构开发的包层次结构 创建三层架构开发的包层次结构 domain dao service web ​ controller ​ filters utils factory 1：创建项目：mm com.itheima mm 1.0-SNAPSHOT war 2：在pom.xml文件中添加相关坐标： UTF-8 1.8 1.8 org.mybatis mybatis 3.5.3 com.github.pagehelper pagehelper 5.1.2 mysql mysql-connector-java 5.1.46 com.alibaba druid 1.1.21 junit junit 4.12 test javax.servlet javax.servlet-api 3.1.0 provided javax.servlet.jsp javax.servlet.jsp-api 2.3.3 provided commons-beanutils commons-beanutils 1.9.4 org.apache.commons commons-lang3 3.9 jstl jstl 1.2 com.fasterxml.jackson.core jackson-annotations 2.9.0 com.fasterxml.jackson.core jackson-core 2.9.0 com.fasterxml.jackson.core jackson-databind 2.9.0 commons-fileupload commons-fileupload 1.3.1 org.apache.poi poi 4.0.1 org.apache.poi poi-ooxml 4.0.1 org.apache.poi poi-ooxml-schemas 4.0.1 org.apache.tomcat.maven tomcat7-maven-plugin 2.1 80 / 3：创建相关目录结构，包结构，如下 删除：web.xml 4：启动初始项目，运行查看！ 5：从今日课程资料-------->工程资源文件中找到项目数据库脚本，导入到mysql数据库，创建好相关的库表结构 1.3.2. 2.2 页面结构搭建 管理后台一般有着固定的页面构建模式，我们可以进行快速构建 AdminLTE是一款建立在bootstrap和jquery之上的开源模板主题工具，其中内置了多个模板页面，可以用于快速创建响应式Html5网站，并免去了书写大量的 CSS 与 JS 的工作 黑马程序员研究院对AdminLTE进行了汉化，并改良了个别功能，方便学员学习使用 从今日课程资料中找到：模块页面---------->案例结构页面----------->导入到项目的webapp目录下，如果有文件需要覆盖则选择覆盖， 导入完成后可以启动项目进行查看 由AdminLTE构建的网站后台的整体页面布局如下： 1.4. 3. 企业模块 我们选择一个单表的增删改查功能来进行入门，熟悉开发的模式和流程，因此选择企业模块 要对企业信息做CRUD，我们需要知道要操作企业的那些字段， 1.4.1. 3.1 数据层开发 1：创建实体：com.itheima.domain.store.Company public class Company { private String id; private String name; private Date expirationDate; private String address; private String licenseId; private String representative; private String phone; private String companySize; private String industry; private String remarks; private Integer state; private String city; public String getId() { return id; } public void setId(String id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public Date getExpirationDate() { return expirationDate; } public void setExpirationDate(Date expirationDate) { this.expirationDate = expirationDate; } public String getAddress() { return address; } public void setAddress(String address) { this.address = address; } public String getLicenseId() { return licenseId; } public void setLicenseId(String licenseId) { this.licenseId = licenseId; } public String getRepresentative() { return representative; } public void setRepresentative(String representative) { this.representative = representative; } public String getPhone() { return phone; } public void setPhone(String phone) { this.phone = phone; } public String getCompanySize() { return companySize; } public void setCompanySize(String companySize) { this.companySize = companySize; } public String getIndustry() { return industry; } public void setIndustry(String industry) { this.industry = industry; } public String getRemarks() { return remarks; } public void setRemarks(String remarks) { this.remarks = remarks; } public Integer getState() { return state; } public void setState(Integer state) { this.state = state; } public String getCity() { return city; } public void setCity(String city) { this.city = city; } } 2：创建dao：com.itheima.dao.store.CompanyDao public interface CompanyDao { int save(Company company); int delete(Company company); int update(Company company); Company findById(String id); List findAll(); } 3：从今日课程资料中找到：dao层资源文件---------拷贝配置文件下的资源到项目resources目录下 4：在项目resources目录下创建一个目录：com\\itheima\\dao\\store，然后把CompanyDao.xml配置文件放到该目录中 5：从今日课程资料中找到：dao层资源文件----------拷贝工具类下的资源到项目中的utils包和factory包下；注意别放错位置 总结： 1.4.2. 3.2 业务层开发 业务层基础功能： 增 删 改 查单个 查全部 分页查（分页插件） 我们依次来实现 1：创建业务层接口：com.itheima.service.store.CompanyService public interface CompanyService { /** * 添加 * @param company * @return */ void save(Company company); /** * 删除 * @param company * @return */ void delete(Company company); /** * 修改 * @param company * @return */ void update(Company company); /** * 查询单个 * @param id 查询的条件（id） * @return 查询的结果，单个对象 */ Company findById(String id); /** * 查询全部的数据 * @return 全部数据的列表对象 */ List findAll(); /** * 分页查询数据 * @param page 页码 * @param size 每页显示的数据总量 * @return */ PageInfo findAll(int page,int size); } 2：创建业务层实现类：com.itheima.service.store.impl.CompanyServiceImpl public class CompanyServiceImpl implements CompanyService { @Override public void save(Company company) { SqlSession sqlSession = null; try{ //1.获取SqlSession sqlSession = MapperFactory.getSqlSession(); //2.获取Dao CompanyDao companyDao = MapperFactory.getMapper(sqlSession,CompanyDao.class); //id使用UUID的生成策略来获取 String id = UUID.randomUUID().toString(); company.setId(id); //3.调用Dao层操作 companyDao.save(company); //4.提交事务 TransactionUtil.commit(sqlSession); }catch (Exception e){ TransactionUtil.rollback(sqlSession); throw new RuntimeException(e); //记录日志 }finally { try { TransactionUtil.close(sqlSession); }catch (Exception e){ e.printStackTrace(); } } } @Override public void delete(Company company) { SqlSession sqlSession = null; try{ //1.获取SqlSession sqlSession = MapperFactory.getSqlSession(); //2.获取Dao CompanyDao companyDao = MapperFactory.getMapper(sqlSession,CompanyDao.class); //3.调用Dao层操作 companyDao.delete(company); //4.提交事务 TransactionUtil.commit(sqlSession); }catch (Exception e){ TransactionUtil.rollback(sqlSession); throw new RuntimeException(e); //记录日志 }finally { try { TransactionUtil.close(sqlSession); }catch (Exception e){ e.printStackTrace(); } } } @Override public void update(Company company) { SqlSession sqlSession = null; try{ //1.获取SqlSession sqlSession = MapperFactory.getSqlSession(); //2.获取Dao CompanyDao companyDao = MapperFactory.getMapper(sqlSession,CompanyDao.class); //3.调用Dao层操作 companyDao.update(company); //4.提交事务 TransactionUtil.commit(sqlSession); }catch (Exception e){ TransactionUtil.rollback(sqlSession); throw new RuntimeException(e); //记录日志 }finally { try { TransactionUtil.close(sqlSession); }catch (Exception e){ e.printStackTrace(); } } } @Override public Company findById(String id) { SqlSession sqlSession = null; try{ //1.获取SqlSession sqlSession = MapperFactory.getSqlSession(); //2.获取Dao CompanyDao companyDao = MapperFactory.getMapper(sqlSession,CompanyDao.class); //3.调用Dao层操作 return companyDao.findById(id); }catch (Exception e){ throw new RuntimeException(e); //记录日志 }finally { try { TransactionUtil.close(sqlSession); }catch (Exception e){ e.printStackTrace(); } } } @Override public List findAll() { SqlSession sqlSession = null; try{ //1.获取SqlSession sqlSession = MapperFactory.getSqlSession(); //2.获取Dao CompanyDao companyDao = MapperFactory.getMapper(sqlSession,CompanyDao.class); //3.调用Dao层操作 return companyDao.findAll(); }catch (Exception e){ throw new RuntimeException(e); //记录日志 }finally { try { TransactionUtil.close(sqlSession); }catch (Exception e){ e.printStackTrace(); } } } @Override public PageInfo findAll(int page, int size) { SqlSession sqlSession = null; try{ //1.获取SqlSession sqlSession = MapperFactory.getSqlSession(); //2.获取Dao CompanyDao companyDao = MapperFactory.getMapper(sqlSession,CompanyDao.class); //3.调用Dao层操作 PageHelper.startPage(page,size); List all = companyDao.findAll(); PageInfo pageInfo = new PageInfo(all); return pageInfo; }catch (Exception e){ throw new RuntimeException(e); //记录日志 }finally { try { TransactionUtil.close(sqlSession); }catch (Exception e){ e.printStackTrace(); } } } } 3：创建测试类，对业务层方法依次测试，在测试包下创建：com.itheima.service.store.CompanyServiceTest public class CompanyServiceTest { private static CompanyService companyService = null; @BeforeClass public static void init(){ companyService = new CompanyServiceImpl(); } @Test public void testSave(){ Company company = new Company(); company.setName(\"测试数据\"); companyService.save(company); } @Test public void testFindAll(){ PageInfo all = companyService.findAll(1, 100); System.out.println(all); } @AfterClass public static void destory(){ companyService = null; } } 1.4.3. 3.3 表现层列表功能 功能分析： 1：在今日课程资料中找到：模块页面--------->company下的所有页面----->拷贝并添加到项目webapp\\pages\\store\\company目录下，当然后两级目录需要自己新建 2：在webapp/pages/home/aside.jsp中找到企业管理，修改对应的连接为${ctx}/pages/store/company/list.jsp 3：在项目中创建目录：webapp/pages/common，从今日课程给大家提供的模块页面中找到：公共页面，将里面的jsp拷贝到刚刚创建好的common目录中 4：创建Servlet：com.itheima.web.controller.store.company.CompanyServlet // uri:/store/company?operation=list @WebServlet(\"/store/company\") public class CompanyServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { String operation = request.getParameter(\"operation\"); if(\"list\".equals(operation)){ CompanyService companyService = new CompanyServiceImpl(); PageInfo all = companyService.findAll(1, 100); //将数据保存到指定的位置 request.setAttribute(\"page\",all); //跳转页面 request.getRequestDispatcher(\"/WEB-INF/pages/store/company/list.jsp\").forward(request,response); }else if(\"list\".equals(operation)){ }else if(\"list\".equals(operation)){ }else if(\"list\".equals(operation)){ }else if(\"list\".equals(operation)){ }else if(\"list\".equals(operation)){ } } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doGet(request,response); } } 5：将项目webapp下的pages目录拷贝到WEB-INF目录，并删除home目录，然后删除原本webapp/pages目录下的common及store目录 6：找到webapp/pages/home/aside.jsp中的企业管理，修改连接为${ctx}/store/company?operation=list 7：在页面中进行数据渲染，找到WEB-INF/pages/store/compay/list.jsp，填充数据区，注意页面中已经写好了 企业名称 所在地 地址 企业法人 联系方式 所属行业 状态 操作 ${item.name} ${item.city} ${item.address} ${item.representative} ${item.phone} ${item.industry} ${item.state ==0?'未审核':'已审核'} 编辑 8：优化doGost方法，添加分页控制 @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { String operation = request.getParameter(\"operation\"); if(\"list\".equals(operation)){ CompanyService companyService = new CompanyServiceImpl(); int page = 1; int size = 5; if(StringUtils.isNotBlank(request.getParameter(\"page\"))){ page = Integer.parseInt(request.getParameter(\"page\")); } if(StringUtils.isNotBlank(request.getParameter(\"size\"))){ size = Integer.parseInt(request.getParameter(\"size\")); } PageInfo all = companyService.findAll(page, size); //将数据保存到指定的位置 request.setAttribute(\"page\",all); //跳转页面 request.getRequestDispatcher(\"/WEB-INF/pages/store/company/list.jsp\").forward(request,response); }else if(\"list\".equals(operation)){ }else if(\"list\".equals(operation)){ }else if(\"list\".equals(operation)){ }else if(\"list\".equals(operation)){ }else if(\"list\".equals(operation)){ } } 1.4.4. 3.4 表现层添加功能 1：为了应对更多的方法，我们进行方法抽取 // uri:/store/company?operation=list @WebServlet(\"/store/company\") public class CompanyServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { String operation = request.getParameter(\"operation\"); if(\"list\".equals(operation)){ this.list(request,response); }else if(\"toAdd\".equals(operation)){ this.toAdd(request,response); }else if(\"save\".equals(operation)){ this.save(request, response); } } private void list(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException { //进入列表页 //获取数据 CompanyService companyService = new CompanyServiceImpl(); int page = 1; int size = 5; if(StringUtils.isNotBlank(request.getParameter(\"page\"))){ page = Integer.parseInt(request.getParameter(\"page\")); } if(StringUtils.isNotBlank(request.getParameter(\"size\"))){ size = Integer.parseInt(request.getParameter(\"size\")); } PageInfo all = companyService.findAll(page, size); //将数据保存到指定的位置 request.setAttribute(\"page\",all); //跳转页面 request.getRequestDispatcher(\"/WEB-INF/pages/store/company/list.jsp\").forward(request,response); } private void toAdd(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException { //跳转页面 request.getRequestDispatcher(\"/WEB-INF/pages/store/company/add.jsp\").forward(request,response); } private void save(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException { } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doGet(request,response); } } 2：编辑/WEB-INF/pages/store/company/add.jsp页面（无需修改） 3：从课程资料中找到：web层资源文件，在里面找到：BeanUtil.java拷贝到项目utils包下 4：编写save方法，完成数据的保存 private void save(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException { //将数据获取到，封装成一个对象 Company company = BeanUtil.fillBean(request,Company.class,\"yyyy-MM-dd\"); //调用业务层接口save CompanyService companyService = new CompanyServiceImpl(); companyService.save(company); //跳转回到页面list //list(request,response); response.sendRedirect(request.getContextPath()+\"/store/company?operation=list\"); } 1.4.5. 3.5 表现层删除修改功能 修改和保存差异不大，一个是做save，一个是做update， 1：在doGet方法添加去到修改页面和真正修改的两个方法 @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { String operation = request.getParameter(\"operation\"); if(\"list\".equals(operation)){ this.list(request,response); }else if(\"toAdd\".equals(operation)){ this.toAdd(request,response); }else if(\"save\".equals(operation)){ this.save(request, response); }else if(\"toEdit\".equals(operation)){ this.toEdit(request,response); }else if(\"edit\".equals(operation)){ this.edit(request,response); } } private void toEdit(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //查询要修改的数据findById String id = request.getParameter(\"id\"); CompanyService companyService = new CompanyServiceImpl(); Company company = companyService.findById(id); //将数据加载到指定区域，供页面获取 request.setAttribute(\"company\",company); //跳转页面 request.getRequestDispatcher(\"/WEB-INF/pages/store/company/update.jsp\").forward(request,response); } private void edit(HttpServletRequest request, HttpServletResponse response) throws IOException { //将数据获取到，封装成一个对象 Company company = BeanUtil.fillBean(request,Company.class,\"yyyy-MM-dd\"); //调用业务层接口save CompanyService companyService = new CompanyServiceImpl(); companyService.update(company); //跳转回到页面list //list(request,response); response.sendRedirect(request.getContextPath()+\"/store/company?operation=list\"); } 2：删除功能后台相对简单，主要是前台对要删除数据的id如何获取，对于后台，在doGet方法中添加对删除操作的判断，并添加删除方法 @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { String operation = request.getParameter(\"operation\"); if(\"list\".equals(operation)){ this.list(request,response); }else if(\"toAdd\".equals(operation)){ this.toAdd(request,response); }else if(\"save\".equals(operation)){ this.save(request, response); }else if(\"toEdit\".equals(operation)){ this.toEdit(request,response); }else if(\"edit\".equals(operation)){ this.edit(request,response); }else if(\"delete\".equals(operation)){ this.delete(request,response); } } private void delete(HttpServletRequest request, HttpServletResponse response) throws IOException { //将数据获取到，封装成一个对象 Company company = BeanUtil.fillBean(request,Company.class); //调用业务层接口save // CompanyService companyService = new CompanyServiceImpl(); companyService.delete(company); //跳转回到页面list //list(request,response); response.sendRedirect(request.getContextPath()+\"/store/company?operation=list\"); } 3：代码优化，在所有的操作方法中我们要调用业务层，我们都要去创建业务层对象，每个方法中都去创建略显复杂，怎么办？ 创建一个BaseServlet：com.itheima.web.controller.BaseServlet public class BaseServlet extends HttpServlet { protected CompanyService companyService; @Override public void init() throws ServletException { companyService = new CompanyServiceImpl(); } } 4：修改CompanyServlet让其继承自BaseServlet，然后在各个方法中注释掉业务层对象创建的代码，完整的CompanyServlet如下 // uri:/store/company?operation=list @WebServlet(\"/store/company\") public class CompanyServlet extends BaseServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { String operation = request.getParameter(\"operation\"); if(\"list\".equals(operation)){ this.list(request,response); }else if(\"toAdd\".equals(operation)){ this.toAdd(request,response); }else if(\"save\".equals(operation)){ this.save(request, response); }else if(\"toEdit\".equals(operation)){ this.toEdit(request,response); }else if(\"edit\".equals(operation)){ this.edit(request,response); }else if(\"delete\".equals(operation)){ this.delete(request,response); } } private void list(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException { //进入列表页 //获取数据 // CompanyService companyService = new CompanyServiceImpl(); int page = 1; int size = 5; if(StringUtils.isNotBlank(request.getParameter(\"page\"))){ page = Integer.parseInt(request.getParameter(\"page\")); } if(StringUtils.isNotBlank(request.getParameter(\"size\"))){ size = Integer.parseInt(request.getParameter(\"size\")); } PageInfo all = companyService.findAll(page, size); //将数据保存到指定的位置 request.setAttribute(\"page\",all); //跳转页面 request.getRequestDispatcher(\"/WEB-INF/pages/store/company/list.jsp\").forward(request,response); } private void toAdd(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException { //跳转页面 request.getRequestDispatcher(\"/WEB-INF/pages/store/company/add.jsp\").forward(request,response); } private void save(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException { //将数据获取到，封装成一个对象 Company company = BeanUtil.fillBean(request,Company.class,\"yyyy-MM-dd\"); //调用业务层接口save // CompanyService companyService = new CompanyServiceImpl(); companyService.save(company); //跳转回到页面list //list(request,response); response.sendRedirect(request.getContextPath()+\"/store/company?operation=list\"); } private void toEdit(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //查询要修改的数据findById String id = request.getParameter(\"id\"); // CompanyService companyService = new CompanyServiceImpl(); Company company = companyService.findById(id); //将数据加载到指定区域，供页面获取 request.setAttribute(\"company\",company); //跳转页面 request.getRequestDispatcher(\"/WEB-INF/pages/store/company/update.jsp\").forward(request,response); } private void edit(HttpServletRequest request, HttpServletResponse response) throws IOException { //将数据获取到，封装成一个对象 Company company = BeanUtil.fillBean(request,Company.class,\"yyyy-MM-dd\"); //调用业务层接口save // CompanyService companyService = new CompanyServiceImpl(); companyService.update(company); //跳转回到页面list //list(request,response); response.sendRedirect(request.getContextPath()+\"/store/company?operation=list\"); } private void delete(HttpServletRequest request, HttpServletResponse response) throws IOException { //将数据获取到，封装成一个对象 Company company = BeanUtil.fillBean(request,Company.class); //调用业务层接口save // CompanyService companyService = new CompanyServiceImpl(); companyService.delete(company); //跳转回到页面list //list(request,response); response.sendRedirect(request.getContextPath()+\"/store/company?operation=list\"); } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doGet(request,response); } } 1.5. 4. 部门模块 对于部门，我们要弄清楚的部门的结构 1.5.1. 4.1 部门模块单表开发 1：创建实体：com.itheima.domain.system.Dept public class Dept { private String id; private String deptName; private String parentId; private Integer state; public String getId() { return id; } public void setId(String id) { this.id = id; } public String getDeptName() { return deptName; } public void setDeptName(String deptName) { this.deptName = deptName; } public String getParentId() { return parentId; } public void setParentId(String parentId) { this.parentId = parentId; } public Integer getState() { return state; } public void setState(Integer state) { this.state = state; } } 2：在src/main/resources下创建目录com/itheima/dao/system，找到课程资料的dao层资源文件\\配置文件\\DeptDao.xml，拷贝到该目录下 3：创建dao接口：com.itheima.dao.system.DeptDao public interface DeptDao { int save(Dept dept); int delete(Dept dept); int update(Dept dept); Dept findById(String id); List findAll(); } 4：创建业务层接口：com.itheima.service.system.DeptService public interface DeptService { /** * 添加 * @param dept * @return */ void save(Dept dept); /** * 删除 * @param dept * @return */ void delete(Dept dept); /** * 修改 * @param dept * @return */ void update(Dept dept); /** * 查询单个 * @param id 查询的条件（id） * @return 查询的结果，单个对象 */ Dept findById(String id); /** * 查询全部的数据 * @return 全部数据的列表对象 */ List findAll(); /** * 分页查询数据 * @param page 页码 * @param size 每页显示的数据总量 * @return */ PageInfo findAll(int page, int size); } 5：创建业务层实现类：com.itheima.service.system.impl.DeptServiceImpl public class DeptServiceImpl implements DeptService { @Override public void save(Dept dept) { SqlSession sqlSession = null; try{ //1.获取SqlSession sqlSession = MapperFactory.getSqlSession(); //2.获取Dao DeptDao deptDao = MapperFactory.getMapper(sqlSession,DeptDao.class); //id使用UUID的生成策略来获取 String id = UUID.randomUUID().toString(); dept.setId(id); //3.调用Dao层操作 deptDao.save(dept); //4.提交事务 TransactionUtil.commit(sqlSession); }catch (Exception e){ TransactionUtil.rollback(sqlSession); throw new RuntimeException(e); //记录日志 }finally { try { TransactionUtil.close(sqlSession); }catch (Exception e){ e.printStackTrace(); } } } @Override public void delete(Dept dept) { SqlSession sqlSession = null; try{ //1.获取SqlSession sqlSession = MapperFactory.getSqlSession(); //2.获取Dao DeptDao deptDao = MapperFactory.getMapper(sqlSession,DeptDao.class); //3.调用Dao层操作 deptDao.delete(dept); //4.提交事务 TransactionUtil.commit(sqlSession); }catch (Exception e){ TransactionUtil.rollback(sqlSession); throw new RuntimeException(e); //记录日志 }finally { try { TransactionUtil.close(sqlSession); }catch (Exception e){ e.printStackTrace(); } } } @Override public void update(Dept dept) { SqlSession sqlSession = null; try{ //1.获取SqlSession sqlSession = MapperFactory.getSqlSession(); //2.获取Dao DeptDao deptDao = MapperFactory.getMapper(sqlSession,DeptDao.class); //3.调用Dao层操作 deptDao.update(dept); //4.提交事务 TransactionUtil.commit(sqlSession); }catch (Exception e){ TransactionUtil.rollback(sqlSession); throw new RuntimeException(e); //记录日志 }finally { try { TransactionUtil.close(sqlSession); }catch (Exception e){ e.printStackTrace(); } } } @Override public Dept findById(String id) { SqlSession sqlSession = null; try{ //1.获取SqlSession sqlSession = MapperFactory.getSqlSession(); //2.获取Dao DeptDao deptDao = MapperFactory.getMapper(sqlSession,DeptDao.class); //3.调用Dao层操作 return deptDao.findById(id); }catch (Exception e){ throw new RuntimeException(e); //记录日志 }finally { try { TransactionUtil.close(sqlSession); }catch (Exception e){ e.printStackTrace(); } } } @Override public List findAll() { SqlSession sqlSession = null; try{ //1.获取SqlSession sqlSession = MapperFactory.getSqlSession(); //2.获取Dao DeptDao deptDao = MapperFactory.getMapper(sqlSession,DeptDao.class); //3.调用Dao层操作 return deptDao.findAll(); }catch (Exception e){ throw new RuntimeException(e); //记录日志 }finally { try { TransactionUtil.close(sqlSession); }catch (Exception e){ e.printStackTrace(); } } } @Override public PageInfo findAll(int page, int size) { SqlSession sqlSession = null; try{ //1.获取SqlSession sqlSession = MapperFactory.getSqlSession(); //2.获取Dao DeptDao deptDao = MapperFactory.getMapper(sqlSession,DeptDao.class); //3.调用Dao层操作 PageHelper.startPage(page,size); List all = deptDao.findAll(); PageInfo pageInfo = new PageInfo(all); return pageInfo; }catch (Exception e){ throw new RuntimeException(e); //记录日志 }finally { try { TransactionUtil.close(sqlSession); }catch (Exception e){ e.printStackTrace(); } } } } 6：创建Servlet：com.itheima.web.controller.system.DeptServlet // uri:/system/dept?operation=list @WebServlet(\"/system/dept\") public class DeptServlet extends BaseServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { String operation = request.getParameter(\"operation\"); if(\"list\".equals(operation)){ this.list(request,response); }else if(\"toAdd\".equals(operation)){ this.toAdd(request,response); }else if(\"save\".equals(operation)){ this.save(request, response); }else if(\"toEdit\".equals(operation)){ this.toEdit(request,response); }else if(\"edit\".equals(operation)){ this.edit(request,response); }else if(\"delete\".equals(operation)){ this.delete(request,response); } } private void list(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException { //进入列表页 //获取数据 int page = 1; int size = 5; if(StringUtils.isNotBlank(request.getParameter(\"page\"))){ page = Integer.parseInt(request.getParameter(\"page\")); } if(StringUtils.isNotBlank(request.getParameter(\"size\"))){ size = Integer.parseInt(request.getParameter(\"size\")); } PageInfo all = deptService.findAll(page, size); //将数据保存到指定的位置 request.setAttribute(\"page\",all); //跳转页面 request.getRequestDispatcher(\"/WEB-INF/pages/system/dept/list.jsp\").forward(request,response); } private void toAdd(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException { //跳转页面 request.getRequestDispatcher(\"/WEB-INF/pages/system/dept/add.jsp\").forward(request,response); } private void save(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException { //将数据获取到，封装成一个对象 Dept dept = BeanUtil.fillBean(request,Dept.class,\"yyyy-MM-dd\"); //调用业务层接口save // DeptService deptService = new DeptServiceImpl(); deptService.save(dept); //跳转回到页面list //list(request,response); response.sendRedirect(request.getContextPath()+\"/system/dept?operation=list\"); } private void toEdit(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //查询要修改的数据findById String id = request.getParameter(\"id\"); // DeptService deptService = new DeptServiceImpl(); Dept dept = deptService.findById(id); //将数据加载到指定区域，供页面获取 request.setAttribute(\"dept\",dept); //跳转页面 request.getRequestDispatcher(\"/WEB-INF/pages/system/dept/update.jsp\").forward(request,response); } private void edit(HttpServletRequest request, HttpServletResponse response) throws IOException { //将数据获取到，封装成一个对象 Dept dept = BeanUtil.fillBean(request,Dept.class,\"yyyy-MM-dd\"); //调用业务层接口save // DeptService deptService = new DeptServiceImpl(); deptService.update(dept); //跳转回到页面list //list(request,response); response.sendRedirect(request.getContextPath()+\"/system/dept?operation=list\"); } private void delete(HttpServletRequest request, HttpServletResponse response) throws IOException { //将数据获取到，封装成一个对象 Dept dept = BeanUtil.fillBean(request,Dept.class); //调用业务层接口save // DeptService deptService = new DeptServiceImpl(); deptService.delete(dept); //跳转回到页面list //list(request,response); response.sendRedirect(request.getContextPath()+\"/system/dept?operation=list\"); } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doGet(request,response); } } 7：在BaseServlet中添加新的代码，如下 public class BaseServlet extends HttpServlet { protected CompanyService companyService; protected DeptService deptService; @Override public void init() throws ServletException { companyService = new CompanyServiceImpl(); deptService = new DeptServiceImpl(); } } 8：创建目录WEB-INF/pages/system/dept，从WEB-INF/pages/store/company/下拷贝add.jsp,list.jsp,update.jsp到该目录中 9：调整上述拷贝过来的list.jsp，修改数据表格部分 部门名称 所属部门 状态 操作 ${dept.deptName } ${dept.parent.deptName } ${dept.state ==0?'未启用':'使用中'} 编辑 了解了如何去修改这些页面后，为方便我们的开发：从今日的课程资料中找到：模块页面\\dept下的所有页面，用他们替换WEB-INF/pages/system/dept下的这些页面即可 1.5.2. 4.2 部门自连接 1：在实体中添加自关联的字段，parent public class Dept { private String id; private String deptName; private String parentId; private Integer state; private Dept parent; public Dept getParent() { return parent; } public void setParent(Dept parent) { this.parent = parent; } //-------其他get/set方法略 } 2：修改映射配置，找到src/main/resources/com/itheima/dao/system/DeptDao.xml，添加关联映射 3：新建的时候要查询所有部门数据，装载到页面上 找到：DeptServlet中的toAdd方法，添加查询部门信息的代码 private void toAdd(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException { //加载所有的部门信息放入到deptList List all = deptService.findAll(); request.setAttribute(\"deptList\",all); //跳转页面 request.getRequestDispatcher(\"/WEB-INF/pages/system/dept/add.jsp\").forward(request,response); } 4：同理找到DeptServlet中的toEdit方法，添加查询部门信息的代码 private void toEdit(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //查询要修改的数据findById String id = request.getParameter(\"id\"); // DeptService deptService = new DeptServiceImpl(); Dept dept = deptService.findById(id); //加载所有的部门信息放入到deptList List all = deptService.findAll(); request.setAttribute(\"deptList\",all); //将数据加载到指定区域，供页面获取 request.setAttribute(\"dept\",dept); //跳转页面 request.getRequestDispatcher(\"/WEB-INF/pages/system/dept/update.jsp\").forward(request,response); } 1.6. 5. 用户模块 1：创建实体：com.itheima.domain.system.User public class User { private String id; private String email; //邮箱 private String userName; //姓名 private String password; //密码 private Long state; //状态 private String gender; //性别 private String telephone; //电话 private Date birthday; //出生年月 private Date joinDate; //入职时间 private String deptId; //部门id private Dept dept; public Dept getDept() { return dept; } @Override public String toString() { return \"User{\" + \"id='\" + id + '\\'' + \", email='\" + email + '\\'' + \", userName='\" + userName + '\\'' + \", password='\" + password + '\\'' + \", state=\" + state + \", gender='\" + gender + '\\'' + \", telephone='\" + telephone + '\\'' + \", birthday=\" + birthday + \", joinDate=\" + joinDate + \", deptId='\" + deptId + '\\'' + \", dept=\" + dept + '}'; } //---------get/set方法略 } 2：创建dao接口：com.itheima.dao.system.UserDao public interface UserDao { int save(User user); int delete(User user); int update(User user); User findById(String id); List findAll(); } 3：添加映射配置文件，从今日课程中找到：dao层资源文件\\配置文件\\UserDao.xml，拷贝到项目中src/main/resources/com/itheima/dao/system/目录下 4：创建业务层接口：com.itheima.service.system.UserService public interface UserService { /** * 添加 * @param user * @return */ void save(User user); /** * 删除 * @param user * @return */ void delete(User user); /** * 修改 * @param user * @return */ void update(User user); /** * 查询单个 * @param id 查询的条件（id） * @return 查询的结果，单个对象 */ User findById(String id); /** * 查询全部的数据 * @return 全部数据的列表对象 */ List findAll(); /** * 分页查询数据 * @param page 页码 * @param size 每页显示的数据总量 * @return */ PageInfo findAll(int page, int size); } 5：创建业务层实现类：com.itheima.service.system.impl.UserServiceImpl public class UserServiceImpl implements UserService { @Override public void save(User user) { SqlSession sqlSession = null; try{ //1.获取SqlSession sqlSession = MapperFactory.getSqlSession(); //2.获取Dao UserDao userDao = MapperFactory.getMapper(sqlSession,UserDao.class); //id使用UUID的生成策略来获取 String id = UUID.randomUUID().toString(); user.setId(id); //3.调用Dao层操作 userDao.save(user); //4.提交事务 TransactionUtil.commit(sqlSession); }catch (Exception e){ TransactionUtil.rollback(sqlSession); throw new RuntimeException(e); //记录日志 }finally { try { TransactionUtil.close(sqlSession); }catch (Exception e){ e.printStackTrace(); } } } @Override public void delete(User user) { SqlSession sqlSession = null; try{ //1.获取SqlSession sqlSession = MapperFactory.getSqlSession(); //2.获取Dao UserDao userDao = MapperFactory.getMapper(sqlSession,UserDao.class); //3.调用Dao层操作 userDao.delete(user); //4.提交事务 TransactionUtil.commit(sqlSession); }catch (Exception e){ TransactionUtil.rollback(sqlSession); throw new RuntimeException(e); //记录日志 }finally { try { TransactionUtil.close(sqlSession); }catch (Exception e){ e.printStackTrace(); } } } @Override public void update(User user) { SqlSession sqlSession = null; try{ //1.获取SqlSession sqlSession = MapperFactory.getSqlSession(); //2.获取Dao UserDao userDao = MapperFactory.getMapper(sqlSession,UserDao.class); //3.调用Dao层操作 userDao.update(user); //4.提交事务 TransactionUtil.commit(sqlSession); }catch (Exception e){ TransactionUtil.rollback(sqlSession); throw new RuntimeException(e); //记录日志 }finally { try { TransactionUtil.close(sqlSession); }catch (Exception e){ e.printStackTrace(); } } } @Override public User findById(String id) { SqlSession sqlSession = null; try{ //1.获取SqlSession sqlSession = MapperFactory.getSqlSession(); //2.获取Dao UserDao userDao = MapperFactory.getMapper(sqlSession,UserDao.class); //3.调用Dao层操作 return userDao.findById(id); }catch (Exception e){ throw new RuntimeException(e); //记录日志 }finally { try { TransactionUtil.close(sqlSession); }catch (Exception e){ e.printStackTrace(); } } } @Override public List findAll() { SqlSession sqlSession = null; try{ //1.获取SqlSession sqlSession = MapperFactory.getSqlSession(); //2.获取Dao UserDao userDao = MapperFactory.getMapper(sqlSession,UserDao.class); //3.调用Dao层操作 return userDao.findAll(); }catch (Exception e){ throw new RuntimeException(e); //记录日志 }finally { try { TransactionUtil.close(sqlSession); }catch (Exception e){ e.printStackTrace(); } } } @Override public PageInfo findAll(int page, int size) { SqlSession sqlSession = null; try{ //1.获取SqlSession sqlSession = MapperFactory.getSqlSession(); //2.获取Dao UserDao userDao = MapperFactory.getMapper(sqlSession,UserDao.class); //3.调用Dao层操作 PageHelper.startPage(page,size); List all = userDao.findAll(); PageInfo pageInfo = new PageInfo(all); return pageInfo; }catch (Exception e){ throw new RuntimeException(e); //记录日志 }finally { try { TransactionUtil.close(sqlSession); }catch (Exception e){ e.printStackTrace(); } } } } 6：创建servlet：com.itheima.web.controller.system.UserServlet // uri:/system/user?operation=list @WebServlet(\"/system/user\") public class UserServlet extends BaseServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { String operation = request.getParameter(\"operation\"); if(\"list\".equals(operation)){ this.list(request,response); }else if(\"toAdd\".equals(operation)){ this.toAdd(request,response); }else if(\"save\".equals(operation)){ this.save(request, response); }else if(\"toEdit\".equals(operation)){ this.toEdit(request,response); }else if(\"edit\".equals(operation)){ this.edit(request,response); }else if(\"delete\".equals(operation)){ this.delete(request,response); } } private void list(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException { //进入列表页 //获取数据 // UserService userService = new UserServiceImpl(); int page = 1; int size = 5; if(StringUtils.isNotBlank(request.getParameter(\"page\"))){ page = Integer.parseInt(request.getParameter(\"page\")); } if(StringUtils.isNotBlank(request.getParameter(\"size\"))){ size = Integer.parseInt(request.getParameter(\"size\")); } PageInfo all = userService.findAll(page, size); //将数据保存到指定的位置 request.setAttribute(\"page\",all); //跳转页面 request.getRequestDispatcher(\"/WEB-INF/pages/system/user/list.jsp\").forward(request,response); } private void toAdd(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException { //跳转页面 request.getRequestDispatcher(\"/WEB-INF/pages/system/user/add.jsp\").forward(request,response); } private void save(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException { //将数据获取到，封装成一个对象 User user = BeanUtil.fillBean(request,User.class,\"yyyy-MM-dd\"); //调用业务层接口save userService.save(user); //跳转回到页面list response.sendRedirect(request.getContextPath()+\"/system/user?operation=list\"); } private void toEdit(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //查询要修改的数据findById String id = request.getParameter(\"id\"); User user = userService.findById(id); //将数据加载到指定区域，供页面获取 request.setAttribute(\"user\",user); //查询部门信息 List all = deptService.findAll(); //放入指定位置 request.setAttribute(\"deptList\",all); //跳转页面 request.getRequestDispatcher(\"/WEB-INF/pages/system/user/update.jsp\").forward(request,response); } private void edit(HttpServletRequest request, HttpServletResponse response) throws IOException { //将数据获取到，封装成一个对象 User user = BeanUtil.fillBean(request,User.class,\"yyyy-MM-dd\"); //调用业务层接口save userService.update(user); //跳转回到页面list response.sendRedirect(request.getContextPath()+\"/system/user?operation=list\"); } private void delete(HttpServletRequest request, HttpServletResponse response) throws IOException { //将数据获取到，封装成一个对象 User user = BeanUtil.fillBean(request,User.class); //调用业务层接口save userService.delete(user); //跳转回到页面list response.sendRedirect(request.getContextPath()+\"/system/user?operation=list\"); } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doGet(request,response); } } 7：修改BaseServlet public class BaseServlet extends HttpServlet { protected CompanyService companyService; protected DeptService deptService; protected UserService userService; @Override public void init() throws ServletException { companyService = new CompanyServiceImpl(); deptService = new DeptServiceImpl(); userService = new UserServiceImpl(); } } 8：创建WEB-INF/pages/user，然后从今日课程资料中找到模块页面\\user下的所有页面，拷贝到该目录 注意：在此处希望大家是自行的拷贝之前dept的页面然后自己修改 9：新建功能时，去新建页面时需要查询部门信息，修改toAdd方法 private void toAdd(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException { //查询部门信息 List all = deptService.findAll(); //放入指定位置 request.setAttribute(\"deptList\",all); //跳转页面 request.getRequestDispatcher(\"/WEB-INF/pages/system/user/add.jsp\").forward(request,response); } 10：新建用户时，用户的密码需要加密 从今日课程资料中找到：service层资源文件/MD5Util.java拷贝到项目utils包下 11：修改业务层代码，找到：save方法，给密码加密完成后再存入数据库 @Override public void save(User user) { SqlSession sqlSession = null; try{ //1.获取SqlSession sqlSession = MapperFactory.getSqlSession(); //2.获取Dao UserDao userDao = MapperFactory.getMapper(sqlSession,UserDao.class); //id使用UUID的生成策略来获取 String id = UUID.randomUUID().toString(); user.setId(id); //密码必须经过加密处理MD5加密 user.setPassword(MD5Util.md5(user.getPassword())); //3.调用Dao层操作 userDao.save(user); //4.提交事务 TransactionUtil.commit(sqlSession); }catch (Exception e){ TransactionUtil.rollback(sqlSession); throw new RuntimeException(e); //记录日志 }finally { try { TransactionUtil.close(sqlSession); }catch (Exception e){ e.printStackTrace(); } } } 12：修改时，在去修改页面是，需要加载部门信息，找到UseServlet的toEdit方法， private void toEdit(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //查询要修改的数据findById String id = request.getParameter(\"id\"); User user = userService.findById(id); //将数据加载到指定区域，供页面获取 request.setAttribute(\"user\",user); //查询部门信息 List all = deptService.findAll(); //放入指定位置 request.setAttribute(\"deptList\",all); //跳转页面 request.getRequestDispatcher(\"/WEB-INF/pages/system/user/update.jsp\").forward(request,response); } 13：真正在修改时，我们需要在业务层做一些处理，找到用户的业务层实现类，修改update方法 @Override public void update(User user) { SqlSession sqlSession = null; try{ //1.获取SqlSession sqlSession = MapperFactory.getSqlSession(); //2.获取Dao UserDao userDao = MapperFactory.getMapper(sqlSession,UserDao.class); //方案1：读取现有库中的信息，覆盖现有的数据 //方案2：修改update语句 System.out.println(user); //3.调用Dao层操作 userDao.update(user); //4.提交事务 TransactionUtil.commit(sqlSession); }catch (Exception e){ TransactionUtil.rollback(sqlSession); throw new RuntimeException(e); //记录日志 }finally { try { TransactionUtil.close(sqlSession); }catch (Exception e){ e.printStackTrace(); } } } 我们采用方案二：找到用户对应的xml配置文件：UserDao.XML，找到update标签，做出修改 update ss_user set user_name = #{userName,jdbcType=VARCHAR}, state = #{state,jdbcType=DECIMAL}, gender = #{gender,jdbcType=CHAR}, telephone = #{telephone,jdbcType=VARCHAR}, dept_id = #{deptId,jdbcType=VARCHAR} where user_id = #{id,jdbcType=VARCHAR} Copyright © MISIN 2022 | 豫ICP备2021006345号-1 all right reserved，powered by Gitbook该文件修订时间： 2022-11-10 11:12:52 "},"2.JavaWeb/Web综合案例/web综合案例-day02.html":{"url":"2.JavaWeb/Web综合案例/web综合案例-day02.html","title":"web综合案例-day02","keywords":"","body":"1. web综合案例1.1. 学习目标1.2. 1. 数据库设计1.2.1. 1.1 数据库设计范式1.2.2. 1.2 数据库设计工具1.3. 2. 学科模块快速开发1.4. 3. 目录模块1.5. 4. 题目模块1.5.1. 4.1 题目模块快速开发1.5.2. 4.2 文件上传基础演示1.5.3. 4.3 添加题目时加入文件上传1.5.4. 4.4 文件上传的重名问题1.5.5. 4.5 修改题目时加入文件上传1.5.6. 4.6 兼容图片上传可选操作与显示问题1.6. 5. 题目选项模块1.6.1. 5.1 列表页制作1.6.2. 5.2 添加功能制作1.6.3. 5.3 删除功能制作1.6.4. 5.4 修改功能制作1.6.5. 5.5 添加修改功能合并1.6.6. 5.6 删除功能相关问题及解决方案1. web综合案例 1.1. 学习目标 目标1：能够说出数据库设计的三种常用范式 目标2：能够使用PD工具进行表结构设计 目标3：完成学科模块的业务开发 目标4：完成目录模块的业务开发 目标5：完成题目模块的业务开发 目标6：能够说出文件上传前台的三要素 目标7：能够完成题目选项模块的业务开发 1.2. 1. 数据库设计 1.2.1. 1.1 数据库设计范式 什么叫数据库设计范式？ 范式：规范的形式，应用于各个行业的标准化 数据库设计中有5种范式，但是常用的分别是：第一范式（1NF）,第二范式（2NF），第三范式（3NF） 第一范式（1NF）：针对数据表中的列，列要具备原子性，不可再拆分 如果数据表这样设计，籍贯这一列不具备原子性，因为数据可再次拆分，不拆分的话无法获取用户的州郡信息或县市信息，拆分之后如下： 第二范式（2NF）：数据表要具备唯一主键，不存在多主键，使得每一行数据具有唯一性 在如图所示的表中：没有哪一个字段（列）能唯一确定一条数据，要想唯一确定一条数据，需要两个或更多的字段，这就违反了第二范式，数据表不具备唯一主键而存在多主键。 那如何来解决呢？在表中加一个唯一主键列：id 第三范式（3NF）：不依赖非主键的字段及更深层次的依赖，使得每个字段都独立依赖于主键字段（独立性） 什么叫依赖：依赖，就是在一个表中，其中某个字段的值B可以由另一个字段值A来决定，那我们称字段B依赖字段A或字段A决定字段B 在如图所示的表结构中：合计列=单价 X 数量，当然这中间还需要依赖商品编号来查询商品单价 总而言之，合计这一列，依赖了表中的非主键字段，以及非主键字段的更深层次的依赖，这表明合计这一列的数据是冗余的，因为我们完全可以通过计算的方式得到合计数据，而不需要在表中来存储。 反三范式：允许少量的数据冗余，提高查询的速度 1.2.2. 1.2 数据库设计工具 PowerDesigner：简称PD，是一款功能强大的建模软件，提供强大的元数据管理功能，可以帮助用户构建关键信息的全方位视图，创建多种类型的模型，包括概念数据模型，物理数据模型，面向对象模型等等，同时集成了数据管理，BI，数据集成和数据整合多种功能。 1.3. 2. 学科模块快速开发 下面我们进行学科模块的快速开发： （1）创建学科实体：com.itheima.domain.store.Course public class Course { private String id; private String name; private String remark; private String state; private Date createTime; // getter/setter略 } （2）创建dao接口：com.itheima.dao.store.CourseDao public interface CourseDao { int save(Course course); int delete(Course course); int update(Course course); Course findById(String id); List findAll(); } （3）从今日课程资料中找到dao层资源文件\\CourseDao.xml，拷贝到项目src/main/resources/com/itheima/dao/store/下 当然这个地方可以将该目录下的所有映射配置文件都拷贝到该目录下，在做后续业务时就无需在拷贝了。 （4）创建业务层接口：com.itheima.service.store.CourseService public interface CourseService { /** * 添加 * @param course * @return */ void save(Course course); /** * 删除 * @param course * @return */ void delete(Course course); /** * 修改 * @param course * @return */ void update(Course course); /** * 查询单个 * @param id 查询的条件（id） * @return 查询的结果，单个对象 */ Course findById(String id); /** * 查询全部的数据 * @return 全部数据的列表对象 */ List findAll(); /** * 分页查询数据 * @param page 页码 * @param size 每页显示的数据总量 * @return */ PageInfo findAll(int page, int size); } （5）创建业务层实现类：com.itheima.service.store.impl.CourseServiceImpl public class CourseServiceImpl implements CourseService { @Override public void save(Course course) { SqlSession sqlSession = null; try{ //1.获取SqlSession sqlSession = MapperFactory.getSqlSession(); //2.获取Dao CourseDao courseDao = MapperFactory.getMapper(sqlSession,CourseDao.class); //id使用UUID的生成策略来获取 String id = UUID.randomUUID().toString(); course.setId(id); //3.调用Dao层操作 courseDao.save(course); //4.提交事务 TransactionUtil.commit(sqlSession); }catch (Exception e){ TransactionUtil.rollback(sqlSession); throw new RuntimeException(e); //记录日志 }finally { try { TransactionUtil.close(sqlSession); }catch (Exception e){ e.printStackTrace(); } } } @Override public void delete(Course course) { SqlSession sqlSession = null; try{ //1.获取SqlSession sqlSession = MapperFactory.getSqlSession(); //2.获取Dao CourseDao courseDao = MapperFactory.getMapper(sqlSession,CourseDao.class); //3.调用Dao层操作 courseDao.delete(course); //4.提交事务 TransactionUtil.commit(sqlSession); }catch (Exception e){ TransactionUtil.rollback(sqlSession); throw new RuntimeException(e); //记录日志 }finally { try { TransactionUtil.close(sqlSession); }catch (Exception e){ e.printStackTrace(); } } } @Override public void update(Course course) { SqlSession sqlSession = null; try{ //1.获取SqlSession sqlSession = MapperFactory.getSqlSession(); //2.获取Dao CourseDao courseDao = MapperFactory.getMapper(sqlSession,CourseDao.class); //3.调用Dao层操作 courseDao.update(course); //4.提交事务 TransactionUtil.commit(sqlSession); }catch (Exception e){ TransactionUtil.rollback(sqlSession); throw new RuntimeException(e); //记录日志 }finally { try { TransactionUtil.close(sqlSession); }catch (Exception e){ e.printStackTrace(); } } } @Override public Course findById(String id) { SqlSession sqlSession = null; try{ //1.获取SqlSession sqlSession = MapperFactory.getSqlSession(); //2.获取Dao CourseDao courseDao = MapperFactory.getMapper(sqlSession,CourseDao.class); //3.调用Dao层操作 return courseDao.findById(id); }catch (Exception e){ throw new RuntimeException(e); //记录日志 }finally { try { TransactionUtil.close(sqlSession); }catch (Exception e){ e.printStackTrace(); } } } @Override public List findAll() { SqlSession sqlSession = null; try{ //1.获取SqlSession sqlSession = MapperFactory.getSqlSession(); //2.获取Dao CourseDao courseDao = MapperFactory.getMapper(sqlSession,CourseDao.class); //3.调用Dao层操作 return courseDao.findAll(); }catch (Exception e){ throw new RuntimeException(e); //记录日志 }finally { try { TransactionUtil.close(sqlSession); }catch (Exception e){ e.printStackTrace(); } } } @Override public PageInfo findAll(int page, int size) { SqlSession sqlSession = null; try{ //1.获取SqlSession sqlSession = MapperFactory.getSqlSession(); //2.获取Dao CourseDao courseDao = MapperFactory.getMapper(sqlSession,CourseDao.class); //3.调用Dao层操作 PageHelper.startPage(page,size); List all = courseDao.findAll(); PageInfo pageInfo = new PageInfo(all); return pageInfo; }catch (Exception e){ throw new RuntimeException(e); //记录日志 }finally { try { TransactionUtil.close(sqlSession); }catch (Exception e){ e.printStackTrace(); } } } } （6）创建servlet：com.itheima.web.controller.store.CourseServlet // uri:/store/course?operation=list @WebServlet(\"/store/course\") public class CourseServlet extends BaseServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { String operation = request.getParameter(\"operation\"); if(\"list\".equals(operation)){ this.list(request,response); }else if(\"toAdd\".equals(operation)){ this.toAdd(request,response); }else if(\"save\".equals(operation)){ this.save(request, response); }else if(\"toEdit\".equals(operation)){ this.toEdit(request,response); }else if(\"edit\".equals(operation)){ this.edit(request,response); }else if(\"delete\".equals(operation)){ this.delete(request,response); } } private void list(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException { //进入列表页 //获取数据 int page = 1; int size = 5; if(StringUtils.isNotBlank(request.getParameter(\"page\"))){ page = Integer.parseInt(request.getParameter(\"page\")); } if(StringUtils.isNotBlank(request.getParameter(\"size\"))){ size = Integer.parseInt(request.getParameter(\"size\")); } PageInfo all = courseService.findAll(page, size); //将数据保存到指定的位置 request.setAttribute(\"page\",all); //跳转页面 request.getRequestDispatcher(\"/WEB-INF/pages/store/course/list.jsp\").forward(request,response); } private void toAdd(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException { //跳转页面 request.getRequestDispatcher(\"/WEB-INF/pages/store/course/add.jsp\").forward(request,response); } private void save(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException { //将数据获取到，封装成一个对象 Course course = BeanUtil.fillBean(request,Course.class,\"yyyy-MM-dd\"); //调用业务层接口save courseService.save(course); //跳转回到页面list response.sendRedirect(request.getContextPath()+\"/store/course?operation=list\"); } private void toEdit(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //查询要修改的数据findById String id = request.getParameter(\"id\"); Course course = courseService.findById(id); //将数据加载到指定区域，供页面获取 request.setAttribute(\"course\",course); //跳转页面 request.getRequestDispatcher(\"/WEB-INF/pages/store/course/update.jsp\").forward(request,response); } private void edit(HttpServletRequest request, HttpServletResponse response) throws IOException { //将数据获取到，封装成一个对象 Course course = BeanUtil.fillBean(request,Course.class,\"yyyy-MM-dd\"); //调用业务层接口save courseService.update(course); //跳转回到页面list response.sendRedirect(request.getContextPath()+\"/store/course?operation=list\"); } private void delete(HttpServletRequest request, HttpServletResponse response) throws IOException { //将数据获取到，封装成一个对象 Course course = BeanUtil.fillBean(request,Course.class); //调用业务层接口save courseService.delete(course); //跳转回到页面list response.sendRedirect(request.getContextPath()+\"/store/course?operation=list\"); } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doGet(request,response); } } （7）修改BaseServlet，添加CourseService public class BaseServlet extends HttpServlet { protected CompanyService companyService; protected DeptService deptService; protected UserService userService; protected CourseService courseService; @Override public void init() throws ServletException { companyService = new CompanyServiceImpl(); deptService = new DeptServiceImpl(); userService = new UserServiceImpl(); courseService = new CourseServiceImpl(); } } （8）创建/WEB-INF/pages/store/course目录，然后从今日课程资料中找到模块页面\\course下的所有页面，拷贝到刚刚创建的目录下 （9）修改业务层的保存方法，添加创建时间的保存 @Override public void save(Course course) { SqlSession sqlSession = null; try{ //1.获取SqlSession sqlSession = MapperFactory.getSqlSession(); //2.获取Dao CourseDao courseDao = MapperFactory.getMapper(sqlSession,CourseDao.class); //id使用UUID的生成策略来获取 String id = UUID.randomUUID().toString(); course.setId(id); //添加创建的时间 course.setCreateTime(new Date()); //3.调用Dao层操作 courseDao.save(course); //4.提交事务 TransactionUtil.commit(sqlSession); }catch (Exception e){ TransactionUtil.rollback(sqlSession); throw new RuntimeException(e); //记录日志 }finally { try { TransactionUtil.close(sqlSession); }catch (Exception e){ e.printStackTrace(); } } } （10）在修改时，我们的创建时间是不允许修改的，因此我们在dao层进行update操作是去掉对创建时间的修改，找到CourseDao对应的持久层映射配置文件CourseDao.xml中的update，去掉创建时间即可 update st_course set name = #{name,jdbcType=VARCHAR}, remark = #{remark,jdbcType=VARCHAR}, state = #{state,jdbcType=VARCHAR} where id = #{id,jdbcType=VARCHAR} （11）解决站点字符编码的问题，从今日课程资料中找到web层资源文件\\CharacterEncodingFilter.java 然后创建一个包com.itheima.web.filters，然后把该文件拷贝到该包下 （12）启动项目进行测试 1.4. 3. 目录模块 （1）创建目录实体：com.itheima.domain.store.Catalog public class Catalog { private String id; private String name; private String remark; private String state; private Date createTime; private String courseId; private Course course; // getter/setter略 } （2）创建dao接口：com.itheima.dao.store.CatalogDao public interface CatalogDao { int save(Catalog catalog); int delete(Catalog catalog); int update(Catalog catalog); Catalog findById(String id); List findAll(); } （3）拷贝dao映射配置文件：前面已完成 （4）创建业务层接口：com.itheima.service.store.CatalogService public interface CatalogService { /** * 添加 * @param catalog * @return */ void save(Catalog catalog); /** * 删除 * @param catalog * @return */ void delete(Catalog catalog); /** * 修改 * @param catalog * @return */ void update(Catalog catalog); /** * 查询单个 * @param id 查询的条件（id） * @return 查询的结果，单个对象 */ Catalog findById(String id); /** * 查询全部的数据 * @return 全部数据的列表对象 */ List findAll(); /** * 分页查询数据 * @param page 页码 * @param size 每页显示的数据总量 * @return */ PageInfo findAll(int page, int size); } （5）创建业务层实现类：com.itheima.service.store.impl.CatalogServiceImpl public class CatalogServiceImpl implements CatalogService { @Override public void save(Catalog catalog) { SqlSession sqlSession = null; try { //1.获取SqlSession sqlSession = MapperFactory.getSqlSession(); //2.获取Dao CatalogDao catalogDao = MapperFactory.getMapper(sqlSession, CatalogDao.class); //id使用UUID的生成策略来获取 String id = UUID.randomUUID().toString(); catalog.setId(id); //3.调用Dao层操作 catalogDao.save(catalog); //4.提交事务 TransactionUtil.commit(sqlSession); } catch (Exception e) { TransactionUtil.rollback(sqlSession); throw new RuntimeException(e); //记录日志 } finally { try { TransactionUtil.close(sqlSession); } catch (Exception e) { e.printStackTrace(); } } } @Override public void delete(Catalog catalog) { SqlSession sqlSession = null; try { //1.获取SqlSession sqlSession = MapperFactory.getSqlSession(); //2.获取Dao CatalogDao catalogDao = MapperFactory.getMapper(sqlSession, CatalogDao.class); //3.调用Dao层操作 catalogDao.delete(catalog); //4.提交事务 TransactionUtil.commit(sqlSession); } catch (Exception e) { TransactionUtil.rollback(sqlSession); throw new RuntimeException(e); //记录日志 } finally { try { TransactionUtil.close(sqlSession); } catch (Exception e) { e.printStackTrace(); } } } @Override public void update(Catalog catalog) { SqlSession sqlSession = null; try { //1.获取SqlSession sqlSession = MapperFactory.getSqlSession(); //2.获取Dao CatalogDao catalogDao = MapperFactory.getMapper(sqlSession, CatalogDao.class); //3.调用Dao层操作 catalogDao.update(catalog); //4.提交事务 TransactionUtil.commit(sqlSession); } catch (Exception e) { TransactionUtil.rollback(sqlSession); throw new RuntimeException(e); //记录日志 } finally { try { TransactionUtil.close(sqlSession); } catch (Exception e) { e.printStackTrace(); } } } @Override public Catalog findById(String id) { SqlSession sqlSession = null; try { //1.获取SqlSession sqlSession = MapperFactory.getSqlSession(); //2.获取Dao CatalogDao catalogDao = MapperFactory.getMapper(sqlSession, CatalogDao.class); //3.调用Dao层操作 return catalogDao.findById(id); } catch (Exception e) { throw new RuntimeException(e); //记录日志 } finally { try { TransactionUtil.close(sqlSession); } catch (Exception e) { e.printStackTrace(); } } } @Override public List findAll() { SqlSession sqlSession = null; try { //1.获取SqlSession sqlSession = MapperFactory.getSqlSession(); //2.获取Dao CatalogDao catalogDao = MapperFactory.getMapper(sqlSession, CatalogDao.class); //3.调用Dao层操作 return catalogDao.findAll(); } catch (Exception e) { throw new RuntimeException(e); //记录日志 } finally { try { TransactionUtil.close(sqlSession); } catch (Exception e) { e.printStackTrace(); } } } @Override public PageInfo findAll(int page, int size) { SqlSession sqlSession = null; try { //1.获取SqlSession sqlSession = MapperFactory.getSqlSession(); //2.获取Dao CatalogDao catalogDao = MapperFactory.getMapper(sqlSession, CatalogDao.class); //3.调用Dao层操作 PageHelper.startPage(page, size); List all = catalogDao.findAll(); PageInfo pageInfo = new PageInfo(all); return pageInfo; } catch (Exception e) { throw new RuntimeException(e); //记录日志 } finally { try { TransactionUtil.close(sqlSession); } catch (Exception e) { e.printStackTrace(); } } } } （6）创建servlet：com.itheima.web.controller.store.CatalogServlet // uri:/store/catalog?operation=list @WebServlet(\"/store/catalog\") public class CatalogServlet extends BaseServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { String operation = request.getParameter(\"operation\"); if(\"list\".equals(operation)){ this.list(request,response); }else if(\"toAdd\".equals(operation)){ this.toAdd(request,response); }else if(\"save\".equals(operation)){ this.save(request, response); }else if(\"toEdit\".equals(operation)){ this.toEdit(request,response); }else if(\"edit\".equals(operation)){ this.edit(request,response); }else if(\"delete\".equals(operation)){ this.delete(request,response); } } private void list(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException { //进入列表页 //获取数据 int page = 1; int size = 5; if(StringUtils.isNotBlank(request.getParameter(\"page\"))){ page = Integer.parseInt(request.getParameter(\"page\")); } if(StringUtils.isNotBlank(request.getParameter(\"size\"))){ size = Integer.parseInt(request.getParameter(\"size\")); } PageInfo all = catalogService.findAll(page, size); //将数据保存到指定的位置 request.setAttribute(\"page\",all); //跳转页面 request.getRequestDispatcher(\"/WEB-INF/pages/store/catalog/list.jsp\").forward(request,response); } private void toAdd(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException { //跳转页面 request.getRequestDispatcher(\"/WEB-INF/pages/store/catalog/add.jsp\").forward(request,response); } private void save(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException { //将数据获取到，封装成一个对象 Catalog catalog = BeanUtil.fillBean(request,Catalog.class,\"yyyy-MM-dd\"); //调用业务层接口save catalogService.save(catalog); //跳转回到页面list response.sendRedirect(request.getContextPath()+\"/store/catalog?operation=list\"); } private void toEdit(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //查询要修改的数据findById String id = request.getParameter(\"id\"); Catalog catalog = catalogService.findById(id); //将数据加载到指定区域，供页面获取 request.setAttribute(\"catalog\",catalog); //跳转页面 request.getRequestDispatcher(\"/WEB-INF/pages/store/catalog/update.jsp\").forward(request,response); } private void edit(HttpServletRequest request, HttpServletResponse response) throws IOException { //将数据获取到，封装成一个对象 Catalog catalog = BeanUtil.fillBean(request,Catalog.class,\"yyyy-MM-dd\"); //调用业务层接口save catalogService.update(catalog); //跳转回到页面list response.sendRedirect(request.getContextPath()+\"/store/catalog?operation=list\"); } private void delete(HttpServletRequest request, HttpServletResponse response) throws IOException { //将数据获取到，封装成一个对象 Catalog catalog = BeanUtil.fillBean(request,Catalog.class); //调用业务层接口save catalogService.delete(catalog); //跳转回到页面list response.sendRedirect(request.getContextPath()+\"/store/catalog?operation=list\"); } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doGet(request,response); } } （7）修改BaseServlet，添加CatalogService public class BaseServlet extends HttpServlet { protected CompanyService companyService; protected DeptService deptService; protected UserService userService; protected CourseService courseService; protected CatalogService catalogService; @Override public void init() throws ServletException { companyService = new CompanyServiceImpl(); deptService = new DeptServiceImpl(); userService = new UserServiceImpl(); courseService = new CourseServiceImpl(); catalogService = new CatalogServiceImpl(); } } （8）创建页面存放目录/WEB-INF/pages/store/catalog，然后从今日课程资料中找到模块页面\\catalog下的所有页面到该目录 （9）修改servlet代码，找到toAdd方法，在去添加页面之前查询所有的学科数据 private void toAdd(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException { //加载学科信息 List all = courseService.findAll(); request.setAttribute(\"courseList\",all); //跳转页面 request.getRequestDispatcher(\"/WEB-INF/pages/store/catalog/add.jsp\").forward(request,response); } （10）保存目录的时候要保存创建时间，修改业务层的save方法，添加对创建时间的保存 @Override public void save(Catalog catalog) { SqlSession sqlSession = null; try { //1.获取SqlSession sqlSession = MapperFactory.getSqlSession(); //2.获取Dao CatalogDao catalogDao = MapperFactory.getMapper(sqlSession, CatalogDao.class); //id使用UUID的生成策略来获取 String id = UUID.randomUUID().toString(); catalog.setId(id); catalog.setCreateTime(new Date()); //3.调用Dao层操作 catalogDao.save(catalog); //4.提交事务 TransactionUtil.commit(sqlSession); } catch (Exception e) { TransactionUtil.rollback(sqlSession); throw new RuntimeException(e); //记录日志 } finally { try { TransactionUtil.close(sqlSession); } catch (Exception e) { e.printStackTrace(); } } } （11）修改servlet代码，找到toEdit方法，去到编辑页面之前查询所有的学科信息， private void toEdit(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //查询要修改的数据findById String id = request.getParameter(\"id\"); Catalog catalog = catalogService.findById(id); //将数据加载到指定区域，供页面获取 request.setAttribute(\"catalog\",catalog); //加载学科信息 List all = courseService.findAll(); request.setAttribute(\"courseList\",all); //跳转页面 request.getRequestDispatcher(\"/WEB-INF/pages/store/catalog/update.jsp\").forward(request,response); } （12）启动项目，进行测试 1.5. 4. 题目模块 1.5.1. 4.1 题目模块快速开发 （1）创建题目实体：com.itheima.domain.store.Question public class Question { private String id; //题目ID private String companyId; //所属企业 private String catalogId; //题目所属目录ID private String remark; //题目简介 private String subject; //题干 private String analysis; //题目分析 private String type; //题目类型 1:单选，2：多选，3：简答 private String difficulty; //难易程度： 1极易 2容易 3普通 4困难 5极难 private String isClassic; //是否经典面试题 0：否 1：是 private String state; //题目状态 0：不可用 1：可用（只有审核通过的题目才可以设置） private String reviewStatus;//审核状态 -1 审核不通过 0 审核中 1 审核通过 private Date createTime; private Company company; private Catalog catalog; // getter/setter 略 } （2）创建dao接口：com.itheima.dao.store.QuestionDao public interface QuestionDao { int save(Question question); int delete(Question question); int update(Question question); Question findById(String id); List findAll(); } （3）添加题目dao的映射配置文件，之前已操作，略 （4）创建业务层接口：com.itheima.service.store.QuestionService public interface QuestionService { /** * 添加 * @param question * @return */ void save(Question question); /** * 删除 * @param question * @return */ void delete(Question question); /** * 修改 * @param question * @return */ void update(Question question); /** * 查询单个 * @param id 查询的条件（id） * @return 查询的结果，单个对象 */ Question findById(String id); /** * 查询全部的数据 * @return 全部数据的列表对象 */ List findAll(); /** * 分页查询数据 * @param page 页码 * @param size 每页显示的数据总量 * @return */ PageInfo findAll(int page, int size); } （5）创建业务层实现类：com.itheima.service.store.impl.QuestionServiceImpl public class QuestionServiceImpl implements QuestionService { @Override public void save(Question question) { SqlSession sqlSession = null; try{ //1.获取SqlSession sqlSession = MapperFactory.getSqlSession(); //2.获取Dao QuestionDao questionDao = MapperFactory.getMapper(sqlSession,QuestionDao.class); //id使用UUID的生成策略来获取 String id = UUID.randomUUID().toString(); question.setId(id); //3.调用Dao层操作 questionDao.save(question); //4.提交事务 TransactionUtil.commit(sqlSession); }catch (Exception e){ TransactionUtil.rollback(sqlSession); throw new RuntimeException(e); //记录日志 }finally { try { TransactionUtil.close(sqlSession); }catch (Exception e){ e.printStackTrace(); } } } @Override public void delete(Question question) { SqlSession sqlSession = null; try{ //1.获取SqlSession sqlSession = MapperFactory.getSqlSession(); //2.获取Dao QuestionDao questionDao = MapperFactory.getMapper(sqlSession,QuestionDao.class); //3.调用Dao层操作 questionDao.delete(question); //4.提交事务 TransactionUtil.commit(sqlSession); }catch (Exception e){ TransactionUtil.rollback(sqlSession); throw new RuntimeException(e); //记录日志 }finally { try { TransactionUtil.close(sqlSession); }catch (Exception e){ e.printStackTrace(); } } } @Override public void update(Question question) { SqlSession sqlSession = null; try{ //1.获取SqlSession sqlSession = MapperFactory.getSqlSession(); //2.获取Dao QuestionDao questionDao = MapperFactory.getMapper(sqlSession,QuestionDao.class); //3.调用Dao层操作 questionDao.update(question); //4.提交事务 TransactionUtil.commit(sqlSession); }catch (Exception e){ TransactionUtil.rollback(sqlSession); throw new RuntimeException(e); //记录日志 }finally { try { TransactionUtil.close(sqlSession); }catch (Exception e){ e.printStackTrace(); } } } @Override public Question findById(String id) { SqlSession sqlSession = null; try{ //1.获取SqlSession sqlSession = MapperFactory.getSqlSession(); //2.获取Dao QuestionDao questionDao = MapperFactory.getMapper(sqlSession,QuestionDao.class); //3.调用Dao层操作 return questionDao.findById(id); }catch (Exception e){ throw new RuntimeException(e); //记录日志 }finally { try { TransactionUtil.close(sqlSession); }catch (Exception e){ e.printStackTrace(); } } } @Override public List findAll() { SqlSession sqlSession = null; try{ //1.获取SqlSession sqlSession = MapperFactory.getSqlSession(); //2.获取Dao QuestionDao questionDao = MapperFactory.getMapper(sqlSession,QuestionDao.class); //3.调用Dao层操作 return questionDao.findAll(); }catch (Exception e){ throw new RuntimeException(e); //记录日志 }finally { try { TransactionUtil.close(sqlSession); }catch (Exception e){ e.printStackTrace(); } } } @Override public PageInfo findAll(int page, int size) { SqlSession sqlSession = null; try{ //1.获取SqlSession sqlSession = MapperFactory.getSqlSession(); //2.获取Dao QuestionDao questionDao = MapperFactory.getMapper(sqlSession,QuestionDao.class); //3.调用Dao层操作 PageHelper.startPage(page,size); List all = questionDao.findAll(); PageInfo pageInfo = new PageInfo(all); return pageInfo; }catch (Exception e){ throw new RuntimeException(e); //记录日志 }finally { try { TransactionUtil.close(sqlSession); }catch (Exception e){ e.printStackTrace(); } } } } （6）创建servlet：com.itheima.web.controller.store.QuestionServlet // uri:/store/question?operation=list @WebServlet(\"/store/question\") public class QuestionServlet extends BaseServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { String operation = request.getParameter(\"operation\"); if(\"list\".equals(operation)){ this.list(request,response); }else if(\"toAdd\".equals(operation)){ this.toAdd(request,response); }else if(\"save\".equals(operation)){ this.save(request, response); }else if(\"toEdit\".equals(operation)){ this.toEdit(request,response); }else if(\"edit\".equals(operation)){ this.edit(request,response); }else if(\"delete\".equals(operation)){ this.delete(request,response); } } private void list(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException { //进入列表页 //获取数据 int page = 1; int size = 5; if(StringUtils.isNotBlank(request.getParameter(\"page\"))){ page = Integer.parseInt(request.getParameter(\"page\")); } if(StringUtils.isNotBlank(request.getParameter(\"size\"))){ size = Integer.parseInt(request.getParameter(\"size\")); } PageInfo all = questionService.findAll(page, size); //将数据保存到指定的位置 request.setAttribute(\"page\",all); //跳转页面 request.getRequestDispatcher(\"/WEB-INF/pages/store/question/list.jsp\").forward(request,response); } private void toAdd(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException { //跳转页面 request.getRequestDispatcher(\"/WEB-INF/pages/store/question/add.jsp\").forward(request,response); } private void save(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException { //将数据获取到，封装成一个对象 Question question = BeanUtil.fillBean(request,Question.class,\"yyyy-MM-dd\"); //调用业务层接口save questionService.save(question); //跳转回到页面list response.sendRedirect(request.getContextPath()+\"/store/question?operation=list\"); } private void toEdit(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //查询要修改的数据findById String id = request.getParameter(\"id\"); Question question = questionService.findById(id); //将数据加载到指定区域，供页面获取 request.setAttribute(\"question\",question); //跳转页面 request.getRequestDispatcher(\"/WEB-INF/pages/store/question/update.jsp\").forward(request,response); } private void edit(HttpServletRequest request, HttpServletResponse response) throws IOException { //将数据获取到，封装成一个对象 Question question = BeanUtil.fillBean(request,Question.class,\"yyyy-MM-dd\"); //调用业务层接口save questionService.update(question); //跳转回到页面list //list(request,response); response.sendRedirect(request.getContextPath()+\"/store/question?operation=list\"); } private void delete(HttpServletRequest request, HttpServletResponse response) throws IOException { //将数据获取到，封装成一个对象 Question question = BeanUtil.fillBean(request,Question.class); //调用业务层接口save questionService.delete(question); //跳转回到页面list response.sendRedirect(request.getContextPath()+\"/store/question?operation=list\"); } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doGet(request,response); } } （7）修改BaserServlet，添加QuestionService public class BaseServlet extends HttpServlet { protected CompanyService companyService; protected DeptService deptService; protected UserService userService; protected CourseService courseService; protected CatalogService catalogService; protected QuestionService questionService; @Override public void init() throws ServletException { companyService = new CompanyServiceImpl(); deptService = new DeptServiceImpl(); userService = new UserServiceImpl(); courseService = new CourseServiceImpl(); catalogService = new CatalogServiceImpl(); questionService = new QuestionServiceImpl(); } } （8）创建页面存放目录,/WEB-INF/pages/store/question，从今日课程资料中找到模块页面\\question，将下面的所有页面拷贝到该目录下 （9）修改servlet，找到toAdd方法，去添加页面之前查询企业和目录数据 private void toAdd(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException { List companyList = companyService.findAll(); List catalogList = catalogService.findAll(); request.setAttribute(\"companyList\",companyList); request.setAttribute(\"catalogList\",catalogList); //跳转页面 request.getRequestDispatcher(\"/WEB-INF/pages/store/question/add.jsp\").forward(request,response); } 找到toEdit方法，去修改页面之前查询企业和目录数据 private void toEdit(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //查询要修改的数据findById String id = request.getParameter(\"id\"); Question question = questionService.findById(id); //将数据加载到指定区域，供页面获取 request.setAttribute(\"question\",question); List companyList = companyService.findAll(); List catalogList = catalogService.findAll(); request.setAttribute(\"companyList\",companyList); request.setAttribute(\"catalogList\",catalogList); //跳转页面 request.getRequestDispatcher(\"/WEB-INF/pages/store/question/update.jsp\").forward(request,response); } （10）修改业务层代码，找到添加数据的方法，需要新增审核状态和创建时间的数据 @Override public void save(Question question) { SqlSession sqlSession = null; try{ //1.获取SqlSession sqlSession = MapperFactory.getSqlSession(); //2.获取Dao QuestionDao questionDao = MapperFactory.getMapper(sqlSession,QuestionDao.class); //id使用UUID的生成策略来获取 String id = UUID.randomUUID().toString(); question.setId(id); //设置新创建的题目默认的审核状态为未审核（0） question.setReviewStatus(\"0\"); question.setCreateTime(new Date()); //3.调用Dao层操作 questionDao.save(question); //4.提交事务 TransactionUtil.commit(sqlSession); }catch (Exception e){ TransactionUtil.rollback(sqlSession); throw new RuntimeException(e); //记录日志 }finally { try { TransactionUtil.close(sqlSession); }catch (Exception e){ e.printStackTrace(); } } } （11）修改查询所有数据时的排序，修改对应的dao映射配置文件QuestionDao.xml select from st_question order by create_time desc （12）在进行数据修改时，有些数据是不能修改的，我们可以在持久层映射配置文件中进行控制 update st_question set company_id = #{companyId,jdbcType=VARCHAR}, catalog_id = #{catalogId,jdbcType=VARCHAR}, remark = #{remark,jdbcType=VARCHAR}, subject = #{subject,jdbcType=VARCHAR}, analysis = #{analysis,jdbcType=VARCHAR}, difficulty = #{difficulty,jdbcType=VARCHAR}, is_classic = #{isClassic,jdbcType=VARCHAR}, state = #{state,jdbcType=VARCHAR} where id = #{id,jdbcType=VARCHAR} 1.5.2. 4.2 文件上传基础演示 文件上传功能需要前台功能和后台功能共同配合完成 前台：文件上传的三要素 页面提供文件上传的表单元素 form表单enctype属性的值为multipart/form-data 表单的提交方式必须是POST，get方式无法提交大量的数据 后台：可以使用的技术有很多，在此处我们使用apache提供的commons-fileupload组件完成文件上次操作，后台的操作步骤如下 确认请求操作是否支持文件上传 创建磁盘工厂对象，用于将页面上传的文件保存到磁盘中 获取servet文件上传核心对象 读取数据 对读取到数据中的文件表单进行操作，并将内容写到指定位置 下面我们开始进行文件上传的演示： （1）从今日课程资料找到文件下载\\testFileUpload.jsp文件上传页面，将其添加到项目/WEB-INF/pages/store/question目录下 （2）在question目录下的list.jsp页面上添加一个新的按钮，点击该按钮跳转到文件上传页面 测试文件上传 （3）在QuestionServlet中添加toTestUpload方法，跳转到文件上传页面 @WebServlet(\"/store/question\") public class QuestionServlet extends BaseServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { String operation = request.getParameter(\"operation\"); if(\"list\".equals(operation)){ this.list(request,response); }else if(\"toAdd\".equals(operation)){ this.toAdd(request,response); }else if(\"save\".equals(operation)){ this.save(request, response); }else if(\"toEdit\".equals(operation)){ this.toEdit(request,response); }else if(\"edit\".equals(operation)){ this.edit(request,response); }else if(\"delete\".equals(operation)){ this.delete(request,response); }else if(\"toTestUpload\".equals(operation)){ this.toTestUpload(request,response); }else if(\"testUpload\".equals(operation)){ try { this.testUpload(request,response); } catch (Exception e) { e.printStackTrace(); } } } private void toTestUpload(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException { request.getRequestDispatcher(\"/WEB-INF/pages/store/question/testFileUpload.jsp\").forward(request,response); } private void testUpload(HttpServletRequest request,HttpServletResponse response) throws Exception { } } （4）完成文件上传的后台代码 private void testUpload(HttpServletRequest request,HttpServletResponse response) throws Exception { //1.确认该操作是否支持文件上传操作，enctype=\"multipart/form-data\" if(ServletFileUpload.isMultipartContent(request)){ //2.创建磁盘工厂对象 DiskFileItemFactory factory = new DiskFileItemFactory(); //3.Servlet文件上传核心对象 ServletFileUpload fileUpload = new ServletFileUpload(factory); //4.从request中读取数据 List fileItems = fileUpload.parseRequest(request); for(FileItem item : fileItems){ //5.当前表单是否是文件表单 if(!item.isFormField()){ //6.从临时存储文件的地方将内容写入到指定位置 item.write(new File(this.getServletContext().getRealPath(\"upload\"),item.getName())); } } } } 需要在项目webapp目录下创建一个upload目录用于存储上传过来的文件 （5）启动测试 1.5.3. 4.3 添加题目时加入文件上传 （1）在题目实体中添加图片的属性 public class Question { // 其他属性略 private String picture; public String getPicture() { return picture; } public void setPicture(String picture) { this.picture = picture; } } （2）在对应的dao映射配置文件中添加图片字段的配置，在resultMap，查询的sql片段，保存，更新几个位置添加映射配置即可，更新的时候是不需要更改图片的名称，因此是去掉对图片名称的更新 id, catalog_id, company_id, remark,subject,analysis,type, difficulty, is_classic, state, review_status, create_time, picture insert into st_question(id, company_id, catalog_id, remark, subject, analysis, type, difficulty, is_classic, state, review_status, create_time ,picture ) values (#{id,jdbcType=VARCHAR}, #{companyId,jdbcType=VARCHAR}, #{catalogId,jdbcType=VARCHAR}, #{remark,jdbcType=VARCHAR}, #{subject,jdbcType=VARCHAR}, #{analysis,jdbcType=VARCHAR}, #{type,jdbcType=VARCHAR}, #{difficulty,jdbcType=VARCHAR}, #{isClassic,jdbcType=VARCHAR}, #{state,jdbcType=VARCHAR}, #{reviewStatus,jdbcType=VARCHAR}, #{createTime,jdbcType=TIMESTAMP}, #{picture,jdbcType=VARCHAR} ) update st_question set company_id = #{companyId,jdbcType=VARCHAR}, catalog_id = #{catalogId,jdbcType=VARCHAR}, remark = #{remark,jdbcType=VARCHAR}, subject = #{subject,jdbcType=VARCHAR}, analysis = #{analysis,jdbcType=VARCHAR}, difficulty = #{difficulty,jdbcType=VARCHAR}, is_classic = #{isClassic,jdbcType=VARCHAR}, state = #{state,jdbcType=VARCHAR} where id = #{id,jdbcType=VARCHAR} （3）在question模块的添加页面add.jsp中加入图片上传的表单项 题干图片 （4）在servlet中修改保存题目的方法save，首先要更改的就是接收数据的方式，我们要按照文件上传的形式来接收 @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { String operation = request.getParameter(\"operation\"); if(\"list\".equals(operation)){ this.list(request,response); }else if(\"toAdd\".equals(operation)){ this.toAdd(request,response); }else if(\"save\".equals(operation)){ try { this.save(request, response); } catch (Exception e) { e.printStackTrace(); } }else if(\"toEdit\".equals(operation)){ this.toEdit(request,response); }else if(\"edit\".equals(operation)){ this.edit(request,response); }else if(\"delete\".equals(operation)){ this.delete(request,response); }else if(\"toTestUpload\".equals(operation)){ this.toTestUpload(request,response); }else if(\"testUpload\".equals(operation)){ try { this.testUpload(request,response); } catch (Exception e) { e.printStackTrace(); } } } private void save(HttpServletRequest request,HttpServletResponse response) throws Exception { //1.确认该操作是否支持文件上传操作，enctype=\"multipart/form-data\" if(ServletFileUpload.isMultipartContent(request)){ //2.创建磁盘工厂对象 DiskFileItemFactory factory = new DiskFileItemFactory(); //3.Servlet文件上传核心对象 ServletFileUpload fileUpload = new ServletFileUpload(factory); //4.从request中读取数据 List fileItems = fileUpload.parseRequest(request); // --处理form表单提交过来的普通数据 //将数据获取到，封装成一个对象 Question question = BeanUtil.fillBean(fileItems,Question.class); //调用业务层接口save questionService.save(question); // --处理form表单提交过来的文件数据 for(FileItem item : fileItems){ //5.当前表单是否是文件表单 if(!item.isFormField()){ //6.从临时存储文件的地方将内容写入到指定位置 item.write(new File(this.getServletContext().getRealPath(\"upload\"),item.getName())); } } } //跳转回到页面list response.sendRedirect(request.getContextPath()+\"/store/question?operation=list\"); } 1.5.4. 4.4 文件上传的重名问题 （1）在question模块的list.jsp页面中添加对图片名称的展示 图片 企业 类别 题目 类型 难度 经典面试题 状态 审核结果 操作 ${o.picture} ${o.company.name} ${o.catalog.name} ${o.subject} 单选 多选 简答 ★ ${o.isClassic eq \"1\" ? \"经典题\":\"普通题\"} ${o.state eq \"1\" ? \"启用\" : \"禁用\"} 审核通过 审核中 审核不通过 编辑 审核 文件上传的常见问题：文件重名问题 （1）修改业务层接口QuestionService的保存方法，添加返回值，将图片的名称返回 /** * 添加 * @param question * @return 保存的图片名称 */ String save(Question question); （2）修改实现类，添加对图片名称的存储及返回图片的名称，图片名称使用该条数据的id @Override public String save(Question question) { SqlSession sqlSession = null; try{ //1.获取SqlSession sqlSession = MapperFactory.getSqlSession(); //2.获取Dao QuestionDao questionDao = MapperFactory.getMapper(sqlSession,QuestionDao.class); //id使用UUID的生成策略来获取 String id = UUID.randomUUID().toString(); question.setId(id); //设置新创建的题目默认的审核状态为未审核（0） question.setReviewStatus(\"0\"); question.setCreateTime(new Date()); //设置当前存储的图片名称为id值 question.setPicture(id); //3.调用Dao层操作 questionDao.save(question); //4.提交事务 TransactionUtil.commit(sqlSession); return id; }catch (Exception e){ TransactionUtil.rollback(sqlSession); throw new RuntimeException(e); //记录日志 }finally { try { TransactionUtil.close(sqlSession); }catch (Exception e){ e.printStackTrace(); } } } （3）在servlet中的save方法中接收图片名称 private void save(HttpServletRequest request,HttpServletResponse response) throws Exception { //1.确认该操作是否支持文件上传操作，enctype=\"multipart/form-data\" if(ServletFileUpload.isMultipartContent(request)){ //2.创建磁盘工厂对象 DiskFileItemFactory factory = new DiskFileItemFactory(); //3.Servlet文件上传核心对象 ServletFileUpload fileUpload = new ServletFileUpload(factory); //4.从request中读取数据 List fileItems = fileUpload.parseRequest(request); // --处理form表单提交过来的普通数据 //将数据获取到，封装成一个对象 Question question = BeanUtil.fillBean(fileItems,Question.class); //调用业务层接口save String picture = questionService.save(question); // --处理form表单提交过来的文件数据 for(FileItem item : fileItems){ //5.当前表单是否是文件表单 if(!item.isFormField()){ //6.从临时存储文件的地方将内容写入到指定位置 item.write(new File(this.getServletContext().getRealPath(\"upload\"),picture)); } } } //跳转回到页面list response.sendRedirect(request.getContextPath()+\"/store/question?operation=list\"); } 1.5.5. 4.5 修改题目时加入文件上传 修改之前需要先将图片展示出来 （1）在question模块的update.jsp页面中添加图片的展示，同时把修改时上传图片的表单项添加进去，以及表单也要配套修改 题干图片 题干图片 （2）修改后台的servlet，找到edit方法进行修改 @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { String operation = request.getParameter(\"operation\"); if(\"list\".equals(operation)){ this.list(request,response); }else if(\"toAdd\".equals(operation)){ this.toAdd(request,response); }else if(\"save\".equals(operation)){ try { this.save(request, response); } catch (Exception e) { e.printStackTrace(); } }else if(\"toEdit\".equals(operation)){ this.toEdit(request,response); }else if(\"edit\".equals(operation)){ try { this.edit(request,response); } catch (Exception e) { e.printStackTrace(); } }else if(\"delete\".equals(operation)){ this.delete(request,response); }else if(\"toTestUpload\".equals(operation)){ this.toTestUpload(request,response); }else if(\"testUpload\".equals(operation)){ try { this.testUpload(request,response); } catch (Exception e) { e.printStackTrace(); } } } private void edit(HttpServletRequest request, HttpServletResponse response) throws Exception { //1.确认该操作是否支持文件上传操作，enctype=\"multipart/form-data\" if(ServletFileUpload.isMultipartContent(request)){ //2.创建磁盘工厂对象 DiskFileItemFactory factory = new DiskFileItemFactory(); //3.Servlet文件上传核心对象 ServletFileUpload fileUpload = new ServletFileUpload(factory); //4.从request中读取数据 List fileItems = fileUpload.parseRequest(request); // --处理form表单提交过来的普通数据 //将数据获取到，封装成一个对象 Question question = BeanUtil.fillBean(fileItems,Question.class); //调用业务层接口save questionService.update(question); // --处理form表单提交过来的文件数据 for(FileItem item : fileItems){ //5.当前表单是否是文件表单 if(!item.isFormField()){ //6.从临时存储文件的地方将内容写入到指定位置 item.write(new File(this.getServletContext().getRealPath(\"upload\"),question.getId())); } } } //跳转回到页面list response.sendRedirect(request.getContextPath()+\"/store/question?operation=list\"); } （3）业务层实现类的update方法在进行数据修改时，图片名称不需要修改，这个我们在持久层的update操作时去掉对图片的更改，我们改一下对应的映射配置文件（这步操作之前已完成）如下 update st_question set company_id = #{companyId,jdbcType=VARCHAR}, catalog_id = #{catalogId,jdbcType=VARCHAR}, remark = #{remark,jdbcType=VARCHAR}, subject = #{subject,jdbcType=VARCHAR}, analysis = #{analysis,jdbcType=VARCHAR}, difficulty = #{difficulty,jdbcType=VARCHAR}, is_classic = #{isClassic,jdbcType=VARCHAR}, state = #{state,jdbcType=VARCHAR} where id = #{id,jdbcType=VARCHAR} 1.5.6. 4.6 兼容图片上传可选操作与显示问题 问题： 如果在新增的时候没有选择上传图片，会导致在修改的时候页面上展示不出图片，如下图所示 产生问题的原因： 新增的时候虽然没有上传图片，但是由于我们保存数据的时候默认是将数据的id作为图片的名称，所以在展示的时候会去找这个名称的图片，但是我们又没上传因此会找到不到 改进方法： 在新增时做一个判断，如果上传了图片再去保存图片的名称，没有上传则不保存图片的名称 （1）在servlet的add方法中去判断当前是否上传文件，可以用一个布尔值标记来表明是否有文件上传，同时在业务层执行保存操作时可以把这个是否有图片的标记传递过去 private void save(HttpServletRequest request,HttpServletResponse response) throws Exception { //1.确认该操作是否支持文件上传操作，enctype=\"multipart/form-data\" if(ServletFileUpload.isMultipartContent(request)){ //2.创建磁盘工厂对象 DiskFileItemFactory factory = new DiskFileItemFactory(); //3.Servlet文件上传核心对象 ServletFileUpload fileUpload = new ServletFileUpload(factory); //4.从request中读取数据 List fileItems = fileUpload.parseRequest(request); //创建一个标记位,标记当前时候有上传文件的操作 boolean flag = false; for(FileItem item :fileItems){ if(StringUtils.isNotBlank(item.getName())){ flag = true; break; } } // --处理form表单提交过来的普通数据 //将数据获取到，封装成一个对象 Question question = BeanUtil.fillBean(fileItems,Question.class); //调用业务层接口save String picture = questionService.save(question , flag); // --处理form表单提交过来的文件数据 for(FileItem item : fileItems){ //5.当前表单是否是文件表单 if(!item.isFormField()){ //6.从临时存储文件的地方将内容写入到指定位置 item.write(new File(this.getServletContext().getRealPath(\"upload\"),picture)); } } } //跳转回到页面list response.sendRedirect(request.getContextPath()+\"/store/question?operation=list\"); } （2）修改业务层接口方法save，添加参数 /** * 添加 * @param question * @param flag 是否有上传文件的操作 * @return 保存的图片名称 */ String save(Question question,boolean flag); （3）修改对应的接口实现类： @Override public String save(Question question,boolean flag) { SqlSession sqlSession = null; try{ //1.获取SqlSession sqlSession = MapperFactory.getSqlSession(); //2.获取Dao QuestionDao questionDao = MapperFactory.getMapper(sqlSession,QuestionDao.class); //id使用UUID的生成策略来获取 String id = UUID.randomUUID().toString(); question.setId(id); //设置新创建的题目默认的审核状态为未审核（0） question.setReviewStatus(\"0\"); question.setCreateTime(new Date()); //检测到前端上传文件了，记录文件名，否则不记录 if(flag) { //设置当前存储的图片名称为id值 question.setPicture(id); } //3.调用Dao层操作 questionDao.save(question); //4.提交事务 TransactionUtil.commit(sqlSession); return id; }catch (Exception e){ TransactionUtil.rollback(sqlSession); throw new RuntimeException(e); //记录日志 }finally { try { TransactionUtil.close(sqlSession); }catch (Exception e){ e.printStackTrace(); } } } （4）在修改时，如果没有图片则不显示图片，有图片信息的时候再显示，我们可以使用进行判断 题干图片 0}\"> 题干图片 （5）页面修改完成后，在进行真正的修改操作时，我们同样需要进行判断，如果上传了图片则进行修改，否则不进行修改。 找到后台的servlet的edit方法，做出如下修改 private void edit(HttpServletRequest request, HttpServletResponse response) throws Exception { //1.确认该操作是否支持文件上传操作，enctype=\"multipart/form-data\" if(ServletFileUpload.isMultipartContent(request)){ //2.创建磁盘工厂对象 DiskFileItemFactory factory = new DiskFileItemFactory(); //3.Servlet文件上传核心对象 ServletFileUpload fileUpload = new ServletFileUpload(factory); //4.从request中读取数据 List fileItems = fileUpload.parseRequest(request); //创建一个标记位,标记当前时候有上传文件的操作 boolean flag = false; for(FileItem item :fileItems){ if(StringUtils.isNotBlank(item.getName())){ flag = true; break; } } // --处理form表单提交过来的普通数据 //将数据获取到，封装成一个对象 Question question = BeanUtil.fillBean(fileItems,Question.class); //调用业务层接口save questionService.update(question , flag); // --处理form表单提交过来的文件数据 for(FileItem item : fileItems){ //5.当前表单是否是文件表单 if(!item.isFormField()){ //6.从临时存储文件的地方将内容写入到指定位置 item.write(new File(this.getServletContext().getRealPath(\"upload\"),question.getId())); } } } //跳转回到页面list response.sendRedirect(request.getContextPath()+\"/store/question?operation=list\"); } （6）同样需要修改业务层接口，在update方法上添加是否修改图片的参数 /** * 修改 * @param question * @param flag 是否有上传文件的操作 * @return */ void update(Question question,boolean flag); （7）在业务层实现类中修改该方法 @Override public void update(Question question, boolean flag) { SqlSession sqlSession = null; try{ //1.获取SqlSession sqlSession = MapperFactory.getSqlSession(); //2.获取Dao QuestionDao questionDao = MapperFactory.getMapper(sqlSession,QuestionDao.class); //检测到前端上传文件了，记录文件名，否则不记录 if(flag) { //设置当前存储的图片名称为id值 question.setPicture(question.getId()); } //3.调用Dao层操作 questionDao.update(question); //4.提交事务 TransactionUtil.commit(sqlSession); }catch (Exception e){ TransactionUtil.rollback(sqlSession); throw new RuntimeException(e); //记录日志 }finally { try { TransactionUtil.close(sqlSession); }catch (Exception e){ e.printStackTrace(); } } } （8）在持久层dao真正进行update操作的时候我们把对图片的更新添加进去，我们去修改对应的映射配置文件即可 update st_question set company_id = #{companyId,jdbcType=VARCHAR}, catalog_id = #{catalogId,jdbcType=VARCHAR}, remark = #{remark,jdbcType=VARCHAR}, subject = #{subject,jdbcType=VARCHAR}, analysis = #{analysis,jdbcType=VARCHAR}, difficulty = #{difficulty,jdbcType=VARCHAR}, is_classic = #{isClassic,jdbcType=VARCHAR}, picture = #{picture,jdbcType=VARCHAR}, state = #{state,jdbcType=VARCHAR} where id = #{id,jdbcType=VARCHAR} 1.6. 5. 题目选项模块 1.6.1. 5.1 列表页制作 （1）创建题目选项实体：com.itheima.domain.store.QuestionItem public class QuestionItem { private String id; //ID private String questionId; //题目ID private String content; //选项内容 private String picture; //选项图片 private String isRight; //是否正确答案 @Override public String toString() { return \"QuestionItem{\" + \"id='\" + id + '\\'' + \", questionId='\" + questionId + '\\'' + \", content='\" + content + '\\'' + \", picture='\" + picture + '\\'' + \", isRight='\" + isRight + '\\'' + '}'; } // getter/setter方法略 } （2）创建dao接口：com.itheima.dao.store.QuestionItemDao public interface QuestionItemDao { int save(QuestionItem questionItem); int delete(QuestionItem questionItem); int update(QuestionItem questionItem); QuestionItem findById(String id); List findAll(); } （3）添加对应的映射配置文件，之前已导入过了 （4）创建业务层接口：com.itheima.service.store.QuestionItemService public interface QuestionItemService { /** * 添加 * @param questionItem * @return */ void save(QuestionItem questionItem); /** * 删除 * @param questionItem * @return */ void delete(QuestionItem questionItem); /** * 修改 * @param questionItem * @return */ void update(QuestionItem questionItem); /** * 查询单个 * @param id 查询的条件（id） * @return 查询的结果，单个对象 */ QuestionItem findById(String id); /** * 查询全部的数据 * @return 全部数据的列表对象 */ List findAll(); /** * 分页查询数据 * @param page 页码 * @param size 每页显示的数据总量 * @return */ PageInfo findAll(int page, int size); } （5）创建业务层实现类：com.itheima.service.store.impl.QuestionItemServiceImpl 我们基于CompanyServiceImpl拷贝然后改造 public class QuestionItemServiceImpl implements QuestionItemService { @Override public void save(QuestionItem questionItem) { SqlSession sqlSession = null; try{ //1.获取SqlSession sqlSession = MapperFactory.getSqlSession(); //2.获取Dao QuestionItemDao questionItemDao = MapperFactory.getMapper(sqlSession,QuestionItemDao.class); //id使用UUID的生成策略来获取 String id = UUID.randomUUID().toString(); questionItem.setId(id); //3.调用Dao层操作 questionItemDao.save(questionItem); //4.提交事务 TransactionUtil.commit(sqlSession); }catch (Exception e){ TransactionUtil.rollback(sqlSession); throw new RuntimeException(e); //记录日志 }finally { try { TransactionUtil.close(sqlSession); }catch (Exception e){ e.printStackTrace(); } } } @Override public void delete(QuestionItem questionItem) { SqlSession sqlSession = null; try{ //1.获取SqlSession sqlSession = MapperFactory.getSqlSession(); //2.获取Dao QuestionItemDao questionItemDao = MapperFactory.getMapper(sqlSession,QuestionItemDao.class); //3.调用Dao层操作 questionItemDao.delete(questionItem); //4.提交事务 TransactionUtil.commit(sqlSession); }catch (Exception e){ TransactionUtil.rollback(sqlSession); throw new RuntimeException(e); //记录日志 }finally { try { TransactionUtil.close(sqlSession); }catch (Exception e){ e.printStackTrace(); } } } @Override public void update(QuestionItem questionItem) { SqlSession sqlSession = null; try{ //1.获取SqlSession sqlSession = MapperFactory.getSqlSession(); //2.获取Dao QuestionItemDao questionItemDao = MapperFactory.getMapper(sqlSession,QuestionItemDao.class); //3.调用Dao层操作 questionItemDao.update(questionItem); //4.提交事务 TransactionUtil.commit(sqlSession); }catch (Exception e){ TransactionUtil.rollback(sqlSession); throw new RuntimeException(e); //记录日志 }finally { try { TransactionUtil.close(sqlSession); }catch (Exception e){ e.printStackTrace(); } } } @Override public QuestionItem findById(String id) { SqlSession sqlSession = null; try{ //1.获取SqlSession sqlSession = MapperFactory.getSqlSession(); //2.获取Dao QuestionItemDao questionItemDao = MapperFactory.getMapper(sqlSession,QuestionItemDao.class); //3.调用Dao层操作 return questionItemDao.findById(id); }catch (Exception e){ throw new RuntimeException(e); //记录日志 }finally { try { TransactionUtil.close(sqlSession); }catch (Exception e){ e.printStackTrace(); } } } @Override public List findAll() { SqlSession sqlSession = null; try{ //1.获取SqlSession sqlSession = MapperFactory.getSqlSession(); //2.获取Dao QuestionItemDao questionItemDao = MapperFactory.getMapper(sqlSession,QuestionItemDao.class); //3.调用Dao层操作 return questionItemDao.findAll(); }catch (Exception e){ throw new RuntimeException(e); //记录日志 }finally { try { TransactionUtil.close(sqlSession); }catch (Exception e){ e.printStackTrace(); } } } @Override public PageInfo findAll(int page, int size) { SqlSession sqlSession = null; try{ //1.获取SqlSession sqlSession = MapperFactory.getSqlSession(); //2.获取Dao QuestionItemDao questionItemDao = MapperFactory.getMapper(sqlSession,QuestionItemDao.class); //3.调用Dao层操作 PageHelper.startPage(page,size); List all = questionItemDao.findAll(); PageInfo pageInfo = new PageInfo(all); return pageInfo; }catch (Exception e){ throw new RuntimeException(e); //记录日志 }finally { try { TransactionUtil.close(sqlSession); }catch (Exception e){ e.printStackTrace(); } } } } （6）创建servlet：com.itheima.web.controller.store.QuestionItemServlet 基于CompanyServlet拷贝进行改造（修改完成后有些方法其实没有用，我们暂时不用去修改，后续我们会逐级进行修改） @WebServlet(\"/store/questionItem\") public class QuestionItemServlet extends BaseServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { String operation = request.getParameter(\"operation\"); if(\"list\".equals(operation)){ this.list(request,response); }else if(\"toAdd\".equals(operation)){ this.toAdd(request,response); }else if(\"save\".equals(operation)){ this.save(request, response); }else if(\"toEdit\".equals(operation)){ this.toEdit(request,response); }else if(\"edit\".equals(operation)){ this.edit(request,response); }else if(\"delete\".equals(operation)){ this.delete(request,response); } } private void list(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException { //进入列表页 //获取数据 int page = 1; int size = 5; if(StringUtils.isNotBlank(request.getParameter(\"page\"))){ page = Integer.parseInt(request.getParameter(\"page\")); } if(StringUtils.isNotBlank(request.getParameter(\"size\"))){ size = Integer.parseInt(request.getParameter(\"size\")); } PageInfo all = questionItemService.findAll(page, size); //将数据保存到指定的位置 request.setAttribute(\"page\",all); //跳转页面 request.getRequestDispatcher(\"/WEB-INF/pages/store/questionItem/list.jsp\").forward(request,response); } private void toAdd(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException { //跳转页面 request.getRequestDispatcher(\"/WEB-INF/pages/store/questionItem/add.jsp\").forward(request,response); } private void save(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException { //将数据获取到，封装成一个对象 QuestionItem questionItem = BeanUtil.fillBean(request,QuestionItem.class,\"yyyy-MM-dd\"); //调用业务层接口save questionItemService.save(questionItem); //跳转回到页面list response.sendRedirect(request.getContextPath()+\"/store/questionItem?operation=list\"); } private void toEdit(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //查询要修改的数据findById String id = request.getParameter(\"id\"); QuestionItem questionItem = questionItemService.findById(id); //将数据加载到指定区域，供页面获取 request.setAttribute(\"questionItem\",questionItem); //跳转页面 request.getRequestDispatcher(\"/WEB-INF/pages/store/questionItem/update.jsp\").forward(request,response); } private void edit(HttpServletRequest request, HttpServletResponse response) throws IOException { //将数据获取到，封装成一个对象 QuestionItem questionItem = BeanUtil.fillBean(request,QuestionItem.class,\"yyyy-MM-dd\"); //调用业务层接口save questionItemService.update(questionItem); //跳转回到页面list response.sendRedirect(request.getContextPath()+\"/store/questionItem?operation=list\"); } private void delete(HttpServletRequest request, HttpServletResponse response) throws IOException { //将数据获取到，封装成一个对象 QuestionItem questionItem = BeanUtil.fillBean(request,QuestionItem.class); //调用业务层接口save questionItemService.delete(questionItem); //跳转回到页面list response.sendRedirect(request.getContextPath()+\"/store/questionItem?operation=list\"); } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doGet(request,response); } （7）在BaseServlet中添加QuestionItemService public class BaseServlet extends HttpServlet { protected CompanyService companyService; protected DeptService deptService; protected UserService userService; protected CourseService courseService; protected CatalogService catalogService; protected QuestionService questionService; protected QuestionItemService questionItemService; @Override public void init() throws ServletException { companyService = new CompanyServiceImpl(); deptService = new DeptServiceImpl(); userService = new UserServiceImpl(); courseService = new CourseServiceImpl(); catalogService = new CatalogServiceImpl(); questionService = new QuestionServiceImpl(); questionItemService = new QuestionItemServiceImpl(); } } （8）创建页面存放的目录/WEB-INF/pages/store/questionItem，从今日课程资料中的模块页面\\questionItem下复制所有的页面到刚创建好的目录中 （9）在question模块的list.jsp页面中添加题目选项列表页的入口，因为题目选项是针对某个具体的题目的，在每条列表数据的操作中添加一个配置选项的按钮 配置选项 同时在questionItem模块中的list.jsp页面中我们需要删除一些页面元素，分页，新建按钮，删除按钮，只留下刷新按钮 （10）在后台servlet的list方法中接收题目的id，我们要查询的列表应该是该题目下的所有选项列表 private void list(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException { String questionId = request.getParameter(\"questionId\"); PageInfo all = questionItemService.findAll(questionId,1, 100); //将数据保存到指定的位置 request.setAttribute(\"page\",all); //跳转页面 request.getRequestDispatcher(\"/WEB-INF/pages/store/questionItem/list.jsp\").forward(request,response); } （11）修改业务层接口方法，添加参数，注意是改带分页的那个方法 /** * 分页查询数据 * @param questionId 题目对应的id * @param page 页码 * @param size 每页显示的数据总量 * @return */ PageInfo findAll(String questionId,int page, int size); （12）在业务层实现类中修改对应的方法 @Override public PageInfo findAll(String questionId,int page, int size) { SqlSession sqlSession = null; try{ //1.获取SqlSession sqlSession = MapperFactory.getSqlSession(); //2.获取Dao QuestionItemDao questionItemDao = MapperFactory.getMapper(sqlSession,QuestionItemDao.class); //3.调用Dao层操作 PageHelper.startPage(page,size); List all = questionItemDao.findAll(questionId); PageInfo pageInfo = new PageInfo(all); return pageInfo; }catch (Exception e){ throw new RuntimeException(e); //记录日志 }finally { try { TransactionUtil.close(sqlSession); }catch (Exception e){ e.printStackTrace(); } } } （13）修改持久层接口方法findAll，添加查询参数 /** * 根据题目id查询所有选项 * @param questionId * @return */ List findAll(String questionId); （14）修改dao映射配置文件，添加条件 select from st_question_item where question_id = #{questionId,jdbcType=VARCHAR} （15）对于业务层原有的不带任何参数的findAll方法，我们可以去掉，删除接口和实现类中的无参的findAll方法 （16）启动项目测试效果 1.6.2. 5.2 添加功能制作 （1）在后台servlet的doGet方法中去掉一些逻辑，toAdd的逻辑判断和对应的toAdd方法需要删除，然后直接查看save方法 （2）save方法最后需要去跳转页面，我们让它直接调用list方法，该方法最后就是跳转页面的 private void save(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException { //将数据获取到，封装成一个对象 QuestionItem questionItem = BeanUtil.fillBean(request,QuestionItem.class,\"yyyy-MM-dd\"); //调用业务层接口save questionItemService.save(questionItem); //跳转回到页面list list(request,response); } （3）找到questionItem模块下的list.jsp页面，在该表单里面添加一个隐藏域，接收题目的id 同时要保证这个值能够在该页面中获取到，我们需要在跳转到该页面的后台list方法中向request域中存入该值即可，修改后台servlet的list方法 private void list(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException { String questionId = request.getParameter(\"questionId\"); //进入list页时添加对应的问题id，为添加操作使用 request.setAttribute(\"questionId\",questionId); PageInfo all = questionItemService.findAll(questionId,1, 100); //将数据保存到指定的位置 request.setAttribute(\"page\",all); //跳转页面 request.getRequestDispatcher(\"/WEB-INF/pages/store/questionItem/list.jsp\").forward(request,response); } （4）启动项目进行测试 1.6.3. 5.3 删除功能制作 （1）删除首先要解决的是删除完成后端页面跳转问题，需要修改后台servlet的delete方法，删除完成后调用list方法进行跳转 private void delete(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException { //将数据获取到，封装成一个对象 QuestionItem questionItem = BeanUtil.fillBean(request,QuestionItem.class); //调用业务层接口save questionItemService.delete(questionItem); //跳转回到页面list list(request,response); } （2）产生的新的问题是，删除后跳转回list.jsp页面其他的数据都不见了，分析得到的原因是后台servlet执行完成删除调用list方法时，需要去获取题目的id，来查询该题目下的所有选项，这个地方缺少了题目的id，因此解决方案是在页面发送删除请求时需要将题目id传递给后台，因此我们需要去修改页面删除的js代码 function deleteById(id) { var questionId = '${questionId}'; if(confirm(\"你确认要删除此条记录吗？\")) { window.location.href=\"${ctx}/store/questionItem?operation=delete&questionId=${questionId}&id=\"+id; } } （3）启动项目，进行测试 1.6.4. 5.4 修改功能制作 （1）修改后台servlet的toEdit方法，查询完数据后跳转页面仍然是调用list方法完成跳转 private void toEdit(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //查询要修改的数据findById String id = request.getParameter(\"id\"); QuestionItem questionItem = questionItemService.findById(id); //将数据加载到指定区域，供页面获取 request.setAttribute(\"questionItem\",questionItem); //跳转回到页面list list(request,response); } （2）出现的问题是，点完编辑后跳转到页面上所有数据都无法显示，包括之前的所有选项数据，我们需要先来解决之前所有的选项数据的显示问题，原因很简单，还是因为在点击编辑的时候没有传递题目的id到后台，后台在通过list方法进行跳转的时候没有题目的id就无法查询题目下的选项 在questionItem/list.jsp页面上修改编辑按钮，添加题目id的参数 编辑 （3）然后在解决点完编辑后对应编辑的数据无法展示的问题，需要调整questionItem/list.jsp页面表单，添加数据的展示 选项内容 选项图片 是否正确答案 请选择 正确答案 错误选项 --%> 是否正确答案 请选择 正确答案 错误选项 （4）启动后测试，发现了新的问题，我们要提交编辑的数据，但结果却变成了保存，问题的原因是什么呢？ 经过分析发现是因为表单的提交路径一直写的就是保存的路径，如何解决呢？ 通过后台传递一个操作类型的变量值到前端，前端在表单的action里面使用该变量值，通过这个变量我们来控制是新增还是编辑 在后台的list和toEdit方法中来操作该变量值 private void list2(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException { String questionId = request.getParameter(\"questionId\"); //进入list页时添加对应的问题id，为添加操作使用 request.setAttribute(\"questionId\",questionId); //获取数据 PageInfo all = questionItemService.findAll(questionId, 1, 100); //将数据保存到指定的位置 request.setAttribute(\"page\",all); if(request.getAttribute(\"operation\") == null) { //保存一个操作的类型，传递到前端save request.setAttribute(\"operation\", \"save\"); } //跳转页面 request.getRequestDispatcher(\"/WEB-INF/pages/store/questionItem/list.jsp\").forward(request,response); } private void toEdit(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //查询要修改的数据findById String id = request.getParameter(\"id\"); QuestionItem questionItem = questionItemService.findById(id); //将数据加载到指定区域，供页面获取 request.setAttribute(\"questionItem\",questionItem); //保存一个操作的类型，传递到前端save request.setAttribute(\"operation\",\"edit\"); //跳转回到页面list list(request,response); } 然后需要在页面的表单action属性上接收该值 （5）启动项目进行测试 （6）测试发现编辑后，提交编辑的数据完成编辑哦呼跳转回页面，页面所有的数据又消失了，回到后台servlet查看edit方法，发现是页面跳转的问题 private void edit(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException { //将数据获取到，封装成一个对象 QuestionItem questionItem = BeanUtil.fillBean(request,QuestionItem.class,\"yyyy-MM-dd\"); //调用业务层接口save questionItemService.update(questionItem); //跳转回到页面list list(request,response); } （7）数据显示的问题解决后我们发现数据并没有真正的修改完成，分析原因发现是因为编辑后提交编辑的数据进行修改，但是没有提交问题选项的id值，我们需要在表单中接收问题选项的id值，能够让它在编辑的时候被提交到后台 （8）启动项目进行测试 1.6.5. 5.5 添加修改功能合并 （1）把questionItem/list.jsp进行备份，questionItem/list2.jsp （2）将后台list,toEdit方法进行备份，分别叫做list2,toEdit2，与前台的list2.jsp配套， （3）在后台servlet中封装一个saveOrUpdate方法，同时需要修改doGet方法 @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { String operation = request.getParameter(\"operation\"); if(\"list\".equals(operation)){ this.list(request,response); }else if(\"save\".equals(operation)){ this.save(request, response); }else if(\"toEdit\".equals(operation)){ this.toEdit(request,response); }else if(\"edit\".equals(operation)){ this.edit(request,response); }else if(\"delete\".equals(operation)){ this.delete(request,response); }else if(\"saveOrUpdate\".equals(operation)){ this.saveOrUpdate(request,response); } } private void saveOrUpdate(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException { //将数据获取到，封装成一个对象 QuestionItem questionItem = BeanUtil.fillBean(request,QuestionItem.class,\"yyyy-MM-dd\"); //如果页面传递了当前数据的id，则为修改业务，否则为添加业务 if(StringUtils.isNotBlank(questionItem.getId())){ questionItemService.update(questionItem); }else { questionItemService.save(questionItem); } //跳转回到页面list list(request,response); } （4）修改原始的list,toEdit方法，不需要之前添加操作标识的变量了 private void list(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException { String questionId = request.getParameter(\"questionId\"); //进入list页时添加对应的问题id，为添加操作使用 request.setAttribute(\"questionId\",questionId); //获取数据 PageInfo all = questionItemService.findAll(questionId, 1, 100); //将数据保存到指定的位置 request.setAttribute(\"page\",all); //跳转页面 request.getRequestDispatcher(\"/WEB-INF/pages/store/questionItem/list.jsp\").forward(request,response); } private void toEdit(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //查询要修改的数据findById String id = request.getParameter(\"id\"); QuestionItem questionItem = questionItemService.findById(id); //将数据加载到指定区域，供页面获取 request.setAttribute(\"questionItem\",questionItem); //跳转回到页面list list(request,response); } （5）修改list.jsp页面表单的action属性 （6）启动项目测试 1.6.6. 5.6 删除功能相关问题及解决方案 题目选项功能完成后，伴随而来的是题目的有些功能出现了问题，比如：删除题目，题目数据删除了，那该题目下的选项数据呢？目前是没有删除， 因此我们要解决的是：删除题目数据的时候伴随着删除该题目下的选项数据 解决方案 解决方案一:触发器 ◆注意使用触发器实现是将业务绑定到了数据库端,在进行系统设计时要确认方案 解决方案二:业务层删除操作中分别调用两个模块的删除功能 ◆注意删除主使用按id删除,删除从使用按关联id删除 ◆注意删除的顺序,先删从,后删主 解决方案三:存储过程 ◆整套的数据层解决方案,没有单一功能使用的 解决方案四:依赖框架提供的级联删除功能 解决方案五:定时维护/垃圾数据清理 Copyright © MISIN 2022 | 豫ICP备2021006345号-1 all right reserved，powered by Gitbook该文件修订时间： 2022-11-10 11:13:36 "},"2.JavaWeb/Web综合案例/web综合案例-day03.html":{"url":"2.JavaWeb/Web综合案例/web综合案例-day03.html","title":"web综合案例-day03","keywords":"","body":"1. web综合案例1.1. 学习目标1.2. 1. ​报表1.2.1. 1.1 POI写Excel文件1.2.2. 1.2 POI读Excel文件1.2.3. 1.3 题目模板表头制作1.2.4. 1.4 题目模板标题制作1.2.5. 1.5 题目模板数据制作1.2.6. 1.6 题目报表数据准备1.2.7. 1.7 题目报表业务实现1.3. 2.权限系统设计与开发1.3.1. 2.1 权限系统简介与结构设计1.3.2. 2.2 角色与模块功能快速开发1.3.3. 2.3 树形控件结构分析（1）1.3.4. 2.4 树形控件结构分析（2）1.3.5. 2.5 树形控件结构分析（3）1.3.6. 2.6 动态加载授权数据1.3.7. 2.7 绑定角色与模块关系1. web综合案例 1.1. 学习目标 目标1：完成使用POI读写Excel的测试案例 目标2：完成题目模板的制作，包括表头，标题及数据 目标3：完成题目报表数据导出的业务功能 目标4：完成角色与模块功能的快速开发 目标5：能够自己独立分析树形控件的页面制作 目标6：完成授权时动态加载授权数据 目标7：完成角色与模块的绑定关系 1.2. 1. ​报表 报表：简单的说，报表就是用表格、图表等格式来动态显示数据，可以用公式表示为：“报表 = 多样的格式 + 动态的数据”。 报表的种类有很多：Excel报表，PDF报表，网页报表等，他们各有优缺点 在本课程中，我们主要来将Excel报表。 对于Excel报表的技术实现上也有很多种选择： JXL：支持xls文件操作 POI：支持xls和xlsx文件操作 我们只要来讲POI技术，要使用POI就要导入其坐标，如下 org.apache.poi poi 4.0.1 org.apache.poi poi-ooxml 4.0.1 org.apache.poi poi-ooxml-schemas 4.0.1 1.2.1. 1.1 POI写Excel文件 在测试包下创建POI测试类：com.itheima.service.store.PoiTest public class PoiTest { @Test public void testWriteByPoi() throws IOException { //1.获取到对应的Excel文件，工作簿文件 Workbook wb = new XSSFWorkbook(); //2.创建工作表 Sheet sheet = wb.createSheet(); wb.createSheet(\"这是啥呀\"); //3.创建工作表中的行对象 Row row = sheet.createRow(1); //4.创建工作表中行中的列对象 Cell cell = row.createCell(1); //5.在列中写数据 cell.setCellValue(\"测试一下单元格\"); //创建一个文件对象，作为excel文件内容的输出文件 File f = new File(\"test.xlsx\"); //输出时通过流的形式对外输出，包装对应的目标文件 OutputStream os = new FileOutputStream(f); //将内存中的workbook数据写入到流中 wb.write(os); wb.close(); os.close(); } } 使用单元测试进行测试！ 1.2.2. 1.2 POI读Excel文件 创建读Excel的测试方法：testReadByPoi @Test public void testReadByPoi() throws IOException { //1.获取要读取的文件工作簿对象 Workbook wb = new XSSFWorkbook(\"test.xlsx\"); //2.获取工作表 Sheet s = wb.getSheetAt(0); //3.获取行 Row row = s.getRow(3); //4.获取列 Cell cell = row.getCell(1); //5.根据数据的类型获取数据 // String data = cell.getStringCellValue(); // double data = cell.getNumericCellValue(); boolean data = cell.getBooleanCellValue(); System.out.println(data); wb.close(); } 直接读取第一节创建好的Excel文件 1.2.3. 1.3 题目模板表头制作 前两节我们讲了如何去读取及写入Excel数据，操作相对简单，但是实际业务中我们要操作的Excel报表还是比较繁琐的，我们可以从今日课程资料中找到我们最终要导出报表的模板：资料\\Excel解析\\模板.xlsx 这种形式的我们如何去操作呢？ 在测试类中再编写一个测试方法：testProjectPoi @Test public void testProjectPoi() throws IOException { //1.获取到对应的Excel文件，工作簿文件 Workbook wb = new XSSFWorkbook(); //2.创建工作表 Sheet s = wb.createSheet(\"题目数据文件\"); //制作标题 s.addMergedRegion(new CellRangeAddress(1,1,1,12)); Row row_1 = s.createRow(1); Cell cell_1_1 = row_1.createCell(1); cell_1_1.setCellValue(\"在线试题导出信息\"); //创建一个样式 CellStyle cs_title = wb.createCellStyle(); cs_title.setAlignment(HorizontalAlignment.CENTER); cs_title.setVerticalAlignment(VerticalAlignment.CENTER); cell_1_1.setCellStyle(cs_title); //制作表头 //制作数据区 //创建一个文件对象，作为excel文件内容的输出文件 File f = new File(\"test.xlsx\"); //输出时通过流的形式对外输出，包装对应的目标文件 OutputStream os = new FileOutputStream(f); //将内存中的workbook数据写入到流中 wb.write(os); wb.close(); os.close(); } 1.2.4. 1.4 题目模板标题制作 下面我们接着来做Excel的表头 在测试方法testProjectPoi中继续编写代码 @Test public void testProjectPoi() throws IOException { //1.获取到对应的Excel文件，工作簿文件 Workbook wb = new XSSFWorkbook(); //2.创建工作表 Sheet s = wb.createSheet(\"题目数据文件\"); //设置通用配置 // s.setColumnWidth(4,100); //制作标题 s.addMergedRegion(new CellRangeAddress(1,1,1,12)); Row row_1 = s.createRow(1); Cell cell_1_1 = row_1.createCell(1); cell_1_1.setCellValue(\"在线试题导出信息\"); //创建一个样式 CellStyle cs_title = wb.createCellStyle(); cs_title.setAlignment(HorizontalAlignment.CENTER); cs_title.setVerticalAlignment(VerticalAlignment.CENTER); cell_1_1.setCellStyle(cs_title); //制作表头 String[] fields = {\"题目ID\",\"所属公司ID\",\"所属目录ID\",\"题目简介\",\"题干描述\", \"题干配图\",\"题目分析\",\"题目类型\",\"题目难度\",\"是否经典题\",\"题目状态\",\"审核状态\"}; Row row_2 = s.createRow(2); for (int i = 0; i 1.2.5. 1.5 题目模板数据制作 我们继续来做数据区 @Test public void testProjectPoi() throws IOException { //1.获取到对应的Excel文件，工作簿文件 Workbook wb = new XSSFWorkbook(); //2.创建工作表 Sheet s = wb.createSheet(\"题目数据文件\"); //设置通用配置 // s.setColumnWidth(4,100); CellStyle cs_field = wb.createCellStyle(); cs_field.setAlignment(HorizontalAlignment.CENTER); cs_field.setBorderTop(BorderStyle.THIN); cs_field.setBorderBottom(BorderStyle.THIN); cs_field.setBorderLeft(BorderStyle.THIN); cs_field.setBorderRight(BorderStyle.THIN); //制作标题 s.addMergedRegion(new CellRangeAddress(1,1,1,12)); Row row_1 = s.createRow(1); Cell cell_1_1 = row_1.createCell(1); cell_1_1.setCellValue(\"在线试题导出信息\"); //创建一个样式 CellStyle cs_title = wb.createCellStyle(); cs_title.setAlignment(HorizontalAlignment.CENTER); cs_title.setVerticalAlignment(VerticalAlignment.CENTER); cell_1_1.setCellStyle(cs_title); //制作表头 String[] fields = {\"题目ID\",\"所属公司ID\",\"所属目录ID\",\"题目简介\",\"题干描述\", \"题干配图\",\"题目分析\",\"题目类型\",\"题目难度\",\"是否经典题\",\"题目状态\",\"审核状态\"}; Row row_2 = s.createRow(2); for (int i = 0; i questionList = new ArrayList<>(); Question qq = new Question(); qq.setId(\"1\"); qq.setPicture(\"12\"); qq.setReviewStatus(\"13\"); qq.setAnalysis(\"14\"); qq.setCatalogId(\"15\"); qq.setCompanyId(\"16\"); qq.setDifficulty(\"17\"); qq.setIsClassic(\"18\"); qq.setRemark(\"19\"); qq.setState(\"21\"); qq.setSubject(\"31\"); qq.setType(\"41\"); questionList.add(qq); Question qqq = new Question(); qqq.setId(\"1\"); qqq.setPicture(\"12\"); qqq.setReviewStatus(\"13\"); qqq.setAnalysis(\"14\"); qqq.setCatalogId(\"15\"); qqq.setCompanyId(\"16\"); qqq.setDifficulty(\"17\"); qqq.setIsClassic(\"18\"); qqq.setRemark(\"19\"); qqq.setState(\"21\"); qqq.setSubject(\"31\"); qqq.setType(\"41\"); questionList.add(qqq); int row_index = 0; for (Question q : questionList) { int cell_index = 0; Row row_temp = s.createRow(3 + row_index++); Cell cell_data_1 = row_temp.createCell(1 + cell_index++); cell_data_1.setCellValue(q.getId()); //++ cell_data_1.setCellStyle(cs_field); Cell cell_data_2 = row_temp.createCell(1 + cell_index++); cell_data_2.setCellValue(q.getCompanyId()); //++ cell_data_2.setCellStyle(cs_field); Cell cell_data_3 = row_temp.createCell(1 + cell_index++); cell_data_3.setCellValue(q.getCatalogId()); //++ cell_data_3.setCellStyle(cs_field); Cell cell_data_4 = row_temp.createCell(1 + cell_index++); cell_data_4.setCellValue(q.getRemark()); //++ cell_data_4.setCellStyle(cs_field); Cell cell_data_5 = row_temp.createCell(1 + cell_index++); cell_data_5.setCellValue(q.getSubject()); //++ cell_data_5.setCellStyle(cs_field); Cell cell_data_6 = row_temp.createCell(1 + cell_index++); cell_data_6.setCellValue(q.getPicture()); //++ cell_data_6.setCellStyle(cs_field); Cell cell_data_7 = row_temp.createCell(1 + cell_index++); cell_data_7.setCellValue(q.getAnalysis()); //++ cell_data_7.setCellStyle(cs_field); Cell cell_data_8 = row_temp.createCell(1 + cell_index++); cell_data_8.setCellValue(q.getType()); //++ cell_data_8.setCellStyle(cs_field); Cell cell_data_9 = row_temp.createCell(1 + cell_index++); cell_data_9.setCellValue(q.getDifficulty()); //++ cell_data_9.setCellStyle(cs_field); Cell cell_data_10 = row_temp.createCell(1 + cell_index++); cell_data_10.setCellValue(q.getIsClassic()); //++ cell_data_10.setCellStyle(cs_field); Cell cell_data_11 = row_temp.createCell(1 + cell_index++); cell_data_11.setCellValue(q.getState()); //++ cell_data_11.setCellStyle(cs_field); Cell cell_data_12 = row_temp.createCell(1 + cell_index++); cell_data_12.setCellValue(q.getReviewStatus()); //++ cell_data_12.setCellStyle(cs_field); } //创建一个文件对象，作为excel文件内容的输出文件 File f = new File(\"test.xlsx\"); //输出时通过流的形式对外输出，包装对应的目标文件 OutputStream os = new FileOutputStream(f); //将内存中的workbook数据写入到流中 wb.write(os); wb.close(); os.close(); } 测试即可！ 1.2.6. 1.6 题目报表数据准备 （1）找到/WEB-INF/pages/store/question/list.jsp页面，修改导出题目的链接 导出题目 （2）在后台servlet中添加对应的方法 // uri:/store/question?operation=list @WebServlet(\"/store/question\") public class QuestionServlet extends BaseServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { String operation = request.getParameter(\"operation\"); if(\"list\".equals(operation)){ this.list(request,response); } //其他的else if判断省略 else if(\"downloadReport\".equals(operation)){ this.downloadReport(request,response); } } private void downloadReport(HttpServletRequest request, HttpServletResponse response) throws IOException { //生成报告的文件，然后传递到前端页面 questionService.getReport(); } } （3）在业务层QuestionService添加一个方法getReport public void getReport() throws IOException; （4）在对应的实现类中去实现该方法，把之前在测试类中的测试方法testProjectPoi里面的所有代码拷贝过来，其中数据我们应该是从数据库中查询出来，因此调用dao完成数据的查询 @Override public void getReport() throws IOException{ //获取对应要展示的数据 SqlSession sqlSession = null; List questionList = null; try{ //1.获取SqlSession sqlSession = MapperFactory.getSqlSession(); //2.获取Dao QuestionDao questionDao = MapperFactory.getMapper(sqlSession,QuestionDao.class); //3.调用Dao层操作 questionList = questionDao.findAll(); }catch (Exception e){ throw new RuntimeException(e); //记录日志 }finally { try { TransactionUtil.close(sqlSession); }catch (Exception e){ e.printStackTrace(); } } //1.获取到对应的Excel文件，工作簿文件 Workbook wb = new XSSFWorkbook(); //2.创建工作表 Sheet s = wb.createSheet(\"题目数据文件\"); //设置通用配置 // s.setColumnWidth(4,100); CellStyle cs_field = wb.createCellStyle(); cs_field.setAlignment(HorizontalAlignment.CENTER); cs_field.setBorderTop(BorderStyle.THIN); cs_field.setBorderBottom(BorderStyle.THIN); cs_field.setBorderLeft(BorderStyle.THIN); cs_field.setBorderRight(BorderStyle.THIN); //制作标题 s.addMergedRegion(new CellRangeAddress(1,1,1,12)); Row row_1 = s.createRow(1); Cell cell_1_1 = row_1.createCell(1); cell_1_1.setCellValue(\"在线试题导出信息\"); //创建一个样式 CellStyle cs_title = wb.createCellStyle(); cs_title.setAlignment(HorizontalAlignment.CENTER); cs_title.setVerticalAlignment(VerticalAlignment.CENTER); cell_1_1.setCellStyle(cs_title); //制作表头 String[] fields = {\"题目ID\",\"所属公司ID\",\"所属目录ID\",\"题目简介\",\"题干描述\", \"题干配图\",\"题目分析\",\"题目类型\",\"题目难度\",\"是否经典题\",\"题目状态\",\"审核状态\"}; Row row_2 = s.createRow(2); for (int i = 0; i 1.2.7. 1.7 题目报表业务实现 现在后台已经能够生成Excel文件并且填充了数据，但是真实的业务中我们是需要将这个文件下载到客户端 （1）修改接口方法getReport，添加返回值 /** * 获取包含了数据的流对象 * @return 包含了报表数据的流对象 * @throws IOException */ ByteArrayOutputStream getReport() throws IOException; （2）在实现类中实现该方法时，将内存中的Excel相关数据写入到ByteArrayOutputStream流中 @Override public ByteArrayOutputStream getReport() throws IOException { //前面的代码无变动 故省略 /** //创建一个文件对象，作为excel文件内容的输出文件 File f = new File(\"test.xlsx\"); //输出时通过流的形式对外输出，包装对应的目标文件 OutputStream os = new FileOutputStream(f); //将内存中的workbook数据写入到流中 wb.write(os); wb.close(); os.close(); */ //将内存中的workbook数据写入到流中 ByteArrayOutputStream os = new ByteArrayOutputStream(); wb.write(os); wb.close(); return os; } （3）修改后台servlet的downloadReport方法 private void downloadReport(HttpServletRequest request, HttpServletResponse response) throws IOException { //返回的数据类型为文件xlsx类型 response.setContentType(\"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet;charset=utf-8\"); String fileName = new String(\"测试文件名.xlsx\".getBytes(),\"iso8859-1\"); response.addHeader(\"Content-Disposition\",\"attachment;fileName=\"+fileName); //生成报告的文件，然后传递到前端页面 ByteArrayOutputStream os = questionService.getReport(); //获取产生响应的流对象 ServletOutputStream sos = response.getOutputStream(); //将数据从原始的字节流对象中提取出来写入到servlet对应的输出流中 os.writeTo(sos); //将输出流刷新 sos.flush(); os.close(); } （4）启动项目，进行测试 1.3. 2.权限系统设计与开发 1.3.1. 2.1 权限系统简介与结构设计 什么是权限系统？ 权限系统是一种设定用户与可操作模块之间关系的系统。 通过设定用户与可操作的模块之间的关系,控制用户在可指定范围内进行业务执行 基于用户的权限控制(UBAC:User-BasedAccessControl) 基于角色的权限控制(RBAC:role-BasedAccessControl) 在本课程中我们采用基于角色的权限控制RBAC 1.3.2. 2.2 角色与模块功能快速开发 首先来看角色与模块各自的结构 （1）创建角色实体：com.itheima.domain.system.Role public class Role { private String id; private String name; private String remark; private Date createTime; // getter/setter略 } （2）创建角色Dao：com.itheima.dao.system.RoleDao public interface RoleDao { int save(Role role); int delete(Role role); int update(Role role); Role findById(String id); List findAll(); } （3）添加接口的映射配置文件，从今日课程资料中找到资料\\dao层资源文件将里面所有的xml映射配置文件拷贝到项目src/main/resources/com/itheima/dao/system目录下 （4）创建业务层接口：com.itheima.service.system.RoleService public interface RoleService { /** * 添加 * @param role * @return */ void save(Role role); /** * 删除 * @param role * @return */ void delete(Role role); /** * 修改 * @param role * @return */ void update(Role role); /** * 查询单个 * @param id 查询的条件（id） * @return 查询的结果，单个对象 */ Role findById(String id); /** * 查询全部的数据 * @return 全部数据的列表对象 */ List findAll(); /** * 分页查询数据 * @param page 页码 * @param size 每页显示的数据总量 * @return */ PageInfo findAll(int page, int size); } （5）创建接口的实现：com.itheima.service.system.impl public class RoleServiceImpl implements RoleService { @Override public void save(Role role) { SqlSession sqlSession = null; try{ //1.获取SqlSession sqlSession = MapperFactory.getSqlSession(); //2.获取Dao RoleDao roleDao = MapperFactory.getMapper(sqlSession,RoleDao.class); //id使用UUID的生成策略来获取 String id = UUID.randomUUID().toString(); role.setId(id); //3.调用Dao层操作 roleDao.save(role); //4.提交事务 TransactionUtil.commit(sqlSession); }catch (Exception e){ TransactionUtil.rollback(sqlSession); throw new RuntimeException(e); //记录日志 }finally { try { TransactionUtil.close(sqlSession); }catch (Exception e){ e.printStackTrace(); } } } @Override public void delete(Role role) { SqlSession sqlSession = null; try{ //1.获取SqlSession sqlSession = MapperFactory.getSqlSession(); //2.获取Dao RoleDao roleDao = MapperFactory.getMapper(sqlSession,RoleDao.class); //3.调用Dao层操作 roleDao.delete(role); //4.提交事务 TransactionUtil.commit(sqlSession); }catch (Exception e){ TransactionUtil.rollback(sqlSession); throw new RuntimeException(e); //记录日志 }finally { try { TransactionUtil.close(sqlSession); }catch (Exception e){ e.printStackTrace(); } } } @Override public void update(Role role) { SqlSession sqlSession = null; try{ //1.获取SqlSession sqlSession = MapperFactory.getSqlSession(); //2.获取Dao RoleDao roleDao = MapperFactory.getMapper(sqlSession,RoleDao.class); //3.调用Dao层操作 roleDao.update(role); //4.提交事务 TransactionUtil.commit(sqlSession); }catch (Exception e){ TransactionUtil.rollback(sqlSession); throw new RuntimeException(e); //记录日志 }finally { try { TransactionUtil.close(sqlSession); }catch (Exception e){ e.printStackTrace(); } } } @Override public Role findById(String id) { SqlSession sqlSession = null; try{ //1.获取SqlSession sqlSession = MapperFactory.getSqlSession(); //2.获取Dao RoleDao roleDao = MapperFactory.getMapper(sqlSession,RoleDao.class); //3.调用Dao层操作 return roleDao.findById(id); }catch (Exception e){ throw new RuntimeException(e); //记录日志 }finally { try { TransactionUtil.close(sqlSession); }catch (Exception e){ e.printStackTrace(); } } } @Override public List findAll() { SqlSession sqlSession = null; try{ //1.获取SqlSession sqlSession = MapperFactory.getSqlSession(); //2.获取Dao RoleDao roleDao = MapperFactory.getMapper(sqlSession,RoleDao.class); //3.调用Dao层操作 return roleDao.findAll(); }catch (Exception e){ throw new RuntimeException(e); //记录日志 }finally { try { TransactionUtil.close(sqlSession); }catch (Exception e){ e.printStackTrace(); } } } @Override public PageInfo findAll(int page, int size) { SqlSession sqlSession = null; try{ //1.获取SqlSession sqlSession = MapperFactory.getSqlSession(); //2.获取Dao RoleDao roleDao = MapperFactory.getMapper(sqlSession,RoleDao.class); //3.调用Dao层操作 PageHelper.startPage(page,size); List all = roleDao.findAll(); PageInfo pageInfo = new PageInfo(all); return pageInfo; }catch (Exception e){ throw new RuntimeException(e); //记录日志 }finally { try { TransactionUtil.close(sqlSession); }catch (Exception e){ e.printStackTrace(); } } } } （6）创建sevlet：com.itheima.web.controller.system.RoleServlet // uri:/system/role?operation=list @WebServlet(\"/system/role\") public class RoleServlet extends BaseServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { String operation = request.getParameter(\"operation\"); if(\"list\".equals(operation)){ this.list(request,response); }else if(\"toAdd\".equals(operation)){ this.toAdd(request,response); }else if(\"save\".equals(operation)){ this.save(request, response); }else if(\"toEdit\".equals(operation)){ this.toEdit(request,response); }else if(\"edit\".equals(operation)){ this.edit(request,response); }else if(\"delete\".equals(operation)){ this.delete(request,response); }else if(\"author\".equals(operation)){ this.author(request,response); } } private void list(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException { //进入列表页 //获取数据 int page = 1; int size = 5; if(StringUtils.isNotBlank(request.getParameter(\"page\"))){ page = Integer.parseInt(request.getParameter(\"page\")); } if(StringUtils.isNotBlank(request.getParameter(\"size\"))){ size = Integer.parseInt(request.getParameter(\"size\")); } PageInfo all = roleService.findAll(page, size); //将数据保存到指定的位置 request.setAttribute(\"page\",all); //跳转页面 request.getRequestDispatcher(\"/WEB-INF/pages/system/role/list.jsp\").forward(request,response); } private void toAdd(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException { //加载所有的部门信息放入到roleList List all = roleService.findAll(); request.setAttribute(\"roleList\",all); //跳转页面 request.getRequestDispatcher(\"/WEB-INF/pages/system/role/add.jsp\").forward(request,response); } private void save(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException { //将数据获取到，封装成一个对象 Role role = BeanUtil.fillBean(request,Role.class,\"yyyy-MM-dd\"); //调用业务层接口save roleService.save(role); //跳转回到页面list response.sendRedirect(request.getContextPath()+\"/system/role?operation=list\"); } private void toEdit(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //查询要修改的数据findById String id = request.getParameter(\"id\"); Role role = roleService.findById(id); //将数据加载到指定区域，供页面获取 request.setAttribute(\"role\",role); //跳转页面 request.getRequestDispatcher(\"/WEB-INF/pages/system/role/update.jsp\").forward(request,response); } private void edit(HttpServletRequest request, HttpServletResponse response) throws IOException { //将数据获取到，封装成一个对象 Role role = BeanUtil.fillBean(request,Role.class,\"yyyy-MM-dd\"); //调用业务层接口save roleService.update(role); //跳转回到页面list response.sendRedirect(request.getContextPath()+\"/system/role?operation=list\"); } private void delete(HttpServletRequest request, HttpServletResponse response) throws IOException { //将数据获取到，封装成一个对象 Role role = BeanUtil.fillBean(request,Role.class); //调用业务层接口save roleService.delete(role); //跳转回到页面list response.sendRedirect(request.getContextPath()+\"/system/role?operation=list\"); } private void author(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException { //获取要授权的角色id String roleId = request.getParameter(\"id\"); //使用id查询对应的数据（角色id对应的模块信息） Role role = roleService.findById(roleId); request.setAttribute(\"role\",role); //根据当前的角色id获取所有的模块数据，并加载关系数据 List map = moduleService.findAuthorDataByRoleId(roleId); //map转成json数据 ObjectMapper om = new ObjectMapper(); String json = om.writeValueAsString(map); request.setAttribute(\"roleModuleJson\",json); // TODO 数据未查询 //跳转到树页面中 request.getRequestDispatcher(\"/WEB-INF/pages/system/role/author.jsp\").forward(request,response); } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doGet(request,response); } } 同时需要在BaseServlet中添加RoleService public class BaseServlet extends HttpServlet { protected CompanyService companyService; protected DeptService deptService; protected UserService userService; protected CourseService courseService; protected CatalogService catalogService; protected QuestionService questionService; protected QuestionItemService questionItemService; protected RoleService roleService; @Override public void init() throws ServletException { companyService = new CompanyServiceImpl(); deptService = new DeptServiceImpl(); userService = new UserServiceImpl(); courseService = new CourseServiceImpl(); catalogService = new CatalogServiceImpl(); questionService = new QuestionServiceImpl(); questionItemService = new QuestionItemServiceImpl(); roleService = new RoleServiceImpl(); } } （7）拷贝页面到项目中，从今日课程资料中找到：资料\\模块页面将下面所有模块全部拷贝到项目/WEB-INF/pages/system目录下 （8）启动项目，进行测试 然后我们按照相同的方式将模块的相关功能快速开发完成 （1）创建模块实体：com.itheima.domain.system.Module public class Module { private String id; private String parentId; private String name; private Long ctype; private Long state; private String curl; private String remark; private Module module; // getter/setter略 } （2）创建模块dao：com.itheima.dao.system.ModuleDao public interface ModuleDao { int save(Module module); int delete(Module module); int update(Module module); Module findById(String id); List findAll(); } （3）映射配置文件，之前已拷贝，查看一下即可 （4）创建业务层接口：com.itheima.service.system.ModuleService public interface ModuleService { /** * 添加 * @param module * @return */ void save(Module module); /** * 删除 * @param module * @return */ void delete(Module module); /** * 修改 * @param module * @return */ void update(Module module); /** * 查询单个 * @param id 查询的条件（id） * @return 查询的结果，单个对象 */ Module findById(String id); /** * 查询全部的数据 * @return 全部数据的列表对象 */ List findAll(); /** * 分页查询数据 * @param page 页码 * @param size 每页显示的数据总量 * @return */ PageInfo findAll(int page, int size); } （5）创建业务层实现类：com.itheima.service.system.impl.ModuleServiceImpl public class ModuleServiceImpl implements ModuleService { @Override public void save(Module module) { SqlSession sqlSession = null; try{ //1.获取SqlSession sqlSession = MapperFactory.getSqlSession(); //2.获取Dao ModuleDao moduleDao = MapperFactory.getMapper(sqlSession,ModuleDao.class); //id使用UUID的生成策略来获取 String id = UUID.randomUUID().toString(); module.setId(id); //3.调用Dao层操作 moduleDao.save(module); //4.提交事务 TransactionUtil.commit(sqlSession); }catch (Exception e){ TransactionUtil.rollback(sqlSession); throw new RuntimeException(e); //记录日志 }finally { try { TransactionUtil.close(sqlSession); }catch (Exception e){ e.printStackTrace(); } } } @Override public void delete(Module module) { SqlSession sqlSession = null; try{ //1.获取SqlSession sqlSession = MapperFactory.getSqlSession(); //2.获取Dao ModuleDao moduleDao = MapperFactory.getMapper(sqlSession,ModuleDao.class); //3.调用Dao层操作 moduleDao.delete(module); //4.提交事务 TransactionUtil.commit(sqlSession); }catch (Exception e){ TransactionUtil.rollback(sqlSession); throw new RuntimeException(e); //记录日志 }finally { try { TransactionUtil.close(sqlSession); }catch (Exception e){ e.printStackTrace(); } } } @Override public void update(Module module) { SqlSession sqlSession = null; try{ //1.获取SqlSession sqlSession = MapperFactory.getSqlSession(); //2.获取Dao ModuleDao moduleDao = MapperFactory.getMapper(sqlSession,ModuleDao.class); //3.调用Dao层操作 moduleDao.update(module); //4.提交事务 TransactionUtil.commit(sqlSession); }catch (Exception e){ TransactionUtil.rollback(sqlSession); throw new RuntimeException(e); //记录日志 }finally { try { TransactionUtil.close(sqlSession); }catch (Exception e){ e.printStackTrace(); } } } @Override public Module findById(String id) { SqlSession sqlSession = null; try{ //1.获取SqlSession sqlSession = MapperFactory.getSqlSession(); //2.获取Dao ModuleDao moduleDao = MapperFactory.getMapper(sqlSession,ModuleDao.class); //3.调用Dao层操作 return moduleDao.findById(id); }catch (Exception e){ throw new RuntimeException(e); //记录日志 }finally { try { TransactionUtil.close(sqlSession); }catch (Exception e){ e.printStackTrace(); } } } @Override public List findAll() { SqlSession sqlSession = null; try{ //1.获取SqlSession sqlSession = MapperFactory.getSqlSession(); //2.获取Dao ModuleDao moduleDao = MapperFactory.getMapper(sqlSession,ModuleDao.class); //3.调用Dao层操作 return moduleDao.findAll(); }catch (Exception e){ throw new RuntimeException(e); //记录日志 }finally { try { TransactionUtil.close(sqlSession); }catch (Exception e){ e.printStackTrace(); } } } @Override public PageInfo findAll(int page, int size) { SqlSession sqlSession = null; try{ //1.获取SqlSession sqlSession = MapperFactory.getSqlSession(); //2.获取Dao ModuleDao moduleDao = MapperFactory.getMapper(sqlSession,ModuleDao.class); //3.调用Dao层操作 PageHelper.startPage(page,size); List all = moduleDao.findAll(); PageInfo pageInfo = new PageInfo(all); return pageInfo; }catch (Exception e){ throw new RuntimeException(e); //记录日志 }finally { try { TransactionUtil.close(sqlSession); }catch (Exception e){ e.printStackTrace(); } } } } （6）创建servlet：com.itheima.web.controller.system.ModuleServlet // uri:/system/module?operation=list @WebServlet(\"/system/module\") public class ModuleServlet extends BaseServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { String operation = request.getParameter(\"operation\"); if(\"list\".equals(operation)){ this.list(request,response); }else if(\"toAdd\".equals(operation)){ this.toAdd(request,response); }else if(\"save\".equals(operation)){ this.save(request, response); }else if(\"toEdit\".equals(operation)){ this.toEdit(request,response); }else if(\"edit\".equals(operation)){ this.edit(request,response); }else if(\"delete\".equals(operation)){ this.delete(request,response); } } private void list(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException { //进入列表页 //获取数据 int page = 1; int size = 10; if(StringUtils.isNotBlank(request.getParameter(\"page\"))){ page = Integer.parseInt(request.getParameter(\"page\")); } if(StringUtils.isNotBlank(request.getParameter(\"size\"))){ size = Integer.parseInt(request.getParameter(\"size\")); } PageInfo all = moduleService.findAll(page, size); //将数据保存到指定的位置 request.setAttribute(\"page\",all); //跳转页面 request.getRequestDispatcher(\"/WEB-INF/pages/system/module/list.jsp\").forward(request,response); } private void toAdd(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException { //加载所有的信息放入到moduleList List all = moduleService.findAll(); request.setAttribute(\"moduleList\",all); //跳转页面 request.getRequestDispatcher(\"/WEB-INF/pages/system/module/add.jsp\").forward(request,response); } private void save(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException { //将数据获取到，封装成一个对象 Module module = BeanUtil.fillBean(request,Module.class,\"yyyy-MM-dd\"); //调用业务层接口save moduleService.save(module); //跳转回到页面list response.sendRedirect(request.getContextPath()+\"/system/module?operation=list\"); } private void toEdit(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //查询要修改的数据findById String id = request.getParameter(\"id\"); Module module = moduleService.findById(id); //将数据加载到指定区域，供页面获取 request.setAttribute(\"module\",module); //跳转页面 request.getRequestDispatcher(\"/WEB-INF/pages/system/module/update.jsp\").forward(request,response); } private void edit(HttpServletRequest request, HttpServletResponse response) throws IOException { //将数据获取到，封装成一个对象 Module module = BeanUtil.fillBean(request,Module.class,\"yyyy-MM-dd\"); //调用业务层接口save moduleService.update(module); //跳转回到页面list response.sendRedirect(request.getContextPath()+\"/system/module?operation=list\"); } private void delete(HttpServletRequest request, HttpServletResponse response) throws IOException { //将数据获取到，封装成一个对象 Module module = BeanUtil.fillBean(request,Module.class); //调用业务层接口save moduleService.delete(module); //跳转回到页面list response.sendRedirect(request.getContextPath()+\"/system/module?operation=list\"); } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doGet(request,response); } } 同时需要在BserServlet中添加ModuleService public class BaseServlet extends HttpServlet { protected CompanyService companyService; protected DeptService deptService; protected UserService userService; protected CourseService courseService; protected CatalogService catalogService; protected QuestionService questionService; protected QuestionItemService questionItemService; protected RoleService roleService; protected ModuleService moduleService; @Override public void init() throws ServletException { companyService = new CompanyServiceImpl(); deptService = new DeptServiceImpl(); userService = new UserServiceImpl(); courseService = new CourseServiceImpl(); catalogService = new CatalogServiceImpl(); questionService = new QuestionServiceImpl(); questionItemService = new QuestionItemServiceImpl(); roleService = new RoleServiceImpl(); moduleService = new ModuleServiceImpl(); } } （7）拷贝页面：之前已经拷贝过了，我们可以直接启动项目进行测试！ 1.3.3. 2.3 树形控件结构分析（1） 树形结构如下图所示： 对应的实现技术有： dTree tdTree zTree 我们主要来看关于zTree的相关操作，从今日课程资料中找到：资料\\树\\zTree-zTree_v3-master\\zTree_v3\\demo\\cn\\index.html，打开就可查阅 我们主要是针对里面的Checkbox 勾选操作进行学习，我们自己来编写一个测试页面test.html来完成一个树形结构，操作步骤： 1.观察整体的页面结构 2.去除无效的基础信息 3.去除页面无效的基础信息 4.分析页面js内容 5.分页结构所使用的数据 6.简化页面内容书写 - 1.观察整体的页面结构 - 2.去除无效的基础信息 - 3.去除页面无效的基础信息 - 4.分析页面js内容 - 5.分页结构所使用的数据 - 6.简化页面内容书写 var setting = { check: { enable: true }, data: { simpleData: { enable: true } } }; /**/var zNodes =[ { id:11, pId:1, name:\"随意勾选 1-1\", open:true}, { id:111, pId:11, name:\"随意勾选 1-1-1\"}, { id:112, pId:11, name:\"随意勾选 1-1-2\"}, { id:12, pId:1, name:\"随意勾选 1-2\", open:true}, { id:121, pId:12, name:\"随意勾选 1-2-1\"}, { id:122, pId:12, name:\"随意勾选 1-2-2\"}, { id:2, pId:0, name:\"随意勾选 2\", checked:true, open:true}, { id:21, pId:2, name:\"随意勾选 2-1\"}, { id:22, pId:2, name:\"随意勾选 2-2\", open:true}, { id:221, pId:22, name:\"随意勾选 2-2-1\", checked:true}, { id:222, pId:22, name:\"随意勾选 2-2-2\"}, { id:23, pId:2, name:\"随意勾选 2-3\"}, { id:1, pId:0, name:\"随意勾选 1\", open:true} ]; var code; function setCheck() { var zTree = $.fn.zTree.getZTreeObj(\"treeDemo\"), py = $(\"#py\").attr(\"checked\")? \"p\":\"\", sy = $(\"#sy\").attr(\"checked\")? \"s\":\"\", pn = $(\"#pn\").attr(\"checked\")? \"p\":\"\", sn = $(\"#sn\").attr(\"checked\")? \"s\":\"\", type = { \"Y\":py + sy, \"N\":pn + sn}; zTree.setting.check.chkboxType = type; showCode('setting.check.chkboxType = { \"Y\" : \"' + type.Y + '\", \"N\" : \"' + type.N + '\" };'); } function showCode(str) { if (!code) code = $(\"#code\"); code.empty(); code.append(\"\"+str+\"\"); } $(document).ready(function(){ $.fn.zTree.init($(\"#treeDemo\"), setting, zNodes); setCheck(); $(\"#py\").bind(\"change\", setCheck); $(\"#sy\").bind(\"change\", setCheck); $(\"#pn\").bind(\"change\", setCheck); $(\"#sn\").bind(\"change\", setCheck); }); 关联父 关联子 关联父 关联子 1.3.4. 2.4 树形控件结构分析（2） 分析页面js - 1.观察整体的页面结构 - 2.去除无效的基础信息 - 3.去除页面无效的基础信息 - 4.分析页面js内容 - 5.分页结构所使用的数据 - 6.简化页面内容书写 var setting = {check: {enable: true},data: { simpleData: {enable: true}}}; var zNodes =[ { id:11, pId:1, name:\"随意勾选 1-1\", open:true}, { id:111, pId:11, name:\"随意勾选 1-1-1\"}, { id:112, pId:11, name:\"随意勾选 1-1-2\"}, { id:12, pId:1, name:\"随意勾选 1-2\", open:true}, { id:121, pId:12, name:\"随意勾选 1-2-1\"}, { id:122, pId:12, name:\"随意勾选 1-2-2\"}, { id:2, pId:0, name:\"随意勾选 2\", checked:true, open:true}, { id:21, pId:2, name:\"随意勾选 2-1\"}, { id:22, pId:2, name:\"随意勾选 2-2\", open:true}, { id:221, pId:22, name:\"随意勾选 2-2-1\", checked:true}, { id:222, pId:22, name:\"随意勾选 2-2-2\"}, { id:23, pId:2, name:\"随意勾选 2-3\"}, { id:1, pId:0, name:\"随意勾选 1\", open:true} ]; $(document).ready(function(){ $.fn.zTree.init($(\"#treeDemo\"), setting, zNodes); var zTree = $.fn.zTree.getZTreeObj(\"treeDemo\") zTree.setting.check.chkboxType = { \"Y\" : \"ps\", \"N\" : \"ps\" } }); 1.3.5. 2.5 树形控件结构分析（3） 继续进行数据结构的分析 var setting = {check: {enable: true},data: { simpleData: {enable: true}}}; var zNodes =[ { id:2, pId:0, name:\"test\", checked:true, open:true}, { id:21, pId:2, name:\"test22222\"}, { id:22, pId:1, name:\"test22222\"} ]; $(document).ready(function(){ $.fn.zTree.init($(\"#treeDemo\"), setting, zNodes); var zTree = $.fn.zTree.getZTreeObj(\"treeDemo\") zTree.setting.check.chkboxType = { \"Y\" : \"ps\", \"N\" : \"ps\" } }); 1.3.6. 2.6 动态加载授权数据 （1）查看页面：/WEB-INF/pages/system/role/list.jsp，授权按钮点击时要传递id （2）进入后台servlet：RoleServlet添加author方法 @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { String operation = request.getParameter(\"operation\"); if(\"list\".equals(operation)){ this.list(request,response); }else if(\"toAdd\".equals(operation)){ this.toAdd(request,response); }else if(\"save\".equals(operation)){ this.save(request, response); }else if(\"toEdit\".equals(operation)){ this.toEdit(request,response); }else if(\"edit\".equals(operation)){ this.edit(request,response); }else if(\"delete\".equals(operation)){ this.delete(request,response); }else if(\"author\".equals(operation)){ this.author(request,response); } } private void author(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException { //获取要授权的角色id String roleId = request.getParameter(\"id\"); // TODO 数据未查询 //跳转到树页面中 request.getRequestDispatcher(\"/WEB-INF/pages/system/role/author.jsp\").forward(request,response); } （3）在/WEB-INF/pages/system/role下创建一个jsp页面：test.jsp，内容粘贴我们之前编辑的test.html页面，我们在后台跳转的时候跳转的是该目录下的author.jsp，我们可以拿这俩页面做一个对比 （4）完善servlet中的author方法 private void author(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException { //获取要授权的角色id String roleId = request.getParameter(\"id\"); //使用id查询对应的数据（角色id对应的模块信息） Role role = roleService.findById(roleId); request.setAttribute(\"role\",role); //根据当前的角色id获取所有的模块数据，并加载关系数据 List map = moduleService.findAuthorDataByRoleId(roleId); //map转成json数据 ObjectMapper om = new ObjectMapper(); String json = om.writeValueAsString(map); request.setAttribute(\"roleModuleJson\",json); // TODO 数据未查询 //跳转到树页面中 request.getRequestDispatcher(\"/WEB-INF/pages/system/role/author.jsp\").forward(request,response); } 在WEB-INF\\pages\\system\\role\\author.jsp页面中修改js代码：用后台查询的数据直接赋值给zNodes var zNodes =${roleModuleJson} （5）在ModuleService中添加findAuthorDataByRoleId方法 /** * 根据角色id获取对应的所有模块关联数据 * @param roleId 角色id */ List findAuthorDataByRoleId(String roleId); （6）在实现类中实现该方法 @Override public List findAuthorDataByRoleId(String roleId) { SqlSession sqlSession = null; try{ //1.获取SqlSession sqlSession = MapperFactory.getSqlSession(); //2.获取Dao ModuleDao moduleDao = MapperFactory.getMapper(sqlSession,ModuleDao.class); //3.调用Dao层操作 return moduleDao.findAuthorDataByRoleId(roleId); }catch (Exception e){ throw new RuntimeException(e); //记录日志 }finally { try { TransactionUtil.close(sqlSession); }catch (Exception e){ e.printStackTrace(); } } } （7）添加dao接口方法：findAuthorDataByRoleId List findAuthorDataByRoleId(String roleId); （8）在ModuleDao对应的映射配置文件中添加对应的查询语句 select module_id as id, parent_id as pId, name as name, case when module_id in (select module_id from ss_role_module where role_id = #{roleId}) then 'true' else 'false' end as checked from ss_module （9）启动测试 1.3.7. 2.7 绑定角色与模块关系 （1）查看WEB-INF\\pages\\system\\role\\author.jsp页面中提交保存的js代码 //实现权限分配 function submitCheckedNodes() { //1.获取所有的勾选权限节点 var nodes = zTreeObj.getCheckedNodes(true);//true:被勾选，false：未被勾选 //2.循环nodes，获取每个节点的id，并将数据加入数组 //1,2,3,4,5 1+\",\"+2+\",\"+3..... //数据的临时存储数组，为了方便内容连接成为一个由逗号分隔的字符串 var moduleArrays = []; for(var i=0;i （2）在后台servlet中添加方法updateRoleModule @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { String operation = request.getParameter(\"operation\"); if(\"list\".equals(operation)){ this.list(request,response); } //中间的else if无变动 省略 else if(\"updateRoleModule\".equals(operation)){ this.updateRoleModule(request,response); } } private void updateRoleModule(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException { String roleId = request.getParameter(\"roleId\"); String moduleIds = request.getParameter(\"moduleIds\"); roleService.updateRoleModule(roleId,moduleIds); //跳转回到页面list response.sendRedirect(request.getContextPath()+\"/system/role?operation=list\"); } （3）在RoleService中添加方法updateRoleModule /** * 建立角色与模块之间的关联 * @param roleId 角色id * @param moduleIds 模块id（多个） */ void updateRoleModule(String roleId, String moduleIds); （4）在对应的实现类中实现该方法 @Override public void updateRoleModule(String roleId, String moduleIds) { SqlSession sqlSession = null; try{ //1.获取SqlSession sqlSession = MapperFactory.getSqlSession(); //2.获取Dao RoleDao roleDao = MapperFactory.getMapper(sqlSession,RoleDao.class); //3.调用Dao层操作 //修改role_module //3.1现有的关系全部取消掉 roleDao.deleteRoleModule(roleId); //3.2建立新的关系（多个） String[] moduleArray = moduleIds.split(\",\"); for(String moduleId:moduleArray){ roleDao.saveRoleModule(roleId,moduleId); } //4.提交事务 TransactionUtil.commit(sqlSession); }catch (Exception e){ TransactionUtil.rollback(sqlSession); throw new RuntimeException(e); //记录日志 }finally { try { TransactionUtil.close(sqlSession); }catch (Exception e){ e.printStackTrace(); } } } （5）在RoleDao中添加方法deleteRoleModule，saveRoleModule void deleteRoleModule(String roleId); void saveRoleModule(@Param(\"roleId\") String roleId, @Param(\"moduleId\") String moduleId); （6）在对应的映射配置文件中添加对应的操作 delete from ss_role_module where role_id = #{roleId,jdbcType=VARCHAR} insert into ss_role_module (role_id, module_id) values (#{roleId,jdbcType=VARCHAR}, #{moduleId,jdbcType=VARCHAR}) （7）启动项目进行测试 Copyright © MISIN 2022 | 豫ICP备2021006345号-1 all right reserved，powered by Gitbook该文件修订时间： 2022-11-10 11:13:48 "},"2.JavaWeb/Web综合案例/web综合案例-day04.html":{"url":"2.JavaWeb/Web综合案例/web综合案例-day04.html","title":"web综合案例-day04","keywords":"","body":"1. web综合案例1.1. 学习目标1.2. 1. 用户与角色1.2.1. 1.1 绑定用户与角色关系数据准备1.2.2. 1.2 绑定用户与角色关系1.3. 2. 登陆1.3.1. 2.1 登陆功能快速开发1.3.2. 2.2 用户菜单控制数据准备1.3.3. 2.3 登陆用户菜单控制1.4. 3.权限校验1.4.1. 3.1 获取请求url1.4.2. 3.2 获取登陆用户可执行操作1.4.3. 3.3 权限校验1. web综合案例 1.1. 学习目标 目标1：完成用户与角色的绑定功能 目标2：完成登陆功能的快速开发 目标3：完成登陆用户菜单控制的功能 目标4：完成登陆用户权限校验的功能 1.2. 1. 用户与角色 1.2.1. 1.1 绑定用户与角色关系数据准备 （1）在用户模块下的\\WEB-INF\\pages\\system\\user\\list.jsp页面中找到角色按钮，对应的点击事件和函数的绑定都已完成，roleList方法中向后台UserServelt发送请求，执行userRoleList方法，传递参数用户id （2）找到UserServlet，添加方法 @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { String operation = request.getParameter(\"operation\"); if(\"list\".equals(operation)){ this.list(request,response); } //中间的省略 else if(\"userRoleList\".equals(operation)){ this.userRoleList(request,response); } } private void userRoleList(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { String userId = request.getParameter(\"id\"); User user = userService.findById(userId); //将数据加载到指定区域，供页面获取 request.setAttribute(\"user,user); //获取所有的角色列表 List all = roleService.findAllRoleByUserId(userId); request.setAttribute(\"roleList\",all); //跳转页面 request.getRequestDispatcher(\"/WEB-INF/pages/system/user/role.jsp\").forward(request,response); } 同时从day03的课程资料中找到：模块页面\\user\\role.jsp，拷贝到工程/WEB-INF/pages/system/user/目录下 （3）在RoleService接口中添加查询方法，根据用户id查询角色列表 List findAllRoleByUserId(String userId); （4）在对应的实现类中去实现该方法 @Override public List findAllRoleByUserId(String userId) { SqlSession sqlSession = null; try{ //1.获取SqlSession sqlSession = MapperFactory.getSqlSession(); //2.获取Dao RoleDao roleDao = MapperFactory.getMapper(sqlSession,RoleDao.class); //3.调用Dao层操作 return roleDao.findAllRoleByUserId(userId); }catch (Exception e){ throw new RuntimeException(e); //记录日志 }finally { try { TransactionUtil.close(sqlSession); }catch (Exception e){ e.printStackTrace(); } } } （5）在dao接口RoleDao中添加查询方法findAllRoleByUserId List findAllRoleByUserId(String userId); （6）在映射配置文件RoleDao.xml中添加对应的查询 SELECT role_id, NAME, CASE WHEN role_id IN (SELECT role_id FROM ss_role_user WHERE user_id = #{'userId'}) THEN 'checked' ELSE '' END AS remark FROM ss_role （7）修改页面/WEB-INF/pages/system/user/role.jsp，添加checked ${role.name} （8）启动项目测试！ 1.2.2. 1.2 绑定用户与角色关系 现在要真正去绑定用户与角色的关系，前台页面提交表单后会将用户的id和选择的角色的id传递到后台servlet （1）在UserServlet中添加新的方法 @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { String operation = request.getParameter(\"operation\"); if(\"list\".equals(operation)){ this.list(request,response); } //中间的省略 else if(\"userRoleList\".equals(operation)){ this.userRoleList(request,response); }else if(\"updateRole\".equals(operation)){ this.updateRole(request,response); } } private void updateRole(HttpServletRequest request, HttpServletResponse response) throws IOException { String userId = request.getParameter(\"userId\"); String[] roleIds = request.getParameterValues(\"roleIds\"); userService.updateRole(userId,roleIds); //跳转回到页面list response.sendRedirect(request.getContextPath()+\"/system/user?operation=list\"); } （2）在UserService接口中添加一个新的方法updateRole void updateRole(String userId, String[] roleIds); （3）在对应的实现类中去实现 @Override public void updateRole(String userId, String[] roleIds) { SqlSession sqlSession = null; try{ //1.获取SqlSession sqlSession = MapperFactory.getSqlSession(); //2.获取Dao UserDao userDao = MapperFactory.getMapper(sqlSession,UserDao.class); userDao.deleteRole(userId); for(String roleId : roleIds){ userDao.updateRole(userId,roleId); } //4.提交事务 TransactionUtil.commit(sqlSession); }catch (Exception e){ TransactionUtil.rollback(sqlSession); throw new RuntimeException(e); //记录日志 }finally { try { TransactionUtil.close(sqlSession); }catch (Exception e){ e.printStackTrace(); } } } （4）在dao接口UserDao中添加两个方法 void deleteRole(String userId); void updateRole(@Param(\"userId\") String userId, @Param(\"roleId\")String roleId); （5）在该接口对应的映射配置文件中添加两个操作 delete from ss_role_user where user_id = #{userId,jdbcType=VARCHAR} insert into ss_role_user (role_id, user_id) values (#{roleId,jdbcType=VARCHAR}, #{userId,jdbcType=VARCHAR}) （6）启动项目进行测试！ 1.3. 2. 登陆 1.3.1. 2.1 登陆功能快速开发 （1）找到项目webapp/login.jsp登陆页面，修改form表单提交的action路径 （2）在后台UserServlet添加登陆的方法 @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { String operation = request.getParameter(\"operation\"); if(\"list\".equals(operation)){ this.list(request,response); } //中间省略 else if(\"login\".equals(operation)){ this.login(request,response); } } private void login(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { String email = request.getParameter(\"email\"); String pwd = request.getParameter(\"password\"); User user = userService.login(email,pwd); if(user != null) { request.getSession().setAttribute(\"loginUser\", user); //跳转页面 request.getRequestDispatcher(\"/WEB-INF/pages/home/main.jsp\").forward(request, response); }else{ response.sendRedirect(request.getContextPath()+\"/login.jsp\"); } } （3）在因为层接口UserService中添加登陆的方法 /** * 根据邮箱和密码登录 * @param email * @param pwd * @return */ User login(String email, String pwd); （4）在对应的实现类中去实现登陆方法 @Override public User login(String email, String pwd) { SqlSession sqlSession = null; try{ //1.获取SqlSession sqlSession = MapperFactory.getSqlSession(); //2.获取Dao UserDao userDao = MapperFactory.getMapper(sqlSession,UserDao.class); //3.调用Dao层操作 pwd = MD5Util.md5(pwd); return userDao.findByEmailAndPwd(email,pwd); }catch (Exception e){ throw new RuntimeException(e); //记录日志 }finally { try { TransactionUtil.close(sqlSession); }catch (Exception e){ e.printStackTrace(); } } } （5）在UserDao接口中添加查询方法 User findByEmailAndPwd(@Param(\"email\")String email, @Param(\"password\")String pwd); （6）在UserDao.xml中添加查询 select from ss_user where email = #{email,jdbcType=VARCHAR} and password = #{password,jdbcType=VARCHAR} （7）将原本在webapp/pages/home下的所有页面统一挪到/WEB-INF/pages下，注意是连同home目录一起挪 （8）修改/WEB-INF/pages/home/main.jsp内容区的路径 （9）在后台UserServlet中添加方法 @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { String operation = request.getParameter(\"operation\"); if(\"list\".equals(operation)){ this.list(request,response); } //中间省略 else if(\"home\".equals(operation)){ this.home(request,response); } } private void home(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { request.getRequestDispatcher(\"/WEB-INF/pages/home/home.jsp\").forward(request, response); } （10）启动项目测试 1.3.2. 2.2 用户菜单控制数据准备 我们先来完成登陆后的注销操作，这是一套的 （1）找到/WEB-INF/pages/home/header.jsp中找到注销，添加请求连接 注销 （2）在后台UserServlet中添加对应的方法logout @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { String operation = request.getParameter(\"operation\"); if(\"list\".equals(operation)){ this.list(request,response); } //中间的省略 else if(\"login\".equals(operation)){ this.login(request,response); }else if(\"logout\".equals(operation)){ this.logout(request,response); }else if(\"home\".equals(operation)){ this.home(request,response); } } private void logout(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { request.getSession().removeAttribute(\"loginUser\"); response.sendRedirect(request.getContextPath()+\"/login.jsp\"); } （3）在用户登陆的时候需要去查询该用户对应的角色对应的所有模块，因此需要在后台的UserServlet中修改用户登陆的方法，添加数据的查询 private void login(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { String email = request.getParameter(\"email\"); String pwd = request.getParameter(\"password\"); User user = userService.login(email,pwd); if(user != null) { request.getSession().setAttribute(\"loginUser\", user); //如果登录成功，加载该用户对应的角色对应的所有模块 List moduleList = userService.findModuleById(user.getId()); request.setAttribute(\"moduleList\",moduleList); //跳转页面 request.getRequestDispatcher(\"/WEB-INF/pages/home/main.jsp\").forward(request, response); }else{ response.sendRedirect(request.getContextPath()+\"/login.jsp\"); } } （4）在UserService接口中添加方法findModuleById /** * 根据用户id查询所有可以操作的菜单对象 * @param id 用户的id * @return */ List findModuleById(String id); （5）在实现类中去实现该方法 @Override public List findModuleById(String id) { SqlSession sqlSession = null; try{ //1.获取SqlSession sqlSession = MapperFactory.getSqlSession(); //2.获取Dao ModuleDao moduleDao = MapperFactory.getMapper(sqlSession,ModuleDao.class); //3.调用Dao层操作 return moduleDao.findModuleByUserId(id); }catch (Exception e){ throw new RuntimeException(e); //记录日志 }finally { try { TransactionUtil.close(sqlSession); }catch (Exception e){ e.printStackTrace(); } } } （6）在ModuleDao接口中添加查询方法findModuleByUserId List findModuleByUserId(String id); （7）在ModuleDao.xml中添加对应的查询 /*userid->用户角色关系表->roleid->角色模块关系表->moduleid->module信息*/ SELECT DISTINCT m.module_id, m.parent_id, m.name, m.ctype, m.state, m.curl, m.remark FROM ss_module AS m, ss_role_module AS rm, ss_role_user AS ru WHERE m.module_id = rm.module_id AND rm.role_id = ru.role_id AND ru.user_id = #{id,jdbcType=VARCHAR} 至此：用户的角色对应的模块数据已查询出来了，后续就是要在页面进行控制展示 1.3.3. 2.3 登陆用户菜单控制 （1）找到/WEB-INF/pages/home/aside.jsp页面，添加用户菜单的展示 菜单 ${item.name} ${item2.name} 启动项目进行测试 1.4. 3.权限校验 1.4.1. 3.1 获取请求url （1）创建过滤器：com.itheima.web.filters.AuthorFilter @WebFilter(value = \"/*\") public class AuthorFilter implements Filter { private FilterConfig filterConfig; /** * 初始化方法，获取过滤器的配置对象 * @param filterConfig * @throws ServletException */ @Override public void init(FilterConfig filterConfig) throws ServletException { this.filterConfig = filterConfig; } @Override public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws IOException, ServletException { //1.定义和协议相关的请求和响应对象 HttpServletRequest request ; HttpServletResponse response; try{ //2.把参数转换成协议相关的对象 request = (HttpServletRequest)req; response = (HttpServletResponse)resp; //1.获取本次操作 String url = request.getRequestURI(); String queryString = request.getQueryString(); //1.当前获取到的url： /system/dept url = url.substring(1); //2.当前获取到的查询参数：operation=list operation=toEdit&id=100 int index = queryString.indexOf('&'); if(index != -1){ queryString = queryString.substring(0,index); } url = url + \"?\" + queryString; //2.获取到当前登录人允许的操作 //3.比对本次操作是否在当前登录人允许的操作范围内 //3.1如果允许，放行 //3.2不允许跳转到非法访问页 //6.放行 chain.doFilter(request,response); }catch (Exception e){ e.printStackTrace(); } } @Override public void destroy() { //可以做一些清理操作 } } 1.4.2. 3.2 获取登陆用户可执行操作 （1）登陆成功后需要将用户的觉得对应的模块信息存放到session，找到UserServlet中的登陆方法login， private void login(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { String email = request.getParameter(\"email\"); String pwd = request.getParameter(\"password\"); User user = userService.login(email,pwd); if(user != null) { request.getSession().setAttribute(\"loginUser\", user); //如果登录成功，加载该用户对应的角色对应的所有模块 List moduleList = userService.findModuleById(user.getId()); request.setAttribute(\"moduleList\",moduleList); //当前登录用户对应的可操作模块的所有url拼接成一个大的字符串 StringBuffer sbf = new StringBuffer(); for(Module m: moduleList){ sbf.append(m.getCurl()); sbf.append(','); } request.getSession().setAttribute(\"authorStr\",sbf.toString()); //跳转页面 request.getRequestDispatcher(\"/WEB-INF/pages/home/main.jsp\").forward(request, response); }else{ response.sendRedirect(request.getContextPath()+\"/login.jsp\"); } } （2）修改AuthorFilter @Override public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws IOException, ServletException { //1.定义和协议相关的请求和响应对象 HttpServletRequest request ; HttpServletResponse response; HttpSession session; try{ //2.把参数转换成协议相关的对象 request = (HttpServletRequest)req; response = (HttpServletResponse)resp; session = request.getSession(); //1.获取本次操作 String url = request.getRequestURI(); //.css .js .png .jpg .index if(url.endsWith(\".css\") || url.endsWith(\".js\") || url.endsWith(\".png\") || url.endsWith(\".jpg\") || url.endsWith(\"index.jsp\") || url.endsWith(\"login.jsp\")){ chain.doFilter(request,response); return; } String queryString = request.getQueryString(); if(queryString.endsWith(\"operation=login\")){ chain.doFilter(request,response); return; } //1.当前获取到的url： /system/dept url = url.substring(1); //2.当前获取到的查询参数：operation=list operation=toEdit&id=100 int index = queryString.indexOf('&'); if(index != -1){ queryString = queryString.substring(0,index); } url = url + \"?\" + queryString; //2.获取到当前登录人允许的操作 String authorStr = session.getAttribute(\"authorStr\").toString(); //3.比对本次操作是否在当前登录人允许的操作范围内 //3.1如果允许，放行 //3.2不允许跳转到非法访问页 //6.放行 chain.doFilter(request,response); }catch (Exception e){ e.printStackTrace(); } } （3）启动项目在模块管理功能中去添加一些数据，如下所示 然后需要在角色管理中为对应的角色进行授权 1.4.3. 3.3 权限校验 开始授权 （1）从day03的课程资料中找到模块页面/unauthorized.jsp，拷贝到项目的webapp下即可 （2）更改AuthorFilter， @Override public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws IOException, ServletException { HttpServletRequest request ; HttpServletResponse response; HttpSession session; try{ request = (HttpServletRequest)req; response = (HttpServletResponse)resp; session = request.getSession(); //1.获取本次操作 String url = request.getRequestURI(); //.css .js .png .jpg .index if(url.endsWith(\".css\") || url.endsWith(\".js\") || url.endsWith(\".png\") || url.endsWith(\".jpg\") || url.endsWith(\"index.jsp\") || url.endsWith(\"unauthorized.jsp\") || url.endsWith(\"login.jsp\")){ chain.doFilter(request,response); return; } String queryString = request.getQueryString(); if(queryString.endsWith(\"operation=login\") ||queryString.endsWith(\"operation=home\") ||queryString.endsWith(\"operation=logout\")){ chain.doFilter(request,response); return; } //1.当前获取到的url： /system/dept url = url.substring(1); //2.当前获取到的查询参数：operation=list operation=toEdit&id=100 int index = queryString.indexOf('&'); if(index != -1){ queryString = queryString.substring(0,index); } url = url + \"?\" + queryString; //2.获取到当前登录人允许的操作 String authorStr = session.getAttribute(\"authorStr\").toString(); //3.比对本次操作是否在当前登录人允许的操作范围内 if(authorStr.contains(url)){ //3.1如果允许，放行 chain.doFilter(request,response); return; }else{ //3.2不允许跳转到非法访问页 response.sendRedirect(request.getContextPath()+\"/unauthorized.jsp\"); } }catch (Exception e){ e.printStackTrace(); } } （3）对于页面上的元素，如果没有操作权限，我们直接让用户看不到即可，怎么操作呢？在页面上做一个判断，我们举一个例子，其他操作都是一样的 找到/WEB-INF/pages/system/user/list.jsp， 新建 删除 刷新 角色 （4）启动项目，测试 Copyright © MISIN 2022 | 豫ICP备2021006345号-1 all right reserved，powered by Gitbook该文件修订时间： 2022-11-10 11:14:04 "},"2.JavaWeb/Web综合案例/web综合案例-day05.html":{"url":"2.JavaWeb/Web综合案例/web综合案例-day05.html","title":"web综合案例-day05","keywords":"","body":"1. web综合案例1.1. 1.登录功能1.1.1. 1.1 登录功能1.1.2. 1.2 将登陆信息保存到redis中1.1.3. 1.3 登陆状态校验1.1.4. 1.4 退出登录1.2. 2.答题试卷1.2.1. 2.1 生成试卷1.2.2. 2.2 加载选项1.2.3. 2.3 单选结果处理1.2.4. 2.4 多选结果处理1.2.5. 2.5 提交试卷1. web综合案例 1.1. 1.登录功能 1.1.1. 1.1 登录功能 （1）MemberServlet中添加login方法 public Result login(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { Member member = getData(request,Member.class); member = memberService.login(member.getEmail(),member.getPassword()); if(member != null){ return new Result(\"登录成功！\", member); }else{ return new Result(\"用户名密码错误，请重试！\", false, null, Code.LOGIN_FAIL); } } （2）Code中添加 常量 public static final Integer LOGIN_FAIL = 50101; （3）补全service和impl和dao、xml代码 MemberService /** * 根据email和密码登录 * @param email * @param password * @return */ Member login(String email, String password); MemberServiceImpl @Override public Member login(String email, String password) { SqlSession sqlSession = null; try{ //1.获取SqlSession sqlSession = MapperFactory.getSqlSession(); //2.获取Dao MemberDao memberDao = MapperFactory.getMapper(sqlSession, MemberDao.class); password = MD5Util.md5(password); Member member = memberDao.findByEmailAndPwd(email,password); return member; }catch (Exception e){ e.printStackTrace(); throw new RuntimeException(e); //记录日志 }finally { try { TransactionUtil.close(sqlSession); }catch (Exception e){ e.printStackTrace(); } } } MemberDao Member findByEmailAndPwd(@Param(\"email\") String email,@Param(\"password\") String password); MemberDao.xml id,nick_name,password,gender,birthday,email,telephone,address,register_date,state select from tr_memberwhere email = #{email,jdbcType=VARCHAR} and password = #{password,jdbcType=VARCHAR} （4）修改login.html，添加164行左右 //根据返回的结果进行下一步的动作 if( res.flag){ // 跳转页面 index.html window.open(\"index.html\",\"_self\"); }else{ alert(res.message); } 启动服务器，访问页面，进行登录 1.1.2. 1.2 将登陆信息保存到redis中 （1）将资料中工程资源文件中的JedisUtils拷贝工程目录下。 （2）将资料中工程资源文件中的jedis.properties拷贝到resources下 （3）将登录用户id信息放入到redis是，修改``login 方法，添加如下代码 @Override public Member login(String email, String password) { SqlSession sqlSession = null; try{ //1.获取SqlSession sqlSession = MapperFactory.getSqlSession(); //2.获取Dao MemberDao memberDao = MapperFactory.getMapper(sqlSession, MemberDao.class); password = MD5Util.md5(password); Member member = memberDao.findByEmailAndPwd(email,password); //3.将登录人的信息保存到redis中 Jedis jedis = JedisUtils.getResource(); //使用登录人的id作为key，设定3600秒的过期时间，value值待定 jedis.setex(member.getId(),3600,\"\"); jedis.close(); return member; }catch (Exception e){ e.printStackTrace(); throw new RuntimeException(e); //记录日志 }finally { try { TransactionUtil.close(sqlSession); }catch (Exception e){ e.printStackTrace(); } } } 启动redis服务器。 启动项目服务进行测试 1.1.3. 1.3 登陆状态校验 （1）在MemberServlet中添加方法checkLogin方法，用于判断登录用户的id是否存在redis中 public Result checkLogin(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { Member member = getData(request,Member.class); //根据获取到的id去redis中查找，是否存在 String nickName = memberService.getLoginInfo(member.getId()); return new Result(\"\", nickName); } （2）修改index.html中checkLogin()方法 checkLogin() { //判断当前用户是否登录了，判断现在是否有登录人的信息 /* 状态1：未登录 document.querySelector(\"#register\").style.display = 'block'; document.querySelector(\"#login\").style.display = 'block'; document.querySelector(\"#myexam\").style.display = 'none'; document.querySelector(\"#exam\").style.display = 'none'; document.querySelector(\"#exit\").style.display = 'none'; document.querySelector(\"#nickname\").style.display = 'none'; */ /* 状态2：已登录 document.querySelector(\"#register\").style.display = 'none'; document.querySelector(\"#login\").style.display = 'none'; document.querySelector(\"#myexam\").style.display = 'block'; document.querySelector(\"#exam\").style.display = 'block'; document.querySelector(\"#exit\").style.display = 'block'; document.querySelector(\"#nickname\").style.display = 'block'; */ let _this = this; //从localStorage中获取数据，获取当前保存的用户名，再根据用户名获取后台是否登录的状态 if(!window.localStorage){ alert(\"浏览器不支持localStorage，请升级浏览器\") }else { //获取localStorage对象 let storage = window.localStorage; alert(\"id：\"+storage.id); //测试是否有登录数据，id if(storage.id == undefined){ //如果本地没有用户信息，显示登陆和注册按钮 document.querySelector(\"#register\").style.display = 'block'; document.querySelector(\"#login\").style.display = 'block'; document.querySelector(\"#myexam\").style.display = 'none'; document.querySelector(\"#exam\").style.display = 'none'; document.querySelector(\"#exit\").style.display = 'none'; document.querySelector(\"#nickname\").style.display = 'none'; }else { //如果本地存在用户信息，需要确认服务器是否存在当前用户登录信息（redis中） //发送请求，根据当前id去服务器中查找对应的数据 axios.post('/member/checkLogin', '{\"id\":\"'+storage.id+'\"}').then(function (response) { //alert(response.data.data) //获取响应数据 let res = response.data; //alert(\"redis服务器中存储的用户名信息 : \"+res.data) //判定本地用户对应是否处于登录状态，处于登录状态的用户具有用户名信息 if(res.data == undefined){ //如果没有用户名信息，当前用户未登录，显示登陆与注册按钮 document.querySelector(\"#register\").style.display = 'block'; document.querySelector(\"#login\").style.display = 'block'; document.querySelector(\"#myexam\").style.display = 'none'; document.querySelector(\"#exam\").style.display = 'none'; document.querySelector(\"#exit\").style.display = 'none'; document.querySelector(\"#nickname\").style.display = 'none'; }else{ //如果具有用户名信息，显示用户答题相关按钮 //设置vue对象nickname属性值 _this.nickname = res.data; document.querySelector(\"#register\").style.display = 'none'; document.querySelector(\"#login\").style.display = 'none'; document.querySelector(\"#myexam\").style.display = 'block'; document.querySelector(\"#exam\").style.display = 'block'; document.querySelector(\"#exit\").style.display = 'block'; //显示当前登录用户对应的登录信息组件 document.querySelector(\"#nickname\").style.display = 'block'; } }).catch(function (err) { console.log(err) }); } } }, （3）显示登录昵称 MemberService接口中添加方法 getLoginInfo /** * 根据登录人id获取对应的昵称，从redis中获取 * @param id * @return */ String getLoginInfo(String id); 修改MemberServiceImpl实现类中login方法 //使用登录人的id作为key，设定3600秒的过期时间，value值待定 jedis.setex(member.getId(),3600,member.getNickName()); 添加方法getLoginInfo方法 @Override public String getLoginInfo(String id) { //使用给定的id去查找redis中是否存在当前数据 Jedis jedis = JedisUtils.getResource(); String nickName = jedis.get(id); jedis.close(); return nickName; } 1.1.4. 1.4 退出登录 （1）修改index.html页面，将退出方法名修改成logout，并添加logout方法 退出 logout(){ //1.获取localStorage let storage = window.localStorage; //2.发送请求，清除登录状态 axios.post('/member/logout', '{\"id\":\"'+storage.id+'\"}').then(function (response) { //1.获取响应数据 let data = response.data; //2.提示 //alert(data.flag); }).catch(function (err) { console.log(err) }); //3.清理localStorage window.localStorage.clear(); //4.通过调用checkLogin方法重置主页面的右上角显示区域 this.checkLogin(); } }, (2) MemberServlet添加logout方法 public Result logout(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { Member member = getData(request,Member.class); boolean flag = memberService.logout(member.getId()); if(flag){ return new Result(\"退出成功!\", flag); }else{ return new Result(\"\", false, flag, Code.LOGOUT_FAIL); } } MemberService添加方法 boolean logout(String id); MemberServiceImpl添加方法 @Override public boolean logout(String id) { Jedis jedis = JedisUtils.getResource(); Long row = jedis.del(id); jedis.close(); return row > 0 ; } 1.2. 2.答题试卷 1.2.1. 2.1 生成试卷 （1）创建实体类Question package com.itheima.domain.store; import java.util.List; public class Question { private String id; //题目ID private String subject; //题干 private String type; //题目类型 1:单选，2：多选，3：简答 } (2) 创建ExamServlet继承BaseServlet @WebServlet(\"/exam/*\") public class ExamServlet extends BaseServlet { public Result getPaper(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { List questionList = examService.getPaper(); return new Result(\"试卷生成成功！\", questionList); } } (3) 创建ExamService public interface ExamService { List getPaper(); } (4) 创建ExamServiceImpl实现ExamService public class ExamServiceImpl implements ExamService { @Override public List getPaper() { SqlSession sqlSession = null; try{ //1.获取SqlSession sqlSession = MapperFactory.getSqlSession(); //2.获取Dao QuestionDao questionDao = MapperFactory.getMapper(sqlSession, QuestionDao.class); List questionList = questionDao.findAll(); return questionList; }catch (Exception e){ e.printStackTrace(); throw new RuntimeException(e); //记录日志 }finally { try { TransactionUtil.close(sqlSession); }catch (Exception e){ e.printStackTrace(); } } } } (5) 创建QuestionDao public interface QuestionDao { List findAll(); } (6) 创建QuestionDao.xml id, subject,type select from st_question order by limit 2 启动服务，开始测试 1.2.2. 2.2 加载选项 （1）创建QuestionItem实体类 package com.itheima.domain.store; public class QuestionItem { private String id; //ID private String questionId; //题目ID private String content; //选项内容 private String isRight; //是否正确答案 } （2）给Question实体类添加属性questionItemList private List questionItemList; public List getQuestionItemList() { return questionItemList; } public void setQuestionItemList(List questionItemList) { this.questionItemList = questionItemList; } (3) 创建QuestionItemDao public interface QuestionItemDao { List findByQuestionId(String questionId); } （4）创建QuestionItemDao.xml id, question_id, content, is_right select from st_question_item where question_id = #{questionId,jdbcType=VARCHAR} select from st_question_item where id = #{id,jdbcType=VARCHAR} select from st_question_item where question_id = #{questionId} (5) 修改QuestionDao.xml id, subject,type select from st_question order by id desc limit 2 1.2.3. 2.3 单选结果处理 在paper.html页面中，修改changeResultRadio方法 changeResultRadio(item){ //输出选中信息 // alert(\"当前选项所属题目id：\"+item.questionId); // alert('当前选项id：'+item.id); // alert(\"本次操作前数据结果：\" + JSON.stringify(this.results)) //组织数据（要加入到results中的数据） var temp = {\"questionId\":item.questionId,\"answer\":item.id}; //alert(JSON.stringify(temp)) //删除当前results中已经存在的本题目对应的数据 this.results = this.results.filter(e=>{return e.questionId !== item.questionId}) //alert(\"results[操作前]：\" + JSON.stringify(this.results)) //将本次操作的结果加入到results this.results.push(temp); //alert(\"results[操作后]：\" + JSON.stringify(this.results)) }, 刷新页面，查看alert信息 1.2.4. 2.4 多选结果处理 在paper.html页面中，修改changeResultCheckBox方法 changeResultCheckBox(item){ /* var s = '11,22,33,44'; x = '33' var arr = s.split(\",\"); var index = arr.indexOf(x); arr.splice(index,1); s = arr.join(\",\"); alert(s) */ //输出选中信息 // alert(\"当前选项所属题目id：\"+item.questionId); // alert(\"当前选项id：\"+item.id); // alert('当前'+ this.checked); // alert(\"本次操作前数据结果：\" + JSON.stringify(this.results)) var temp = this.results.find(e=>{return e.questionId === item.questionId}) if(temp == undefined){ //当前题目从来未作答过 temp = {\"questionId\":item.questionId,\"answer\":item.id}; }else{ if(this.checked){ // 添加该答案 temp.answer = temp.answer + \",\" + item.id; }else{ //删除该答案 var arr = temp.answer.split(\",\"); var index = arr.indexOf(item.id); arr.splice(index,1); temp.answer = arr.join(\",\"); } } //组织数据（要加入到results中的数据） // var temp = {\"questionId\":item.questionId,\"answer\":item.id}; // alert(JSON.stringify(temp)) //删除当前results中已经存在的本题目对应的数据 this.results = this.results.filter(e=>{return e.questionId !== item.questionId}) alert(\"results[操作前]：\" + JSON.stringify(this.results)) //将本次操作的结果加入到results this.results.push(temp); alert(\"results[操作后]：\" + JSON.stringify(this.results)) }, 1.2.5. 2.5 提交试卷 paper.html最终代码 --> 自我测试 开&nbsp;&nbsp;&nbsp; 始&nbsp;&nbsp;&nbsp; 答&nbsp;&nbsp;&nbsp; 题 题干 选项 {{question.subject}} {{item.content}} {{item.content}} 交卷 /* 脚本中创建对象,处理业务 */ new Vue({ el: '#app', data: { questions:[], results:[], checked:[], }, methods: { /*-------------------------单选多选题处理结构 开始------------------------- //1.分情况处理，单选题与多选题处理方式不同 //2.约定回传的答案格式 单选题由题号与选项组成，多选题由题号和多个选项组成 { questionId:XXXXXXXX, answer:mm } { questionId:XXXXXXXX, answer:mm,nn } //3.无论是单选还是多选，最终都是将所有题目的答案结果放置在一个数据中保存（results），整体操作就是为results添加/修改数据 [{},{},{}] //4.操作模式 每次操作一个题目，先将当前题目对应的questionId在原始results中删除，添加新数据到results中 [1,1,1] 单选：加入一个数据，如果之前有这个题目的数据，先删除再添加 多选：加入一个数据，如果之前有这个题目的数据，先删除再添加 -------------------------单选多选题处理结构 结束-------------------------*/ changeResultRadio(item){ //输出选中信息 // alert(\"当前选项所属题目id：\"+item.questionId); // alert('当前选项id：'+item.id); // alert(\"本次操作前数据结果：\" + JSON.stringify(this.results)) //组织数据（要加入到results中的数据） var temp = {\"questionId\":item.questionId,\"answer\":item.id}; //alert(JSON.stringify(temp)) //删除当前results中已经存在的本题目对应的数据 this.results = this.results.filter(e=>{return e.questionId !== item.questionId}) //alert(\"results[操作前]：\" + JSON.stringify(this.results)) //将本次操作的结果加入到results this.results.push(temp); //alert(\"results[操作后]：\" + JSON.stringify(this.results)) }, changeResultCheckBox(item){ /* var s = '11,22,33,44'; x = '33' var arr = s.split(\",\"); var index = arr.indexOf(x); arr.splice(index,1); s = arr.join(\",\"); alert(s) */ //输出选中信息 // alert(\"当前选项所属题目id：\"+item.questionId); // alert(\"当前选项id：\"+item.id); // alert('当前'+ this.checked); // alert(\"本次操作前数据结果：\" + JSON.stringify(this.results)) var temp = this.results.find(e=>{return e.questionId === item.questionId}) if(temp == undefined){ //当前题目从来未作答过 temp = {\"questionId\":item.questionId,\"answer\":item.id}; }else{ if(this.checked){ // 添加该答案 temp.answer = temp.answer + \",\" + item.id; }else{ //删除该答案 var arr = temp.answer.split(\",\"); var index = arr.indexOf(item.id); arr.splice(index,1); temp.answer = arr.join(\",\"); } } //组织数据（要加入到results中的数据） // var temp = {\"questionId\":item.questionId,\"answer\":item.id}; // alert(JSON.stringify(temp)) //删除当前results中已经存在的本题目对应的数据 this.results = this.results.filter(e=>{return e.questionId !== item.questionId}) //alert(\"results[操作前]：\" + JSON.stringify(this.results)) //将本次操作的结果加入到results this.results.push(temp); //alert(\"results[操作后]：\" + JSON.stringify(this.results)) var arr ; var temp = this.results.find(e=>{return e.questionId === item.questionId}) if(temp == undefined){ temp = {\"questionId\":item.questionId,\"answer\":item.id}; }else{ if(this.checked){ temp.answer = temp.answer + \",\" + item.id; }else{ arr = temp.answer.split(\",\"); var index = arr.indexOf(item.id); arr.splice(index,1); temp.answer = arr.join(\",\"); } } this.results = this.results.filter(e=>{return e.questionId !== item.questionId}) if(var.length > 0){ this.results.push(temp); } var temp = this.results.find(e=>{return e.questionId === item.questionId}) if(temp == undefined){ temp = {\"questionId\":item.questionId,\"answer\":item.id}; }else{ if(this.checked){ temp.answer = temp.answer + \",\" + item.id; }else{ var arr = temp.answer.split(\",\"); var index = arr.indexOf(item.id); arr.splice(index,1); temp.answer = arr.join(\",\"); } } this.results = this.results.filter(e=>{return e.questionId !== item.questionId}) this.results.push(temp); }, submitForm(formName) { if(this.results.length != this.questions.length){ alert(\"请检查题目是否全部选择\"); return; }else{ if(window.confirm(\"确定交卷吗？\")) { //把json数据转成字符串 let str = JSON.stringify(this.results); //获取localSotrage let storage = window.localStorage; //发送请求，交卷 axios.post('/exam/applyPaper', '{\"memberId\":\"'+storage.id+'\",\"results\":'+str+'}').then(function (response) { //输出提示信息 //alert(response.data.message); //发送完请求，跳转到交卷成功页面 window.open('/index.html', '_self'); }).catch(function (err) { console.log(err) }); } } }, findQuestion(){ let _this = this; //4.发送post请求，获取题目信息 axios.post('/exam/getPaper').then(function (response) { //5.得到响应数据 var res = response.data; //alert(JSON.stringify(res)); _this.questions = res.data; }).catch(function (err) { console.log(err) }); } }, created(){ this.findQuestion(); }, }); ExamServlet @WebServlet(\"/exam/*\") public class ExamServlet extends BaseServlet { public Result getPaper(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { List questionList = examService.getPaper(); return new Result(\"试卷生成成功！\", questionList); } public Result applyPaper(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //memberId:?????,results:[{},{}] //1.得到全部请求的json数据 String json = JSONObject.parseObject(request.getInputStream(), String.class); //2.将json数据转换为json对象 JSONObject jsonObject = JSON.parseObject(json); //3.获取当前提交试卷人的id String memberId = jsonObject.getObject(\"memberId\", String.class); //4.获取当前提交的试卷信息 JSONArray jsonArray = jsonObject.getJSONArray(\"results\"); List examQuestionList = jsonArray.toJavaList(ExamQuestion.class); boolean flag = examService.applyPaper(memberId,examQuestionList); return new Result(\"试卷提交成功！\",flag); } } ExamPaper实体类 package com.itheima.domain.front; import java.util.Date; public class ExamPaper { private String id; private String memberId; private Date applyTime; private String state; //1-可用 0-不可用 private Integer score; } ExamQuestion实体类 package com.itheima.domain.front; public class ExamQuestion { private String id; private String examPaperId; private String questionId; private String answer; } ExamService接口 package com.itheima.service.front; import com.itheima.domain.front.ExamQuestion; import com.itheima.domain.store.Question; import java.util.List; public interface ExamService { List getPaper(); boolean applyPaper(String memberId, List examQuestionList); } ExamServiceImpl实现类 package com.itheima.service.front.impl; import com.itheima.dao.front.ExamPaperDao; import com.itheima.dao.front.ExamQuestionDao; import com.itheima.dao.store.QuestionDao; import com.itheima.domain.front.ExamPaper; import com.itheima.domain.front.ExamQuestion; import com.itheima.domain.store.Question; import com.itheima.factory.MapperFactory; import com.itheima.service.front.ExamService; import com.itheima.utils.TransactionUtil; import org.apache.ibatis.session.SqlSession; import java.util.Date; import java.util.List; import java.util.UUID; public class ExamServiceImpl implements ExamService { @Override public List getPaper() { SqlSession sqlSession = null; try{ //1.获取SqlSession sqlSession = MapperFactory.getSqlSession(); //2.获取Dao QuestionDao questionDao = MapperFactory.getMapper(sqlSession, QuestionDao.class); List questionList = questionDao.findAll(); return questionList; }catch (Exception e){ e.printStackTrace(); throw new RuntimeException(e); //记录日志 }finally { try { TransactionUtil.close(sqlSession); }catch (Exception e){ e.printStackTrace(); } } } @Override public boolean applyPaper(String memberId, List examQuestionList) { SqlSession sqlSession = null; try{ boolean flag = true; //1.获取SqlSession sqlSession = MapperFactory.getSqlSession(); //2.获取Dao ExamPaperDao examPaperDao = MapperFactory.getMapper(sqlSession, ExamPaperDao.class); ExamQuestionDao examQuestionDao = MapperFactory.getMapper(sqlSession, ExamQuestionDao.class); //3.提交保存的试卷信息 ExamPaper examPaper = new ExamPaper(); String paperId = UUID.randomUUID().toString(); examPaper.setId(paperId); examPaper.setApplyTime(new Date()); examPaper.setMemberId(memberId); examPaper.setState(\"1\"); flag = flag && examPaperDao.save(examPaper) > 0; //4.提交保存的试卷中的所有题目对应的答案信息 for(ExamQuestion eq: examQuestionList) { eq.setId(UUID.randomUUID().toString()); eq.setExamPaperId(paperId); flag = flag && examQuestionDao.save(eq) > 0; } TransactionUtil.commit(sqlSession); return flag; }catch (Exception e){ TransactionUtil.rollback(sqlSession); throw new RuntimeException(e); //记录日志 }finally { try { TransactionUtil.close(sqlSession); }catch (Exception e){ e.printStackTrace(); } } } } ExamPaperDao接口 package com.itheima.dao.front; import com.itheima.domain.front.ExamPaper; public interface ExamPaperDao { int save(ExamPaper examPaper); } ExamQuestionDao接口 package com.itheima.dao.front; import com.itheima.domain.front.ExamQuestion; public interface ExamQuestionDao { int save(ExamQuestion eq); } ExamPaperDao.xml文件 insert into tr_examination_paper (id, member_id, state, apply_time) values (#{id}, #{memberId}, #{state}, #{applyTime}) ExamQuestionDao.xml文件 insert into tr_member_question (id, question_id, examinationpaper_id,answer_result) values (#{id}, #{questionId}, #{examPaperId},#{answer}) Copyright © MISIN 2022 | 豫ICP备2021006345号-1 all right reserved，powered by Gitbook该文件修订时间： 2020-07-01 16:53:10 "},"3.主流框架/1.spring/Spring-day01.html":{"url":"3.主流框架/1.spring/Spring-day01.html","title":"Spring Day 01","keywords":"","body":"1. Spring-day01 IoC1.1. 1)Spring简介1.1.1. 1.1)什么是框架1.1.2. 1.2)框架的作用1.1.3. 1.3)Spring是什么1.1.4. 1.4)Spring的体系结构1.1.5. 1.5)Spring的发展历史1.1.6. 1.6)Spring优势1.2. 2)IoC简介1.2.1. 2.1)优质程序代码的制作原则1.2.2. 2.2)耦合与内聚1.2.3. 2.3)工厂模式发展史1.2.4. 2.4)Spring发展历程1.2.5. 2.5)IoC1.3. 3)入门案例1.3.1. 3.1)案例环境说明1.3.2. 3.2)IoC入门案例制作步骤1.4. 4)IoC配置（XML格式）1.4.1. 4.1)bean1.4.2. 4.2)bean属性scope1.4.3. 4.3)bean生命周期1.4.4. 4.4)bean对象创建方式（了解）1.4.5. 4.5)DI1.4.6. 4.6)set注入（主流）1.4.7. 4.7)构造器注入（了解）1.4.8. 4.8)集合类型数据注入1.4.9. 4.9)使用p命名空间简化配置（了解）1.4.10. 4.10)SpEL （了解）1.4.11. 4.11)properties文件1.4.12. 4.12)团队开发1.4.13. 4.13)ApplicationContext1.4.14. 4.14)第三方资源配置1.5. 5)综合案例1.5.1. 5.1)案例介绍1.5.2. 5.2)案例分析1.5.3. 5.3)案例制作步骤——基础准备工作1.5.4. 5.4)案例制作步骤——整合准备工作1.5.5. 5.5)案例制作步骤——整合工作1.5.6. 小节1. Spring-day01 IoC 1.1. 1)Spring简介 1.1.1. 1.1)什么是框架 源自于建筑学，隶属土木工程，后发展到软件工程领域 软件工程框架：经过验证的，具有一定功能的，半成品软件 经过验证 具有一定功能 半成品 1.1.2. 1.2)框架的作用 1.1.3. 1.3)Spring是什么 Spring是分层的JavaSE/EE应用full-stack轻量级开源框架 1.1.4. 1.4)Spring的体系结构 1.1.5. 1.5)Spring的发展历史 1.1.6. 1.6)Spring优势 | Spring的优势 | | | ———————— | ——— | | 方便解耦，简化开发 | 第一天 | | 方便集成各种优秀框架 | 第一天 | | 方便程序的测试 | 第二天 | | AOP编程的支持 | 第三天 | | 声明式事务的支持 | 第四天 | | 降低JavaEE API的使用难度 | 第四天 | | Java源码是经典学习范例 | 长期学习 | 1.2. 2)IoC简介 1.2.1. 2.1)优质程序代码的制作原则 1.2.2. 2.2)耦合与内聚 耦合（Coupling）：代码书写过程中所使用技术的结合紧密度，用于衡量软件中各个模块之间的互联程度 内聚（Cohesion）：代码书写过程中单个模块内部各组成部分间的联系，用于衡量软件中各个功能模块内部的功能联系 程序书写的目标：高内聚，低耦合 就是同一个模块内的各个元素之间要高度紧密，但是各个模块之间的相互依存度却不要那么紧密 1.2.3. 2.3)工厂模式发展史 1.2.4. 2.4)Spring发展历程 1.2.5. 2.5)IoC IoC（Inversion Of Control）控制反转，Spring反向控制应用程序所需要使用的外部资源 Spring控制的资源全部放置在Spring容器中，该容器称为IoC容器 1.3. 3)入门案例 1.3.1. 3.1)案例环境说明 模拟三层架构中表现层调用业务层功能 表现层：UserApp模拟UserServlet（使用main方法模拟） 业务层：UserService 1.3.2. 3.2)IoC入门案例制作步骤 1.导入spring坐标（5.1.9.release） 2.编写业务层与表现层（模拟）接口与实现类 3.建立spring配置文件 4.配置所需资源（Service）为spring控制的资源 5.表现层（App）通过spring获取资源（Service实例） 3.2.1)IoC入门案例制作步骤-1 org.springframework spring-context 5.1.9.RELEASE 3.2.2)IoC入门案例制作步骤-2 public interface UserService { //业务方法 void save(); } 3.2.3)IoC入门案例制作步骤-3 public class UserServiceImpl implements UserService { public void save() { System.out.println(“user service running...”); } } 3.2.4)IoC入门案例制作步骤-4 3.2.5)IoC入门案例制作步骤-5 public class UserApp { public static void main(String[] args) { //2.加载配置文件 ApplicationContext ctx = new ClassPathXmlApplicationContext(“applicationContext.xml”); //3.获取资源 UserService userService = (UserService) ctx.getBean(“userService”); userService.save(); } } 1.4. 4)IoC配置（XML格式） 1.4.1. 4.1)bean 名称：bean 类型：标签 归属：beans标签 作用：定义spring中的资源，受此标签定义的资源将受到spring控制 格式： 基本属性： ​ id：bean的名称，通过id值获取bean ​ class：bean的类型 ​ name：bean的名称，可以通过name值获取bean，用于多人配合时给bean起别名 1.4.2. 4.2)bean属性scope 名称：scope 类型：属性 归属：bean标签 作用：定义bean的作用范围 格式： 取值： singleton：设定创建出的对象保存在spring容器中，是一个单例的对象 prototype：设定创建出的对象保存在spring容器中，是一个非单例的对象 request、session、application、 websocket ：设定创建出的对象放置在web容器对应的位置 1.4.3. 4.3)bean生命周期 名称：init-method，destroy-method 类型：属性 归属：bean标签 作用：定义bean对象在初始化或销毁时完成的工作 格式： 取值：bean对应的类中对应的具体方法名 注意事项： 当scope=“singleton”时，spring容器中有且仅有一个对象，init方法在创建容器时仅执行一次 当scope=“prototype”时，spring容器要创建同一类型的多个对象，init方法在每个对象创建时均执行一次 当scope=“singleton”时，关闭容器会导致bean实例的销毁，调用destroy方法一次 当scope=“prototype”时，对象的销毁由垃圾回收机制gc()控制，destroy方法将不会被执行 1.4.4. 4.4)bean对象创建方式（了解） (1)factory-bean 名称：factory-bean 类型：属性 归属：bean标签 作用：定义bean对象创建方式，使用静态工厂的形式创建bean，兼容早期遗留系统的升级工作 格式： 取值：工厂bean中用于获取对象的静态方法名 注意事项： class属性必须配置成静态工厂的类名 (2)factory-bean，factory-method 名称：factory-bean，factory-method 类型：属性 归属：bean标签 作用：定义bean对象创建方式，使用实例工厂的形式创建bean，兼容早期遗留系统的升级工作 格式： 取值：工厂bean中用于获取对象的实例方法名 注意事项： 使用实例工厂创建bean首先需要将实例工厂配置bean，交由spring进行管理 factory-bean是实例工厂的beanId 1.4.5. 4.5)DI IoC（Inversion Of Control）控制翻转，Spring反向控制应用程序所需要使用的外部资源 DI（Dependency Injection）依赖注入，应用程序运行依赖的资源由Spring为其提供，资源进入应用程序的方式称为注入 IoC与DI的关系 IoC与DI是同一件事站在不同角度看待问题 半杯水 set注入（主流） 1.4.6. 4.6)set注入（主流） 名称：property 类型：标签 归属：bean标签 作用：使用set方法的形式为bean提供资源 格式： 基本属性： ​ name：对应bean中的属性名，要求该属性必须提供可访问的set方法（严格规范为此名称是set方法对应名称） ​ value：设定非引用类型属性对应的值，不能与ref同时使用 ​ ref：设定引用类型属性对应bean的id ，不能与value同时使用 注意：一个bean可以有多个property标签 1.4.7. 4.7)构造器注入（了解） 名称：constructor-arg 类型：标签 归属：bean标签 作用：使用构造方法的形式为bean提供资源，兼容早期遗留系统的升级工作 格式： 基本属性： ​ name：对应bean中的构造方法所携带的参数名 ​ value：设定非引用类型构造方法参数对应的值，不能与ref同时使用 其他属性： ​ ref：设定引用类型构造方法参数对应bean的id ，不能与value同时使用 ​ type ：设定构造方法参数的类型，用于按类型匹配参数或进行类型校验 ​ index ：设定构造方法参数的位置，用于按位置匹配参数，参数index值从0开始计数 注意：一个bean可以有多个constructor-arg标签 1.4.8. 4.8)集合类型数据注入 名称：array，list，set，map，props 类型：标签 归属：property标签 或 constructor-arg标签 作用：注入集合数据类型属性 格式： (1)集合类型数据注入——list itheima 66666 (2)集合类型数据注入——props itheima666 666666 (3)集合类型数据注入——array （了解） 123456 66666 (4)集合类型数据注入——set（了解） itheima 66666 (5)集合类型数据注入——map（了解） 1.4.9. 4.9)使用p命名空间简化配置（了解） 名称：p:propertyName，p:propertyName-ref 类型：属性 归属：bean标签 作用：为bean注入属性值 格式： 注意：使用p命令空间需要先开启spring对p命令空间的的支持，在beans标签中添加对应空间支持 后续课程中还将开启其他的命名空间，方式同上 案例： 1.4.10. 4.10)SpEL （了解） Spring提供了对EL表达式的支持，统一属性注入格式 类型：属性值 归属：value属性值 作用：为bean注入属性值 格式： 注意：所有属性值不区分是否引用类型，统一使用value赋值 所有格式统一使用 value=“**” 常量 #{10} #{3.14} #{2e5} #{‘itcast’} 引用bean #{beanId} 引用bean属性 #{beanId.propertyName} 引用bean方法 beanId.methodName().method2() 引用静态方法 T(java.lang.Math).PI 运算符支持 #{3 lt 4 == 4 ge 3} 正则表达式支持 #{user.name matches‘[a-z]{6,}’} 集合支持 #{likes[3]} 案例： 1.4.11. 4.11)properties文件 Spring提供了读取外部properties文件的机制，使用读取到的数据为bean的属性赋值 操作步骤 1.准备外部properties文件 2.开启context命名空间支持 xmlns:context=“http://www.springframework.org/schema/context” ​ 3.加载指定的properties文件 ​ 4.使用加载的数据 注意：如果需要加载所有的properties文件，可以使用*.properties表示加载所有的properties文件 注意：读取数据使用${propertiesName}格式进行，其中propertiesName指properties文件中的属性名 1.4.12. 4.12)团队开发 名称：import 类型：标签 归属：beans标签 作用：在当前配置文件中导入其他配置文件中的项 格式： 基本属性： ​ resource：加载的配置文件名 Spring容器加载多个配置文件 new ClassPathXmlApplicationContext(“config1.xml”,”config2.xml”); Spring容器中的bean定义冲突问题 同id的bean，后定义的覆盖先定义的 导入配置文件可以理解为将导入的配置文件复制粘贴到对应位置 导入配置文件的顺序与位置不同可能会导致最终程序运行结果不同 1.4.13. 4.13)ApplicationContext 1.ApplicationContext是一个接口，提供了访问spring容器的API 2.ClassPathXmlApplicationContext是一个类，实现了上述功能 3.ApplicationContext的顶层接口是BeanFactory 4.BeanFactory定义了bean相关的最基本操作 5.ApplicationContext在BeanFactory基础上追加了若干新功能 对比BeanFactory 1.BeanFactory创建的bean采用延迟加载形式，使用才创建 2.ApplicationContext创建的bean默认采用立即加载形式 FileSystemXmlApplicationContext 可以加载文件系统中任意位置的配置文件，而ClassPathXmlApplicationContext只能加载类路径下的配置文件 BeanFactory Resource res = new ClassPathResource(\"applicationContext.xml\"); BeanFactory bf = new XmlBeanFactory(res); UserService userService = (UserService)bf.getBean(\"userService\"); 1.4.14. 4.14)第三方资源配置 阿里数据源方案Druid 1.5. 5)综合案例 1.5.1. 5.1)案例介绍 使用spring整合mybatis技术，完成账户模块（Account）的基础增删改查功能 账户模块对应字段 编号：id 账户名：name 余额：money 1.5.2. 5.2)案例分析 非spring环境 1.实体类与表 2.业务层接口与实现 3.数据层接口 4.Mybatis核心配置 5.Mybatis映射配置 6.客户端程序测试功能 spring环境 1.实体类与表 2.业务层接口与实现（提供数据层接口的注入操作） 3.数据层接口 4.Mybatis核心配置（交给spring控制，该文件省略） 5.Mybatis映射配置 6.客户端程序测试功能（使用spring方式获取bean） 7.Spring核心配置文件 8.Druid数据源的应用（可选） 9.Spring整合MyBatis 1.5.3. 5.3)案例制作步骤——基础准备工作 环境准备 1.导入Spring坐标，MyBatis坐标，MySQL坐标，Druid坐标 业务类与接口准备 2.创建数据库表，并制作相应的实体类Account 3.定义业务层接口与数据层接口 4.在业务层调用数据层接口，并实现业务方法的调用 基础配置文件 5.jdbc.properties 6.MyBatis映射配置文件 1.5.4. 5.4)案例制作步骤——整合准备工作 整合前基础准备工作 1.spring配置文件，加上context命名空间，用于加载properties文件 2.开启加载properties文件 3.配置数据源druid（备用） 4.定义service层bean，注入dao层bean 5.dao的bean无需定义，使用代理自动生成 1.5.5. 5.5)案例制作步骤——整合工作 整合工作 1.导入Spring整合MyBatis坐标 2.将mybatis配置成spring管理的bean（SqlSessionFactoryBean） ​ -将原始配置文件中的所有项，转入到当前配置中 ​ 数据源转换 ​ 映射转换 3.通过spring加载mybatis的映射配置文件到spring环境中 4.设置类型别名 测试结果 5.使用spring环境加载业务层bean，执行操作 1.5.6. 小节 需要专用的spring整合mybatis的jar包 Mybatis核心配置文件消失 环境environment转换成数据源对象 映射Mapper扫描工作交由spring处理 类型别名交由spring处理 业务发起使用spring上下文对象获取对应的bean Copyright © MISIN 2022 | 豫ICP备2021006345号-1 all right reserved，powered by Gitbook该文件修订时间： 2022-11-10 13:57:22 "},"3.主流框架/1.spring/Spring-day02.html":{"url":"3.主流框架/1.spring/Spring-day02.html","title":"Spring Day 02","keywords":"","body":"1. 注解开发1.1. 1)注解驱动的意义1.1.1. 1.1)什么是注解驱动1.1.2. 1.2)注解驱动的弊端1.2. 2)常用注解1.2.1. 2.1)启动注解功能1.2.2. 2.2)bean的定义1.2.3. 2.3)bean的作用域1.2.4. 2.4)bean的生命周期1.2.5. 2.5)加载第三方资源1.2.6. 2.6)bean的非引用类型属性注入1.2.7. 2.7)bean的引用类型属性注入1.2.8. 2.8)bean的引用类型属性注入1.2.9. 2.9)bean的引用类型属性注入1.2.10. 2.10)加载properties文件1.2.11. 2.11)纯注解格式1.2.12. 2.12)第三方bean配置与管理1.3. 3)bean加载控制1.3.1. 3.1)依赖加载1.3.2. 3.2)依赖加载应用场景1.4. 4)整合第三方技术1.4.1. 4.1)综合案例改版（注解整合MyBatis）1.4.2. 4.2)注解整合MyBatis分析1.4.3. 4.3)注解整合MyBatis步骤1.4.4. 4.4)综合案例改版（注解整合Junit）1.5. 5)IoC底层核心原理1.5.1. 5.1)IoC核心接口1.5.2. 5.2)组件扫描器1.5.3. 5.3)设定组件扫描加载过滤器1.5.4. 5.4)自定义组件过滤器1.5.5. 5.5)自定义导入器1.5.6. 5.6)自定义注册器1.5.7. 5.7)bean初始化过程解析1.5.8. 5.8)bean初始化过程解析1.5.9. 5.9)bean初始化过程解析1.5.10. 5.10)繁琐的bean初始化过程处理1. 注解开发 1.1. 1)注解驱动的意义 1.1.1. 1.1)什么是注解驱动 注解启动时使用注解的形式替代xml配置，将繁杂的spring配置文件从工程中彻底消除掉，简化书写 1.1.2. 1.2)注解驱动的弊端 为了达成注解驱动的目的，可能会将原先很简单的书写，变的更加复杂 XML中配置第三方开发的资源是很方便的，但使用注解驱动无法在第三方开发的资源中进行编辑，因此会增大开发工作量 1.2. 2)常用注解 1.2.1. 2.1)启动注解功能 启动注解扫描，加载类中配置的注解项 说明： 在进行包所扫描时，会对配置的包及其子包中所有文件进行扫描 扫描过程是以文件夹递归迭代的形式进行的 扫描过程仅读取合法的java文件 扫描时仅读取spring可识别的注解 扫描结束后会将可识别的有效注解转化为spring对应的资源加入IoC容器 注意： 无论是注解格式还是XML配置格式，最终都是将资源加载到IoC容器中，差别仅仅是数据读取方式不同 从加载效率上来说注解优于XML配置文件 1.2.2. 2.2)bean的定义 名称：@Component @Controller @Service @Repository 类型：类注解 位置：类定义上方 作用：设置该类为spring管理的bean 范例： @Component public class ClassName{} 说明： @Controller、@Service 、@Repository是@Component的衍生注解，功能同@Component 相关属性 value（默认）：定义bean的访问id 1.2.3. 2.3)bean的作用域 名称：@Scope 类型：类注解 位置：类定义上方 作用：设置该类作为bean对应的scope属性 范例： @Scope public class ClassName{} 相关属性 value（默认）：定义bean的作用域，默认为singleton 1.2.4. 2.4)bean的生命周期 名称：@PostConstruct、@PreDestroy 类型：方法注解 位置：方法定义上方 作用：设置该类作为bean对应的生命周期方法 范例： @PostConstruct public void init() { System.out.println(“init...”); } 1.2.5. 2.5)加载第三方资源 名称：@Bean 类型：方法注解 位置：方法定义上方 作用：设置该方法的返回值作为spring管理的bean 范例： @Bean(“dataSource”) public DruidDataSource createDataSource() { return ……; } 说明： 因为第三方bean无法在其源码上进行修改，使用@Bean解决第三方bean的引入问题 该注解用于替代XML配置中的静态工厂与实例工厂创建bean，不区分方法是否为静态或非静态 @Bean所在的类必须被spring扫描加载，否则该注解无法生效 相关属性 value（默认）：定义bean的访问id 1.2.6. 2.6)bean的非引用类型属性注入 名称：@Value 类型：属性注解、方法注解 位置：属性定义上方，方法定义上方 作用：设置对应属性的值或对方法进行传参 范例： @Value(“${jdbc.username}”) private String username; 说明： value值仅支持非引用类型数据，赋值时对方法的所有参数全部赋值 value值支持读取properties文件中的属性值，通过类属性将properties中数据传入类中 value值支持SpEL @value注解如果添加在属性上方，可以省略set方法（set方法的目的是为属性赋值） 相关属性 value（默认）：定义对应的属性值或参数值 1.2.7. 2.7)bean的引用类型属性注入 名称：@Autowired、@Qualifier 类型：属性注解、方法注解 位置：属性定义上方，方法定义上方 作用：设置对应属性的对象或对方法进行引用类型传参 范例： @Autowired(required = false) @Qualifier(“userDao”) private UserDao userDao; 说明： @Autowired默认按类型装配，指定@Qualifier后可以指定自动装配的bean的id 相关属性 required：定义该属性是否允许为null 1.2.8. 2.8)bean的引用类型属性注入 名称：@Primary 类型：类注解 位置：类定义上方 作用：设置类对应的bean按类型装配时优先装配 范例： @Primary public class ClassName{} 说明： @Autowired默认按类型装配，当出现相同类型的bean，使用@Primary提高按类型自动装配的优先级，多个@Primary会导致优先级设置无效 1.2.9. 2.9)bean的引用类型属性注入 名称：@Inject、@Named、@Resource 说明： @Inject与@Named是JSR330规范中的注解，功能与@Autowired和@Qualifier完全相同，适用于不同架构场景 @Resource是JSR250规范中的注解，可以简化书写格式 @Resource相关属性 name：设置注入的bean的id type：设置注入的bean的类型，接收的参数为Class类型 1.2.10. 2.10)加载properties文件 名称：@PropertySource 类型：类注解 位置：类定义上方 作用：加载properties文件中的属性值 范例： @PropertySource(value = “classpath:filename.properties”) public class ClassName { @Value(“${propertiesAttributeName}”) private String attributeName; } 说明： 不支持*通配格式，一旦加载，所有spring控制的bean中均可使用对应属性值 相关属性 value（默认）：设置加载的properties文件名 ignoreResourceNotFound：如果资源未找到，是否忽略，默认为false 1.2.11. 2.11)纯注解格式 名称：@Configuration、@ComponentScan 类型：类注解 位置：类定义上方 作用：设置当前类为spring核心配置加载类 范例： @Configuration @ComponentScan(“scanPackageName”) public class SpringConfigClassName{ } 说明： 核心配合类用于替换spring核心配置文件，此类可以设置空的，不设置变量与属性 bean扫描工作使用注解@ComponentScan替代 AnnotationConfigApplicationContext 加载纯注解格式上下文对象，需要使用AnnotationConfigApplicationContext AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class); 1.2.12. 2.12)第三方bean配置与管理 名称：@Import 类型：类注解 位置：类定义上方 作用：导入第三方bean作为spring控制的资源 范例： @Configuration @Import(OtherClassName.class) public class ClassName { } 说明： @Import注解在同一个类上，仅允许添加一次，如果需要导入多个，使用数组的形式进行设定 在被导入的类中可以继续使用@Import导入其他资源（了解） @Bean所在的类可以使用导入的形式进入spring容器，无需声明为bean 1.3. 3)bean加载控制 1.3.1. 3.1)依赖加载 (1)@DependsOn 名称：@DependsOn 类型：类注解、方法注解 位置：bean定义的位置（类上或方法上） 作用：控制bean的加载顺序，使其在指定bean加载完毕后再加载 范例： @DependsOn(“beanId”) public class ClassName { } 说明： 配置在方法上，使@DependsOn指定的bean优先于@Bean配置的bean进行加载 配置在类上，使@DependsOn指定的bean优先于当前类中所有@Bean配置的bean进行加载 配置在类上，使@DependsOn指定的bean优先于@Component等配置的bean进行加载 相关属性 value（默认）：设置当前bean所依赖的bean的id (2)@Order 名称：@Order 类型：配置类注解 位置：配置类定义的位置（类上） 作用：控制配置类的加载顺序 范例： @Order(1) public class SpringConfigClassName { } (3)@Lazy 名称：@Lazy 类型：类注解、方法注解 位置：bean定义的位置（类上或方法上） 作用：控制bean的加载时机，使其延迟加载 范例： @Lazy public class ClassName { } 1.3.2. 3.2)依赖加载应用场景 @DependsOn 微信订阅号，发布消息和订阅消息的bean的加载顺序控制 双11活动期间，零点前是结算策略A，零点后是结算策略B，策略B操作的数据为促销数据。策略B加载顺序与促销数据的加载顺序 @Lazy 程序灾难出现后对应的应急预案处理是启动容器时加载时机 @Order 多个种类的配置出现后，优先加载系统级的，然后加载业务级的，避免细粒度的加载控制 1.4. 4)整合第三方技术 1.4.1. 4.1)综合案例改版（注解整合MyBatis） 1.4.2. 4.2)注解整合MyBatis分析 业务类使用注解形式声明bean，属性采用注解注入 建立独立的配置管理类，分类管理外部资源，根据功能进行分类，并提供对应的方法获取bean 使用注解形式启动bean扫描，加载所有注解配置的资源（bean） 使用AnnotationConfigApplicationContext对象加载所有的启动配置类，内部使用导入方式进行关联 1.4.3. 4.3)注解整合MyBatis步骤 1.修改mybatis外部配置文件格式为注解格式 2.业务类使用@Component声明bean，使用@Autowired注入对象 3.建立配置文件JDBCConfig与MyBatisConfig类，并将其导入到核心配置类SpringConfig 4.开启注解扫描 5.使用AnnotationConfigApplicationContext对象加载配置项 1.4.4. 4.4)综合案例改版（注解整合Junit） 1.Spring接管Junit的运行权，使用Spring专用的Junit类加载器 2.为Junit测试用例设定对应的spring容器： 从Spring5.0以后，要求Junit的版本必须是4.12及以上 Junit仅用于单元测试，不能将Junit的测试类配置成spring的bean，否则该配置将会被打包进入工程中 导入Spring整合Junit坐标 junit junit 4.12 org.springframework spring-test 5.1.9.RELEASE Spring整合Junit测试用例注解格式 @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(classes = SpringConfig.class) public class UserServiceTest { } 1.5. 5)IoC底层核心原理 1.5.1. 5.1)IoC核心接口 1.5.2. 5.2)组件扫描器 开发过程中，需要根据需求加载必要的bean，排除指定bean 1.5.3. 5.3)设定组件扫描加载过滤器 名称：@ComponentScan 类型：类注解 位置：类定义上方 作用：设置spring配置加载类扫描规则 范例： @ComponentScan( value=“com.itheima”, //设置基础扫描路径 excludeFilters = //设置过滤规则，当前为排除过滤 @ComponentScan.Filter( //设置过滤器 type= FilterType.ANNOTATION, //设置过滤方式为按照注解进行过滤 classes=Repository.class) //设置具体的过滤项，过滤所有@Repository修饰的bean ) ​ includeFilters：设置包含性过滤器 ​ excludeFilters：设置排除性过滤器 ​ type：设置过滤器类型 1.5.4. 5.4)自定义组件过滤器 名称：TypeFilter 类型：接口 作用：自定义类型过滤器 范例： public class MyTypeFilter implements TypeFilter { public boolean match(MetadataReader mr, MetadataReaderFactory mrf) throws IOException { ClassMetadata cm = metadataReader.getClassMetadata(); tring className = cm.getClassName(); if(className.equals(“com.itheima.dao.impl.BookDaoImpl”)){ return false; } return false; } } 1.5.5. 5.5)自定义导入器 bean只有通过配置才可以进入spring容器，被spring加载并控制 配置bean的方式如下： XML文件中使用标签配置 使用@Component及衍生注解配置 企业开发过程中，通常需要配置大量的bean，需要一种快速高效配置大量bean的方式 ImportSelector 名称： ImportSelector 类型：接口 作用：自定义bean导入器 范例： public class MyImportSelector implements ImportSelector { public String[] selectImports(AnnotationMetadata icm) { return new String[]{“com.itheima.dao.impl.AccountDaoImpl”}; } } @Configuration @ComponentScan(“com.itheima”) @Import(MyImportSelector.class) public class SpringConfig { } 1.5.6. 5.6)自定义注册器 名称：ImportBeanDefinitionRegistrar 类型：接口 作用：自定义bean定义注册器 范例： public class MyImportBeanDefinitionRegistrar implements ImportBeanDefinitionRegistrar { public void registerBeanDefinitions(AnnotationMetadata icm, BeanDefinitionRegistry r) { ClassPathBeanDefinitionScanner scanner = new ClassPathBeanDefinitionScanner(r, false); TypeFilter tf = new TypeFilter() { public boolean match(MetadataReader mr, MetadataReaderFactory mrf) throws IOException { return true; } }; scanner.addIncludeFilter(tf); //scanner.addExcludeFilter(tf); scanner.scan(“com.itheima”); } } 1.5.7. 5.7)bean初始化过程解析 1.5.8. 5.8)bean初始化过程解析 BeanFactoryPostProcessor 作用：定义了在bean工厂对象创建后，bean对象创建前执行的动作，用于对工厂进行创建后业务处理 运行时机：当前操作用于对工厂进行处理，仅运行一次 BeanPostProcessor 作用：定义了所有bean初始化前后进行的统一动作，用于对bean进行创建前业务处理与创建后业务处理 运行时机：当前操作伴随着每个bean的创建过程，每次创建bean均运行该操作 InitializingBean 作用：定义了每个bean的初始化前进行的动作，属于非统一性动作，用于对bean进行创建前业务处理 运行时机：当前操作伴随着任意一个bean的创建过程，保障其个性化业务处理 注意：上述操作均需要被spring容器加载放可运行 1.5.9. 5.9)bean初始化过程解析 1.5.10. 5.10)繁琐的bean初始化过程处理 FactoryBean 对单一的bean的初始化过程进行封装，达到简化配置的目的 FactoryBean与BeanFactory区别 FactoryBean：封装单个bean的创建过程 BeanFactory：Spring容器顶层接口，定义了bean相关的获取操作 Copyright © MISIN 2022 | 豫ICP备2021006345号-1 all right reserved，powered by Gitbook该文件修订时间： 2022-11-10 13:57:46 "},"3.主流框架/1.spring/Spring-day03.html":{"url":"3.主流框架/1.spring/Spring-day03.html","title":"Spring Day 03","keywords":"","body":"1. AOP1.1. 1)AOP简介1.1.1. 1.1)OOP开发思路1.1.2. 1.2)AOP开发思想1.1.3. 1.3)AOP概念1.1.4. 1.4)AOP作用1.1.5. 1.5)AOP优势1.2. 2)AOP入门案例1.2.1. 2.1)AOP相关概念1.2.2. 2.2)AOP开发过程1.2.3. 2.2)AOP开发方式1.2.4. 2.3)入门案例制作分析1.3. 3)AOP配置（XML）1.3.1. 3.1)AspectJ1.3.2. 3.2)AOP配置1.3.3. 3.3)切入点1.3.4. 3.4)切入点表达式的组成1.3.5. 3.5)切入点的三种配置方式1.3.6. 3.6)切入点配置经验1.3.7. 3.7)通知类型1.3.8. 3.8)通知顺序（了解）1.3.9. 3.9)通知获取数据1.4. 4)AOP配置（注解）1.4.1. 4.1)AOP配置1.4.2. 4.2)注解开发AOP制作步骤1.4.3. 4.3)注解开发AOP注意事项1.4.4. 4.4)AOP注解详解1.4.5. 4.5)AOP注解开发通知执行顺序控制（了解）1.4.6. 4.6)AOP注解驱动1.5. 5)综合案例1.5.1. 5.1)案例介绍1.5.2. 5.2)案例分析1.5.3. 5.3)案例制作步骤1.5.4. 5.4)案例制作核心代码1.5.5. 5.5)案例后续思考与设计1.6. 6)AOP底层原理1.6.1. 6.1)静态代理1.6.2. 6.2)动态代理——JDK Proxy1.6.3. 6.3)动态代理——CGLIB1.6.4. 6.4)代理模式的选择1.6.5. 6.5)织入时机1. AOP 1.1. 1)AOP简介 1.1.1. 1.1)OOP开发思路 1.1.2. 1.2)AOP开发思想 1.1.3. 1.3)AOP概念 AOP(Aspect Oriented Programing)面向切面编程，一种编程范式，隶属于软工范畴，指导开发者如何组织程序结构 AOP弥补了OOP的不足，基于OOP基础之上进行横向开发 uOOP规定程序开发以类为主体模型，一切围绕对象进行，完成某个任务先构建模型 uAOP程序开发主要关注基于OOP开发中的共性功能，一切围绕共性功能进行，完成某个任务先构建可能遇到的所有共性功能（当所有功能都开发出来也就没有共性与非共性之分） “AOP联盟” 1.1.4. 1.4)AOP作用 伴随着AOP时代的降临，可以从各个行业的标准化、规范化开始入手，一步一步将所有共性功能逐一开发完毕，最终以功能组合来完成个别业务模块乃至整体业务系统的开发 目标：将软件开发由手工制作走向半自动化/全自动化阶段，实现“插拔式组件体系结构”搭建 1.1.5. 1.5)AOP优势 提高代码的可重用性 业务代码编码更简洁 业务代码维护更高效 业务功能扩展更便捷 1.2. 2)AOP入门案例 1.2.1. 2.1)AOP相关概念 Joinpoint(连接点)：就是方法 Pointcut(切入点)：就是挖掉共性功能的方法 Advice(通知)：就是共性功能，最终以一个方法的形式呈现 Aspect(切面)：就是共性功能与挖的位置的对应关系 Target(目标对象)：就是挖掉功能的方法对应的类产生的对象，这种对象是无法直接完成最终工作的 Weaving(织入)：就是将挖掉的功能回填的动态过程 Proxy(代理)：目标对象无法直接完成工作，需要对其进行功能回填，通过创建原始对象的代理对象实现 Introduction(引入/引介) ：就是对原始对象无中生有的添加成员变量或成员方法 1.2.2. 2.2)AOP开发过程 开发阶段(开发者完成) 正常的制作程序 将非共性功能开发到对应的目标对象类中，并制作成切入点方法 将共性功能独立开发出来，制作成通知 在配置文件中，声明切入点 在配置文件中，声明切入点与通知间的关系（含通知类型），即切面 运行阶段(AOP完成) Spring容器加载配置文件，监控所有配置的切入点方法的执行 当监控到切入点方法被运行，使用代理机制，动态创建目标对象的代理对象，根据通知类别，在代理对象的对应位置将通知对应的功能织入，完成完整的代码逻辑并运行 1.2.3. 2.2)AOP开发方式 XML方式 XML+注解方式 注解方式 1.2.4. 2.3)入门案例制作分析 1.导入相关坐标 2.确认要抽取的功能，并将其制作成方法保存到专用的类中，删除原始业务中对应的功能 3.将所有进行AOP操作的资源加载到IoC容器中 4.使用配置的方式描述被抽取功能的位置，并描述被抽取功能与对应位置的关系 5.运行程序 步骤一 导入坐标 org.aspectj aspectjweaver 1.9.4 步骤二 在业务层抽取通用代码 步骤三 把通知加入spring容器管理 步骤四 在配置文件中配置aop的配置 1.3. 3)AOP配置（XML） 1.3.1. 3.1)AspectJ Aspect（切面）用于描述切入点与通知间的关系，是AOP编程中的一个概念 AspectJ是基于java语言对Aspect的实现 1.3.2. 3.2)AOP配置 3.2.1)aop:config 名称：aop:config 类型：标签 归属：beans标签 作用：设置AOP 格式： …… …… 说明：一个beans标签中可以配置多个aop:config标签 3.2.2)aop:aspect 名称：aop:aspect 类型：标签 归属：aop:config标签 作用：设置具体的AOP通知对应的切入点 格式： …… …… 说明： 一个aop:config标签中可以配置多个aop:aspect标签 基本属性： ref ：通知所在的bean的id 3.2.3)aop:pointcut 名称：aop:pointcut 类型：标签 归属：aop:config标签、aop:aspect标签 作用：设置切入点 格式： 说明： 一个aop:config标签中可以配置多个aop:pointcut标签，且该标签可以配置在aop:aspect标签内 基本属性： id ：识别切入点的名称 expression ：切入点表达式 1.3.3. 3.3)切入点 切入点描述的是某个方法 切入点表达式是一个快速匹配方法描述的通配格式，类似于正则表达式 1.3.4. 3.4)切入点表达式的组成 切入点描述的是某个方法 切入点表达式是一个快速匹配方法描述的通配格式，类似于正则表达式 关键字（访问修饰符 返回值 包名.类名.方法名（参数）异常名） ​ 关键字：描述表达式的匹配模式（参看关键字列表） ​ 访问修饰符：方法的访问控制权限修饰符 ​ 类名：方法所在的类（此处可以配置接口名称） ​ 异常：方法定义中指定抛出的异常 范例： execution（public User com.itheima.service.UserService.findById（int）） 3.4.1)切入点表达式——关键字 execution ：匹配执行指定方法 args ：匹配带有指定参数类型的方法 within ：…… this ：…… target ：…… @within ：…… @target ：…… @args ：…… @annotation ：…… bean ：…… reference pointcut ：…… 3.4.2)切入点表达式——通配符 *：单个独立的任意符号，可以独立出现，也可以作为前缀或者后缀的匹配符出现 execution（public * com.itheima.*.UserService.find*（*）） ​ 匹配com.itheima包下的任意包中的UserService类或接口中所有find开头的带有一个参数的方法 .. ：多个连续的任意符号，可以独立出现，常用于简化包名与参数的书写 execution（public User com..UserService.findById（..）） ​ 匹配com包下的任意包中的UserService类或接口中所有名称为findById的方法 +：专用于匹配子类类型 execution(* *..*Service+.*(..)) 3.4.3)切入点表达式——逻辑运算符 && ：连接两个切入点表达式，表示两个切入点表达式同时成立的匹配 || ：连接两个切入点表达式，表示两个切入点表达式成立任意一个的匹配 ! ：连接单个切入点表达式，表示该切入点表达式不成立的匹配 3.4.4)切入点表达式——范例 execution(* *(..)) execution(* *..*(..)) execution(* *..*.*(..)) execution(public * *..*.*(..)) execution(public int *..*.*(..)) execution(public void *..*.*(..)) execution(public void com..*.*(..)) execution(public void com..service.*.*(..)) execution(public void com.itheima.service.*.*(..)) execution(public void com.itheima.service.User*.*(..)) execution(public void com.itheima.service.*Service.*(..)) execution(public void com.itheima.service.UserService.*(..)) execution(public User com.itheima.service.UserService.find*(..)) execution(public User com.itheima.service.UserService.*Id(..)) execution(public User com.itheima.service.UserService.findById(..)) execution(public User com.itheima.service.UserService.findById(int)) execution(public User com.itheima.service.UserService.findById(int,int)) execution(public User com.itheima.service.UserService.findById(int,*)) execution(public User com.itheima.service.UserService.findById(*,int)) execution(public User com.itheima.service.UserService.findById()) execution(List com.itheima.service.*Service+.findAll(..)) 1.3.5. 3.5)切入点的三种配置方式 1.3.6. 3.6)切入点配置经验 企业开发命名规范严格遵循规范文档进行 先为方法配置局部切入点 再抽取类中公共切入点 最后抽取全局切入点 代码走查过程中检测切入点是否存在越界性包含 代码走查过程中检测切入点是否存在非包含性进驻 设定AOP执行检测程序，在单元测试中监控通知被执行次数与预计次数是否匹配 设定完毕的切入点如果发生调整务必进行回归测试 （以上规则适用于XML配置格式） 1.3.7. 3.7)通知类型 AOP的通知类型共5种 前置通知：原始方法执行前执行，如果通知中抛出异常，阻止原始方法运行 应用：数据校验 后置通知：原始方法执行后执行，无论原始方法中是否出现异常，都将执行通知 应用：现场清理 返回后通知：原始方法正常执行完毕并返回结果后执行，如果原始方法中抛出异常，无法执行 应用：返回值相关数据处理 抛出异常后通知：原始方法抛出异常后执行，如果原始方法没有抛出异常，无法执行 应用：对原始方法中出现的异常信息进行处理 环绕通知：在原始方法执行前后均有对应执行执行，还可以阻止原始方法的执行 应用：十分强大，可以做任何事情 3.7.1)aop:before 名称：aop:before 类型：标签 归属：aop:aspect标签 作用：设置前置通知 格式： 说明：一个aop:aspect标签中可以配置多个aop:before标签 基本属性： method ：在通知类中设置当前通知类别对应的方法 pointcut ：设置当前通知对应的切入点表达式，与pointcut-ref属性冲突 pointcut-ref ：设置当前通知对应的切入点id，与pointcut属性冲突 3.7.2)aop:after 名称：aop:after 类型：标签 归属：aop:aspect标签 作用：设置后置通知 格式： 说明：一个aop:aspect标签中可以配置多个aop:after标签 基本属性： method ：在通知类中设置当前通知类别对应的方法 pointcut ：设置当前通知对应的切入点表达式，与pointcut-ref属性冲突 pointcut-ref ：设置当前通知对应的切入点id，与pointcut属性冲突 3.7.3)aop:after-returning 名称：aop:after-returning 类型：标签 归属：aop:aspect标签 作用：设置返回后通知 格式： 说明：一个aop:aspect标签中可以配置多个aop:after-returning标签 基本属性： method ：在通知类中设置当前通知类别对应的方法 pointcut ：设置当前通知对应的切入点表达式，与pointcut-ref属性冲突 pointcut-ref ：设置当前通知对应的切入点id，与pointcut属性冲突 3.7.4)aop:after-throwing 名称：aop:after-throwing 类型：标签 归属：aop:aspect标签 作用：设置抛出异常后通知 格式： 说明：一个aop:aspect标签中可以配置多个aop:after-throwing标签 基本属性： method ：在通知类中设置当前通知类别对应的方法 pointcut ：设置当前通知对应的切入点表达式，与pointcut-ref属性冲突 pointcut-ref ：设置当前通知对应的切入点id，与pointcut属性冲突 3.7.5)aop:around 名称：aop:around 类型：标签 归属：aop:aspect标签 作用：设置环绕通知 格式： 说明：一个aop:aspect标签中可以配置多个aop:around标签 基本属性： method ：在通知类中设置当前通知类别对应的方法 pointcut ：设置当前通知对应的切入点表达式，与pointcut-ref属性冲突 pointcut-ref ：设置当前通知对应的切入点id，与pointcut属性冲突 环绕通知的开发方式 环绕通知是在原始方法的前后添加功能，在环绕通知中，存在对原始方法的显式调用 public Object around(ProceedingJoinPoint pjp) throws Throwable { Object ret = pjp.proceed(); return ret; } 环绕通知方法相关说明： 方法须设定Object类型的返回值，否则会拦截原始方法的返回。如果原始方法返回值类型为void，通知方 也可以设定返回值类型为void，最终返回null 方法需在第一个参数位置设定ProceedingJoinPoint对象，通过该对象调用proceed()方法，实现对原始方法的调用。如省略该参数，原始方法将无法执行 使用proceed()方法调用原始方法时，因无法预知原始方法运行过程中是否会出现异常，强制抛出Throwable对象，封装原始方法中可能出现的异常信息 1.3.8. 3.8)通知顺序（了解） 当同一个切入点配置了多个通知时，通知会存在运行的先后顺序，该顺序以通知配置的顺序为准 1.3.9. 3.9)通知获取数据 参数 返回值 异常 3.9.1)通知获取参数数据 第一种情况： 设定通知方法第一个参数为JoinPoint，通过该对象调用getArgs()方法，获取原始方法运行的参数数组 public void before(JoinPoint jp) throws Throwable { Object[] args = jp.getArgs(); } 所有的通知均可以获取参数 第二种情况： 设定切入点表达式为通知方法传递参数（锁定通知变量名） 原始方法 第三种情况 设定切入点表达式为通知方法传递参数（改变通知变量名的定义顺序） 原始方法 3.9.2)通知获取返回值数据 第一种：返回值变量名 设定返回值变量名 原始方法 public int save() { System.out.println(“user service running...”); return 100; } AOP配置 通知类 public void afterReturning(Object ret) { System.out.println(ret); } 适用于返回后通知（after-returning） 第二种： 在通知类的方法中调用原始方法获取返回值 原始方法 public int save() { System.out.println(“user service running...”); return 100; } AOP配置l 通知类 public Object around(ProceedingJoinPoint pjp) throws Throwable { Object ret = pjp.proceed(); return ret; } 适用于环绕通知（around） 3.9.3)通知获取异常数据 第一种：通知类的方法中调用原始方法捕获异常 在通知类的方法中调用原始方法捕获异常 原始方法 public void save() { System.out.println(“user service running...”); int i = 1/0; } AOP配置 通知类 public Object around(ProceedingJoinPoint pjp) throws Throwable { Object ret = pjp.proceed(); //对此处调用进行try……catch……捕获异常，或抛出异常 return ret; } 适用于环绕通知（around） 第二种： 设定异常对象变量名 原始方法 public void save() { System.out.println(“user service running...”); int i = 1/0; } AOP配置 通知类 public void afterThrowing(Throwable t){ System.out.println(t.getMessage()); } 适用于返回后通知（after-throwing） 1.4. 4)AOP配置（注解） 1.4.1. 4.1)AOP配置 1.4.2. 4.2)注解开发AOP制作步骤 在XML格式基础上 导入坐标（伴随spring-context坐标导入已经依赖导入完成） 开启AOP注解支持 配置切面@Aspect 定义专用的切入点方法，并配置切入点@Pointcut 为通知方法配置通知类型及对应切入点@Before 1.4.3. 4.3)注解开发AOP注意事项 1.切入点最终体现为一个方法，无参无返回值，无实际方法体内容，但不能是抽象方法 2.引用切入点时必须使用方法调用名称，方法后面的（）不能省略 3.切面类中定义的切入点只能在当前类中使用，如果想引用其他类中定义的切入点使用“类名.方法名()”引用 4.可以在通知类型注解后添加参数，实现XML配置中的属性，例如after-returning后的returning属性 1.4.4. 4.4)AOP注解详解 4.4.1)@Aspect 名称：@Aspect 类型：注解 位置：类定义上方 作用：设置当前类为切面类 格式： @Aspect public class AopAdvice { } 说明：一个beans标签中可以配置多个aop:config标签 4.4.2)@Pointcut 名称：@Pointcut 类型：注解 位置：方法定义上方 作用：使用当前方法名作为切入点引用名称 格式： @Pointcut(“execution(* *(..))”) public void pt() { } 说明：被修饰的方法忽略其业务功能，格式设定为无参无返回值的方法，方法体内空实现（非抽象） 4.4.3)@Before 名称：@Before 类型：注解 位置：方法定义上方 作用：标注当前方法作为前置通知 格式： @Before(“pt()”) public void before(){ } 特殊参数： 无 4.4.4)@After 名称：@After 类型：注解 位置：方法定义上方 作用：标注当前方法作为后置通知 格式： @After(“pt()”) public void after(){ } 特殊参数： 无 4.4.5)@AfterReturning 名称：@AfterReturning 类型：注解 位置：方法定义上方 作用：标注当前方法作为返回后通知 格式： @AfterReturning(value=“pt()”,returning = “ret”) public void afterReturning(Object ret) { } 特殊参数： returning ：设定使用通知方法参数接收返回值的变量名 4.4.6)@AfterThrowing 名称：@AfterThrowing 类型：注解 位置：方法定义上方 作用：标注当前方法作为异常后通知 格式： @AfterThrowing(value=“pt()”,throwing = “t”) public void afterThrowing(Throwable t){ } 特殊参数： throwing ：设定使用通知方法参数接收原始方法中抛出的异常对象名 4.4.7)@Around 名称：@Around 类型：注解 位置：方法定义上方 作用：标注当前方法作为环绕通知 格式： @Around(“pt()”) public Object around(ProceedingJoinPoint pjp) throws Throwable { Object ret = pjp.proceed(); return ret; } 特殊参数： 无 1.4.5. 4.5)AOP注解开发通知执行顺序控制（了解） 1.AOP使用XML配置情况下，通知的执行顺序由配置顺序决定，在注解情况下由于不存在配置顺序的概念的概念，参照通知所配置的方法名字符串对应的编码值顺序，可以简单理解为字母排序 同一个通知类中，相同通知类型以方法名排序为准 不同通知类中，以类名排序为准 使用@Order注解通过变更bean的加载顺序改变通知的加载顺序 2.企业开发经验 通知方法名由3部分组成，分别是前缀、顺序编码、功能描述 前缀为固定字符串，例如baidu、itheima等，无实际意义 顺序编码为6位以内的整数，通常3位即可，不足位补0 功能描述为该方法对应的实际通知功能，例如exception、strLenCheck 制通知执行顺序使用顺序编码控制，使用时做一定空间预留 003使用，006使用，预留001、002、004、005、007、008 使用时从中段开始使用，方便后期做前置追加或后置追加 最终顺序以运行顺序为准，以测试结果为准，不以设定规则为准 1.4.6. 4.6)AOP注解驱动 名称：@EnableAspectJAutoProxy 类型：注解 位置：Spring注解配置类定义上方 作用：设置当前类开启AOP注解驱动的支持，加载AOP注解 格式： @Configuration @ComponentScan(“com.itheima”) @EnableAspectJAutoProxy public class SpringConfig { } 1.5. 5)综合案例 1.5.1. 5.1)案例介绍 对项目进行业务层接口执行监控，测量业务层接口的执行效率 public interface AccountService { void save(Account account); void delete(Integer id); void update(Account account); List findAll(); Account findById(Integer id); } 1.5.2. 5.2)案例分析 测量接口执行效率：接口方法执行前后获取执行时间，求出执行时长 System.currentTimeMillis( ) 对项目进行监控：项目中所有接口方法，AOP思想，执行期动态织入代码 环绕通知 proceed()方法执行前后获取系统时间 1.5.3. 5.3)案例制作步骤 定义切入点（务必要绑定到接口上，而不是接口实现类上） 制作AOP环绕通知，完成测量功能 注解配置AOP 开启注解驱动支持 1.5.4. 5.4)案例制作核心代码 public class RunTimeMonitorAdvice { //拦截所有的业务层接口中查询操作的执行 @Pointcut(“execution(* com.itheima.service.*Service.find*(..))”) public void pt(){} @Around(“pt()”) public Object runtimeMonitor(ProceedingJoinPoint pjp) throws Throwable { //获取执行签名信息 Signature signature = pjp.getSignature(); //通过签名获取执行类型（接口名） String targetClass = signature.getDeclaringTypeName(); //通过签名获取执行操作名称（方法名） String targetMethod = signature.getName(); //获取操作前系统时间beginTime long beginTime = System.currentTimeMillis(); Object ret = pjp.proceed(pjp.getArgs()); //获取操作后系统时间endTime long endTime = System.currentTimeMillis(); System.out.println(targetClass+” 中 “+targetMethod+” 运行时长 “+(endTime-beginTime)+”ms”); return ret; } } 1.5.5. 5.5)案例后续思考与设计 测量真实性 开发测量是隔离性反复执行某个操作，是理想情况，上线测量差异过大 上线测量服务器性能略低于单机开发测量 上线测量基于缓存的性能查询要优于数据库查询测量 上线测量接口的性能与最终对外提供的服务性能差异过大 当外部条件发生变化（硬件），需要进行回归测试，例如数据库迁移 测量结果展示 测量结果无需每一个都展示，需要设定检测阈值 阈值设定要根据业务进行区分，一个复杂的查询与简单的查询差异化很大 阈值设定需要做独立的配置文件或通过图形工具配置（工具级别的开发） 配合图形界面展示测量结果 1.6. 6)AOP底层原理 静态代理 动态代理——Proxy 动态代理——CGLIB 织入形式 1.6.1. 6.1)静态代理 装饰者模式（Decorator Pattern）：在不惊动原始设计的基础上，为其添加功能 public class UserServiceDecorator implements UserService{ private UserService userService; public UserServiceDecorator(UserService userService) { this.userService = userService; } public void save() { //原始调用 userService.save(); //增强功能（后置） System.out.println(“刮大白”); } } 1.6.2. 6.2)动态代理——JDK Proxy JDKProxy动态代理是针对对象做代理，要求原始对象具有接口实现，并对接口方法进行增强 public class UserServiceJDKProxy { public UserService createUserServiceJDKProxy(final UserService userService){ //获取被代理对象的类加载器 ClassLoader classLoader = userService.getClass().getClassLoader(); //获取被代理对象实现的接口 Class[] classes = userService.getClass().getInterfaces(); //对原始方法执行进行拦截并增强 InvocationHandler ih = new InvocationHandler() { public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { //前置增强内容 Object ret = method.invoke(userService, args); //后置增强内容 System.out.println(“刮大白2”); return ret; } }; //使用原始被代理对象创建新的代理对象 UserService proxy = (UserService) Proxy.newProxyInstance(classLoader,classes,ih); return proxy; } } 1.6.3. 6.3)动态代理——CGLIB CGLIB(Code Generation Library)，Code生成类库 CGLIB动态代理不限定是否具有接口，可以对任意操作进行增强 CGLIB动态代理无需要原始被代理对象，动态创建出新的代理对象 public class UserServiceImplCglibProxy { public static UserServiceImpl createUserServiceCglibProxy(Class clazz){ //创建Enhancer对象（可以理解为内存中动态创建了一个类的字节码） Enhancer enhancer = new Enhancer(); //设置Enhancer对象的父类是指定类型UserServerImpl enhancer.setSuperclass(clazz); Callback cb = new MethodInterceptor() { public Object intercept(Object o, Method m, Object[] a, MethodProxy mp) throws Throwable { Object ret = mp.invokeSuper(o, a); if(m.getName().equals(“save”)) { System.out.println(“刮大白”); } return ret; } }; //设置回调方法 enhancer.setCallback(cb); //使用Enhancer对象创建对应的对象 return (UserServiceImpl)enhancer.create(); } } 1.6.4. 6.4)代理模式的选择 Spirng可以通过配置的形式控制使用的代理形式，默认使用jdkproxy，通过配置可以修改为使用cglib XML配置 \u000b XML注解支持 注解驱动 //注解驱动 @EnableAspectJAutoProxy(proxyTargetClass = true) 1.6.5. 6.5)织入时机 Copyright © MISIN 2022 | 豫ICP备2021006345号-1 all right reserved，powered by Gitbook该文件修订时间： 2022-11-10 13:58:03 "},"3.主流框架/1.spring/spring-day04.html":{"url":"3.主流框架/1.spring/spring-day04.html","title":"Spring Day 04","keywords":"","body":"1. spring 事务1.1. 1)事务回顾1.1.1. 1.1)什么是事务？1.1.2. 1.2)事务的作用1.1.3. 1.3)事务的隔离级1.2. 2)事务管理1.2.1. 2.1)Spring事务核心对象1.2.2. 2.2)PlatformTransactionManager1.2.3. 2.3)TransactionDefinition1.2.4. 2.4)TransactionStatus1.2.5. 2.5)事务控制方式1.2.6. 2.6)案例说明1.2.7. 2.7)使用AOP控制事务1.2.8. 2.8声明式事务（XML）1.2.9. 2.9)事务传播行为1.2.10. 2.10)事务传播行为1.2.11. 2.11)事务传播应用1.2.12. 2.12)声明式事务（注解）1.2.13. 2.13)声明式事务（纯注解驱动）1.3. 3)模板对象1.3.1. 3.1)Spring模块对象1.3.2. 3.2)JdbcTemplate（了解）1.3.3. 3.3)NamedParameterJdbcTemplate(了解）1.3.4. 3.4)RedisTemplate1.4. 4)事务底层原理解析1.4.1. 4.1)策略模式应用1. spring 事务 1.1. 1)事务回顾 1.1.1. 1.1)什么是事务？ 事务指数据库中多个操作合并在一起形成的操作序列 1.1.2. 1.2)事务的作用 1.当数据库操作序列中个别操作失败时，提供一种方式使数据库状态恢复到正常状态（A），保障数据库即使在异常状态下仍能保持数据一致性（C）（要么操作前状态，要么操作后状态）。 2.当出现并发访问数据库时，在多个访问间进行相互隔离，防止并发访问操作结果互相干扰（I）。 事务特征（ACID） 原子性（Atomicity）指事务是一个不可分割的整体，其中的操作要么全执行或全不执行 一致性（Consistency）事务前后数据的完整性必须保持一致 隔离性（Isolation）事务的隔离性是多个用户并发访问数据库时，数据库为每一个用户开启的事务，不能被其他事务的操作数据所干扰，多个并发事务之间要相互隔离 持久性（Durability）持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响 1.1.3. 1.3)事务的隔离级 脏读：允许读取未提交的信息 原因：Read uncommitted 解决方案： （表级读锁） 不可重复读：读取过程中单个数据发生了变化 解决方案： Repeatable read （行级写锁） 幻读：读取过程中数据条目发生了变化 解决方案： Serializable（表级写锁） 1.2. 2)事务管理 1.2.1. 2.1)Spring事务核心对象 J2EE开发使用分层设计的思想进行，对于简单的业务层转调数据层的单一操作，事务开启在业务层或者数据层并无太大差别，当业务中包含多个数据层的调用时，需要在业务层开启事务，对数据层中多个操作进行组合并归属于同一个事务进行处理 Spring为业务层提供了整套的事务解决方案 PlatformTransactionManager TransactionDefinition TransactionStatus 1.2.2. 2.2)PlatformTransactionManager 平台事务管理器实现类 DataSourceTransactionManager 适用于Spring JDBC或MyBatis HibernateTransactionManager 适用于Hibernate3.0及以上版本 JpaTransactionManager 适用于JPA JdoTransactionManager 适用于JDO JtaTransactionManager 适用于JTA JPA（Java Persistence API）Java EE 标准之一，为POJO提供持久化标准规范，并规范了持久化开发的统一API，符合JPA规范的开发可以在不同的JPA框架下运行 JDO(Java Data Object )是Java对象持久化规范，用于存取某种数据库中的对象，并提供标准化API。与JDBC相比，JDBC仅针对关系数据库进行操作，JDO可以扩展到关系数据库、文件、XML、对象数据库（ODBMS）等，可移植性更强 JTA（Java Transaction API）Java EE 标准之一，允许应用程序执行分布式事务处理。与JDBC相比，JDBC事务则被限定在一个单一的数据库连接，而一个JTA事务可以有多个参与者，比如JDBC连接、JDO 都可以参与到一个JTA事务中 此接口定义了事务的基本操作 获取事务 ： TransactionStatus getTransaction(TransactionDefinition definition) 提交事务 ： void commit(TransactionStatus status) 回滚事务 ： void rollback(TransactionStatus status) 1.2.3. 2.3)TransactionDefinition 此接口定义了事务的基本信息 获取事务定义名称 String getName() 获取事务的读写属性 boolean isReadOnly() 获取事务隔离级别 int getIsolationLevel() 获事务超时时间 int getTimeout() 获取事务传播行为特征 int getPropagationBehavior() 1.2.4. 2.4)TransactionStatus 此接口定义了事务在执行过程中某个时间点上的状态信息及对应的状态操作 1.2.5. 2.5)事务控制方式 编程式 声明式（XML） 声明式（注解） 1.2.6. 2.6)案例说明 2.6.1)案例说明 银行转账业务说明 银行转账操作中，涉及从A账户到B账户的资金转移操作。数据层仅提供单条数据的基础操作，未设计多账户间的业务操作。 2.6.2)案例环境（基于Spring、Mybatis整合） 业务层接口提供转账操作 /** * 转账操作 * @param outName 出账用户名 * @param inName 入账用户名 * @param money 转账金额 */ public void transfer(String outName,String inName,Double money); 业务层实现提供转账操作 public void transfer(String outName,String inName,Double money){ accountDao.inMoney(outName,money); accountDao.outMoney(inName,money); } 数据层提供对应的入账与出账操作 update account set money = money + #{money} where name = #{name} update account set money = money - #{money} where name = #{name} 2.6.3)编程式事务 public void transfer(String outName,String inName,Double money){ //创建事务管理器 DataSourceTransactionManager dstm = new DataSourceTransactionManager(); //为事务管理器设置与数据层相同的数据源 dstm.setDataSource(dataSource); //创建事务定义对象 TransactionDefinition td = new DefaultTransactionDefinition(); //创建事务状态对象，用于控制事务执行 TransactionStatus ts = dstm.getTransaction(td); accountDao.inMoney(outName,money); int i = 1/0; //模拟业务层事务过程中出现错误 accountDao.outMoney(inName,money); //提交事务 dstm.commit(ts); } 1.2.7. 2.7)使用AOP控制事务 将业务层的事务处理功能抽取出来制作成AOP通知，利用环绕通知运行期动态织入 public Object tx(ProceedingJoinPoint pjp) throws Throwable { DataSourceTransactionManager dstm = new DataSourceTransactionManager(); dstm.setDataSource(dataSource); TransactionDefinition td = new DefaultTransactionDefinition(); TransactionStatus ts = dstm.getTransaction(td); Object ret = pjp.proceed(pjp.getArgs()); dstm.commit(ts); return ret; } 配置AOP通知类，并注入dataSource 使用环绕通知将通知类织入到原始业务对象执行过程中 1.2.8. 2.8声明式事务（XML） AOP配置事务是否具有特例性？ public Object tx(ProceedingJoinPoint pjp) throws Throwable { DataSourceTransactionManager dstm = new DataSourceTransactionManager(); dstm.setDataSource(dataSource); TransactionDefinition td = new DefaultTransactionDefinition(); TransactionStatus ts = dstm.getTransaction(td); Object ret = pjp.proceed(pjp.getArgs()); dstm.commit(ts); return ret; } 使用tx命名空间配置事务专属通知类 使用aop:advisor在AOP配置中引用事务专属通知类 2.8.1)aop:advice与aop:advisor区别 aop:advice配置的通知类可以是普通java对象，不实现接口，也不使用继承关系 aop:advisor配置的通知类必须实现通知接口 MethodBeforeAdvice AfterReturningAdvice ThrowsAdvice …… 2.8.2)tx配置-—tx:advice 名称：tx:advice 类型：标签 归属：beans标签 作用：专用于声明事务通知 格式： 基本属性： id ：用于配置aop时指定通知器的id transaction-manager ：指定事务管理器bean 2.8.3)tx配置-—tx:attributes 名称：tx:attributes 类型：标签 归属：tx:advice标签 作用：定义通知属性 格式： 基本属性： 无 2.8.4)tx配置-—tx:method 名称：tx:method 类型：标签 归属：tx:attribute标签 作用：设置具体的事务属性 格式： 说明： 通常事务属性会配置多个，包含1个读写的全事务属性，1个只读的查询类事务属性 tx:method属性 1.2.9. 2.9)事务传播行为 事务管理员 事务协调员 事务传播行为描述的是事务协调员对事务管理员所携带事务的处理态度 1.2.10. 2.10)事务传播行为 1.2.11. 2.11)事务传播应用 场景A：生成订单业务 子业务S1：记录日志到数据库表X 子业务S2：保存订单数据到数据库表Y 子业务S3：…… 如果S2或S3或……事务提交失败，此时S1是否回滚？如何控制？ （S1需要新事务） 场景B：生成订单业务 背景1：订单号生成依赖数据库中一个专门用于控制订单号编号生成的表M获取 背景2：每次获取完订单号，表M中记录的编号自增1 子业务S1：从表M中获取订单编号 子业务S2：保存订单数据，订单编号来自于表M 子业务S3：…… 如果S2或S3或……事务提交失败，此时S1是否回滚？如何控制？ （S1需要新事务） 1.2.12. 2.12)声明式事务（注解） 2.12.1)@Transactional 名称：@Transactional 类型：方法注解，类注解，接口注解 位置：方法定义上方，类定义上方，接口定义上方 作用：设置当前类/接口中所有方法或具体方法开启事务，并指定相关事务属性 范例： @Transactional( readOnly = false, timeout = -1, isolation = Isolation.DEFAULT, rollbackFor = {ArithmeticException.class, IOException.class}, noRollbackFor = {}, propagation = Propagation.REQUIRES_NEW ) 2.12.2)tx:annotation-driven 名称：tx:annotation-driven 类型：标签 归属：beans标签 作用：开启事务注解驱动，并指定对应的事务管理器 范例： 1.2.13. 2.13)声明式事务（纯注解驱动） 名称：@EnableTransactionManagement 类型：类注解 位置：Spring注解配置类上方 作用：开启注解驱动，等同XML格式中的注解驱动 范例： @Configuration @ComponentScan(“com.itheima”) @PropertySource(“classpath:jdbc.properties”) @Import({JDBCConfig.class,MyBatisConfig.class,TransactionManagerConfig.class}) @EnableTransactionManagement public class SpringConfig { } public class TransactionManagerConfig { @Bean public PlatformTransactionManager getTransactionManager(@Autowired DataSource dataSource){ return new DataSourceTransactionManager(dataSource); } } 1.3. 3)模板对象 1.3.1. 3.1)Spring模块对象 TransactionTemplate JdbcTemplate RedisTemplate RabbitTemplate JmsTemplate HibernateTemplate RestTemplate 1.3.2. 3.2)JdbcTemplate（了解） 提供标准的sql语句操作API public void save(Account account) { String sql = “insert into account(name,money)values(?,?)”; jdbcTemplate.update(sql,account.getName(),account.getMoney()); } 1.3.3. 3.3)NamedParameterJdbcTemplate(了解） 提供标准的具名sql语句操作API public void save(Account account) { String sql = “insert into account(name,money)values(:name,:money)”; Map pm = new HashMap(); pm.put(“name”,account.getName()); pm.put(“money”,account.getMoney()); jdbcTemplate.update(sql,pm); } 1.3.4. 3.4)RedisTemplate RedisTemplate对象结构 public void changeMoney(Integer id, Double money) { redisTemplate.opsForValue().set(“account:id:”+id,money); } public Double findMondyById(Integer id) { Object money = redisTemplate.opsForValue().get(“account:id:” + id); return new Double(money.toString()); } 1.4. 4)事务底层原理解析 1.4.1. 4.1)策略模式应用 策略模式（Strategy Pattern）使用不同策略的对象实现不同的行为方式，策略对象的变化导致行为的变化。 策略模式（Strategy Pattern）使用不同策略的对象实现不同的行为方式，策略对象的变化导致行为的变化。 Copyright © MISIN 2022 | 豫ICP备2021006345号-1 all right reserved，powered by Gitbook该文件修订时间： 2022-11-10 13:58:18 "},"3.主流框架/2.springMVC/day01.html":{"url":"3.主流框架/2.springMVC/day01.html","title":"Day 01","keywords":"","body":"1. 1 SpringMVC 概述2. 2 入门案例2.1. 2.1 入门案例制作2.2. 2.2 入门案例工作流程分析2.3. 2.3 SpringMVC 技术架构图3. 3 基本配置3.1. 3.1 常规配置（Controller加载控制）3.1.1. 3.1.1 静态资源加载3.1.2. 3.1.2 中文乱码处理3.2. 3.2 注解驱动4. 4 请求4.1. 4.1 普通类型参数传参4.2. 4.2 POJO类型参数传参4.3. 4.3 数组与集合类型参数传参4.4. 4.4 类型转换器4.5. 4.5 日期类型格式转换4.6. 4.6 自定义类型转换器4.7. 4.7 请求映射 @RequestMapping4.7.1. 4.7.1 方法注解4.7.2. 4.7.2 类注解5. 5 响应5.1. 5.1 页面跳转5.2. 5.2 页面访问快捷设定 (InternalResourceViewResolver)5.3. 5.3 带数据页面跳转5.4. 5.4 返回json数据6. 6 Servlet相关接口-Servlet相关接口替换方案1. 1 SpringMVC 概述 三层架构 表现层：负责数据展示 业务层：负责业务处理 数据层：负责数据操作 MVC（Model View Controller），一种用于设计创建Web应用程序表现层的模式 Model（模型）：数据模型，用于封装数据 View（视图）：页面视图，用于展示数据 jsp html Controller（控制器）：处理用户交互的调度器，用于根据用户需求处理程序逻辑 Servlet SpringMVC 2. 2 入门案例 2.1. 2.1 入门案例制作 ①导入SpringMVC相关坐标 javax.servlet javax.servlet-api 3.1.0 provided javax.servlet.jsp jsp-api 2.1 provided org.springframework spring-context 5.1.9.RELEASE org.springframework spring-web 5.1.9.RELEASE org.springframework spring-webmvc 5.1.9.RELEASE ②定义表现层业务处理器Controller，并配置成spring的bean（等同于Servlet） @Controller public class UserController { public void save(){ System.out.println(\"user mvc controller is running ...\"); } } ③web.xml中配置SpringMVC核心控制器，用于将请求转发到对应的具体业务处理器Controller中（等同于Servlet配置） DispatcherServlet org.springframework.web.servlet.DispatcherServlet contextConfigLocation classpath*:spring-mvc.xml DispatcherServlet / ④设定具体Controller的访问路径（等同于Servlet在web.xml中的配置） //设定当前方法的访问映射地址 @RequestMapping(\"/save\") public void save(){ System.out.println(\"user mvc controller is running ...\"); } ⑤设置返回页面 //设定当前方法的访问映射地址 @RequestMapping(\"/save\") //设置当前方法返回值类型为String，用于指定请求完成后跳转的页面 public String save(){ System.out.println(\"user mvc controller is running ...\"); //设定具体跳转的页面 return \"success.jsp\"; } 2.2. 2.2 入门案例工作流程分析 服务器启动 加载web.xml中DispatcherServlet 读取spring-mvc.xml中的配置，加载所有com.itheima包中所有标记为bean的类 读取bean中方法上方标注@RequestMapping的内容 处理请求 DispatcherServlet配置拦截所有请求 / 使用请求路径与所有加载的@RequestMapping的内容进行比对 执行对应的方法 根据方法的返回值在webapp目录中查找对应的页面并展示 2.3. 2.3 SpringMVC 技术架构图 DispatcherServlet：前端控制器， 是整体流程控制的中心，由其调用其它组件处理用户的请求， 有 效的降低了组件间的耦合性 HandlerMapping：处理器映射器， 负责根据用户请求找到对应具体的Handler处理器 Handler：处理器，业务处理的核心类，通常由开发者编写，描述具体的业务 HandlAdapter：处理器适配器，通过它对处理器进行执行 View Resolver：视图解析器， 将处理结果生成View视图 View：视图，最终产出结果， 常用视图如jsp、 html 3. 3 基本配置 3.1. 3.1 常规配置（Controller加载控制） SpringMVC的处理器对应的bean必须按照规范格式开发，未避免加入无效的bean可通过bean加载过滤器进 行包含设定或排除设定，表现层bean标注通常设定为@Controller xml方式 3.1.1. 3.1.1 静态资源加载 3.1.2. 3.1.2 中文乱码处理 SpringMVC提供专用的中文字符过滤器，用于处理乱码问题 配置在 web.xml 里面 CharacterEncodingFilter org.springframework.web.filter.CharacterEncodingFilter encoding UTF-8 CharacterEncodingFilter /* 3.2. 3.2 注解驱动 使用注解形式转化SpringMVC核心配置文件为配置类 @Configuration @ComponentScan(value = \"com.itheima\",includeFilters = @ComponentScan.Filter(type=FilterType.ANNOTATION,classes = {Controller.class}) ) public class SpringMVCConfiguration implements WebMvcConfigurer{ //注解配置放行指定资源格式 // @Override // public void addResourceHandlers(ResourceHandlerRegistry registry) { // registry.addResourceHandler(\"/img/**\").addResourceLocations(\"/img/\"); // registry.addResourceHandler(\"/js/**\").addResourceLocations(\"/js/\"); // registry.addResourceHandler(\"/css/**\").addResourceLocations(\"/css/\"); // } //注解配置通用放行资源的格式 @Override public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) { configurer.enable();; } } 基于servlet3.0规范，自定义Servlet容器初始化配置类，加载SpringMVC核心配置类 public class ServletContainersInitConfig extends AbstractDispatcherServletInitializer { //创建Servlet容器时，使用注解的方式加载SPRINGMVC配置类中的信息，并加载成WEB专用的 //ApplicationContext对象 //该对象放入了ServletContext范围，后期在整个WEB容器中可以随时获取调用 @Override protected WebApplicationContext createServletApplicationContext() { AnnotationConfigWebApplicationContext ctx = new AnnotationConfigWebApplicationContext(); ctx.register(SpringMVCConfiguration.class); return ctx; } //注解配置映射地址方式，服务于SpringMVC的核心控制器DispatcherServlet @Override protected String[] getServletMappings() { return new String[]{\"/\"}; } @Override protected WebApplicationContext createRootApplicationContext() { return null; } //乱码处理作为过滤器，在servlet容器启动时进行配置，相关内容参看Servlet零配置相关课程 @Override public void onStartup(ServletContext servletContext) throws ServletException { super.onStartup(servletContext); CharacterEncodingFilter cef = new CharacterEncodingFilter(); cef.setEncoding(\"UTF-8\"); FilterRegistration.Dynamic registration = servletContext.addFilter(\"characterEncodingFilter\", cef); registration.addMappingForUrlPatterns(EnumSet.of(DispatcherType.REQUEST,DispatcherType.FORWARD,DispatcherType.INCLUDE),false,\"/*\"); } } 删除web.xml 删除spring-mvc.xml 小节  基于servlet3.0规范，配置Servlet容器初始化配置类，初始化时加载SpringMVC配置类  转化SpringMVC核心配置文件  转化为注解（例如： spring处理器加载过滤）  转化为bean进行加载  按照标准接口进行开发并加载（例如：中文乱码处理、静态资源加载过滤） 4. 4 请求 4.1. 4.1 普通类型参数传参 参数名与处理器方法形参名保持一致 访问URL： http://localhost/requestParam1?name=itheima&age=14 @RequestMapping(\"/requestParam1\") public String requestParam1(String name ,String age){ System.out.println(\"name=\"+name+\",age=\"+age); return \"page.jsp\"; } @RequestParam 的使用  类型： 形参注解  位置：处理器类中的方法形参前方  作用：绑定请求参数与对应处理方法形参间的关系 @RequestMapping(\"/requestParam2\") public String requestParam2(@RequestParam( name = \"userName\", required = true, defaultValue = \"itheima\") String name){ System.out.println(\"name=\"+name); return \"page.jsp\"; } 4.2. 4.2 POJO类型参数传参 当POJO中使用简单类型属性时， 参数名称与POJO类属性名保持一致 访问URL： http://localhost/requestParam3?name=itheima&age=14 Controller @RequestMapping(\"/requestParam3\") public String requestParam3(User user){ System.out.println(\"name=\"+user.getName()); return \"page.jsp\"; } POJO类 public class User { private String name; private Integer age; public String getName() { return name; } public void setName(String name) { this.name = name; } public Integer getAge() { return age; } public void setAge(Integer age) { this.age = age; } } 参数冲突  当POJO类型属性与其他形参出现同名问题时，将被同时赋值  建议使用@RequestParam注解进行区分 访问URL： http://localhost/requestParam4?name=itheima&**age**=14 @RequestMapping(\"/requestParam4\") public String requestParam4(User user,String age){ System.out.println(\"user.age=\"+user.getAge()+\",age=\"+age); return \"page.jsp\"; } 复杂POJO类型参数  当POJO中出现对象属性时，参数名称与对象层次结构名称保持一致 访问URL： http://localhost/requestParam5?address.province=beijing public class User { private String name; private Integer age; private Address address; public Address getAddress() { return address; } public void setAddress(Address address) { this.address = address; } public String getName() { return name; } public void setName(String name) { this.name = name; } public Integer getAge() { return age; } public void setAge(Integer age) { this.age = age; } } @RequestMapping(\"/requestParam5\") public String requestParam5(User user){ System.out.println(\"user.address=\"+user.getAddress().getProvince()); return \"page.jsp\"; } 当POJO中出现List，保存对象数据，参数名称与对象层次结构名称保持一致，使用数组格式描述集合中对象的位置 访问URL： http://localhost/requestParam7?addresses[0].province=bj&addresses[1].province=tj public class User { private String name; private Integer age; private List addresses; } public class Address { private String province; private String city; private String address; } @RequestMapping(\"/requestParam7\") public String requestParam7(User user){ System.out.println(\"user.addresses=\"+user.getAddress()); return \"page.jsp\"; } 当POJO中出现Map，保存对象数据，参数名称与对象层次结构名称保持一致，使用映射格式描述集合中对象的位置 访问URL： http://localhost/requestParam8?addressMap[’home’].province=bj&addressMap[’job’].province=tj public class User { private String name; private Integer age; private Map addressMap; } public class Address { private String province; private String city; private String address; } @RequestMapping(\"/requestParam8\") public String requestParam8(User user){ System.out.println(\"user.addressMap=\"+user.getAddressMap()); return \"page.jsp\"; } 4.3. 4.3 数组与集合类型参数传参 数组类型参数 请求参数名与处理器方法形参名保持一致，且请求参数数量＞ 1个 访问URL： http://localhost/requestParam9?nick=Jockme&nick=zahc @RequestMapping(\"/requestParam9\") public String requestParam9(String[] nick){ System.out.println(nick[0]+\",\"+nick[1]); return \"page.jsp\"; } 集合类型参数  保存简单类型数据，请求参数名与处理器方法形参名保持一致，且请求参数数量＞ 1个 访问URL： http://localhost/requestParam10?nick=Jockme&nick=zahc @RequestMapping(\"/requestParam10\") public String requestParam10(@RequestParam(\"nick\") List nick){ System.out.println(nick); return \"page.jsp\"; }  注意： SpringMVC默认将List作为对象处理，赋值前先创建对象，然后将nick作为对象的属性进行处理。由于 List是接口，无法创建对象，报无法找到构造方法异常；修复类型为可创建对象的ArrayList类型后，对象可 以创建，但没有nick属性，因此数据为空。此时需要告知SpringMVC的处理器nick是一组数据，而不是一个单 一数据。通过@RequestParam注解，将数量大于1个names参数打包成参数数组后， SpringMVC才能识别该数 据格式，并判定形参类型是否为数组或集合，并按数组或集合对象的形式操作数据。 小节  请求POJO类型参数获取  POJO的简单属性  POJO的对象属性  POJO的集合属性（存储简单数据）  POJO的集合属性（存储对象数据）  名称冲突问题 4.4. 4.4 类型转换器 SpringMVC对接收的数据进行自动类型转换，该工作通过Converter接口实现 标量转换器  StringToBooleanConverter String→Boolean  ObjectToStringConverter Object→String  StringToNumberConverterFactory String→Number（ Integer、 Long等）  NumberToNumberConverterFactory Number子类型之间(Integer、 Long、 Double等)  StringToCharacterConverter String→java.lang.Character  NumberToCharacterConverter Number子类型(Integer、 Long、 Double等)→java.lang.Character  CharacterToNumberFactory java.lang.Character→Number子类型(Integer、 Long、 Double等)  StringToEnumConverterFactory String→enum类型  EnumToStringConverter enum类型→String  StringToLocaleConverter String→java.util.Local  PropertiesToStringConverter java.util.Properties→String  StringToPropertiesConverter String→java.util.Properties 集合、数组相关转换器  ArrayToCollectionConverter 数组→集合（ List、 Set）  CollectionToArrayConverter 集合（ List、 Set） →数组  ArrayToArrayConverter 数组间  CollectionToCollectionConverter 集合间（ List、 Set）  MapToMapConverter Map间  ArrayToStringConverter 数组→String类型  StringToArrayConverter String→数组， trim后使用“,”split  ArrayToObjectConverter 数组→Object  ObjectToArrayConverter Object→单元素数组  CollectionToStringConverter 集合（ List、 Set） →String  StringToCollectionConverter String→集合（ List、 Set）， trim后使用“,”split  CollectionToObjectConverter 集合→Object  ObjectToCollectionConverter Object→单元素集合 默认转换器  ObjectToObjectConverter Object间  IdToEntityConverter Id→Entity  FallbackObjectToStringConverter Object→String SpringMVC对接收的数据进行自动类型转换，该工作通过Converter接口实现 4.5. 4.5 日期类型格式转换 声明自定义的转换格式并覆盖系统转换格式 日期类型格式转换（简化版）  名称： @DateTimeFormat  类型： 形参注解、成员变量注解  位置：形参前面 或 成员变量上方  作用：为当前参数或变量指定类型转换规则  范例： public String requestParam12(@DateTimeFormat(pattern = \"yyyy-MM-dd\") Date date){ System.out.println(\"date=\"+date); return \"page.jsp\"; } @DateTimeFormat(pattern = \"yyyy-MM-dd\") private Date birthday; 注意：依赖注解驱动支持 4.6. 4.6 自定义类型转换器 自定义类型转换器，实现Converter接口，并制定转换前与转换后的类型 的泛型为准--> //自定义类型转换器，实现Converter接口，接口中指定的泛型即为最终作用的条件 //本例中的泛型填写的是String，Date，最终出现字符串转日期时，该类型转换器生效 public class MyDateConverter implements Converter { //重写接口的抽象方法，参数由泛型决定 public Date convert(String source) { DateFormat df = new SimpleDateFormat(\"yyyy-MM-dd\"); Date date = null; //类型转换器无法预计使用过程中出现的异常，因此必须在类型转换器内部捕获，不允许抛出，框架无法预计此类异常如何处理 try { date = df.parse(source); } catch (ParseException e) { e.printStackTrace(); } return date; } } 通过注册自定义转换器，将该功能加入到SpringMVC的转换服务ConverterService中 4.7. 4.7 请求映射 @RequestMapping 4.7.1. 4.7.1 方法注解 名称： @RequestMapping  类型： 方法注解  位置：处理器类中的方法定义上方  作用：绑定请求地址与对应处理方法间的关系  范例：  访问路径： /requestURL1 @Controller @RequestMapping(\"/user\") public class UserController { @RequestMapping(\"/requestURL2\") public String requestURL2() { return \"page.jsp\"; } } 4.7.2. 4.7.2 类注解 名称： @RequestMapping  类型： 类注解  位置：处理器类定义上方  作用：为当前处理器中所有方法设定公共的访问路径前缀  范例：  访问路径： /user/requestURL1 @Controller @RequestMapping(\"/user\") public class UserController { @RequestMapping(\"/requestURL2\") public String requestURL2() { return \"page.jsp\"; } } 常用属性 @RequestMapping( value=\"/requestURL3\", //设定请求路径，与path属性、 value属性相同 method = RequestMethod.GET, //设定请求方式 params = \"name\", //设定请求参数条件 headers = \"content-type=text/*\", //设定请求消息头条件 consumes = \"text/*\", //用于指定可以接收的请求正文类型（MIME类型） produces = \"text/*\" //用于指定可以生成的响应正文类型（MIME类型） ) public String requestURL3() { return \"/page.jsp\"; } 5. 5 响应 5.1. 5.1 页面跳转 转发（默认） @RequestMapping(\"/showPage1\") public String showPage1() { System.out.println(\"user mvc controller is running ...\"); return \"forward:page.jsp\"; } 重定向 @RequestMapping(\"/showPage2\") public String showPage2() { System.out.println(\"user mvc controller is running ...\"); return \"redirect:page.jsp\"; }  注意：页面访问地址中所携带的 / 5.2. 5.2 页面访问快捷设定 (InternalResourceViewResolver) 展示页面的保存位置通常固定，且结构相似，可以设定通用的访问路径，简化页面配置格式 /bean> public String showPage3() { return \"page\"; } 如果未设定了返回值，使用void类型，则默认使用访问路径作页面地址的前缀后缀 //最简页面配置方式，使用访问路径作为页面名称，省略返回值 @RequestMapping(\"/showPage5\") public void showPage5() { System.out.println(\"user mvc controller is running ...\"); } 5.3. 5.3 带数据页面跳转 方式一：使用HttpServletRequest类型形参进行数据传递 @RequestMapping(\"/showPageAndData1\") public String showPageAndData1(HttpServletRequest request) { request.setAttribute(\"name\",\"itheima\"); return \"page\"; } 方式二：使用Model类型形参进行数据传递 @RequestMapping(\"/showPageAndData2\") public String showPageAndData2(Model model) { model.addAttribute(\"name\",\"itheima\"); Book book = new Book(); book.setName(\"SpringMVC入门实战\"); book.setPrice(66.6d); model.addAttribute(\"book\",book); return \"page\"; } 方式三：使用ModelAndView类型形参进行数据传递，将该对象作为返回值传递给调用者 //使用ModelAndView形参传递参数，该对象还封装了页面信息 @RequestMapping(\"/showPageAndData3\") public ModelAndView showPageAndData3(ModelAndView modelAndView) { //ModelAndView mav = new ModelAndView(); 替换形参中的参数 Book book = new Book(); book.setName(\"SpringMVC入门案例\"); book.setPrice(66.66d); //添加数据的方式，key对value modelAndView.addObject(\"book\",book); //添加数据的方式，key对value modelAndView.addObject(\"name\",\"Jockme\"); //设置页面的方式，该方法最后一次执行的结果生效 modelAndView.setViewName(\"page\"); //返回值设定成ModelAndView对象 return modelAndView; } 5.4. 5.4 返回json数据 方式一：基于response返回数据的简化格式，返回JSON数据 //使用jackson进行json数据格式转化 @RequestMapping(\"/showData3\") @ResponseBody public String showData3() throws JsonProcessingException { Book book = new Book(); book.setName(\"SpringMVC入门案例\"); book.setPrice(66.66d); ObjectMapper om = new ObjectMapper(); return om.writeValueAsString(book); } 使用SpringMVC提供的消息类型转换器将对象与集合数据自动转换为JSON数据 //使用SpringMVC注解驱动，对标注@ResponseBody注解的控制器方法进行结果转换，由于返回值为引用类型，自动调用jackson提供的类型转换器进行格式转换 @RequestMapping(\"/showData4\") @ResponseBody public Book showData4() { Book book = new Book(); book.setName(\"SpringMVC入门案例\"); book.setPrice(66.66d); return book; } 需要手工添加信息类型转换器 方式三：使用SpringMVC注解驱动简化配置 6. 6 Servlet相关接口-Servlet相关接口替换方案 HttpServletRequest / HttpServletResponse / HttpSession SpringMVC提供访问原始Servlet接口API的功能，通过形参声明即可 @RequestMapping(\"/servletApi\") public String servletApi(HttpServletRequest request, HttpServletResponse response, HttpSession session){ System.out.println(request); System.out.println(response); System.out.println(session); request.setAttribute(\"name\",\"itheima\"); System.out.println(request.getAttribute(\"name\")); return \"page.jsp\"; } Head数据获取  名称： @RequestHeader  类型： 形参注解  位置：处理器类中的方法形参前方  作用：绑定请求头数据与对应处理方法形参间的关系  范例： @RequestMapping(\"/headApi\") public String headApi(@RequestHeader(\"Accept-Language\") String head){ System.out.println(head); return \"page.jsp\"; } Cookie数据获取  名称： @CookieValue  类型： 形参注解  位置：处理器类中的方法形参前方  作用：绑定请求Cookie数据与对应处理方法形参间的关系  范例： @RequestMapping(\"/cookieApi\") public String cookieApi(@CookieValue(\"JSESSIONID\") String jsessionid){ System.out.println(jsessionid); return \"page.jsp\"; } Session数据获取  名称： @SessionAttribute  类型： 形参注解  位置：处理器类中的方法形参前方  作用：绑定请求Session数据与对应处理方法形参间的关系  范例： @RequestMapping(\"/sessionApi\") public String sessionApi(@SessionAttribute(\"name\") String name){ System.out.println(name); return \"page.jsp\"; } Session数据设置（了解）  名称： @SessionAttributes  类型： 类注解  位置：处理器类上方  作用：声明放入session范围的变量名称，适用于Model类型数据传参  范例： @Controller @SessionAttributes(names={\"name\"}) public class ServletController { @RequestMapping(\"/setSessionData2\") public String setSessionDate2(Model model) { model.addAttribute(\"name\", \"Jock2\"); return \"page.jsp\"; } } 注解式参数数据封装底层原理  数据的来源不同，对应的处理策略要进行区分  Head  Cookie  Session  SpringMVC使用策略模式进行处理分发  顶层接口： HandlerMethodArgumentResolver  实现类： …… Copyright © MISIN 2022 | 豫ICP备2021006345号-1 all right reserved，powered by Gitbook该文件修订时间： 2020-06-05 23:02:28 "},"3.主流框架/2.springMVC/day02.html":{"url":"3.主流框架/2.springMVC/day02.html","title":"Day 02","keywords":"","body":"1. 1 异步调用1.1. 1.1 发送异步请求（回顾）1.2. 1.2 接受异步请求参数1.3. 1.3 异步请求接受响应数据2. 2 异步请求-跨域访问2.1. 2.1 跨域访问介绍2.2. 2.2 跨域环境搭建2.3. 2.3 跨域访问支持3. 3 拦截器3.1. 3.1 拦截器概念3.2. 3.2 自定义拦截器开发过程3.3. 3.3 拦截器执行流程3.4. 3.4 拦截器配置与方法参数3.4.1. 3.4.1 前置处理方法3.4.2. 3.4.2 后置处理方法3.4.3. 3.4.3 完成处理方法3.5. 3.5 拦截器配置项3.6. 3.6 多拦截器配置4. 4 异常处理4.1. 4.1 异常处理器4.2. 4.2 注解开发异常处理器4.3. 4.3 异常处理解决方案4.4. 4.4 自定义异常5. 5 实用技术5.1. 5.1 文件上传下载5.2. 5.2 文件上传注意事项5.3. 5.4 Restful风格配置5.3.1. 5.4.1 Rest5.3.2. 5.4.2 Rest行为约定方式5.3.3. 5.4.3 Restful开发入门5.4. 5.5 postman工具安装与使用1. 1 异步调用 1.1. 1.1 发送异步请求（回顾） 访问controller $(function(){ $(\"#testAjax\").click(function(){ //为id=\"testAjax\"的组件绑定点击事件 $.ajax({ //发送异步调用 type:\"POST\", //请求方式： POST请求 url:\"ajaxController\", //请求参数（也就是请求内容） data:'ajax message', //请求参数（也就是请求内容） dataType:\"text\", //响应正文类型 contentType:\"application/text\", //请求正文的MIME类型 }); }); }); 1.2. 1.2 接受异步请求参数  名称： @RequestBody  类型： 形参注解  位置：处理器类中的方法形参前方  作用：将异步提交数据组织成标准请求参数格式，并赋值给形参  范例： @RequestMapping(\"/ajaxController\") public String ajaxController(@RequestBody String message){ System.out.println(message); return \"page.jsp\"; } 注解添加到Pojo参数前方时，封装的异步提交数据按照Pojo的属性格式进行关系映射 注解添加到集合参数前方时，封装的异步提交数据按照集合的存储结构进行关系映射 @RequestMapping(\"/ajaxPojoToController\") //如果处理参数是POJO，且页面发送的请求数据格式与POJO中的属性对应，@RequestBody注解可以自动映射对应请求数据到POJO中 //注意：POJO中的属性如果请求数据中没有，属性值为null，POJO中没有的属性如果请求数据中有，不进行映射 public String ajaxPojoToController(@RequestBody User user){ System.out.println(\"controller pojo :\"+user); return \"page.jsp\"; } @RequestMapping(\"/ajaxListToController\") //如果处理参数是List集合且封装了POJO，且页面发送的数据是JSON格式的对象数组，数据将自动映射到集合参数中 public String ajaxListToController(@RequestBody List userList){ System.out.println(\"controller list :\"+userList); return \"page.jsp\"; } 1.3. 1.3 异步请求接受响应数据 方法返回值为Pojo时，自动封装数据成json对象数据 @RequestMapping(\"/ajaxReturnJson\") @ResponseBody public User ajaxReturnJson(){ System.out.println(\"controller return json pojo...\"); User user = new User(); user.setName(\"Jockme\"); user.setAge(40); return user; } 方法返回值为List时，自动封装数据成json对象数组数据 @RequestMapping(\"/ajaxReturnJsonList\") @ResponseBody //基于jackon技术，使用@ResponseBody注解可以将返回的保存POJO对象的集合转成json数组格式数据 public List ajaxReturnJsonList(){ System.out.println(\"controller return json list...\"); User user1 = new User(); user1.setName(\"Tom\"); user1.setAge(3); User user2 = new User(); user2.setName(\"Jerry\"); user2.setAge(5); ArrayList al = new ArrayList(); al.add(user1); al.add(user2); return al; } 2. 2 异步请求-跨域访问 2.1. 2.1 跨域访问介绍 当通过域名A下的操作访问域名B下的资源时，称为跨域访问 跨域访问时，会出现无法访问的现象 2.2. 2.2 跨域环境搭建 为当前主机添加备用域名 修改windows安装目录中的host文件 格式： ip 域名 动态刷新DNS 命令： ipconfig /displaydns 命令： ipconfig /flushdns 2.3. 2.3 跨域访问支持  名称： @CrossOrigin  类型： 方法注解 、 类注解  位置：处理器类中的方法上方 或 类上方  作用：设置当前处理器方法/处理器类中所有方法支持跨域访问  范例： @RequestMapping(\"/cross\") @ResponseBody //使用@CrossOrigin开启跨域访问 //标注在处理器方法上方表示该方法支持跨域访问 //标注在处理器类上方表示该处理器类中的所有处理器方法均支持跨域访问 @CrossOrigin public User cross(HttpServletRequest request){ System.out.println(\"controller cross...\"+request.getRequestURL()); User user = new User(); user.setName(\"Jockme\"); user.setAge(39); return user; } 3. 3 拦截器 3.1. 3.1 拦截器概念 请求处理过程解析  拦截器（ Interceptor）是一种动态拦截方法调用的机制  作用： 1. 在指定的方法调用前后执行预先设定后的的代码 2. 阻止原始方法的执行  核心原理： AOP思想  拦截器链：多个拦截器按照一定的顺序，对原始被调用功能进行增强 拦截器VS过滤器  归属不同： Filter属于Servlet技术， Interceptor属于SpringMVC技术  拦截内容不同： Filter对所有访问进行增强， Interceptor仅针对SpringMVC的访问进行增强 3.2. 3.2 自定义拦截器开发过程 实现HandlerInterceptor接口 //自定义拦截器需要实现HandleInterceptor接口 public class MyInterceptor implements HandlerInterceptor { //处理器运行之前执行 @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { System.out.println(\"前置运行----a1\"); //返回值为false将拦截原始处理器的运行 //如果配置多拦截器，返回值为false将终止当前拦截器后面配置的拦截器的运行 return true; } //处理器运行之后执行 @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { System.out.println(\"后置运行----b1\"); } //所有拦截器的后置执行全部结束后，执行该操作 @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { System.out.println(\"完成运行----c1\"); } //三个方法的运行顺序为 preHandle -> postHandle -> afterCompletion //如果preHandle返回值为false，三个方法仅运行preHandle } 配置拦截器 配置拦截器 注意：配置顺序为先配置执行位置，后配置执行类 3.3. 3.3 拦截器执行流程 3.4. 3.4 拦截器配置与方法参数 3.4.1. 3.4.1 前置处理方法 原始方法之前运行 public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { System.out.println(\"preHandle\"); return true; } 参数  request:请求对象  response:响应对象  handler:被调用的处理器对象，本质上是一个方法对象，对反射中的Method对象进行了再包装 返回值  返回值为false，被拦截的处理器将不执行 3.4.2. 3.4.2 后置处理方法 原始方法运行后运行，如果原始方法被拦截，则不执行 public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { System.out.println(\"postHandle\"); }  参数  modelAndView:如果处理器执行完成具有返回结果，可以读取到对应数据与页面信息，并进行调整 3.4.3. 3.4.3 完成处理方法 拦截器最后执行的方法，无论原始方法是否执行 public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { System.out.println(\"afterCompletion\"); }  参数  ex:如果处理器执行过程中出现异常对象，可以针对异常情况进行单独处理 3.5. 3.5 拦截器配置项 3.6. 3.6 多拦截器配置 责任链模式  责任链模式是一种行为模式  特征： 沿着一条预先设定的任务链顺序执行，每个节点具有独立的工作任务  优势： 独立性：只关注当前节点的任务，对其他任务直接放行到下一节点 隔离性：具备链式传递特征，无需知晓整体链路结构，只需等待请求到达后进行处理即可 灵活性：可以任意修改链路结构动态新增或删减整体链路责任 解耦：将动态任务与原始任务解耦  弊端： 链路过长时，处理效率低下 可能存在节点上的循环引用现象，造成死循环，导致系统崩溃 4. 4 异常处理 4.1. 4.1 异常处理器 HandlerExceptionResolver接口（异常处理器） @Component public class ExceptionResolver implements HandlerExceptionResolver { public ModelAndView resolveException(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) { System.out.println(\"异常处理器正在执行中\"); ModelAndView modelAndView = new ModelAndView(); //定义异常现象出现后，反馈给用户查看的信息 modelAndView.addObject(\"msg\",\"出错啦！ \"); //定义异常现象出现后，反馈给用户查看的页面 modelAndView.setViewName(\"error.jsp\"); return modelAndView; } } 根据异常的种类不同，进行分门别类的管理，返回不同的信息 public class ExceptionResolver implements HandlerExceptionResolver { @Override public ModelAndView resolveException(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) { System.out.println(\"my exception is running ....\"+ex); ModelAndView modelAndView = new ModelAndView(); if( ex instanceof NullPointerException){ modelAndView.addObject(\"msg\",\"空指针异常\"); }else if ( ex instanceof ArithmeticException){ modelAndView.addObject(\"msg\",\"算数运算异常\"); }else{ modelAndView.addObject(\"msg\",\"未知的异常\"); } modelAndView.setViewName(\"error.jsp\"); return modelAndView; } } 4.2. 4.2 注解开发异常处理器 使用注解实现异常分类管理  名称： @ControllerAdvice  类型： 类注解  位置：异常处理器类上方  作用：设置当前类为异常处理器类  范例： @Component @ControllerAdvice public class ExceptionAdvice { } 使用注解实现异常分类管理  名称： @ExceptionHandler  类型： 方法注解  位置：异常处理器类中针对指定异常进行处理的方法上方  作用：设置指定异常的处理方式  范例：  说明：处理器方法可以设定多个@ExceptionHandler(Exception.class) @ResponseBody public String doOtherException(Exception ex){ return \"出错啦，请联系管理员！ \"; } 4.3. 4.3 异常处理解决方案 异常处理方案 业务异常：  发送对应消息传递给用户，提醒规范操作 系统异常：  发送固定消息传递给用户，安抚用户  发送特定消息给运维人员，提醒维护  记录日志 其他异常：  发送固定消息传递给用户，安抚用户  发送特定消息给编程人员，提醒维护  纳入预期范围内  记录日志 4.4. 4.4 自定义异常 异常定义格式 //自定义异常继承RuntimeException，覆盖父类所有的构造方法 public class BusinessException extends RuntimeException { public BusinessException() { } public BusinessException(String message) { super(message); } public BusinessException(String message, Throwable cause) { super(message, cause); } public BusinessException(Throwable cause) { super(cause); } public BusinessException(String message, Throwable cause, boolean enableSuppression, boolean writableStackTrace) { super(message, cause, enableSuppression, writableStackTrace); } } 异常触发方式 if(user.getName().trim().length() 通过自定义异常将所有的异常现象进行分类管理，以统一的格式对外呈现异常消息 5. 5 实用技术 5.1. 5.1 文件上传下载 上传文件过程分析 MultipartResolver接口 MultipartResolver接口定义了文件上传过程中的相关操作，并对通用性操作进行了封装 MultipartResolver接口底层实现类CommonsMultipartResovler CommonsMultipartResovler并未自主实现文件上传下载对应的功能，而是调用了apache的文件上传下载组件 commons-fileupload commons-fileupload 1.4 文件上传下载实现 页面表单 上传LOGO： SpringMVC配置 控制器 @RequestMapping(value = \"/fileupload\") public void fileupload(MultipartFile file){ file.transferTo(new File(\"file.png\")); } 5.2. 5.2 文件上传注意事项 文件命名问题， 获取上传文件名，并解析文件名与扩展名 文件名过长问题 文件保存路径 重名问题 @RequestMapping(value = \"/fileupload\") //参数中定义MultipartFile参数，用于接收页面提交的type=file类型的表单，要求表单名称与参数名相同 public String fileupload(MultipartFile file,MultipartFile file1,MultipartFile file2, HttpServletRequest request) throws IOException { System.out.println(\"file upload is running ...\"+file); // MultipartFile参数中封装了上传的文件的相关信息 // System.out.println(file.getSize()); // System.out.println(file.getBytes().length); // System.out.println(file.getContentType()); // System.out.println(file.getName()); // System.out.println(file.getOriginalFilename()); // System.out.println(file.isEmpty()); //首先判断是否是空文件，也就是存储空间占用为0的文件 if(!file.isEmpty()){ //如果大小在范围要求内正常处理，否则抛出自定义异常告知用户（未实现） //获取原始上传的文件名，可以作为当前文件的真实名称保存到数据库中备用 String fileName = file.getOriginalFilename(); //设置保存的路径 String realPath = request.getServletContext().getRealPath(\"/images\"); //保存文件的方法，指定保存的位置和文件名即可，通常文件名使用随机生成策略产生，避免文件名冲突问题 file.transferTo(new File(realPath,file.getOriginalFilename())); } //测试一次性上传多个文件 if(!file1.isEmpty()){ String fileName = file1.getOriginalFilename(); //可以根据需要，对不同种类的文件做不同的存储路径的区分，修改对应的保存位置即可 String realPath = request.getServletContext().getRealPath(\"/images\"); file1.transferTo(new File(realPath,file1.getOriginalFilename())); } if(!file2.isEmpty()){ String fileName = file2.getOriginalFilename(); String realPath = request.getServletContext().getRealPath(\"/images\"); file2.transferTo(new File(realPath,file2.getOriginalFilename())); } return \"page.jsp\"; } 5.3. 5.4 Restful风格配置 5.3.1. 5.4.1 Rest Rest（ REpresentational State Transfer） 一种网络资源的访问风格，定义了网络资源的访问方式 传统风格访问路径  http://localhost/user/get?id=1  http://localhost/deleteUser?id=1 Rest风格访问路径  http://localhost/user/1 Restful是按照Rest风格访问网络资源 优点  隐藏资源的访问行为，通过地址无法得知做的是何种操作  书写简化 5.3.2. 5.4.2 Rest行为约定方式  GET（查询） http://localhost/user/1 GET  POST（保存） http://localhost/user POST  PUT（更新） http://localhost/user PUT  DELETE（删除） http://localhost/user DELETE 注意：上述行为是约定方式，约定不是规范，可以打破，所以称Rest风格，而不是Rest规范 5.3.3. 5.4.3 Restful开发入门 //设置rest风格的控制器 @RestController //设置公共访问路径，配合下方访问路径使用 @RequestMapping(\"/user/\") public class UserController { //rest风格访问路径完整书写方式 @RequestMapping(\"/user/{id}\") //使用@PathVariable注解获取路径上配置的具名变量，该配置可以使用多次 public String restLocation(@PathVariable Integer id){ System.out.println(\"restful is running ....\"); return \"success.jsp\"; } //rest风格访问路径简化书写方式，配合类注解@RequestMapping使用 @RequestMapping(\"{id}\") public String restLocation2(@PathVariable Integer id){ System.out.println(\"restful is running ....get:\"+id); return \"success.jsp\"; } //接收GET请求配置方式 @RequestMapping(value = \"{id}\",method = RequestMethod.GET) //接收GET请求简化配置方式 @GetMapping(\"{id}\") public String get(@PathVariable Integer id){ System.out.println(\"restful is running ....get:\"+id); return \"success.jsp\"; } //接收POST请求配置方式 @RequestMapping(value = \"{id}\",method = RequestMethod.POST) //接收POST请求简化配置方式 @PostMapping(\"{id}\") public String post(@PathVariable Integer id){ System.out.println(\"restful is running ....post:\"+id); return \"success.jsp\"; } //接收PUT请求简化配置方式 @RequestMapping(value = \"{id}\",method = RequestMethod.PUT) //接收PUT请求简化配置方式 @PutMapping(\"{id}\") public String put(@PathVariable Integer id){ System.out.println(\"restful is running ....put:\"+id); return \"success.jsp\"; } //接收DELETE请求简化配置方式 @RequestMapping(value = \"{id}\",method = RequestMethod.DELETE) //接收DELETE请求简化配置方式 @DeleteMapping(\"{id}\") public String delete(@PathVariable Integer id){ System.out.println(\"restful is running ....delete:\"+id); return \"success.jsp\"; } } HiddenHttpMethodFilter org.springframework.web.filter.HiddenHttpMethodFilter HiddenHttpMethodFilter DispatcherServlet  开启SpringMVC对Restful风格的访问支持过滤器，即可通过页面表单提交PUT与DELETE请求  页面表单使用隐藏域提交请求类型，参数名称固定为_method，必须配合提交类型method=post使用 Restful请求路径简化配置方式 @RestController public class UserController { @RequestMapping(value = \"/user/{id}\",method = RequestMethod.DELETE) public String restDelete(@PathVariable String id){ System.out.println(\"restful is running ....delete:\"+id); return \"success.jsp\"; } } 5.4. 5.5 postman工具安装与使用 postman 是 一款可以发送Restful风格请求的工具，方便开发调试。首次运行需要联网注册 Copyright © MISIN 2022 | 豫ICP备2021006345号-1 all right reserved，powered by Gitbook该文件修订时间： 2020-04-27 18:11:52 "},"3.主流框架/2.springMVC/day03.html":{"url":"3.主流框架/2.springMVC/day03.html","title":"Day 03","keywords":"","body":"1. 1 校验框架1.1. 1.1 校验框架入门1.1.1. 1.1.1 表单校验的重要性1.1.2. 1.1.2 表单校验分类1.1.3. 1.1.3 表单校验规则1.1.4. 1.1.4 表单校验框架1.2. 1.2 快速使用1.3. 1.3 多规则校验1.4. 1.4 嵌套校验1.5. 1.5 分组校验2. 2 ssm整合2.1. 2.1 整合流程简介2.2. 2.2 项目结构搭建2.3. 2.3 Spring整合Mybatis（复习）2.4. 2.4 整合junit2.5. 2.5 Spring整合SpringMVC2.6. 2.7 自定义异常2.7. 2.8 返回消息兼容异常信息3. 3 纯注解开发SSM3.1. 3.1 用注解替代applicationContext.xml3.2. 3.2 用注解替代spring-mvc.xml1. 1 校验框架 1.1. 1.1 校验框架入门 1.1.1. 1.1.1 表单校验的重要性 表单校验保障了数据有效性、安全性 数据可以随意输入，导致错误的结果。后端表单校验的重要性。 1.1.2. 1.1.2 表单校验分类 校验位置： 客户端校验 服务端校验 校验内容与对应方式： 格式校验 客户端：使用Js技术，利用正则表达式校验 服务端：使用校验框架 逻辑校验 客户端：使用ajax发送要校验的数据，在服务端完成逻辑校验，返回校验结果 服务端：接收到完整的请求后，在执行业务操作前，完成逻辑校验 1.1.3. 1.1.3 表单校验规则 长度：例如用户名长度，评论字符数量 非法字符：例如用户名组成 数据格式：例如Email格式、 IP地址格式 边界值：例如转账金额上限，年龄上下限 重复性：例如用户名是否重复 1.1.4. 1.1.4 表单校验框架 JSR（Java Specification Requests）：Java 规范提案 303：提供bean属性相关校验规则 JSR规范列表 企业应用技术  Contexts and Dependency Injection for Java (Web Beans 1.0) (JSR 299)  Dependency Injection for Java 1.0 (JSR 330)@postConstruct, @PreDestroy  Bean Validation 1.0 (JSR 303)  Enterprise JavaBeans 3.1 (includes Interceptors 1.1) (JSR 318)  Java EE Connector Architecture 1.6 (JSR 322)  Java Persistence 2.0 (JSR 317)  Common Annotations for the Java Platform 1.1 (JSR 250)  Java Message Service API 1.1 (JSR 914)  Java Transaction API (JTA) 1.1 (JSR 907)  JavaMail 1.4 (JSR 919) Web应用技术  Java Servlet 3.0 (JSR 315)  JavaServer Faces 2.0 (JSR 314)  JavaServer Pages 2.2/Expression Language 2.2 (JSR 245)  Standard Tag Library for JavaServer Pages (JSTL) 1.2 (JSR 52)  Debugging Support for Other Languages 1.0 (JSR 45)  模块化 (JSR 294)  Swing应用框架 (JSR 296)  JavaBeans Activation Framework (JAF) 1.1 (JSR 925)  Streaming API for XML (StAX) 1.0 (JSR 173) 管理与安全技术  Java Authentication Service Provider Interface for Containers (JSR 196)  Java Authorization Contract for Containers 1.3 (JSR 115)  Java EE Application Deployment 1.2 (JSR 88)  J2EE Management 1.1 (JSR 77)  Java SE中与Java EE有关的规范  JCache API (JSR 107)  Java Memory Model (JSR 133)  Concurrency Utilitie (JSR 166)  Java API for XML Processing (JAXP) 1.3 (JSR 206)  Java Database Connectivity 4.0 (JSR 221)  Java Management Extensions (JMX) 2.0 (JSR 255)  Java Portlet API (JSR 286) Web Service技术  Java Date与Time API (JSR 310)  Java API for RESTful Web Services (JAX-RS) 1.1 (JSR 311)  Implementing Enterprise Web Services 1.3 (JSR 109)  Java API for XML-Based Web Services (JAX-WS) 2.2 (JSR 224)  Java Architecture for XML Binding (JAXB) 2.2 (JSR 222)  Web Services Metadata for the Java Platform (JSR 181)  Java API for XML-Based RPC (JAX-RPC) 1.1 (JSR 101)  Java APIs for XML Messaging 1.3 (JSR 67)  Java API for XML Registries (JAXR) 1.0 (JSR 93) JCP（Java Community Process）：Java社区 Hibernate框架中包含一套独立的校验框架hibernate-validator 导入坐标 org.hibernate hibernate-validator 6.1.0.Final 注意： tomcat7 ：搭配hibernate-validator版本5...Final tomcat8.5↑ ：搭配hibernate-validator版本6...Final 1.2. 1.2 快速使用 1. 开启校验  名称：@Valid 、 @Validated  类型：形参注解  位置：处理器类中的实体类类型的方法形参前方  作用：设定对当前实体类类型参数进行校验  范例： @RequestMapping(value = \"/addemployee\") public String addEmployee(@Valid Employee employee) { System.out.println(employee); } 2.设置校验规则  名称：@NotNull  类型：属性注解 等  位置：实体类属性上方  作用：设定当前属性校验规则  范例： 每个校验规则所携带的参数不同，根据校验规则进行相应的调整 具体的校验规则查看对应的校验框架进行获取 public class Employee{ @NotNull(message = \"姓名不能为空\") private String name;//员工姓名 } 3.获取错误信息 @RequestMapping(value = \"/addemployee\") public String addEmployee(@Valid Employee employee, Errors errors, Model model){ System.out.println(employee); if(errors.hasErrors()){ for(FieldError error : errors.getFieldErrors()){ model.addAttribute(error.getField(),error.getDefaultMessage()); } return \"addemployee.jsp\"; } return \"success.jsp\"; } 通过形参Errors获取校验结果数据，通过Model接口将数据封装后传递到页面显示 员工姓名：${name} 员工年龄：${age} 通过形参Errors获取校验结果数据，通过Model接口将数据封装后传递到页面显示 页面获取后台封装的校验结果信息 1.3. 1.3 多规则校验 同一个属性可以添加多个校验器 @NotNull(message = \"请输入您的年龄\") @Max(value = 60,message = \"年龄最大值不允许超过60岁\") @Min(value = 18,message = \"年龄最小值不允许低于18岁\") private Integer age;//员工年龄 3种判定空校验器的区别 1.4. 1.4 嵌套校验  名称：@Valid  类型：属性注解  位置：实体类中的引用类型属性上方  作用：设定当前应用类型属性中的属性开启校验  范例： public class Employee { //实体类中的引用类型通过标注@Valid注解，设定开启当前引用类型字段中的属性参与校验 @Valid private Address address; }  注意：开启嵌套校验后，被校验对象内部需要添加对应的校验规则 1.5. 1.5 分组校验 同一个模块，根据执行的业务不同，需要校验的属性会有不同 新增用户 修改用户 对不同种类的属性进行分组，在校验时可以指定参与校验的字段所属的组类别 定义组（通用） 为属性设置所属组，可以设置多个 开启组校验 public interface GroupOne { } public String addEmployee(@Validated({GroupOne.class}) Employee employee){ } @NotEmpty(message = \"姓名不能为空\",groups = {GroupOne.class}) private String name;//员工姓名 2. 2 ssm整合 2.1. 2.1 整合流程简介 整合步骤分析 SSM（Spring+SpringMVC+MyBatis） Spring 框架基础 MyBatis mysql+druid+pagehelper Spring整合MyBatis junit测试业务层接口 SpringMVC rest风格（postman测试请求结果） 数据封装json（jackson） Spring整合SpringMVC Controller调用Service 其他 表现层数据封装 自定义异常 表结构 ​ 最重要的5个步骤 Spring MyBatis Spring整合MyBatis SpringMVC Spring整合SpringMVC 2.2. 2.2 项目结构搭建 Part0： 项目基础结构搭建 创建项目，组织项目结构，创建包 创建表与实体类 创建三层架构对应的模块、接口与实体类，建立关联关系 数据层接口（代理自动创建实现类） 业务层接口+业务层实现类 表现层类 public interface UserDao { public boolean save(User user); public boolean update(User user); public boolean delete(Integer uuid); public User get(Integer uuid); public List getAll(int page,int size); public interface UserService { public boolean save(User user); public boolean update(User user); public boolean delete(Integer uuid); public User get(Integer uuid); public List getAll(int page, int size); /** 用户登录 @param userName 用户名 @param password 密码信息 @return */ public User login(String userName,String password); } 2.3. 2.3 Spring整合Mybatis（复习） Part1 : Spring环境配置 Part1 : Mybatis配置事务 MyBatis映射 insert into user(userName,password,realName,gender,birthday)values(#{userName},#{password},#{realName},#{gender},#{birthday}) delete from user where uuid = #{uuid} update user set userName=#{userName},password=#{password},realName=#{realName},gender=#{gender},birthday=#{birthday} where uuid=#{uuid} select * from user where uuid = #{uuid} select * from user select * from user where userName=#{userName} and password=#{password} Mybatis核心配置 mysql true 2.4. 2.4 整合junit Part2：单元测试整合junit @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(locations = \"classpath:applicationContext.xml\") public class UserServiceTest { @Autowired private UserService userService; @Test public void testDelete(){ User user = new User(); userService.delete(3); } } 2.5. 2.5 Spring整合SpringMVC Part3：SpringMVC web.xml配置 DispatcherServlet org.springframework.web.servlet.DispatcherServlet contextConfigLocation classpath*:spring-mvc.xml DispatcherServlet / spring-mvc.xml controller层 @RestController @RequestMapping(\"/user\") public class UserController { @PostMapping public boolean save(User user) { System.out.println(\"save ...\" + user); return true; } @PostMapping(\"/login\") public User login(String userName,String password){ System.out.println(\"login ...\" + userName + \" ,\" +password); return null; } } Part4：Spring整合SpringMVC web.xml加载Spring环境 contextConfigLocation classpath*:applicationContext.xml org.springframework.web.context.ContextLoaderListener Controller调用Service ```java @RestController @RequestMapping(\"/user\") public class UserController { @Autowired private UserService userService; @PostMapping public boolean save(User user){ return userService.save(user); } } ## 2.6 表现层数据封装 **Part5-1：**表现层数据封装 * 前端接收表现层返回的数据种类 | u操作是否成功 | true/false | 格式A | | ------------- | ---------- | ----- | | u单个数据 | 1,100,true | 格式B | | u对象数据 | json对象 | 格式C | | u集合数据 | json数组 | 格式D | ![image-20200506103851845](day03.assets/image-20200506103851845.png) * 返回数据格式设计 ![image-20200506104339019](day03.assets/image-20200506104339019.png) * 代码 ```java public class Result { // 操作结果编码 private Integer code; // 操作数据结果 private Object data; // 消息 private String message; public Result(Integer code) { this.code = code; } public Result(Integer code, Object data) { this.code = code; this.data = data; } } 状态码常量可以根据自己的业务需求设定 public class Code { public static final Integer SAVE_OK = 20011; public static final Integer SAVE_ERROR = 20010; //其他编码 } controller 调用 @RestController public class UserController { @Autowired private UserService userService; @PostMapping public Result save(User user){ boolean flag = userService.save(user); return new Result(flag ? Code.SAVE_OK:Code.SAVE_ERROR); } @GetMapping(\"/{uuid}\") public Result get(@PathVariable Integer uuid){ User user = userService.get(uuid); return new Result(null != user ?Code.GET_OK: Code.GET_ERROR,user); } } 2.6. 2.7 自定义异常 Part5-2：自定义异常 设定自定义异常，封装程序执行过程中出现的问题，便于表现层进行统一的异常拦截并进行处理 BusinessException SystemException 自定义异常消息返回时需要与业务正常执行的消息按照统一的格式进行处理 定义BusinessException public class BusinessException extends RuntimeException { //自定义异常中封装对应的错误编码，用于异常处理时获取对应的操作编码 private Integer code; public Integer getCode() { return code; } public void setCode(Integer code) { this.code = code; } public BusinessException(Integer code) { this.code = code; } public BusinessException(String message, Integer code) { super(message); this.code = code; } public BusinessException(String message, Throwable cause,Integer code) { super(message, cause); this.code = code; } public BusinessException(Throwable cause,Integer code) { super(cause); this.code = code; } public BusinessException(String message, Throwable cause, boolean enableSuppression, boolean writableStackTrace,Integer code) { super(message, cause, enableSuppression, writableStackTrace); this.code = code; } } @GetMapping(\"/{uuid}\") public Result get(@PathVariable Integer uuid){ User user = userService.get(uuid); //模拟出现异常，使用条件控制，便于测试结果 if (uuid == 10 ) throw new BusinessException(\"查询出错啦，请重试！\",Code.GET_ERROR); return new Result(null != user ?Code.GET_OK: Code.GET_ERROR,user); } 2.7. 2.8 返回消息兼容异常信息 @Component @ControllerAdvice public class ProjectExceptionAdivce { @ExceptionHandler(BusinessException.class) @ResponseBody //对出现异常的情况进行拦截，并将其处理成统一的页面数据结果格式 public Result doBusinessException(BusinessException e){ return new Result(e.getCode(),e.getMessage()); } } 3. 3 纯注解开发SSM 3.1. 3.1 用注解替代applicationContext.xml 同前期设置，添加事务注解驱动 @Configuration //扫描组件，排除SpringMVC对应的bean，等同于 @ComponentScan(value = \"com.itheima\",excludeFilters = { @ComponentScan.Filter(type= FilterType.ANNOTATION,classes = {Controller.class})}) @PropertySource(\"classpath:jdbc.properties\") @Import({JdbcConfig.class,MyBatisConfig.class}) //等同于，导入的默认名称为transactionManager @EnableTransactionManagement public class SpringConfig { //等同于 @Bean(\"transactionManager\") public DataSourceTransactionManager getDataSourceTxManager(@Autowired DataSource dataSource){ DataSourceTransactionManager dtm = new DataSourceTransactionManager(); //等同于 dtm.setDataSource(dataSource); return dtm; } } 3.2. 3.2 用注解替代spring-mvc.xml 同前期设置，添加@EnableWebMvc注解 @Configuration @ComponentScan(\"com.itheima.controller\") @EnableWebMvc public class SpringMvcConfig implements WebMvcConfigurer { } EnableWebMvc 支持ConversionService的配置，可以方便配置自定义类型转换器 支持@NumberFormat注解格式化数字类型 支持@DateTimeFormat注解格式化日期数据，日期包括Date,Calendar,JodaTime（JodaTime要导包） 支持@Valid的参数校验(需要导入JSR-303规范) 配合第三方jar包和SpringMVC提供的注解读写XML和JSON格式数据 Copyright © MISIN 2022 | 豫ICP备2021006345号-1 all right reserved，powered by Gitbook该文件修订时间： 2020-05-06 16:28:22 "},"3.主流框架/3.Maven高级/Maven高级.html":{"url":"3.主流框架/3.Maven高级/Maven高级.html","title":"Maven高级","keywords":"","body":"1. Maven高级1.1. 1)分模块开发与设计1.1.1. 1.1)工程模块与模块划分1.1.2. 1.2)ssm_pojo拆分1.1.3. 1.3)ssm_dao拆分1.1.4. 1.4)ssm_service拆分1.1.5. 1.5)ssm_control拆分1.2. 2)聚合1.2.1. 2.1)多模块构建维护1.2.2. 2.2)聚合1.3. 3)继承1.3.1. 3.1)模块依赖关系维护1.3.2. 3.2)继承1.3.3. 3.3)继承依赖定义1.3.4. 3.4)继承依赖使用1.3.5. 3.5)继承的资源1.3.6. 3.6)继承与聚合1.4. 4)属性1.4.1. 4.1)版本统一的重要性1.4.2. 4.2)属性类别1.4.3. 4.3)属性类别：自定义属性1.4.4. 4.4)属性类别：内置属性1.4.5. 4.5)属性类别：Setting属性1.4.6. 4.6)属性类别：Java系统属性1.4.7. 4.7)属性类别：环境变量属性1.5. 5)版本管理1.5.1. 5.1)工程版本区分1.5.2. 5.2)工程版本1.5.3. 5.3)工程版本号约定1.6. 6)资源配置1.6.1. 6.1)资源配置多文件维护1.6.2. 6.2)配置文件引用pom属性1.7. 7)多环境开发配置1.7.1. 7.1)多环境兼容1.7.2. 7.2)多环境配置1.7.3. 7.3)加载指定环境1.8. 8)跳过测试1.8.1. 8.1)跳过测试环节的应用场景1.8.2. 8.2)使用命令跳过测试1.8.3. 8.3)使用界面操作跳过测试1.8.4. 8.4)使用配置跳过测试1.9. 9)私服1.9.1. 9.1)分模块合作开发1.9.2. 9.2)Nexus1.9.3. 9.3)Nexus*安装、启动与配置1.9.4. 9.4)私服资源获取1.9.5. 9.5)仓库分类1.9.6. 9.6)资源上传1.9.7. 9.7)idea环境中资源上传与下载1.9.8. 9.8)访问私服配置（本地仓库访问私服）1.9.9. 9.9)访问私服配置（ 项目工程访问私服）1. Maven高级 1.1. 1)分模块开发与设计 1.1.1. 1.1)工程模块与模块划分 1.1.2. 1.2)ssm_pojo拆分 新建模块 拷贝原始项目中对应的相关内容到ssm_pojo模块中 ​ 实体类（User） ​ 配置文件（无） 1.1.3. 1.3)ssm_dao拆分 新建模块 拷贝原始项目中对应的相关内容到ssm_dao模块中 数据层接口（UserDao） 配置文件：保留与数据层相关配置文件(3个） 注意：分页插件在配置中与SqlSessionFactoryBean绑定，需要保留 pom.xml：引入数据层相关坐标即可，删除springmvc相关坐标 spring mybatis spring 整合mybatis mysql druid pagehelper 直接依赖ssm_pojo（对ssm_pojo模块执行install指令，将其安装到本地仓库） 1.1.4. 1.4)ssm_service拆分 新建模块 拷贝原始项目中对应的相关内容到ssm_service模块中 业务层接口与实现类（UserService、UserServiceImpl） 配置文件：保留与数据层相关配置文件(1个） pom.xml：引入数据层相关坐标即可，删除springmvc相关坐标 spring junit spring 整合junit 直接依赖ssm_dao（对ssm_dao模块执行install指令，将其安装到本地仓库） 间接依赖ssm_pojo（由ssm_dao模块负责依赖关系的建立） 修改service模块spring核心配置文件名，添加模块名称，格式：applicationContext-service.xml 修改dao模块spring核心配置文件名，添加模块名称，格式：applicationContext-dao.xml 修改单元测试引入的配置文件名称，由单个文件修改为多个文件 1.1.5. 1.5)ssm_control拆分 新建模块（使用webapp模板） 拷贝原始项目中对应的相关内容到ssm_controller模块中 现层控制器类与相关设置类（UserController、异常相关……） 配置文件：保留与表现层相关配置文件(1个）、服务器相关配置文件（1个） pom.xml：引入数据层相关坐标即可，删除springmvc相关坐标 spring springmvc jackson servlet tomcat服务器插件 直接依赖ssm_service（对ssm_service模块执行install指令，将其安装到本地仓库） 间接依赖ssm_dao、ssm_pojo 修改web.xml配置文件中加载spring环境的配置文件名称，使用*通配，加载所有applicationContext-开始的配置文件 小节 分模块开发 模块中仅包含当前模块对应的功能类与配置文件 spring核心配置根据模块功能不同进行独立制作 当前模块所依赖的模块通过导入坐标的形式加入当前模块后才可以使用 web.xml需要加载所有的spring核心配置文件 1.2. 2)聚合 1.2.1. 2.1)多模块构建维护 1.2.2. 2.2)聚合 作用：聚合用于快速构建maven工程，一次性构建多个项目/模块。 制作方式： 创建一个空模块，打包类型定义为pom pom 定义当前模块进行构建操作时关联的其他模块名称 ../ssm_controller ../ssm_service ../ssm_dao ../ssm_pojo 注意事项：参与聚合操作的模块最终执行顺序与模块间的依赖关系有关，与配置顺序无关 1.3. 3)继承 1.3.1. 3.1)模块依赖关系维护 1.3.2. 3.2)继承 作用：通过继承可以实现在子工程中沿用父工程中的配置 maven中的继承与java中的继承相似，在子工程中配置继承关系 制作方式： 在子工程中声明其父工程坐标与对应的位置 com.itheima ssm 1.0-SNAPSHOT ../ssm/pom.xml 1.3.3. 3.3)继承依赖定义 在父工程中定义依赖管理 org.springframework spring-context 5.1.9.RELEASE 1.3.4. 3.4)继承依赖使用 在子工程中定义依赖关系，无需声明依赖版本，版本参照父工程中依赖的版本 org.springframework spring-context 1.3.5. 3.5)继承的资源 groupId：项目组ID，项目坐标的核心元素 version：项目版本，项目坐标的核心因素 description：项目的描述信息 organization：项目的组织信息 inceptionYear：项目的创始年份 url：项目的URL地址 developers：项目的开发者信息 contributors：项目的贡献者信息 distributionManagement：项目的部署配置 issueManagement：项目的缺陷跟踪系统信息 ciManagement：项目的持续集成系统信息 scm：项目的版本控制系统西溪 malilingLists：项目的邮件列表信息 properties：自定义的Maven属性 dependencies：项目的依赖配置 dependencyManagement：项目的依赖管理配置 repositories：项目的仓库配置 build：包括项目的源码目录配置、输出目录配置、插件配置、插件管理配置等 reporting：包括项目的报告输出目录配置、报告插件配置等 1.3.6. 3.6)继承与聚合 作用 聚合用于快速构建项目 继承用于快速配置 相同点： 聚合与继承的pom.xml文件打包方式均为pom，可以将两种关系制作到同一个pom文件中 聚合与继承均属于设计型模块，并无实际的模块内容 不同点： 聚合是在当前模块中配置关系，聚合可以感知到参与聚合的模块有哪些 继承是在子模块中配置关系，父模块无法感知哪些子模块继承了自己 1.4. 4)属性 1.4.1. 4.1)版本统一的重要性 1.4.2. 4.2)属性类别 1.自定义属性 2.内置属性 3.Setting属性 4.Java系统属性 5.环境变量属性 1.4.3. 4.3)属性类别：自定义属性 作用 等同于定义变量，方便统一维护 定义格式： 5.1.9.RELEASE 4.12 聚合与继承的pom.xml文件打包方式均为pom，可以将两种关系制作到同一个pom文件中 聚合与继承均属于设计型模块，并无实际的模块内容 调用格式： org.springframework spring-context ${spring.version} 1.4.4. 4.4)属性类别：内置属性 作用 使用maven内置属性，快速配置 调用格式： ${basedir} ${version} 1.4.5. 4.5)属性类别：Setting属性 作用 使用Maven配置文件setting.xml中的标签属性，用于动态配置 调用格式： ${settings.localRepository} 1.4.6. 4.6)属性类别：Java系统属性 作用 读取Java系统属性 调用格式 ${user.home} 系统属性查询方式 mvn help:system 1.4.7. 4.7)属性类别：环境变量属性 作用 使用Maven配置文件setting.xml中的标签属性，用于动态配置 调用格式 ${env.JAVA_HOME} 环境变量属性查询方式 mvn help:system 1.5. 5)版本管理 1.5.1. 5.1)工程版本区分 1.5.2. 5.2)工程版本 SNAPSHOT（快照版本） 项目开发过程中，为方便团队成员合作，解决模块间相互依赖和时时更新的问题，开发者对每个模块进行构建的时候，输出的临时性版本叫快照版本（测试阶段版本） u快照版本会随着开发的进展不断更新 RELEASE（发布版本） u项目开发到进入阶段里程碑后，向团队外部发布较为稳定的版本，这种版本所对应的构件文件是稳定的，即便进行功能的后续开发，也不会改变当前发布版本内容，这种版本称为发布版本 1.5.3. 5.3)工程版本号约定 约定规范： ... 主版本：表示项目重大架构的变更，如：spring5相较于spring4的迭代 次版本：表示有较大的功能增加和变化，或者全面系统地修复漏洞 增量版本：表示有重大漏洞的修复 里程碑版本：表明一个版本的里程碑（版本内部）。这样的版本同下一个正式版本相比，相对来说不是很稳定，有待更多的测试 范例： 5.1.9.RELEASE 1.6. 6)资源配置 1.6.1. 6.1)资源配置多文件维护 1.6.2. 6.2)配置文件引用pom属性 作用 在任意配置文件中加载pom文件中定义的属性 调用格式 ${jdbc.url} 开启配置文件加载pom属性 ${project.basedir}/src/main/resources true 1.7. 7)多环境开发配置 1.7.1. 7.1)多环境兼容 1.7.2. 7.2)多环境配置 pro_env jdbc:mysql://127.1.1.1:3306/ssm_db true dev_env …… 1.7.3. 7.3)加载指定环境 作用 加载指定环境配置 调用格式 mvn 指令 –P 环境定义id 范例 mvn install –P pro_env 1.8. 8)跳过测试 1.8.1. 8.1)跳过测试环节的应用场景 整体模块功能未开发 模块中某个功能未开发完毕 单个功能更新调试导致其他功能失败 快速打包 …… 1.8.2. 8.2)使用命令跳过测试 命令 mvn 指令 –D skipTests 注意事项 执行的指令生命周期必须包含测试环节 1.8.3. 8.3)使用界面操作跳过测试 1.8.4. 8.4)使用配置跳过测试 maven-surefire-plugin 2.22.1 true **/User*Test.java **/User*TestCase.java 1.9. 9)私服 1.9.1. 9.1)分模块合作开发 1.9.2. 9.2)Nexus Nexus是Sonatype公司的一款maven私服产品 下载地址：https://help.sonatype.com/repomanager3/download 1.9.3. 9.3)Nexus*安装、启动与配置 启动服务器（命令行启动） nexus.exe /run nexus 访问服务器（默认端口：8081） http://localhost:8081 修改基础配置信息 安装路径下etc目录中nexus-default.properties文件保存有nexus基础配置信息，例如默认访问端口 修改服务器运行配置信息 安装路径下bin目录中nexus.vmoptions文件保存有nexus服务器启动对应的配置信息，例如默认占用内存空间 1.9.4. 9.4)私服资源获取 1.9.5. 9.5)仓库分类 宿主仓库hosted 保存无法从中央仓库获取的资源 自主研发 第三方非开源项目 代理仓库proxy 代理远程仓库，通过nexus访问其他公共仓库，例如中央仓库 仓库组group 将若干个仓库组成一个群组，简化配置 仓库组不能保存资源，属于设计型仓库 1.9.6. 9.6)资源上传 上传资源时提供对应的信息 保存的位置（宿主仓库） 资源文件 对应坐标 1.9.7. 9.7)idea环境中资源上传与下载 1.9.8. 9.8)访问私服配置（本地仓库访问私服） 配置本地仓库访问私服的权限（setting.xml） heima-release admin admin heima-snapshots admin admin 配置本地仓库资源来源（setting.xml） nexus-heima * http://localhost:8081/repository/maven-public/ 1.9.9. 9.9)访问私服配置（ 项目工程访问私服） 配置当前项目访问私服上传资源的保存位置（pom.xml） heima-release http://localhost:8081/repository/heima-release/ heima-snapshots http://localhost:8081/repository/heima-snapshots/ 发布资源到私服命令 mvn deploy Copyright © MISIN 2022 | 豫ICP备2021006345号-1 all right reserved，powered by Gitbook该文件修订时间： 2022-11-10 13:58:53 "},"3.主流框架/4.Dubbo/Dubbo.html":{"url":"3.主流框架/4.Dubbo/Dubbo.html","title":"Dubbo","keywords":"","body":"1.1. 1-今日内容1.2. 2-相关概念1.2.1. 2.1-互联网项目架构-特点1.2.2. 2.2-互联网项目架构-目标1.2.3. 2.3-集群和分布式1.2.4. 2.4-架构演进1.3. 3-dubbo 概述1.4. 4-dubbo快速入门1.4.1. 4.1zookeeper安装1.4.2. 4.2spring和springmvc整合1.4.3. 4.3服务提供者1.4.4. 4.4服务消费者1.5. 5-dubbo高级特性1.5.1. 5.1dubbo-admin安装1.5.2. 5.2-dubbo-admin使用1.5.3. 5.3序列化1.5.4. 5.4地址缓存1.5.5. 5.5 超时1.5.6. 5.6重试1.5.7. 5.7多版本1.5.8. 5.8负载均衡1.5.9. 5.9集群容错1.5.10. 5.10服务降级1.1. 1-今日内容 分布式系统中的相关概念 dubbo 概述 dubbo快速入门 dubbo的高级特性 1.2. 2-相关概念 1.2.1. 2.1-互联网项目架构-特点 互联网项目架构-特点 用户多 流量大，并发高 海量数据 易受攻击 功能繁琐 变更快 传统项目和互联网项目的不同 用户体验： 美观、功能、速度、稳定性 衡量一个网站速度是否快: 打开一个新页面一瞬间完成;页面内跳转，-刹那间完成。 根据佛经《僧衹律》记载:一 刹那者为-念,二十念为-瞬,二十瞬为-弹 指，二十弹指为-罗预， 二十罗预为-须臾，一日一夜有三十须臾。 1.2.2. 2.2-互联网项目架构-目标 衡量网站的性能指标: 响应时间:指执行一个请求从开始到最后收到响应数据所花费的总体时间。 并发数:指系统同时能处理的请求数量。 并发连接数: 指的是客户端向服务器发起请求，并建立了TCP连接。每秒钟服务器连接的总TCP数量 请求数:也称为QPS(Query Per Second)指每秒多少请求. 并发用户数:单位时间内有多少用户 吞吐量:指单位时间内系统能处理的请求数量。 ●QPS: Query Per Second每秒查询数。 ●TPS: Transactions Per Second每秒事务数。 ●一个事务是指一 个客户机向服务器发送请求然后服务器做出反应的过程。客户机在发送请求时开始计时，收到服务器响应后结束 计时，以此来计算使用的时间和完成的事务个数。 ●一个页面的一次访问，只会形成一 个TPS; 但-次页面请求，可能产生多次对服务器的请求，就会有多个QPS QPS>=并发连接数>= TPS 大型互联网项目架构目标: ​ ●高性能:提供快速的访问体验。 ​ ●高可用:网站服务- 可以正常访问 1.2.3. 2.3-集群和分布式 集群和分布式， ●集群:很多“人”一起，干一样的事。 ●一个业务模块，部署在多台服务器上。 ●分布式:很多\"人”一起，干不样的事。这些不一样的事， 合起来是一件大事。 1.2.4. 2.4-架构演进 单体架构： 优点: 简单:开发部署都很方便，小型项目首选 缺点: ●项目启动慢 ●可靠性差 垂直架构：垂直架构是指将单体架构中的多个模块拆分为多个独立的项目。形成多个独立的单体架构。 单体架构存在的问题: 项目启动慢 可靠性差 可伸缩性差 扩展性和可维护性差 性能低 垂直架构存在的问题: 重复功能太多 分布式架构：是指在垂直架构的基础上,将公共业务模块抽取出来,作为独立的服务供其他调用者消费，以实现服务的共享和重用。底层通过RPC（远程过程调用实现） RPC: Remote Procedure Call远程过程调用。有非常多的协议和技术来都实现了RPC的过程。比如: HTTP REST风格，Java RMI规范、WebService SOAP协议Hession等等。 垂直架构存在的问题: ●重复功能太多 分布式架构存在的问题: ​ ●服务提供方- -旦产生变更,所有消费方都需要变更。 SOA: (Service- Oriented Architecture,面向服务的架构)：是一个组件模型,它将应用程序的不同功能单元(称为服务)进行拆分，并通过这些服务之间定义良好的接口和契约联系起来。 ESB: (Enterparise Servce Bus)：企业服务总线,服务中介。主要是提供了一一个服 务于服务之间的交互。ESB包含的功能如:负载均衡，流量控制，加密处理，服务 的监控，异常处理，监控告急等等。 微服务架构： ●微服务架构是在SOA上做的升华,微服务架构强调的一个重点是“业务需要彻底的组件化和服务化”，原有的单个 业务系统会拆分为多个可以独立开发、设计、运行的小应用。这些小应用之间通过服务完成交互和集成。 ●微服务架构= 80%的SOA服务架构思想+ 100%的组件化架构思想+ 80%的领域建模思想 特点: ●服务实现组件化:开发者可以自由选择开发技术。也不需要协调其他团队 ●服务之间交互一 般使用REST API ●去中心化:每个微服务有自己私有的数据库持久化业务数据 ●自动化部署:把应用拆分成为一 个-个独立的单个服务,方便自动化部署、测试、运维 1.3. 3-dubbo 概述 Dubbo概念 ●Dubbo是阿里巴巴公司开源的一个高性能、轻量级的Java RPC框架。 ●致力于提供高性能和透明化的RPC远程服务调用方案,以及SOA服务治理方案。 ●官网: htp://ubbo.apache.orgo 节点角色说明: . ●Provider: 暴露服务的服务提供方 ●Contahier: 服务运行容器 ●Consumer: 调用远程服务的服务消费方 ●Registry: 服务注册与发现的注册中心 ●Monitor:统计服务的调用次数和调用时间的监控中心 1.4. 4-dubbo快速入门 1.4.1. 4.1zookeeper安装 安装步骤： 第一步：安装 jdk（略） 第二步：把 zookeeper 的压缩包（zookeeper-3.4.6.tar.gz）上传到 linux 系统 第三步：解压缩压缩包 tar -zxvf zookeeper-3.4.6.tar.gz 第四步：进入zookeeper-3.4.6目录，创建data目录 mkdir data 第五步：进入conf目录 ，把zoo_sample.cfg 改名为zoo.cfg cd conf mv zoo_sample.cfg zoo.cfg 第六步：打开zoo.cfg文件, 修改data属性： dataDir=/root/zookeeper-3.4.6/data 进入Zookeeper的bin目录，启动服务命令 ./zkServer.sh start 停止服务命令 ./zkServer.sh stop 查看服务状态：standalone 单节点 ./zkServer.sh status 1.4.2. 4.2spring和springmvc整合 实施步骤： 1.创建服务提供者Provider模块 2.创建服务消费者Consumer模块 3.在服务提供者模块编写UserServicelmpl提供服务 4.在服务消费者中的UserC ontroller远程调用 5.UserServicelmpl提供的服务 6.分别启动两个服务，测试 Dubbo作为一个RPC框架，其最核心的功能就是要实现跨网络的远程调用。本小节就是要创建两个应用，一个作为服务的提供方，一个作为服务的消费方。通过Dubbo来实现服务消费方远程调用服务提供方的方法。 1 服务提供方开发 开发步骤： （1）创建maven工程（打包方式为war）dubbodemo_provider，在pom.xml文件中导入如下坐标 UTF-8 1.8 1.8 5.0.5.RELEASE org.springframework spring-context ${spring.version} org.springframework spring-beans ${spring.version} org.springframework spring-webmvc ${spring.version} org.springframework spring-jdbc ${spring.version} org.springframework spring-aspects ${spring.version} org.springframework spring-jms ${spring.version} org.springframework spring-context-support ${spring.version} com.alibaba dubbo 2.6.0 org.apache.zookeeper zookeeper 3.4.6 com.github.sgroschupf zkclient 0.1 javassist javassist 3.12.1.GA com.alibaba fastjson 1.2.47 org.apache.maven.plugins maven-compiler-plugin 2.3.2 1.8 1.8 org.apache.tomcat.maven tomcat7-maven-plugin 8081 / （2）配置web.xml文件 Archetype Created Web Application contextConfigLocation classpath:applicationContext*.xml org.springframework.web.context.ContextLoaderListener （3）创建服务接口 package com.itheima.service; public interface HelloService { public String sayHello(String name); } （4）创建服务实现类 注意：服务实现类上使用的Service注解是Dubbo提供的，用于对外发布服务 package com.itheima.service.impl; import com.alibaba.dubbo.config.annotation.Service; import com.itheima.service.HelloService; @Service public class HelloServiceImpl implements HelloService { public String sayHello(String name) { return \"hello \" + name; } } tomcat7:run 2 服务消费方开发 开发步骤： （1）创建maven工程（打包方式为war）dubbodemo_consumer，pom.xml配置和上面服务提供者相同，只需要将Tomcat插件的端口号改为8082即可 （2）配置web.xml文件 Archetype Created Web Application springmvc org.springframework.web.servlet.DispatcherServlet contextConfigLocation classpath:applicationContext-web.xml 1 springmvc *.do （3）将服务提供者工程中的HelloService接口复制到当前工程 （4）编写Controller package com.itheima.controller; import com.alibaba.dubbo.config.annotation.Reference; import com.itheima.service.HelloService; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.ResponseBody; @Controller @RequestMapping(\"/demo\") public class HelloController { @Reference private HelloService helloService; @RequestMapping(\"/hello\") @ResponseBody public String getName(String name){ //远程调用 String result = helloService.sayHello(name); System.out.println(result); return result; } } 注意：Controller中注入HelloService使用的是Dubbo提供的@Reference注解 1.4.3. 4.3服务提供者 在dubbodemo_provider工程中src/main/resources下创建applicationContext-service.xml 1.4.4. 4.4服务消费者 在dubbodemo_consumer工程中src/main/resources下创建applicationContext-web.xml 运行测试 tomcat7:run启动 在浏览器输入http://localhost:8082/demo/hello.do?name=Jack，查看浏览器输出结果 1.5. 5-dubbo高级特性 1.5.1. 5.1dubbo-admin安装 dubbo- admin ●dubbo-admin管理平台，是图形化的服务管理页面 ●从注册中心中获取到所有的提供者 /消费者进行配置管理 ●路由规则、动态配置、服务降级、访问控制、权重调整、负载均衡等管理功能 ●dubbo- admin是一个前后端分离的项目。前端使用vue，后端使用springboot ●安装dubbo-admin其实就是部署该项目 具体安装参见：dubbo-admin.md 1.5.2. 5.2-dubbo-admin使用 具体安装参见：dubbo-admin.md 1.5.3. 5.3序列化 dubbo 内部已经将序列化和反序列化的过程内部封装了 我们只需要在定义pojo类时实现seriali zable接口即可 一般会定义一 个公共的pojo模块,让生产者和消费者都依赖该模块。 User对象未实现seriali zable接口 错误信息： 解决办法： User implements Serializable 1.5.4. 5.4地址缓存 注册中心挂了，服务是否可以正常访问？ 可以，因为dubbo服务消费者在第一-次调用时，会将服务提供方地址缓存到本地，以后在调用则不会访问注册中心。 当服务提供者地址发生变化时，注册中心会通知服务消费者。 1.5.5. 5.5 超时 服务消费者在调用服务提供者的时候发生了阻塞、等待的情形,这个时候,服务消费者会直等待下去。 在某个峰值时刻，大量的请求都在同时请求服务消费者,会造成线程的大量堆积，势必会造成雪崩。 dubbo利用超时机制来解决这个问题，设置-个超时时间, 在这个时间段内，无法完成服务访问,则自动断开连接。 使用timeout属性配置超时时间，默认值1000，单位毫秒 //timeout 超时时间 单位毫秒 retries 重试次数 @Service(timeout = 3000,retries=0) 1.5.6. 5.6重试 设置了超时时间，在这个时间段内，无法完成服务访问,则自动断开连接。 如果出现网络抖动,则这一-次请求就会失败。 Dubbo提供重试机制来避免类似问题的发生。 通过retries属性来设置重试次数。默认为2次 //timeout 超时时间 单位毫秒 retries 重试次数 @Service(timeout = 3000,retries=0) 1.5.7. 5.7多版本 灰度发布:当出现新功能时,会让一部分用户先使用新功能，用户反馈没问题时，再将所有用户迁移到新功能。 dubbo中使用version属性来设置和调用同一个接口的不同版本 生产者配置 @Service(version=\"v2.0\") public class UserServiceImp12 implements UserService {...} 消费者配置 @Reference(version = \"v2.0\")//远程注入 private UserService userService; 1.5.8. 5.8负载均衡 负载均衡策略(4种) : Random:按权重随机，默认值。按权重设置随机概率。 RoundRobin: 按权重轮询。 LeastActive: 最少活跃调用数,相同活跃数的随机。 ConsistentHash:一 致性Hash,相同参数的请求总是发到同一提供者。 服务提供者配置 @Service(weight = 100) public class UserServiceImp12 implements UserService {...} application.xml 配置parameter key 消费者配置 //@Reference(loadbalance = \"roundrobin\") //@Reference(loadbalance = \"leastactive\") //@Reference(loadbalance = \"consistenthash\") @Reference(loadbalance = \"random\")//默认 按权重随机 private UserService userService; 1.5.9. 5.9集群容错 集群容错模式: Failover Cluster:失败重试。默认值。当出现失败，重试其它服务器，默认重试2次，使用retries配置。一般用于读操作 Failfast Cluster :快速失败,发起-次调用，失败立即报错。通常用于写操作。 Failsafe Cluster:失败安全，出现异常时，直接忽略。返回一个空结果。 Failback Cluster:失败自动恢复,后台记录失败请求,定时重发。 Forking Cluster :并行调用多个服务器，只要一个成功即返回。 Broadcast Cluster: 广播调用所有提供者,逐个调用，任意一台报错则报错。 消费者配置 @Reference(cluster = \"failover\")//远程注入 private UserService userService; 1.5.10. 5.10服务降级 服务降级：当服务器压力剧增的情况下，根据实际业务情况及流量，对一些服务和页面有策略的不处理或换种简单的方式处理，从而释放服务器资源以保证核心交易正常运作或高效运作 服务降级方式: mock= force:return null：表示消费方对该服务的方法调用都直接返回null值,不发起远程调用。用来屏蔽不重要服务不可用时对调用方的影响。 mock=fail:return null：表示消费方对该服务的方法调用在失败后，再返回null值,不抛异常。用来容忍不重要服务不稳定时对调用方的影响 消费方配置 //远程注入 @Reference(mock =“ force :return null\")//不再调用userService的服务 private UserService userService; Copyright © MISIN 2022 | 豫ICP备2021006345号-1 all right reserved，powered by Gitbook该文件修订时间： 2020-02-11 11:20:22 "},"3.主流框架/5.Zookeeper/zookeeper讲义md.html":{"url":"3.主流框架/5.Zookeeper/zookeeper讲义md.html","title":"zookeeper讲义md","keywords":"","body":"1. Zookeeper1.1. 1)初识 Zookeeper1.1.1. 1.1)Zookeeper概念1.2. 2)ZooKeeper 安装与配置1.2.1. 2.1) 下载安装1.2.2. 2.2) 配置启动1.3. 3)ZooKeeper 命令操作1.3.1. 3.1)Zookeeper命令操作数据模型1.3.2. 3.2)Zookeeper命令操作服务端命令1.3.3. 3.3)Zookeeper客户端常用命令1.3.4. 3.4)客户端命令-创建临时有序节点1.4. 4)ZooKeeper JavaAPI 操作1.4.1. 4.1)urator介绍1.4.2. 4.2)JavaAPI操作建立连接1.4.3. 4.3)Zookeeper JavaAPI操作-创建节点1.4.4. 4.4)ZookeeperJavaAPI操作-查询节点1.4.5. 4.5)Zookeeper JavaAPI操作-修改节点1.4.6. 4.6)Zookeeper JavaAPI操作-删除节点1.4.7. 4.7)Zookeeper JavaAPI操作-Watch监听概述1.4.8. 4.8Zookeeper JavaAPI操作-Watch监听-NodeCache1.4.9. 4.9)Zookeeper JavaAPI操作-Watch监听-PathChildrenCache1.4.10. 4.10)Zookeeper JavaAPI操作-Watch监听-TreeCache1.4.11. 4.11)Zookeeper分布式锁-概念1.4.12. 4.12)Zookeeper 分布式锁-zookeeper分布式锁原理1.4.13. 4.13)Zookeeper 分布式锁-模拟12306售票案例1.5. 5)ZooKeeper 集群搭建1.5.1. 5.1)Zookeeper集群介绍1.5.2. 5.2)搭建要求1.5.3. 5.3)准备工作1.5.4. 5.4)配置集群1.5.5. 5.5)启动集群1.5.6. 5.6)模拟集群异常1.6. 6)Zookeeper 核心理论1. Zookeeper 1.1. 1)初识 Zookeeper 1.1.1. 1.1)Zookeeper概念 •Zookeeper 是 Apache Hadoop 项目下的一个子项目，是一个树形目录服务。 •Zookeeper 翻译过来就是 动物园管理员，他是用来管 Hadoop（大象）、Hive(蜜蜂)、Pig(小 猪)的管理员。简称zk •Zookeeper 是一个分布式的、开源的分布式应用程序的协调服务。 •Zookeeper 提供的主要功能包括： •配置管理 •分布式锁 •集群管理 1.2. 2)ZooKeeper 安装与配置 1.2.1. 2.1) 下载安装 2.1.1、环境准备 ZooKeeper服务器是用Java创建的，它运行在JVM之上。需要安装JDK 7或更高版本。 2.1.2、上传 将下载的ZooKeeper放到/opt/ZooKeeper目录下 #上传zookeeper alt+p put f:/setup/apache-zookeeper-3.5.6-bin.tar.gz #打开 opt目录 cd /opt #创建zooKeeper目录 mkdir zooKeeper #将zookeeper安装包移动到 /opt/zooKeeper mv apache-zookeeper-3.5.6-bin.tar.gz /opt/zookeeper/ 2.1.3、解压 将tar包解压到/opt/zookeeper目录下 tar -zxvf apache-ZooKeeper-3.5.6-bin.tar.gz 1.2.2. 2.2) 配置启动 2.2.1、配置zoo.cfg 进入到conf目录拷贝一个zoo_sample.cfg并完成配置 #进入到conf目录 cd /opt/zooKeeper/apache-zooKeeper-3.5.6-bin/conf/ #拷贝 cp zoo_sample.cfg zoo.cfg 修改zoo.cfg #打开目录 cd /opt/zooKeeper/ #创建zooKeeper存储目录 mkdir zkdata #修改zoo.cfg vim /opt/zooKeeper/apache-zooKeeper-3.5.6-bin/conf/zoo.cfg 修改存储目录：dataDir=/opt/zookeeper/zkdata 2.2.2、启动ZooKeeper cd /opt/zooKeeper/apache-zooKeeper-3.5.6-bin/bin/ #启动 ./zkServer.sh start 看到上图表示ZooKeeper成功启动 3、查看ZooKeeper状态 ./zkServer.sh status zookeeper启动成功。standalone代表zk没有搭建集群，现在是单节点 zookeeper没有启动 1.3. 3)ZooKeeper 命令操作 1.3.1. 3.1)Zookeeper命令操作数据模型 •ZooKeeper 是一个树形目录服务,其数据模型和Unix的文件系统目录树很类似，拥有一个层次化结构。 •这里面的每一个节点都被称为： ZNode，每个节点上都会保存自己的数据和节点信息。 • 节点可以拥有子节点，同时也允许少量（1MB）数据存储在该节点之下。 •节点可以分为四大类： •PERSISTENT 持久化节点 •EPHEMERAL 临时节点 ：-e •PERSISTENT_SEQUENTIAL 持久化顺序节点 ：-s •EPHEMERAL_SEQUENTIAL 临时顺序节点 ：-es 1.3.2. 3.2)Zookeeper命令操作服务端命令 •启动 ZooKeeper 服务: ./zkServer.sh start •查看 ZooKeeper 服务状态: ./zkServer.sh status •停止 ZooKeeper 服务: ./zkServer.sh stop •重启 ZooKeeper 服务: ./zkServer.sh restart 1.3.3. 3.3)Zookeeper客户端常用命令 •连接ZooKeeper服务端 ./zkCli.sh –server ip:port •断开连接 quit •查看命令帮助 help •显示指定目录下节点 ls 目录 •创建节点 create /节点path value •获取节点值 get /节点path •设置节点值 set /节点path value •删除单个节点 delete /节点path •删除带有子节点的节点 deleteall /节点path 1.3.4. 3.4)客户端命令-创建临时有序节点 •创建临时节点 create -e /节点path value •创建顺序节点 create -s /节点path value •查询节点详细信息 ls –s /节点path •czxid：节点被创建的事务ID •ctime: 创建时间 •mzxid: 最后一次被更新的事务ID •mtime: 修改时间 •pzxid：子节点列表最后一次被更新的事务ID •cversion：子节点的版本号 •dataversion：数据版本号 •aclversion：权限版本号 •ephemeralOwner：用于临时节点，代表临时节点的事务ID，如果为持久节点则为0 •dataLength：节点存储的数据的长度 •numChildren：当前节点的子节点个数 1.4. 4)ZooKeeper JavaAPI 操作 1.4.1. 4.1)urator介绍 •Curator 是 Apache ZooKeeper 的Java客户端库。 •常见的ZooKeeper Java API ： •原生Java API •ZkClient •Curator •Curator 项目的目标是简化 ZooKeeper 客户端的使用。 •Curator 最初是 Netfix 研发的,后来捐献了 Apache 基金会,目前是 Apache 的顶级项目。 •官网：http://curator.apache.org/ 1.4.2. 4.2)JavaAPI操作建立连接 1，搭建项目 创建项目curator-zk 引入pom和日志文件 资料文件夹下pom.xml和log4j.properties 2、创建测试类，使用curator连接zookeeper @Before public void testConnect() { //重试策略 RetryPolicy retryPolicy = new ExponentialBackoffRetry(3000, 10); //2.第二种方式 //CuratorFrameworkFactory.builder(); client = CuratorFrameworkFactory.builder() .connectString(“192.168.200.130:2181”) .sessionTimeoutMs(60 * 1000) .connectionTimeoutMs(15 * 1000) .retryPolicy(retryPolicy) .namespace(“itheima”) .build(); //开启连接 client.start(); } 1.4.3. 4.3)Zookeeper JavaAPI操作-创建节点 /** * 创建节点：create 持久 临时 顺序 数据 * 1. 基本创建 ：create().forPath(“”) * 2. 创建节点 带有数据:create().forPath(“”,data) * 3. 设置节点的类型：create().withMode().forPath(“”,data) * 4. 创建多级节点 /app1/p1 ：create().creatingParentsIfNeeded().forPath(“”,data) */ @Test public void testCreate() throws Exception { //2. 创建节点 带有数据 //如果创建节点，没有指定数据，则默认将当前客户端的ip作为数据存储 String path = client.create().forPath(“/app2”, “hehe”.getBytes()); System.out.println(path); } @Test public void testCreate2() throws Exception { //1. 基本创建 //如果创建节点，没有指定数据，则默认将当前客户端的ip作为数据存储 String path = client.create().forPath(“/app1”); System.out.println(path); } @Test public void testCreate3() throws Exception { //3. 设置节点的类型 //默认类型：持久化 String path = client.create().withMode(CreateMode.EPHEMERAL).forPath(“/app3”); System.out.println(path); } @Test public void testCreate4() throws Exception { //4. 创建多级节点 /app1/p1 //creatingParentsIfNeeded():如果父节点不存在，则创建父节点 String path = client.create().creatingParentsIfNeeded().forPath(“/app4/p1”); System.out.println(path); } 1.4.4. 4.4)ZookeeperJavaAPI操作-查询节点 /** * 查询节点： * 1. 查询数据：get: getData().forPath() * 2. 查询子节点： ls: getChildren().forPath() * 3. 查询节点状态信息：ls -s:getData().storingStatIn(状态对象).forPath() */ @Test public void testGet1() throws Exception { //1. 查询数据：get byte[] data = client.getData().forPath(“/app1”); System.out.println(new String(data)); } @Test public void testGet2() throws Exception { // 2. 查询子节点： ls List path = client.getChildren().forPath(“/“); System.out.println(path); } @Test public void testGet3() throws Exception { Stat status = new Stat(); System.out.println(status); //3. 查询节点状态信息：ls -s client.getData().storingStatIn(status).forPath(“/app1”); System.out.println(status); } 1.4.5. 4.5)Zookeeper JavaAPI操作-修改节点 /** * 修改数据 * 1. 基本修改数据：setData().forPath() * 2. 根据版本修改: setData().withVersion().forPath() * * version 是通过查询出来的。目的就是为了让其他客户端或者线程不干扰我。 * * @throws Exception */ @Test public void testSet() throws Exception { client.setData().forPath(“/app1”, “itcast”.getBytes()); } @Test public void testSetForVersion() throws Exception { Stat status = new Stat(); //3. 查询节点状态信息：ls -s client.getData().storingStatIn(status).forPath(“/app1”); int version = status.getVersion();//查询出来的 3 System.out.println(version); client.setData().withVersion(version).forPath(“/app1”, “hehe”.getBytes()); } 1.4.6. 4.6)Zookeeper JavaAPI操作-删除节点 /** * 删除节点： delete deleteall * 1. 删除单个节点:delete().forPath(“/app1”); * 2. 删除带有子节点的节点:delete().deletingChildrenIfNeeded().forPath(“/app1”); * 3. 必须成功的删除:为了防止网络抖动。本质就是重试。 client.delete().guaranteed().forPath(“/app2”); * 4. 回调：inBackground * @throws Exception */ @Test public void testDelete() throws Exception { // 1. 删除单个节点 client.delete().forPath(“/app1”); } @Test public void testDelete2() throws Exception { //2. 删除带有子节点的节点 client.delete().deletingChildrenIfNeeded().forPath(“/app4”); } @Test public void testDelete3() throws Exception { //3. 必须成功的删除 client.delete().guaranteed().forPath(“/app2”); } @Test public void testDelete4() throws Exception { //4. 回调 client.delete().guaranteed().inBackground(new BackgroundCallback(){ @Override public void processResult(CuratorFramework client, CuratorEvent event) throws Exception { System.out.println(“我被删除了~”); System.out.println(event); } }).forPath(“/app1”); } 1.4.7. 4.7)Zookeeper JavaAPI操作-Watch监听概述 •ZooKeeper 允许用户在指定节点上注册一些Watcher，并且在一些特定事件触发的时候，ZooKeeper 服务端会将事件通知到感兴趣的客户端上去，该机制是 ZooKeeper 实现分布式协调服务的重要特性。 •ZooKeeper 中引入了Watcher机制来实现了发布/订阅功能能，能够让多个订阅者同时监听某一个对象，当一个对象自身状态变化时，会通知所有订阅者。 •ZooKeeper 原生支持通过注册Watcher来进行事件监听，但是其使用并不是特别方便 ​ 需要开发人员自己反复注册Watcher，比较繁琐。 •Curator引入了 Cache 来实现对 ZooKeeper 服务端事件的监听。 •ZooKeeper提供了三种Watcher： •NodeCache : 只是监听某一个特定的节点 •PathChildrenCache : 监控一个ZNode的子节点. •TreeCache : 可以监控整个树上的所有节点，类似于PathChildrenCache和NodeCache的组合 1.4.8. 4.8Zookeeper JavaAPI操作-Watch监听-NodeCache /** * 演示 NodeCache：给指定一个节点注册监听器 */ @Test public void testNodeCache() throws Exception { //1. 创建NodeCache对象 final NodeCache nodeCache = new NodeCache(client,”/app1”); //2. 注册监听 nodeCache.getListenable().addListener(new NodeCacheListener() { @Override public void nodeChanged() throws Exception { System.out.println(“节点变化了~”); //获取修改节点后的数据 byte[] data = nodeCache.getCurrentData().getData(); System.out.println(new String(data)); } }); //3. 开启监听.如果设置为true，则开启监听是，加载缓冲数据 nodeCache.start(true); while (true){ } } 1.4.9. 4.9)Zookeeper JavaAPI操作-Watch监听-PathChildrenCache @Test public void testPathChildrenCache() throws Exception { //1.创建监听对象 PathChildrenCache pathChildrenCache = new PathChildrenCache(client,”/app2”,true); //2. 绑定监听器 pathChildrenCache.getListenable().addListener(new PathChildrenCacheListener() { @Override public void childEvent(CuratorFramework client, PathChildrenCacheEvent event) throws Exception { System.out.println(“子节点变化了~”); System.out.println(event); //监听子节点的数据变更，并且拿到变更后的数据 //1.获取类型 PathChildrenCacheEvent.Type type = event.getType(); //2.判断类型是否是update if(type.equals(PathChildrenCacheEvent.Type.CHILD_UPDATED)){ System.out.println(“数据变了！！！”); byte[] data = event.getData().getData(); System.out.println(new String(data)); } } }); //3. 开启 pathChildrenCache.start(); while (true){ } } 1.4.10. 4.10)Zookeeper JavaAPI操作-Watch监听-TreeCache /** * 演示 TreeCache：监听某个节点自己和所有子节点们 */ @Test public void testTreeCache() throws Exception { //1. 创建监听器 TreeCache treeCache = new TreeCache(client,”/app2”); //2. 注册监听 treeCache.getListenable().addListener(new TreeCacheListener() { @Override public void childEvent(CuratorFramework client, TreeCacheEvent event) throws Exception { System.out.println(“节点变化了”); System.out.println(event); } }); //3. 开启 treeCache.start(); while (true){ } } 1.4.11. 4.11)Zookeeper分布式锁-概念 •在我们进行单机应用开发，涉及并发同步的时候，我们往往采用synchronized或者Lock的方式来解决多线程间的代码同步问题，这时多线程的运行都是在同一个JVM之下，没有任何问题。 •但当我们的应用是分布式集群工作的情况下，属于多JVM下的工作环境，跨JVM之间已经无法通过多线程的锁解决同步问题。 •那么就需要一种更加高级的锁机制，来处理种跨机器的进程之间的数据同步问题——这就是分布式锁。 1.4.12. 4.12)Zookeeper 分布式锁-zookeeper分布式锁原理 •核心思想：当客户端要获取锁，则创建节点，使用完锁，则删除该节点。 1.客户端获取锁时，在lock节点下创建临时顺序节点。 2.然后获取lock下面的所有子节点，客户端获取到所有的子节点之后，如果发现自己创建的子节点序号最小，那么就认为该客户端获取到了锁。使用完锁后，将该节点删除。 3.如果发现自己创建的节点并非lock所有子节点中最小的，说明自己还没有获取到锁，此时客户端需要找到比自己小的那个节点，同时对其注册事件监听器，监听删除事件。 4.如果发现比自己小的那个节点被删除，则客户端的 ​ Watcher会收到相应通知，此时再次判断自己创建的节点 ​ 是否是lock子节点中序号最小的，如果是则获取到了锁， ​ 如果不是则重复以上步骤继续获取到比自己小的一个节点 ​ 并注册监听。 1.4.13. 4.13)Zookeeper 分布式锁-模拟12306售票案例 Curator实现分布式锁API 在Curator中有五种锁方案： InterProcessSemaphoreMutex：分布式排它锁（非可重入锁） InterProcessMutex：分布式可重入排它锁 InterProcessReadWriteLock：分布式读写锁 InterProcessMultiLock：将多个锁作为单个实体管理的容器 InterProcessSemaphoreV2：共享信号量 1,创建线程进行加锁设置 public class Ticket12306 implements Runnable{ private int tickets = 10;//数据库的票数 private InterProcessMutex lock ; @Override public void run() { while(true){ //获取锁 try { lock.acquire(3, TimeUnit.SECONDS); if(tickets > 0){ System.out.println(Thread.currentThread()+”:”+tickets); Thread.sleep(100); tickets—; } } catch (Exception e) { e.printStackTrace(); }finally { //释放锁 try { lock.release(); } catch (Exception e) { e.printStackTrace(); } } } } } 2,创建连接，并且初始化锁 public Ticket12306(){ //重试策略 RetryPolicy retryPolicy = new ExponentialBackoffRetry(3000, 10); //2.第二种方式 //CuratorFrameworkFactory.builder(); CuratorFramework client = CuratorFrameworkFactory.builder() .connectString(“192.168.149.135:2181”) .sessionTimeoutMs(60 * 1000) .connectionTimeoutMs(15 * 1000) .retryPolicy(retryPolicy) .build(); //开启连接 client.start(); lock = new InterProcessMutex(client,”/lock”); } 3,运行多个线程进行测试 public class LockTest { public static void main(String[] args) { Ticket12306 ticket12306 = new Ticket12306(); //创建客户端 Thread t1 = new Thread(ticket12306,”携程”); Thread t2 = new Thread(ticket12306,”飞猪”); t1.start(); t2.start(); } } 1.5. 5)ZooKeeper 集群搭建 1.5.1. 5.1)Zookeeper集群介绍 Leader选举： •Serverid：服务器ID 比如有三台服务器，编号分别是1,2,3。 编号越大在选择算法中的权重越大。 •Zxid：数据ID 服务器中存放的最大数据ID.值越大说明数据 越新，在选举算法中数据越新权重越大。 •在Leader选举的过程中，如果某台ZooKeeper ​ 获得了超过半数的选票， ​ 则此ZooKeeper就可以成为Leader了。 1.5.2. 5.2)搭建要求 真实的集群是需要部署在不同的服务器上的，但是在我们测试时同时启动很多个虚拟机内存会吃不消，所以我们通常会搭建伪集群，也就是把所有的服务都搭建在一台虚拟机上，用端口进行区分。 我们这里要求搭建一个三个节点的Zookeeper集群（伪集群）。 1.5.3. 5.3)准备工作 重新部署一台虚拟机作为我们搭建集群的测试服务器。 （1）安装JDK 【此步骤省略】。 （2）Zookeeper压缩包上传到服务器 （3）将Zookeeper解压 ，建立/usr/local/zookeeper-cluster目录，将解压后的Zookeeper复制到以下三个目录 /usr/local/zookeeper-cluster/zookeeper-1 /usr/local/zookeeper-cluster/zookeeper-2 /usr/local/zookeeper-cluster/zookeeper-3 [root@localhost ~]# mkdir /usr/local/zookeeper-cluster [root@localhost ~]# cp -r apache-zookeeper-3.5.6-bin /usr/local/zookeeper-cluster/zookeeper-1 [root@localhost ~]# cp -r apache-zookeeper-3.5.6-bin /usr/local/zookeeper-cluster/zookeeper-2 [root@localhost ~]# cp -r apache-zookeeper-3.5.6-bin /usr/local/zookeeper-cluster/zookeeper-3 （4）创建data目录 ，并且将 conf下zoo_sample.cfg 文件改名为 zoo.cfg mkdir /usr/local/zookeeper-cluster/zookeeper-1/data mkdir /usr/local/zookeeper-cluster/zookeeper-2/data mkdir /usr/local/zookeeper-cluster/zookeeper-3/data mv /usr/local/zookeeper-cluster/zookeeper-1/conf/zoo_sample.cfg /usr/local/zookeeper-cluster/zookeeper-1/conf/zoo.cfg mv /usr/local/zookeeper-cluster/zookeeper-2/conf/zoo_sample.cfg /usr/local/zookeeper-cluster/zookeeper-2/conf/zoo.cfg mv /usr/local/zookeeper-cluster/zookeeper-3/conf/zoo_sample.cfg /usr/local/zookeeper-cluster/zookeeper-3/conf/zoo.cfg （5） 配置每一个Zookeeper 的dataDir 和 clientPort 分别为2181 2182 2183 修改/usr/local/zookeeper-cluster/zookeeper-1/conf/zoo.cfg vim /usr/local/zookeeper-cluster/zookeeper-1/conf/zoo.cfg clientPort=2181 dataDir=/usr/local/zookeeper-cluster/zookeeper-1/data 修改/usr/local/zookeeper-cluster/zookeeper-2/conf/zoo.cfg vim /usr/local/zookeeper-cluster/zookeeper-2/conf/zoo.cfg clientPort=2182 dataDir=/usr/local/zookeeper-cluster/zookeeper-2/data 修改/usr/local/zookeeper-cluster/zookeeper-3/conf/zoo.cfg vim /usr/local/zookeeper-cluster/zookeeper-3/conf/zoo.cfg clientPort=2183 dataDir=/usr/local/zookeeper-cluster/zookeeper-3/data 1.5.4. 5.4)配置集群 （1）在每个zookeeper的 data 目录下创建一个 myid 文件，内容分别是1、2、3 。这个文件就是记录每个服务器的ID echo 1 >/usr/local/zookeeper-cluster/zookeeper-1/data/myid echo 2 >/usr/local/zookeeper-cluster/zookeeper-2/data/myid echo 3 >/usr/local/zookeeper-cluster/zookeeper-3/data/myid （2）在每一个zookeeper 的 zoo.cfg配置客户端访问端口（clientPort）和集群服务器IP列表。 集群服务器IP列表如下 vim /usr/local/zookeeper-cluster/zookeeper-1/conf/zoo.cfg vim /usr/local/zookeeper-cluster/zookeeper-2/conf/zoo.cfg vim /usr/local/zookeeper-cluster/zookeeper-3/conf/zoo.cfg server.1=192.168.149.135:2881:3881 server.2=192.168.149.135:2882:3882 server.3=192.168.149.135:2883:3883 解释：server.服务器ID=服务器IP地址：服务器之间通信端口：服务器之间投票选举端口 1.5.5. 5.5)启动集群 启动集群就是分别启动每个实例。 /usr/local/zookeeper-cluster/zookeeper-1/bin/zkServer.sh start /usr/local/zookeeper-cluster/zookeeper-2/bin/zkServer.sh start /usr/local/zookeeper-cluster/zookeeper-3/bin/zkServer.sh start 启动后我们查询一下每个实例的运行状态 /usr/local/zookeeper-cluster/zookeeper-1/bin/zkServer.sh status /usr/local/zookeeper-cluster/zookeeper-2/bin/zkServer.sh status /usr/local/zookeeper-cluster/zookeeper-3/bin/zkServer.sh status 先查询第一个服务 Mode为follower表示是跟随者（从） 再查询第二个服务Mod 为leader表示是领导者（主） 查询第三个为跟随者（从） 1.5.6. 5.6)模拟集群异常 （1）首先我们先测试如果是从服务器挂掉，会怎么样 把3号服务器停掉，观察1号和2号，发现状态并没有变化 /usr/local/zookeeper-cluster/zookeeper-3/bin/zkServer.sh stop /usr/local/zookeeper-cluster/zookeeper-1/bin/zkServer.sh status /usr/local/zookeeper-cluster/zookeeper-2/bin/zkServer.sh status 由此得出结论，3个节点的集群，从服务器挂掉，集群正常 （2）我们再把1号服务器（从服务器）也停掉，查看2号（主服务器）的状态，发现已经停止运行了。 /usr/local/zookeeper-cluster/zookeeper-1/bin/zkServer.sh stop /usr/local/zookeeper-cluster/zookeeper-2/bin/zkServer.sh status 由此得出结论，3个节点的集群，2个从服务器都挂掉，主服务器也无法运行。因为可运行的机器没有超过集群总数量的半数。 （3）我们再次把1号服务器启动起来，发现2号服务器又开始正常工作了。而且依然是领导者。 /usr/local/zookeeper-cluster/zookeeper-1/bin/zkServer.sh start /usr/local/zookeeper-cluster/zookeeper-2/bin/zkServer.sh status （4）我们把3号服务器也启动起来，把2号服务器停掉,停掉后观察1号和3号的状态。 /usr/local/zookeeper-cluster/zookeeper-3/bin/zkServer.sh start /usr/local/zookeeper-cluster/zookeeper-2/bin/zkServer.sh stop /usr/local/zookeeper-cluster/zookeeper-1/bin/zkServer.sh status /usr/local/zookeeper-cluster/zookeeper-3/bin/zkServer.sh status 发现新的leader产生了~ 由此我们得出结论，当集群中的主服务器挂了，集群中的其他服务器会自动进行选举状态，然后产生新得leader （5）我们再次测试，当我们把2号服务器重新启动起来启动后，会发生什么？2号服务器会再次成为新的领导吗？我们看结果 /usr/local/zookeeper-cluster/zookeeper-2/bin/zkServer.sh start /usr/local/zookeeper-cluster/zookeeper-2/bin/zkServer.sh status /usr/local/zookeeper-cluster/zookeeper-3/bin/zkServer.sh status 我们会发现，2号服务器启动后依然是跟随者（从服务器），3号服务器依然是领导者（主服务器），没有撼动3号服务器的领导地位。 由此我们得出结论，当领导者产生后，再次有新服务器加入集群，不会影响到现任领导者。 1.6. 6)Zookeeper 核心理论 Zookeepe集群角色 在ZooKeeper集群服中务中有三个角色： •Leader 领导者 ： ​ 1. 处理事务请求 ​ 2. 集群内部各服务器的调度者 •Follower 跟随者 ： ​ 1. 处理客户端非事务请求，转发事务请求给Leader服务器 ​ 2. 参与Leader选举投票 •Observer 观察者： 1. 处理客户端非事务请求，转发事务请求给Leader服务器 Copyright © MISIN 2022 | 豫ICP备2021006345号-1 all right reserved，powered by Gitbook该文件修订时间： 2022-11-10 14:01:37 "},"4.流行框架/1.Redis高级/第二章 Redis高级.html":{"url":"4.流行框架/1.Redis高级/第二章 Redis高级.html","title":"第二章 Redis高级","keywords":"","body":"1. 第二章：Redis高级1.1. 学习目标1.2. 1.数据删除与淘汰策略1.2.1. 1.1 过期数据1.2.2. 1.2 数据删除策略1.2.3. 1.3 数据淘汰策略（逐出算法）1.3. 2.主从复制1.3.1. 2.1 主从复制简介1.3.2. 2.2 主从复制工作流程1.3.3. 2.3 主从复制常见问题1.4. 3.哨兵模式1.4.1. 3.1 哨兵简介1.4.2. 3.2 启用哨兵1.4.3. 3.3 哨兵工作原理1.5. 4.集群cluster1.5.1. 4.1 集群简介1.5.2. 4.2 Cluster集群结构设计1.5.3. 4.3 Cluster集群结构搭建1.6. 5.企业级解决方案1.6.1. 5.1 缓存预热1.6.2. 5.2 缓存雪崩1.6.3. 5.3 缓存击穿1.6.4. 5.4 缓存穿透1.6.5. 5.5 性能指标监控1. 第二章：Redis高级 1.1. 学习目标 目标1：能够说出redis中的数据删除策与略淘汰策略 目标2：能够说出主从复制的概念，工作流程以及场景问题及解决方案 目标3：能够说出哨兵的作用以及工作原理，以及如何启用哨兵 目标4：能够说出集群的架构设计，完成集群的搭建 目标5：能够说出缓存预热，雪崩，击穿，穿透的概念，能说出redis的相关监控指标 1.2. 1.数据删除与淘汰策略 1.2.1. 1.1 过期数据 1.1.1 Redis中的数据特征 Redis是一种内存级数据库，所有数据均存放在内存中，内存中的数据可以通过TTL指令获取其状态 TTL返回的值有三种情况：正数，-1，-2 正数：代表该数据在内存中还能存活的时间 -1：永久有效的数据 2 ：已经过期的数据 或被删除的数据 或 未定义的数据 删除策略就是针对已过期数据的处理策略，已过期的数据是真的就立即删除了吗？其实也不是，我们会有多种删除策略，是分情况的，在不同的场景下使用不同的删除方式会有不同效果，这也正是我们要将的数据的删除策略的问题 1.1.2 时效性数据的存储结构 在Redis中，如何给数据设置它的失效周期呢？数据的时效在redis中如何存储呢？看下图： 过期数据是一块独立的存储空间，Hash结构，field是内存地址，value是过期时间，保存了所有key的过期描述，在最终进行过期处理的时候，对该空间的数据进行检测， 当时间到期之后通过field找到内存该地址处的数据，然后进行相关操作。 1.2.2. 1.2 数据删除策略 1.2.1 数据删除策略的目标 在内存占用与CPU占用之间寻找一种平衡，顾此失彼都会造成整体redis性能的下降，甚至引发服务器宕机或 内存泄露 针对过期数据要进行删除的时候都有哪些删除策略呢？ 1.定时删除 2.惰性删除 3.定期删除 1.2.2 定时删除 创建一个定时器，当key设置有过期时间，且过期时间到达时，由定时器任务立即执行对键的删除操作 优点：节约内存，到时就删除，快速释放掉不必要的内存占用 缺点：CPU压力很大，无论CPU此时负载量多高，均占用CPU，会影响redis服务器响应时间和指令吞吐量 总结：用处理器性能换取存储空间（拿时间换空间） 1.2.3 惰性删除 数据到达过期时间，不做处理。等下次访问该数据时，我们需要判断 如果未过期，返回数据 发现已过期，删除，返回不存在 优点：节约CPU性能，发现必须删除的时候才删除 缺点：内存压力很大，出现长期占用内存的数据 总结：用存储空间换取处理器性能（拿时间换空间） 1.2.4 定期删除 定时删除和惰性删除这两种方案都是走的极端，那有没有折中方案？ 我们来讲redis的定期删除方案： Redis启动服务器初始化时，读取配置server.hz的值，默认为10 每秒钟执行server.hz次serverCron()-------->databasesCron()--------->activeExpireCycle() activeExpireCycle()对每个expires[*]逐一进行检测，每次执行耗时：250ms/server.hz 对某个expires[*]检测时，随机挑选W个key检测 如果key超时，删除key 如果一轮中删除的key的数量>W*25%，循环该过程 如果一轮中删除的key的数量≤W*25%，检查下一个expires[*]，0-15循环 W取值=ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP属性值 参数current_db用于记录activeExpireCycle() 进入哪个expires[*] 执行 如果activeExpireCycle()执行时间到期，下次从current_db继续向下执行 总的来说：定期删除就是周期性轮询redis库中的时效性数据，采用随机抽取的策略，利用过期数据占比的方式控制删除频度 特点1：CPU性能占用设置有峰值，检测频度可自定义设置 特点2：内存压力不是很大，长期占用内存的冷数据会被持续清理 总结：周期性抽查存储空间（随机抽查，重点抽查） 1.2.5 删除策略对比 1：定时删除： 节约内存，无占用, 不分时段占用CPU资源，频度高, 拿时间换空间 2：惰性删除： 内存占用严重 延时执行，CPU利用率高 拿空间换时间 3：定期删除： 内存定期随机清理 每秒花费固定的CPU资源维护内存 随机抽查，重点抽查 1.2.3. 1.3 数据淘汰策略（逐出算法） 1.3.1 淘汰策略概述 什么叫数据淘汰策略？什么样的应用场景需要用到数据淘汰策略？ 当新数据进入redis时，如果内存不足怎么办？在执行每一个命令前，会调用freeMemoryIfNeeded()检测内存是否充足。如果内存不满足新 加入数据的最低存储要求，redis要临时删除一些数据为当前指令清理存储空间。清理数据的策略称为逐出算法。 注意：逐出数据的过程不是100%能够清理出足够的可使用的内存空间，如果不成功则反复执行。当对所有数据尝试完毕， 如不能达到内存清理的要求，将出现错误信息如下 (error) OOM command not allowed when used memory >'maxmemory' 1.3.2 策略配置 影响数据淘汰的相关配置如下： 1：最大可使用内存，即占用物理内存的比例，默认值为0，表示不限制。生产环境中根据需求设定，通常设置在50%以上 maxmemory ?mb 2：每次选取待删除数据的个数，采用随机获取数据的方式作为待检测删除数据 maxmemory-samples count 3：对数据进行删除的选择策略 maxmemory-policy policy 那数据删除的策略policy到底有几种呢？一共是3类8种 第一类：检测易失数据（可能会过期的数据集server.db[i].expires ） volatile-lru：挑选最近最少使用的数据淘汰 volatile-lfu：挑选最近使用次数最少的数据淘汰 volatile-ttl：挑选将要过期的数据淘汰 volatile-random：任意选择数据淘汰 第二类：检测全库数据（所有数据集server.db[i].dict ） allkeys-lru：挑选最近最少使用的数据淘汰 allkeLyRs-lfu：：挑选最近使用次数最少的数据淘汰 allkeys-random：任意选择数据淘汰，相当于随机 第三类：放弃数据驱逐 no-enviction（驱逐）：禁止驱逐数据(redis4.0中默认策略)，会引发OOM(Out Of Memory) 注意：这些策略是配置到哪个属性上？怎么配置？如下所示 maxmemory-policy volatile-lru 数据淘汰策略配置依据 使用INFO命令输出监控信息，查询缓存 hit 和 miss 的次数，根据业务需求调优Redis配置 1.3. 2.主从复制 1.3.1. 2.1 主从复制简介 2.1.1 高可用 首先我们要理解互联网应用因为其独有的特性我们演化出的三高架构 高并发 应用要提供某一业务要能支持很多客户端同时访问的能力，我们称为并发，高并发意思就很明确了 高性能 性能带给我们最直观的感受就是：速度快，时间短 高可用 可用性：一年中应用服务正常运行的时间占全年时间的百分比，如下图：表示了应用服务在全年宕机的时间 我们把这些时间加在一起就是全年应用服务不可用的时间，然后我们可以得到应用服务全年可用的时间 4小时27分15秒+11分36秒+2分16秒=4小时41分7秒=16867秒 1年=3652460*60=31536000秒 可用性=（31536000-16867）/31536000*100%=99.9465151% 业界可用性目标5个9，即99.999%，即服务器年宕机时长低于315秒，约5.25分钟 2.1.2 主从复制概念 知道了三高的概念之后，我们想：你的“Redis”是否高可用？那我们要来分析单机redis的风险与问题 问题1.机器故障 现象：硬盘故障、系统崩溃 本质：数据丢失，很可能对业务造成灾难性打击 结论：基本上会放弃使用redis. 问题2.容量瓶颈 现象：内存不足，从16G升级到64G，从64G升级到128G，无限升级内存 本质：穷，硬件条件跟不上 结论：放弃使用redis 结论： 为了避免单点Redis服务器故障，准备多台服务器，互相连通。将数据复制多个副本保存在不同的服务器上，连接在一起，并保证数据是同步的。即使有其中一台服务器宕机，其他服务器依然可以继续提供服务，实现Redis的高可用，同时实现数据冗余备份。 多台服务器连接方案： 提供数据方：master 主服务器，主节点，主库主客户端 接收数据方：slave 从服务器，从节点，从库 从客户端 需要解决的问题： 数据同步（master的数据复制到slave中） 这里我们可以来解释主从复制的概念： 概念：主从复制即将master中的数据即时、有效的复制到slave中 特征：一个master可以拥有多个slave，一个slave只对应一个master 职责：master和slave各自的职责不一样 master: 写数据 执行写操作时，将出现变化的数据自动同步到slave 读数据（可忽略） slave: 读数据 写数据（禁止） 2.1.3 主从复制的作用 读写分离：master写、slave读，提高服务器的读写负载能力 负载均衡：基于主从结构，配合读写分离，由slave分担master负载，并根据需求的变化，改变slave的数 量，通过多个从节点分担数据读取负载，大大提高Redis服务器并发量与数据吞吐量 故障恢复：当master出现问题时，由slave提供服务，实现快速的故障恢复 数据冗余：实现数据热备份，是持久化之外的一种数据冗余方式 高可用基石：基于主从复制，构建哨兵模式与集群，实现Redis的高可用方案 1.3.2. 2.2 主从复制工作流程 主从复制过程大体可以分为3个阶段 建立连接阶段（即准备阶段） 数据同步阶段 命令传播阶段（反复同步） 而命令的传播其实有4种，分别如下： 2.2.1 主从复制的工作流程（三个阶段） 2.2.1.1 阶段一：建立连接 建立slave到master的连接，使master能够识别slave，并保存slave端口号 流程如下： 步骤1：设置master的地址和端口，保存master信息 步骤2：建立socket连接 步骤3：发送ping命令（定时器任务） 步骤4：身份验证 步骤5：发送slave端口信息 至此，主从连接成功！ 当前状态： slave：保存master的地址与端口 master：保存slave的端口 总体：之间创建了连接的socket master和slave互联 接下来就要通过某种方式将master和slave连接到一起 方式一：客户端发送命令 slaveof masterip masterport 方式二：启动服务器参数 redis-server --slaveof masterip masterport 方式三：服务器配置（主流方式） slaveof masterip masterport slave系统信息 master_link_down_since_seconds masterhost & masterport master系统信息 uslave_listening_port(多个) 主从断开连接 断开slave与master的连接，slave断开连接后，不会删除已有数据，只是不再接受master发送的数据 slaveof no one 授权访问 master客户端发送命令设置密码 requirepass password master配置文件设置密码 config set requirepass password config get requirepass slave客户端发送命令设置密码 auth password slave配置文件设置密码 masterauth password slave启动服务器设置密码 redis-server –a password 2.2.1.2 阶段二：数据同步 在slave初次连接master后，复制master中的所有数据到slave 将slave的数据库状态更新成master当前的数据库状态 同步过程如下： 步骤1：请求同步数据 步骤2：创建RDB同步数据 步骤3：恢复RDB同步数据 步骤4：请求部分同步数据 步骤5：恢复部分同步数据 至此，数据同步工作完成！ 当前状态： slave：具有master端全部数据，包含RDB过程接收的数据 master：保存slave当前数据同步的位置 总体：之间完成了数据克隆 数据同步阶段master说明 1：如果master数据量巨大，数据同步阶段应避开流量高峰期，避免造成master阻塞，影响业务正常执行 2：复制缓冲区大小设定不合理，会导致数据溢出。如进行全量复制周期太长，进行部分复制时发现数据已经存在丢失的情况，必须进行第二次全量复制，致使slave陷入死循环状态。 repl-backlog-size ?mb master单机内存占用主机内存的比例不应过大，建议使用50%-70%的内存，留下30%-50%的内存用于执 行bgsave命令和创建复制缓冲区 数据同步阶段slave说明 为避免slave进行全量复制、部分复制时服务器响应阻塞或数据不同步，建议关闭此期间的对外服务 slave-serve-stale-data yes|no 数据同步阶段，master发送给slave信息可以理解master是slave的一个客户端，主动向slave发送命令 多个slave同时对master请求数据同步，master发送的RDB文件增多，会对带宽造成巨大冲击，如果master带宽不足，因此数据同步需要根据业务需求，适量错峰 slave过多时，建议调整拓扑结构，由一主多从结构变为树状结构，中间的节点既是master，也是 slave。注意使用树状结构时，由于层级深度，导致深度越高的slave与最顶层master间数据同步延迟 较大，数据一致性变差，应谨慎选择 2.2.1.3 阶段三：命令传播 当master数据库状态被修改后，导致主从服务器数据库状态不一致，此时需要让主从数据同步到一致的状态，同步的动作称为命令传播 master将接收到的数据变更命令发送给slave，slave接收命令后执行命令 命令传播阶段的部分复制 命令传播阶段出现了断网现象： 网络闪断闪连：忽略 短时间网络中断：部分复制 长时间网络中断：全量复制 这里我们主要来看部分复制，部分复制的三个核心要素 服务器的运行 id（run id） 主服务器的复制积压缓冲区 主从服务器的复制偏移量 服务器运行ID（runid） 概念：服务器运行ID是每一台服务器每次运行的身份识别码，一台服务器多次运行可以生成多个运行id 组成：运行id由40位字符组成，是一个随机的十六进制字符 例如：fdc9ff13b9bbaab28db42b3d50f852bb5e3fcdce 作用：运行id被用于在服务器间进行传输，识别身份 如果想两次操作均对同一台服务器进行，必须每次操作携带对应的运行id，用于对方识别 实现方式：运行id在每台服务器启动时自动生成的，master在首次连接slave时，会将自己的运行ID发送给slave， slave保存此ID，通过info Server命令，可以查看节点的runid 复制缓冲区 概念：复制缓冲区，又名复制积压缓冲区，是一个先进先出（FIFO）的队列，用于存储服务器执行过的命令，每次传播命令，master都会将传播的命令记录下来，并存储在复制缓冲区 复制缓冲区默认数据存储空间大小是1M 当入队元素的数量大于队列长度时，最先入队的元素会被弹出，而新元素会被放入队列 作用：用于保存master收到的所有指令（仅影响数据变更的指令，例如set，select） 数据来源：当master接收到主客户端的指令时，除了将指令执行，会将该指令存储到缓冲区中 复制缓冲区内部工作原理： 组成 偏移量 概念：一个数字，描述复制缓冲区中的指令字节位置 分类： master复制偏移量：记录发送给所有slave的指令字节对应的位置（多个） slave复制偏移量：记录slave接收master发送过来的指令字节对应的位置（一个） 作用：同步信息，比对master与slave的差异，当slave断线后，恢复数据使用 数据来源： master端：发送一次记录一次 slave端：接收一次记录一次 字节值 工作原理 通过offset区分不同的slave当前数据传播的差异 master记录已发送的信息对应的offset slave记录已接收的信息对应的offset 2.2.2 流程更新(全量复制/部分复制) 我们再次的总结一下主从复制的三个阶段的工作流程： 2.2.3 心跳机制 什么是心跳机制？ 进入命令传播阶段候，master与slave间需要进行信息交换，使用心跳机制进行维护，实现双方连接保持在线 master心跳： 内部指令：PING 周期：由repl-ping-slave-period决定，默认10秒 作用：判断slave是否在线 查询：INFO replication 获取slave最后一次连接时间间隔，lag项维持在0或1视为正常 slave心跳任务 内部指令：REPLCONF ACK {offset} 周期：1秒 作用1：汇报slave自己的复制偏移量，获取最新的数据变更指令 作用2：判断master是否在线 心跳阶段注意事项： 当slave多数掉线，或延迟过高时，master为保障数据稳定性，将拒绝所有信息同步 min-slaves-to-write 2 min-slaves-max-lag 8 slave数量少于2个，或者所有slave的延迟都大于等于8秒时，强制关闭master写功能，停止数据同步 slave数量由slave发送REPLCONF ACK命令做确认 slave延迟由slave发送REPLCONF ACK命令做确认 至此：我们可以总结出完整的主从复制流程： 1.3.3. 2.3 主从复制常见问题 2.3.1 频繁的全量复制 伴随着系统的运行，master的数据量会越来越大，一旦master重启，runid将发生变化，会导致全部slave的全量复制操作 内部优化调整方案： 1：master内部创建master_replid变量，使用runid相同的策略生成，长度41位，并发送给所有slave 2：在master关闭时执行命令shutdown save，进行RDB持久化,将runid与offset保存到RDB文件中 repl-id repl-offset 通过redis-check-rdb命令可以查看该信息 3：master重启后加载RDB文件，恢复数据，重启后，将RDB文件中保存的repl-id与repl-offset加载到内存中 master_repl_id=repl master_repl_offset =repl-offset 通过info命令可以查看该信息 作用：本机保存上次runid，重启后恢复该值，使所有slave认为还是之前的master 第二种出现频繁全量复制的问题现象：网络环境不佳，出现网络中断，slave不提供服务 问题原因：复制缓冲区过小，断网后slave的offset越界，触发全量复制 最终结果：slave反复进行全量复制 解决方案：修改复制缓冲区大小 repl-backlog-size ?mb 建议设置如下： 1.测算从master到slave的重连平均时长second 2.获取master平均每秒产生写命令数据总量write_size_per_second 3.最优复制缓冲区空间 = 2 second write_size_per_second 2.3.2 频繁的网络中断 问题现象：master的CPU占用过高 或 slave频繁断开连接 问题原因 slave每1秒发送REPLCONFACK命令到master 当slave接到了慢查询时（keys * ，hgetall等），会大量占用CPU性能 master每1秒调用复制定时函数replicationCron()，比对slave发现长时间没有进行响应 最终结果：master各种资源（输出缓冲区、带宽、连接等）被严重占用 解决方案：通过设置合理的超时时间，确认是否释放slave repl-timeout seconds 该参数定义了超时时间的阈值（默认60秒），超过该值，释放slave 问题现象：slave与master连接断开 问题原因 master发送ping指令频度较低 master设定超时时间较短 ping指令在网络中存在丢包 解决方案：提高ping指令发送的频度 repl-ping-slave-period seconds 超时时间repl-time的时间至少是ping指令频度的5到10倍，否则slave很容易判定超时 2.3.3 数据不一致 问题现象：多个slave获取相同数据不同步 问题原因：网络信息不同步，数据发送有延迟 解决方案 优化主从间的网络环境，通常放置在同一个机房部署，如使用阿里云等云服务器时要注意此现象 监控主从节点延迟（通过offset）判断，如果slave延迟过大，暂时屏蔽程序对该slave的数据访问 slave-serve-stale-data yes|no 开启后仅响应info、slaveof等少数命令（慎用，除非对数据一致性要求很高） 1.4. 3.哨兵模式 1.4.1. 3.1 哨兵简介 3.1.1 哨兵概念 首先我们来看一个业务场景：如果redis的master宕机了，此时应该怎么办？ 那此时我们可能需要从一堆的slave中重新选举出一个新的master，那这个操作过程是什么样的呢？这里面会有什么问题出现呢？ 要实现这些功能，我们就需要redis的哨兵，那哨兵是什么呢？ 哨兵 哨兵(sentinel) 是一个分布式系统，用于对主从结构中的每台服务器进行监控，当出现故障时通过投票机制选择新的master并将所有slave连接到新的master。 3.1.2 哨兵作用 哨兵的作用： 监控：监控master和slave 不断的检查master和slave是否正常运行 master存活检测、master与slave运行情况检测 通知（提醒）：当被监控的服务器出现问题时，向其他（哨兵间，客户端）发送通知 自动故障转移：断开master与slave连接，选取一个slave作为master，将其他slave连接新的master，并告知客户端新的服务器地址 注意：哨兵也是一台redis服务器，只是不提供数据相关服务，通常哨兵的数量配置为单数 1.4.2. 3.2 启用哨兵 配置哨兵 配置一拖二的主从结构（利用之前的方式启动即可） 配置三个哨兵（配置相同，端口不同），参看sentinel.conf 1：设置哨兵监听的主服务器信息， sentinel_number表示参与投票的哨兵数量 sentinel monitor master_name master_host master_port sentinel_number 2：设置判定服务器宕机时长，该设置控制是否进行主从切换 sentinel down-after-milliseconds master_name million_seconds 3：设置故障切换的最大超时时 sentinel failover-timeout master_name million_seconds 4：设置主从切换后，同时进行数据同步的slave数量，数值越大，要求网络资源越高，数值越小，同步时间越长 sentinel parallel-syncs master_name sync_slave_number 启动哨兵 redis-sentinel filename 1.4.3. 3.3 哨兵工作原理 哨兵在进行主从切换过程中经历三个阶段 监控 通知 故障转移 3.3.1 监控 用于同步各个节点的状态信息 获取各个sentinel的状态（是否在线） 获取master的状态 master属性 prunid prole：master 各个slave的详细信息 获取所有slave的状态（根据master中的slave信息） slave属性 prunid prole：slave pmaster_host、master_port poffset 其内部的工作原理具体如下： 3.3.2 通知 sentinel在通知阶段要不断的去获取master/slave的信息，然后在各个sentinel之间进行共享，具体的流程如下： 3.3.3 故障转移 当master宕机后sentinel是如何知晓并判断出master是真的宕机了呢？我们来看具体的操作流程 当sentinel认定master下线之后，此时需要决定更换master，那这件事由哪个sentinel来做呢？这时候sentinel之间要进行选举，如下图所示： 在选举的时候每一个人手里都有一票，而每一个人的又都想当这个处理事故的人，那怎么办？大家就开始抢，于是每个人都会发出一个指令，在内网里边告诉大家我要当选举人，比如说现在的sentinel1和sentinel4发出这个选举指令了，那么sentinel2既能接到sentinel1的也能接到sentinel4的，接到了他们的申请以后呢，sentinel2他就会把他的一票投给其中一方，投给谁呢？谁先过来我投给谁，假设sentinel1先过来，所以这个票就给到了sentinel1。那么给过去以后呢，现在sentinel1就拿到了一票，按照这样的一种形式，最终会有一个选举结果。对应的选举最终得票多的，那自然就成为了处理事故的人。需要注意在这个过程中有可能会存在失败的现象，就是一轮选举完没有选取，那就会接着进行第二轮第三轮直到完成选举。 接下来就是由选举胜出的sentinel去从slave中选一个新的master出来的工作，这个流程是什么样的呢？ 首先它有一个在服务器列表中挑选备选master的原则 不在线的OUT 响应慢的OUT 与原master断开时间久的OUT 优先原则 ​ 优先级 offset runid 选出新的master之后，发送指令（ sentinel ）给其他的slave： 向新的master发送slaveof no one 向其他slave发送slaveof 新masterIP端口 总结：故障转移阶段 发现问题，主观下线与客观下线 竞选负责人 优选新master 新master上任，其他slave切换master，原master作为slave故障恢复后连接 1.5. 4.集群cluster 现状问题：业务发展过程中遇到的峰值瓶颈 redis提供的服务OPS可以达到10万/秒，当前业务OPS已经达到10万/秒 内存单机容量达到256G，当前业务需求内存容量1T 使用集群的方式可以快速解决上述问题 1.5.1. 4.1 集群简介 集群就是使用网络将若干台计算机联通起来，并提供统一的管理方式，使其对外呈现单机的服务效果 集群作用： 分散单台服务器的访问压力，实现负载均衡 分散单台服务器的存储压力，实现可扩展性 降低单台服务器宕机带来的业务灾难 1.5.2. 4.2 Cluster集群结构设计 数据存储设计： 通过算法设计，计算出key应该保存的位置 将所有的存储空间计划切割成16384份，每台主机保存一部分 注意：每份代表的是一个存储空间，不是一个key的保存空间 将key按照计算出的结果放到对应的存储空间 那redis的集群是如何增强可扩展性的呢？譬如我们要增加一个集群节点 当我们查找数据时，集群是如何操作的呢？ 各个数据库相互通信，保存各个库中槽的编号数据 一次命中，直接返回 一次未命中，告知具体位置 1.5.3. 4.3 Cluster集群结构搭建 首先要明确的几个要点： 配置服务器（3主3从） 建立通信（Meet） 分槽（Slot） 搭建主从（master-slave） Cluster配置 是否启用cluster，加入cluster节点 cluster-enabled yes|no cluster配置文件名，该文件属于自动生成，仅用于快速查找文件并查询文件内容 cluster-config-file filename 节点服务响应超时时间，用于判定该节点是否下线或切换为从节点 cluster-node-timeout milliseconds master连接的slave最小数量 cluster-migration-barrier min_slave_number Cluster节点操作命令 查看集群节点信息 cluster nodes 更改slave指向新的master cluster replicate master-id 发现一个新节点，新增master cluster meet ip:port 忽略一个没有solt的节点 cluster forget server_id 手动故障转移 cluster failover 集群操作命令： 创建集群 redis-cli –-cluster create masterhost1:masterport1 masterhost2:masterport2 masterhost3:masterport3 [masterhostn:masterportn …] slavehost1:slaveport1 slavehost2:slaveport2 slavehost3:slaveport3 -–cluster-replicas n 注意：master与slave的数量要匹配，一个master对应n个slave，由最后的参数n决定 master与slave的匹配顺序为第一个master与前n个slave分为一组，形成主从结构 添加master到当前集群中，连接时可以指定任意现有节点地址与端口 redis-cli --cluster add-node new-master-host:new-master-port now-host:now-port 添加slave redis-cli --cluster add-node new-slave-host:new-slave-port master-host:master-port --cluster-slave --cluster-master-id masterid 删除节点，如果删除的节点是master，必须保障其中没有槽slot redis-cli --cluster del-node del-slave-host:del-slave-port del-slave-id 重新分槽，分槽是从具有槽的master中划分一部分给其他master，过程中不创建新的槽 redis-cli --cluster reshard new-master-host:new-master:port --cluster-from src- master-id1, src-master-id2, src-master-idn --cluster-to target-master-id -- cluster-slots slots 注意：将需要参与分槽的所有masterid不分先后顺序添加到参数中，使用，分隔 指定目标得到的槽的数量，所有的槽将平均从每个来源的master处获取 重新分配槽，从具有槽的master中分配指定数量的槽到另一个master中，常用于清空指定master中的槽 redis-cli --cluster reshard src-master-host:src-master-port --cluster-from src- master-id --cluster-to target-master-id --cluster-slots slots --cluster-yes 1.6. 5.企业级解决方案 1.6.1. 5.1 缓存预热 场景：“宕机” 服务器启动后迅速宕机 问题排查： 1.请求数量较高，大量的请求过来之后都需要去从缓存中获取数据，但是缓存中又没有，此时从数据库中查找数据然后将数据再存入缓存，造成了短期内对redis的高强度操作从而导致问题 2.主从之间数据吞吐量较大，数据同步操作频度较高 解决方案： 前置准备工作： 1.日常例行统计数据访问记录，统计访问频度较高的热点数据 2.利用LRU数据删除策略，构建数据留存队列例如：storm与kafka配合 准备工作： 1.将统计结果中的数据分类，根据级别，redis优先加载级别较高的热点数据 2.利用分布式多服务器同时进行数据读取，提速数据加载过程 3.热点数据主从同时预热 实施： 4.使用脚本程序固定触发数据预热过程 5.如果条件允许，使用了CDN（内容分发网络），效果会更好 总的来说：缓存预热就是系统启动前，提前将相关的缓存数据直接加载到缓存系统。避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题！用户直接查询事先被预热的缓存数据！ 1.6.2. 5.2 缓存雪崩 场景：数据库服务器崩溃，一连串的场景会随之儿来 1.系统平稳运行过程中，忽然数据库连接量激增 2.应用服务器无法及时处理请求 3.大量408，500错误页面出现 4.客户反复刷新页面获取数据 5.数据库崩溃 6.应用服务器崩溃 7.重启应用服务器无效 8.Redis服务器崩溃 9.Redis集群崩溃 10.重启数据库后再次被瞬间流量放倒 问题排查： 1.在一个较短的时间内，缓存中较多的key集中过期 2.此周期内请求访问过期的数据，redis未命中，redis向数据库获取数据 3.数据库同时接收到大量的请求无法及时处理 4.Redis大量请求被积压，开始出现超时现象 5.数据库流量激增，数据库崩溃 6.重启后仍然面对缓存中无数据可用 7.Redis服务器资源被严重占用，Redis服务器崩溃 8.Redis集群呈现崩塌，集群瓦解 9.应用服务器无法及时得到数据响应请求，来自客户端的请求数量越来越多，应用服务器崩溃 10.应用服务器，redis，数据库全部重启，效果不理想 总而言之就两点：短时间范围内，大量key集中过期 解决方案 思路： 1.更多的页面静态化处理 2.构建多级缓存架构 ​ Nginx缓存+redis缓存+ehcache缓存 3.检测Mysql严重耗时业务进行优化 ​ 对数据库的瓶颈排查：例如超时查询、耗时较高事务等 4.灾难预警机制 ​ 监控redis服务器性能指标 ​ CPU占用、CPU使用率 ​ 内存容量 ​ 查询平均响应时间 ​ 线程数 5.限流、降级 短时间范围内牺牲一些客户体验，限制一部分请求访问，降低应用服务器压力，待业务低速运转后再逐步放开访问 落地实践： 1.LRU与LFU切换 2.数据有效期策略调整 ​ 根据业务数据有效期进行分类错峰，A类90分钟，B类80分钟，C类70分钟 ​ 过期时间使用固定时间+随机值的形式，稀释集中到期的key的数量 3.超热数据使用永久key 4.定期维护（自动+人工） ​ 对即将过期数据做访问量分析，确认是否延时，配合访问量统计，做热点数据的延时 5.加锁：慎用！ 总的来说：缓存雪崩就是瞬间过期数据量太大，导致对数据库服务器造成压力。如能够有效避免过期时间集中，可以有效解决雪崩现象的 出现（约40%），配合其他策略一起使用，并监控服务器的运行数据，根据运行记录做快速调整。 1.6.3. 5.3 缓存击穿 场景：还是数据库服务器崩溃，但是跟之前的场景有点不太一样 1.系统平稳运行过程中 2.数据库连接量瞬间激增 3.Redis服务器无大量key过期 4.Redis内存平稳，无波动 5.Redis服务器CPU正常 6.数据库崩溃 问题排查： 1.Redis中某个key过期，该key访问量巨大 2.多个数据请求从服务器直接压到Redis后，均未命中 3.Redis在短时间内发起了大量对数据库中同一数据的访问 总而言之就两点：单个key高热数据，key过期 解决方案： 1.预先设定 ​ 以电商为例，每个商家根据店铺等级，指定若干款主打商品，在购物节期间，加大此类信息key的过期时长 注意：购物节不仅仅指当天，以及后续若干天，访问峰值呈现逐渐降低的趋势 2.现场调整 ​ 监控访问量，对自然流量激增的数据延长过期时间或设置为永久性key 3.后台刷新数据 ​ 启动定时任务，高峰期来临之前，刷新数据有效期，确保不丢失 4.二级缓存 ​ 设置不同的失效时间，保障不会被同时淘汰就行 5.加锁 ​ 分布式锁，防止被击穿，但是要注意也是性能瓶颈，慎重！ 总的来说：缓存击穿就是单个高热数据过期的瞬间，数据访问量较大，未命中redis后，发起了大量对同一数据的数据库访问，导致对数 据库服务器造成压力。应对策略应该在业务数据分析与预防方面进行，配合运行监控测试与即时调整策略，毕竟单个key的过 期监控难度较高，配合雪崩处理策略即可。 1.6.4. 5.4 缓存穿透 场景：数据库服务器又崩溃了，跟之前的一样吗？ 1.系统平稳运行过程中 2.应用服务器流量随时间增量较大 3.Redis服务器命中率随时间逐步降低 4.Redis内存平稳，内存无压力 5.Redis服务器CPU占用激增 6.数据库服务器压力激增 7.数据库崩溃 问题排查： 1.Redis中大面积出现未命中 2.出现非正常URL访问 问题分析： 获取的数据在数据库中也不存在，数据库查询未得到对应数据 Redis获取到null数据未进行持久化，直接返回 下次此类数据到达重复上述过程 出现黑客攻击服务器 解决方案： 1.缓存null ​ 对查询结果为null的数据进行缓存（长期使用，定期清理），设定短时限，例如30-60秒，最高5分钟 2.白名单策略 ​ 提前预热各种分类数据id对应的bitmaps，id作为bitmaps的offset，相当于设置了数据白名单。当加载正常数据时放行，加载异常数据时直接拦截（效率偏低） ​ 使用布隆过滤器（有关布隆过滤器的命中问题对当前状况可以忽略） 2.实施监控 ​ 实时监控redis命中率（业务正常范围时，通常会有一个波动值）与null数据的占比 ​ 非活动时段波动：通常检测3-5倍，超过5倍纳入重点排查对象 ​ 活动时段波动：通常检测10-50倍，超过50倍纳入重点排查对象 ​ 根据倍数不同，启动不同的排查流程。然后使用黑名单进行防控（运营） 4.key加密 ​ 问题出现后，临时启动防灾业务key，对key进行业务层传输加密服务，设定校验程序，过来的key校验 ​ 例如每天随机分配60个加密串，挑选2到3个，混淆到页面数据id中，发现访问key不满足规则，驳回数据访问 总的来说：缓存击穿是指访问了不存在的数据，跳过了合法数据的redis数据缓存阶段，每次访问数据库，导致对数据库服务器造成压力。通常此类数据的出现量是一个较低的值，当出现此类情况以毒攻毒，并及时报警。应对策略应该在临时预案防范方面多做文章。 无论是黑名单还是白名单，都是对整体系统的压力，警报解除后尽快移除。 1.6.5. 5.5 性能指标监控 redis中的监控指标如下： 性能指标：Performance 响应请求的平均时间: latency 平均每秒处理请求总数 instantaneous_ops_per_sec 缓存查询命中率（通过查询总次数与查询得到非nil数据总次数计算而来） hit_rate(calculated) 内存指标：Memory 当前内存使用量 used_memory 内存碎片率（关系到是否进行碎片整理） mem_fragmentation_ratio 为避免内存溢出删除的key的总数量 evicted_keys 基于阻塞操作（BLPOP等）影响的客户端数量 blocked_clients 基本活动指标：Basic_activity 当前客户端连接总数 connected_clients 当前连接slave总数 connected_slaves 最后一次主从信息交换距现在的秒 master_last_io_seconds_ago key的总数 keyspace 持久性指标：Persistence 当前服务器最后一次RDB持久化的时间 rdb_last_save_time 当前服务器最后一次RDB持久化后数据变化总量 rdb_changes_since_last_save 错误指标：Error 被拒绝连接的客户端总数（基于达到最大连接值的因素） rejected_connections key未命中的总次数 keyspace_misses 主从断开的秒数 master_link_down_since_seconds 要对redis的相关指标进行监控，我们可以采用一些用具： CloudInsight Redis Prometheus Redis-stat Redis-faina RedisLive zabbix 也有一些命令工具： benchmark 测试当前服务器的并发性能 redis-benchmark [-h ] [-p ] [-c ] [-n [-k ] 范例1：50个连接，10000次请求对应的性能 redis-benchmark 范例2：100个连接，5000次请求对应的性能 redis-benchmark -c 100 -n 5000 redis-cli ​ monitor：启动服务器调试信息 monitor slowlog：慢日志 获取慢查询日志 slowlog [operator] ​ get ：获取慢查询日志信息 ​ len ：获取慢查询日志条目数 ​ reset ：重置慢查询日志 相关配置 slowlog-log-slower-than 1000 #设置慢查询的时间下线，单位：微妙 slowlog-max-len 100 #设置慢查询命令对应的日志显示长度，单位：命令数 Copyright © MISIN 2022 | 豫ICP备2021006345号-1 all right reserved，powered by Gitbook该文件修订时间： 2020-06-20 17:37:58 "},"4.流行框架/2.spring boot/01-Springboot-day01.html":{"url":"4.流行框架/2.spring boot/01-Springboot-day01.html","title":"01 Springboot Day 01","keywords":"","body":"1.1. 01-今日内容1.2. 02-SpringBoot概述1.3. 03-SpringBoot快速入门1.4. 04-快速构建SpringBoot工程1.5. 05-SpringBoot起步依赖原理分析1.6. 06-SpringBoot配置-配置文件分类1.7. 07-SpringBoot配置-yaml基本语法1.8. 08-SpringBoot配置-yaml数据格式1.9. 09-SpringBoot配置-获取数据_11.10. 10-SpringBoot配置-获取数据_21.11. 11-SpringBoot配置-profile1.12. 12-SpringBoot配置-项目内部配置文件加载顺序1.13. 13-SpringBoot配置-项目外部配置加载顺序1.14. 14-SpringBoot整合Junit1.15. 15-SpringBoot整合mybatis1.16. 16-SpringBoot整合redis1.1. 01-今日内容 Spring概述、快速入门 SpringBoot配置 SpringBoot整合 1.2. 02-SpringBoot概述 SpringBoot提供了一种快速使用Spring的方式，基于约定优于配置的思想，可以让开发人员不必在配置与逻辑业务之间进行思维的切换，全身心的投入到逻辑业务的代码编写中，从而大大提高了开发的效率 SpringBoot功能 1） 自动配置 Spring Boot的自动配置是一个运行时（更准确地说，是应用程序启动时）的过程，考虑了众多因素，才决定Spring配置应该用哪个，不该用哪个。该过程是SpringBoot自动完成的。 2） 起步依赖 起步依赖本质上是一个Maven项目对象模型（Project Object Model，POM），定义了对其他库的传递依赖，这些东西加在一起即支持某项功能。 简单的说，起步依赖就是将具备某种功能的坐标打包到一起，并提供一些默认的功能。 3） 辅助功能 提供了一些大型项目中常见的非功能性特性，如嵌入式服务器、安全、指标，健康检测、外部配置等。 注意：Spring Boot 并不是对 Spring 功能上的增强，而是提供了一种快速使用 Spring 的方式。 1.3. 03-SpringBoot快速入门 需求：搭建SpringBoot工程，定义HelloController.hello()方法，返回”Hello SpringBoot!”。 实现步骤： ①创建Maven项目 ②导入SpringBoot起步依赖 org.springframework.boot spring-boot-starter-parent 2.1.8.RELEASE org.springframework.boot spring-boot-starter-web ③定义Controller @RestController public class HelloController { @RequestMapping(“/hello”) public String hello(){ return “ hello Spring Boot !”; } } ④编写引导类 /** * 引导类。 SpringBoot项目的入口 */ @SpringBootApplication public class HelloApplication { public static void main(String[] args) { SpringApplication.run(HelloApplication.class,args); } } ⑤启动测试 1.4. 04-快速构建SpringBoot工程 1.5. 05-SpringBoot起步依赖原理分析 在spring-boot-starter-parent中定义了各种技术的版本信息，组合了一套最优搭配的技术版本。 在各种starter中，定义了完成该功能需要的坐标合集，其中大部分版本信息来自于父工程。 我们的工程继承parent，引入starter后，通过依赖传递，就可以简单方便获得需要的jar包，并且不会存在版本冲突等问题。 1.6. 06-SpringBoot配置-配置文件分类 SpringBoot是基于约定的，所以很多配置都有默认值，但如果想使用自己的配置替换默认配置的话，就可以使用application.properties或者application.yml（application.yaml）进行配置。 默认配置文件名称：application 在同一级目录下优先级为：properties>yml > yaml 例如：配置内置Tomcat的端口 properties： server.port=8080 yml: server: port: 8080 1.7. 07-SpringBoot配置-yaml基本语法 大小写敏感 数据值前边必须有空格，作为分隔符 使用缩进表示层级关系 缩进时不允许使用Tab键，只允许使用空格（各个系统 Tab对应的 空格数目可能不同，导致层次混乱）。 缩进的空格数目不重要，只要相同层级的元素左侧对齐即可 ‘’#” 表示注释，从这个字符一直到行尾，都会被解析器忽略。 server: port: 8080 address: 127.0.0.1 name: abc 1.8. 08-SpringBoot配置-yaml数据格式 对象(map)：键值对的集合。 person: name: zhangsan # 行内写法 person: {name: zhangsan} 数组：一组按次序排列的值 address: - beijing - shanghai # 行内写法 address: [beijing,shanghai] 纯量：单个的、不可再分的值 msg1: ‘hello \\n world’ # 单引忽略转义字符 msg2: “hello \\n world” # 双引识别转义字符 参数引用 name: lisi person: name: ${name} # 引用上边定义的name值 1.9. 09-SpringBoot配置-获取数据_1 @Value #获取普通配置 @Value(“${name}”) private String name; #获取对象属性 @Value(“${person.name}”) private String name2; #获取数组 @Value(“${address[0]}”) private String address1; #获取纯量 @Value(“${msg1}”) private String msg1; Evironment @Autowired private Environment env; System.out.println(env.getProperty(“person.name”)); System.out.println(env.getProperty(“address[0]”)); 1.10. 10-SpringBoot配置-获取数据_2 @ConfigurationProperties 注意：prefix一定要写 @Component @ConfigurationProperties(prefix = “person”) public class Person { private String name; private int age; private String[] address; public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public String[] getAddress() { return address; } public void setAddress(String[] address) { this.address = address; } @Override public String toString() { return “Person{“ + “name=‘” + name + ‘\\’’ + “, age=“ + age + ‘}’; } } 1.11. 11-SpringBoot配置-profile profile是用来完成不同环境下，配置动态切换功能的。 profile配置方式 ​ 多profile文件方式：提供多个配置文件，每个代表一种环境。 ​ application-dev.properties/yml 开发环境 ​ application-test.properties/yml 测试环境 ​ application-pro.properties/yml 生产环境 ​ yml多文档方式： ​ 在yml中使用 — 分隔不同配置 profile激活方式 配置文件： 再配置文件中配置：spring.profiles.active=dev 虚拟机参数：在VM options 指定：-Dspring.profiles.active=dev 命令行参数：java –jar xxx.jar —spring.profiles.active=dev 1.12. 12-SpringBoot配置-项目内部配置文件加载顺序 加载顺序为上文的排列顺序，高优先级配置的属性会生效 file:./config/：当前项目下的/config目录下 file:./ ：当前项目的根目录 classpath:/config/：classpath的/config目录 classpath:/ ：classpath的根目录 1.13. 13-SpringBoot配置-项目外部配置加载顺序 外部配置文件的使用是为了对能不文件的配合 1.命令行 java -jar app.jar —name=“Spring“ —server.port=9000 2.指定配置文件位置 java -jar myproject.jar —spring.config.location=e://application.properties 3.外部不带profile的properties文件 classpath:/config/application.properties classpath:/application.properties https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-external-config 1.14. 14-SpringBoot整合Junit 搭建SpringBoot工程 引入starter-test起步依赖 org.springframework.boot spring-boot-starter org.springframework.boot spring-boot-starter-test test 编写测试类 /** * 测试类 */ @RunWith(SpringRunner.class) @SpringBootTest(classes = SpringbootJunitApplication.class ) public class UserServiceTest { @Test public void test(){ System.out.println(111); } } 4.测试 1.15. 15-SpringBoot整合mybatis ①搭建SpringBoot工程 ②引入mybatis起步依赖，添加mysql驱动 org.mybatis.spring.boot mybatis-spring-boot-starter 2.1.0 mysql mysql-connector-java runtime--> org.springframework.boot spring-boot-starter-test test ③编写DataSource和MyBatis相关配置 application.yml # datasource spring: datasource: url: jdbc:mysql:///springboot?serverTimezone=UTC username: root password: root driver-class-name: com.mysql.cj.jdbc.Driver # mybatis mybatis: mapper-locations: classpath:mapper/*Mapper.xml # mapper映射文件路径 type-aliases-package: com.itheima.springbootmybatis.domain # config-location: # 指定mybatis的核心配置文件 ④定义表和实体类 public class User { private int id; private String username; private String password; public int getId() { return id; } public void setId(int id) { this.id = id; } public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public String getPassword() { return password; } public void setPassword(String password) { this.password = password; } @Override public String toString() { return \"User{\" + \"id=\" + id + \", username='\" + username + '\\'' + \", password='\" + password + '\\'' + '}'; } } ⑤编写dao和mapper文件/纯注解开发 编写dao @Mapper @Repository public interface UserXmlMapper { public List findAll(); } mapper.xml select * from t_user 纯注解开发 @Mapper @Repository public interface UserMapper { @Select(\"select * from t_user\") public List findAll(); } ⑥测试 1.16. 16-SpringBoot整合redis ①搭建SpringBoot工程 ②引入redis起步依赖 org.springframework.boot spring-boot-starter-data-redis org.springframework.boot spring-boot-starter-test test ③配置redis相关属性 spring: redis: host: 127.0.0.1 # redis的主机ip port: 6379 ④注入RedisTemplate模板 ⑤编写测试方法，测试 @RunWith(SpringRunner.class) @SpringBootTest public class SpringbootRedisApplicationTests { @Autowired private RedisTemplate redisTemplate; @Test public void testSet() { //存入数据 redisTemplate.boundValueOps(\"name\").set(\"zhangsan\"); } @Test public void testGet() { //获取数据 Object name = redisTemplate.boundValueOps(\"name\").get(); System.out.println(name); } } Copyright © MISIN 2022 | 豫ICP备2021006345号-1 all right reserved，powered by Gitbook该文件修订时间： 2022-11-10 14:02:36 "},"4.流行框架/2.spring boot/02-SpringBoot高级.html":{"url":"4.流行框架/2.spring boot/02-SpringBoot高级.html","title":"02-SpringBoot高级","keywords":"","body":"1.1. 01-SpringBoot高级-今日内容1.2. 02-SpringBoot自动配置-Condition-11.3. 03-SpringBoot自动配置-Condition-21.4. 04-SpringBoot自动配置-切换内置web服务器1.5. 05-SpringBoot自动配置-Enable注解原理1.6. 06-SpringBoot自动配置-@Import详解1.7. 07-SpringBoot自动配置-@EnableAutoConfiguration详解1.8. 08-SpringBoot自动配置-自定义starter步骤分析1.9. 09-SpringBoot自动配置-自定义starter实现-11.10. 10-SpringBoot自动配置-自定义starter实现-21.11. 11-SpringBoot事件监听1.12. 12-SpringBoot流程分析-初始化1.13. 13-SpringBoot流程分析-run1.14. 14-SpringBoot监控-actuator基本使用1.15. 15-SpringBoot监控-actuator开启所有endpoint1.16. 16-SpringBoot监控-springboot admin图形化界面使用1.17. 17-SpringBoot部署1.1. 01-SpringBoot高级-今日内容 SpringBoot自定配置 SpringBoot事件监听 SpringBoot流程分析 SpringBoot监控 SpringBoot部署 1.2. 02-SpringBoot自动配置-Condition-1 Condition是Spring4.0后引入的条件化配置接口，通过实现Condition接口可以完成有条件的加载相应的Bean @Conditional要配和Condition的实现类（ClassCondition）进行使用 ClassCondition public class ClassCondition implements Condition { /** * * @param context 上下文对象。用于获取环境，IOC容器，ClassLoader对象 * @param metadata 注解元对象。 可以用于获取注解定义的属性值 * @return */ @Override public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) { //1.需求： 导入Jedis坐标后创建Bean //思路：判断redis.clients.jedis.Jedis.class文件是否存在 boolean flag = true; try { Class cls = Class.forName(“redis.clients.jedis.Jedis”); } catch (ClassNotFoundException e) { flag = false; } return flag; } } UserConfig @Configuration public class UserConfig { @Bean @Conditional(ClassCondition.class) public User user(){ return new User(); } } 测试 @SpringBootApplication public class SpringbootConditionApplication { public static void main(String[] args) { //启动SpringBoot的应用，返回Spring的IOC容器 ConfigurableApplicationContext context = SpringApplication.run(SpringbootConditionApplication.class, args); Object user = context.getBean(“user”); System.out.println(user); } } 1.3. 03-SpringBoot自动配置-Condition-2 需求：将类的判断定义为动态的。判断哪个字节码文件存在可以动态指定。 自定义条件注解类 import org.springframework.context.annotation.Conditional; import java.lang.annotation.*; @Target({ElementType.TYPE, ElementType.METHOD}) @Retention(RetentionPolicy.RUNTIME) @Documented @Conditional(ClassCondition.class) public @interface ConditionOnClass { String[] value(); } 注意：此处@ConditionOnClass为自定义注解 @Configuration public class UserConfig { @Bean //@Conditional(ClassCondition.class) @ConditionOnClass(“com.alibaba.fastjson.JSON”) public User user(){ return new User(); } @Bean @ConditionalOnProperty(name = “itcast”,havingValue = “itheima”) public User user2(){ return new User(); } } 测试User对象的创建 @SpringBootApplication public class SpringbootConditionApplication { public static void main(String[] args) { //启动SpringBoot的应用，返回Spring的IOC容器 ConfigurableApplicationContext context = SpringApplication.run(SpringbootConditionApplication.class, args); Object user = context.getBean(“user”); System.out.println(user); } } 查看条件注解源码 SpringBoot 提供的常用条件注解： ConditionalOnProperty：判断配置文件中是否有对应属性和值才初始化Bean ConditionalOnClass：判断环境中是否有对应字节码文件才初始化Bean ConditionalOnMissingBean：判断环境中没有对应Bean才初始化Bean 1.4. 04-SpringBoot自动配置-切换内置web服务器 查看继承关系图 排除Tomcat pom文件中的排除依赖效果 org.springframework.boot spring-boot-starter-web spring-boot-starter-tomcat org.springframework.boot spring-boot-starter-jetty org.springframework.boot 1.5. 05-SpringBoot自动配置-Enable注解原理 SpringBoot不能直接获取在其他工程中定义的Bean 演示代码： springboot-enable工程 /** * @ComponentScan 扫描范围：当前引导类所在包及其子包 * * com.itheima.springbootenable * com.itheima.config * //1.使用@ComponentScan扫描com.itheima.config包 * //2.可以使用@Import注解，加载类。这些类都会被Spring创建，并放入IOC容器 * //3.可以对Import注解进行封装。 */ //@ComponentScan(“com.itheima.config”) //@Import(UserConfig.class) @EnableUser @SpringBootApplication public class SpringbootEnableApplication { public static void main(String[] args) { ConfigurableApplicationContext context = SpringApplication.run(SpringbootEnableApplication.class, args); //获取Bean Object user = context.getBean(“user”); System.out.println(user); } } pom中引入springboot-enable-other com.itheima springboot-enable-other 0.0.1-SNAPSHOT springboot-enable-other工程 UserConfig ```java @Configuration public class UserConfig { @Bean public User user() { return new User(); } } **EnableUser注解类** ```java import org.springframework.context.annotation.Import; import java.lang.annotation.*; @Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) @Documented @Import(UserConfig.class) public @interface EnableUser { } 原因：@ComponentScan 扫描范围：当前引导类所在包及其子包 三种解决方案： 1.使用@ComponentScan扫描com.itheima.config包 2.可以使用@Import注解，加载类。这些类都会被Spring创建，并放入IOC容器 3.可以对Import注解进行封装。 重点：Enable注解底层原理是使用@Import注解实现Bean的动态加载 1.6. 06-SpringBoot自动配置-@Import详解 @Enable*底层依赖于@Import注解导入一些类，使用@Import导入的类会被Spring加载到IOC容器中。而@Import提供4中用法： ①导入Bean ②导入配置类 ③导入 ImportSelector 实现类。一般用于加载配置文件中的类 ④导入 ImportBeanDefinitionRegistrar 实现类。 导入Bean @Import(User.class) 导入配置类 @Import(UserConfig.class) 导入 ImportSelector 实现类 @Import(MyImportSelector.class) MyImportSelector public class MyImportSelector implements ImportSelector { @Override public String[] selectImports(AnnotationMetadata importingClassMetadata) { return new String[]{“com.itheima.domain.User”, “com.itheima.domain.Role”}; } } 导入 ImportBeanDefinitionRegistrar 实现类。@Import({MyImportBeanDefinitionRegistrar.class}) ```java public class MyImportBeanDefinitionRegistrar implements ImportBeanDefinitionRegistrar { @Override public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) { AbstractBeanDefinition beanDefinition = BeanDefinitionBuilder.rootBeanDefinition(User.class).getBeanDefinition(); registry.registerBeanDefinition(“user”, beanDefinition); } } SpringbootEnableApplication测试代码 ```java /** * Import4中用法： * 1. 导入Bean * 2. 导入配置类 * 3. 导入ImportSelector的实现类。 * 4. 导入ImportBeanDefinitionRegistrar实现类 */ //@Import(User.class) //@Import(UserConfig.class) //@Import(MyImportSelector.class) //@Import({MyImportBeanDefinitionRegistrar.class}) @SpringBootApplication public class SpringbootEnableApplication { public static void main(String[] args) { ConfigurableApplicationContext context = SpringApplication.run(SpringbootEnableApplication.class, args); /*//获取Bean Object user = context.getBean(“user”); System.out.println(user);*/ /*User user = context.getBean(User.class); System.out.println(user); Role role = context.getBean(Role.class); System.out.println(role);*/ /* Object user = context.getBean(“user”); System.out.println(user);*/ Map map = context.getBeansOfType(User.class); System.out.println(map); } } @EnableAutoConfiguration中使用的是第三种方式：@Import(AutoConfigurationImportSelector.class) 1.7. 07-SpringBoot自动配置-@EnableAutoConfiguration详解 @EnableAutoConfiguration 注解内部使用 @Import(AutoConfigurationImportSelector.class)来加载配置类。 配置文件位置：META-INF/spring.factories，该配置文件中定义了大量的配置类，当 SpringBoot 应用启动时，会自动加载这些配置类，初始化Bean 并不是所有的Bean都会被初始化，在配置类中使用Condition来加载满足条件的Bean 1.8. 08-SpringBoot自动配置-自定义starter步骤分析 需求：自定义redis-starter。要求当导入redis坐标时，SpringBoot自动创建Jedis的Bean。 步骤： ①创建 redis-spring-boot-autoconfigure 模块 ②创建 redis-spring-boot-starter 模块,依赖 redis-spring-boot-autoconfigure的模块 ③在 redis-spring-boot-autoconfigure 模块中初始化 Jedis 的 Bean。并定义META-INF/spring.factories 文件 ④在测试模块中引入自定义的 redis-starter 依赖，测试获取 Jedis 的Bean，操作 redis。 1.9. 09-SpringBoot自动配置-自定义starter实现-1 创建redis-spring-boot-starter工程 ​ pom文件中引入redis-spring-boot-autoconfigure com.itheima redis-spring-boot-autoconfigure 0.0.1-SNAPSHOT 创建redis-spring-boot-autoconfigure配置工程 创建RedisProperties配置文件参数绑定类 @ConfigurationProperties(prefix = “redis”) public class RedisProperties { private String host = “localhost”; private int port = 6379; public String getHost() { return host; } public void setHost(String host) { this.host = host; } public int getPort() { return port; } public void setPort(int port) { this.port = port; } } 创建RedisAutoConfiguration自动配置类 @Configuration @EnableConfigurationProperties(RedisProperties.class) public class RedisAutoConfiguration { /** * 提供Jedis的bean */ @Bean public Jedis jedis(RedisProperties redisProperties) { return new Jedis(redisProperties.getHost(), redisProperties.getPort()); } } 在resource目录下创建META-INF文件夹并创建spring.factories 注意：”\\ “是换行使用的 org.springframework.boot.autoconfigure.EnableAutoConfiguration=\\ com.itheima.redis.config.RedisAutoConfiguration 在springboot-enable工程中引入自定义的redis的starter com.itheima redis-spring-boot-starter 0.0.1-SNAPSHOT 在SpringbootEnableApplication启动类中测试 Jedis jedis = context.getBean(Jedis.class); System.out.println(jedis); 1.10. 10-SpringBoot自动配置-自定义starter实现-2 测试springboot-enable工程中的application.properties中的配置参数 redis.port=6666 使用注解完成有条件加载配置类 @Configuration @EnableConfigurationProperties(RedisProperties.class) @ConditionalOnClass(Jedis.class) public class RedisAutoConfiguration { /** * 提供Jedis的bean */ @Bean @ConditionalOnMissingBean(name = “jedis”) public Jedis jedis(RedisProperties redisProperties) { System.out.println(“RedisAutoConfiguration....”); return new Jedis(redisProperties.getHost(), redisProperties.getPort()); } } 1.11. 11-SpringBoot事件监听 Java中的事件监听机制定义了以下几个角色： ①事件：Event，继承 java.util.EventObject 类的对象 ②事件源：Source ，任意对象Object ③监听器：Listener，实现 java.util.EventListener 接口 的对象 SpringBoot 在项目启动时，会对几个监听器进行回调，我们可以实现这些监听器接口，在项目启动时完成一些操作。 ApplicationContextInitializer、 SpringApplicationRunListener、 CommandLineRunner、 ApplicationRunner 自定义监听器的启动时机：MyApplicationRunner和MyCommandLineRunner都是当项目启动后执行，使用@Component放入容器即可使用 MyApplicationRunner /** * 当项目启动后执行run方法。 */ @Component public class MyApplicationRunner implements ApplicationRunner { @Override public void run(ApplicationArguments args) throws Exception { System.out.println(“ApplicationRunner...run”); System.out.println(Arrays.asList(args.getSourceArgs())); } } MyCommandLineRunner @Component public class MyCommandLineRunner implements CommandLineRunner { @Override public void run(String... args) throws Exception { System.out.println(“CommandLineRunner...run”); System.out.println(Arrays.asList(args)); } } MyApplicationContextInitializer的使用要在resource文件夹下添加META-INF/spring.factories org.springframework.context.ApplicationContextInitializer=com.itheima.springbootlistener.listener.MyApplicationContextInitializer @Component public class MyApplicationContextInitializer implements ApplicationContextInitializer { @Override public void initialize(ConfigurableApplicationContext applicationContext) { System.out.println(“ApplicationContextInitializer....initialize”); } } MySpringApplicationRunListener的使用要添加构造器 public class MySpringApplicationRunListener implements SpringApplicationRunListener { public MySpringApplicationRunListener(SpringApplication application, String[] args) { } @Override public void starting() { System.out.println(“starting...项目启动中”); } @Override public void environmentPrepared(ConfigurableEnvironment environment) { System.out.println(“environmentPrepared...环境对象开始准备”); } @Override public void contextPrepared(ConfigurableApplicationContext context) { System.out.println(“contextPrepared...上下文对象开始准备”); } @Override public void contextLoaded(ConfigurableApplicationContext context) { System.out.println(“contextLoaded...上下文对象开始加载”); } @Override public void started(ConfigurableApplicationContext context) { System.out.println(“started...上下文对象加载完成”); } @Override public void running(ConfigurableApplicationContext context) { System.out.println(“running...项目启动完成，开始运行”); } @Override public void failed(ConfigurableApplicationContext context, Throwable exception) { System.out.println(“failed...项目启动失败”); } } 1.12. 12-SpringBoot流程分析-初始化 配置启动引导类（判断是否有启动主类） 判断是否是Web环境 获取初始化类、监听器类 1.13. 13-SpringBoot流程分析-run 启动计时器 执行监听器 准备环境 打印banner：可以resource下粘贴自定义的banner 创建context refreshContext(context); 执行refreshContext方法后才真正创建Bean 1.14. 14-SpringBoot监控-actuator基本使用 ①导入依赖坐标 org.springframework.boot spring-boot-starter-actuator ②访问http://localhost:8080/acruator { “_links”:{ “self”:{ “href”:”http://localhost:8080/actuator”, “templated”:false }, “health”:{ “href”:”http://localhost:8080/actuator/health”, “templated”:false }, “health-component-instance”:{ “href”:”http://localhost:8080/actuator/health/{component}/{instance}”, “templated”:true }, “health-component”:{ “href”:”http://localhost:8080/actuator/health/{component}”, “templated”:true }, “info”:{ “href”:”http://localhost:8080/actuator/info”, “templated”:false } } } http://localhost:8080/actuator/info 在application.properties中配置 info.name=lucy info.age=99 http://localhost:8080/actuator/health 开启健康检查详细信息 management.endpoint.health.show-details=always { “status”:”UP”, “details”:{ “diskSpace”:{ “status”:”UP”, “details”:{ “total”:159579508736, “free”:13558104064, “threshold”:10485760 } }, “redis”:{ “status”:”UP”, “details”:{ “version”:”2.4.5” } } } } 1.15. 15-SpringBoot监控-actuator开启所有endpoint 开启所有endpoint 在application.properties中配置： management.endpoints.web.exposure.include=* 开启所有endpoint的返回结果： { “_links”:{ “self”:{ “href”:”http://localhost:8080/actuator”, “templated”:false }, “auditevents”:{ “href”:”http://localhost:8080/actuator/auditevents”, “templated”:false }, “beans”:{ “href”:”http://localhost:8080/actuator/beans”, “templated”:false }, “caches-cache”:{ “href”:”http://localhost:8080/actuator/caches/{cache}”, “templated”:true }, “caches”:{ “href”:”http://localhost:8080/actuator/caches”, “templated”:false }, “health-component-instance”:{ “href”:”http://localhost:8080/actuator/health/{component}/{instance}”, “templated”:true }, “health”:{ “href”:”http://localhost:8080/actuator/health”, “templated”:false }, “health-component”:{ “href”:”http://localhost:8080/actuator/health/{component}”, “templated”:true }, “conditions”:{ “href”:”http://localhost:8080/actuator/conditions”, “templated”:false }, “configprops”:{ “href”:”http://localhost:8080/actuator/configprops”, “templated”:false }, “env”:{ “href”:”http://localhost:8080/actuator/env”, “templated”:false }, “env-toMatch”:{ “href”:”http://localhost:8080/actuator/env/{toMatch}”, “templated”:true }, “info”:{ “href”:”http://localhost:8080/actuator/info”, “templated”:false }, “loggers”:{ “href”:”http://localhost:8080/actuator/loggers”, “templated”:false }, “loggers-name”:{ “href”:”http://localhost:8080/actuator/loggers/{name}”, “templated”:true }, “heapdump”:{ “href”:”http://localhost:8080/actuator/heapdump”, “templated”:false }, “threaddump”:{ “href”:”http://localhost:8080/actuator/threaddump”, “templated”:false }, “metrics-requiredMetricName”:{ “href”:”http://localhost:8080/actuator/metrics/{requiredMetricName}”, “templated”:true }, “metrics”:{ “href”:”http://localhost:8080/actuator/metrics”, “templated”:false }, “scheduledtasks”:{ “href”:”http://localhost:8080/actuator/scheduledtasks”, “templated”:false }, “httptrace”:{ “href”:”http://localhost:8080/actuator/httptrace”, “templated”:false }, “mappings”:{ “href”:”http://localhost:8080/actuator/mappings”, “templated”:false } } } 1.16. 16-SpringBoot监控-springboot admin图形化界面使用 SpringBoot Admin 有两个角色，客户端(Client)和服务端(Server)。 以下为创建服务端和客户端工程步骤： admin-server： ①创建 admin-server 模块 ②导入依赖坐标 admin-starter-server de.codecentric spring-boot-admin-starter-server ③在引导类上启用监控功能@EnableAdminServer @EnableAdminServer @SpringBootApplication public class SpringbootAdminServerApplication { public static void main(String[] args) { SpringApplication.run(SpringbootAdminServerApplication.class, args); } } admin-client： ①创建 admin-client 模块 ②导入依赖坐标 admin-starter-client de.codecentric spring-boot-admin-starter-client ③配置相关信息：server地址等 # 执行admin.server地址 spring.boot.admin.client.url=http://localhost:9000 management.endpoint.health.show-details=always management.endpoints.web.exposure.include=* ④启动server和client服务，访问server 1.17. 17-SpringBoot部署 SpringBoot 项目开发完毕后，支持两种方式部署到服务器： ①jar包(官方推荐) ②war包 更改pom文件中的打包方式为war 修改启动类 import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.boot.builder.SpringApplicationBuilder; import org.springframework.boot.web.servlet.support.SpringBootServletInitializer; @SpringBootApplication public class SpringbootDeployApplication extends SpringBootServletInitializer { public static void main(String[] args) { SpringApplication.run(SpringbootDeployApplication.class, args); } @Override protected SpringApplicationBuilder configure(SpringApplicationBuilder builder) { return builder.sources(SpringbootDeployApplication.class); } } 指定打包的名称 springboot org.springframework.boot spring-boot-maven-plugin Copyright © MISIN 2022 | 豫ICP备2021006345号-1 all right reserved，powered by Gitbook该文件修订时间： 2022-11-10 14:02:53 "},"4.流行框架/4.RabbitMQ/RabbitMQ 讲义.html":{"url":"4.流行框架/4.RabbitMQ/RabbitMQ 讲义.html","title":"RabbitMQ 讲义","keywords":"","body":"1. 0. 学习目标2. 1. 消息中间件概述2.1. 1.1. 什么是消息中间件2.2. 1.2. AMQP 和 JMS2.2.1. 1.2.1. AMQP2.2.2. 1.2.2. JMS2.2.3. 1.2.3. AMQP 与 JMS 区别2.3. 1.3. 消息队列产品2.4. 1.4. RabbitMQ3. 2. 安装及配置RabbitMQ4. 3. RabbitMQ入门4.1. 3.1. 搭建示例工程4.1.1. 3.1.1. 创建工程4.1.2. 3.1.2. 添加依赖4.2. 3.2. 编写生产者4.3. 3.3. 编写消费者4.4. 3.4. 小结5. 4. AMQP5.1. 4.1. 相关概念介绍5.2. 4.2. RabbitMQ运转流程5.3. 4.3. 生产者流转过程说明5.4. 4.4. 消费者流转过程说明6. 5. RabbitMQ工作模式6.1. 4.1. Work queues工作队列模式6.1.1. 4.1.1. 模式说明6.1.2. 4.1.2. 代码6.1.3. 4.1.3. 测试6.1.4. 4.1.4. 小结6.2. 4.2. 订阅模式类型6.3. 4.3. Publish/Subscribe发布与订阅模式6.3.1. 4.3.1. 模式说明6.3.2. 4.3.2. 代码6.3.3. 4.3.3. 测试6.3.4. 4.3.4. 小结6.4. 4.4. Routing路由模式6.4.1. 4.4.1. 模式说明6.4.2. 4.4.2. 代码6.4.3. 4.4.3. 测试6.4.4. 4.4.4. 小结6.5. 4.5. Topics通配符模式6.5.1. 4.5.1. 模式说明6.5.2. 4.5.2. 代码6.5.3. 4.5.3. 测试6.5.4. 4.5.4. 小结6.6. 4.6. 模式总结7. 5. Spring 整合RabbitMQ7.1. 5.1. 搭建生产者工程7.1.1. 5.1.1. 创建工程7.1.2. 5.1.2. 添加依赖7.1.3. 5.1.3. 配置整合7.1.4. 5.1.4. 发送消息7.2. 5.2. 搭建消费者工程7.2.1. 5.2.1. 创建工程7.2.2. 5.2.2. 添加依赖7.2.3. 5.2.3. 配置整合7.2.4. 5.2.4. 消息监听器8. 6. Spring Boot整合RabbitMQ8.1. 6.1. 简介8.2. 5.2. 搭建生产者工程8.2.1. 5.2.1. 创建工程8.2.2. 5.2.2. 添加依赖8.2.3. 5.2.3. 启动类8.2.4. 5.2.4. 配置RabbitMQ8.3. 5.3. 搭建消费者工程8.3.1. 5.3.1. 创建工程8.3.2. 5.3.2. 添加依赖8.3.3. 5.3.3. 启动类8.3.4. 5.3.4. 配置RabbitMQ8.3.5. 5.3.5. 消息监听处理类8.4. 5.4. 测试1. 0. 学习目标 能够说出什么是消息中间件 能够安装RabbitMQ 能够编写RabbitMQ的入门程序 能够说出RabbitMQ的5种模式特征 能够使用Spring整合RabbitMQ 2. 1. 消息中间件概述 2.1. 1.1. 什么是消息中间件 MQ全称为Message Queue，消息队列是应用程序和应用程序之间的通信方法。 为什么使用MQ 在项目中，可将一些无需即时返回且耗时的操作提取出来，进行异步处理，而这种异步处理的方式大大的节省了服务器的请求响应时间，从而提高了系统的吞吐量。 开发中消息队列通常有如下应用场景： 1、任务异步处理 将不需要同步处理的并且耗时长的操作由消息队列通知消息接收方进行异步处理。提高了应用程序的响应时间。 2、应用程序解耦合 MQ相当于一个中介，生产方通过MQ与消费方交互，它将应用程序进行解耦合。 3、削峰填谷 如订单系统，在下单的时候就会往数据库写数据。但是数据库只能支撑每秒1000左右的并发写入，并发量再高就容易宕机。低峰期的时候并发也就100多个，但是在高峰期时候，并发量会突然激增到5000以上，这个时候数据库肯定卡死了。 消息被MQ保存起来了，然后系统就可以按照自己的消费能力来消费，比如每秒1000个数据，这样慢慢写入数据库，这样就不会卡死数据库了。 但是使用了MQ之后，限制消费消息的速度为1000，但是这样一来，高峰期产生的数据势必会被积压在MQ中，高峰就被“削”掉了。但是因为消息积压，在高峰期过后的一段时间内，消费消息的速度还是会维持在1000QPS，直到消费完积压的消息,这就叫做“填谷” 2.2. 1.2. AMQP 和 JMS MQ是消息通信的模型；实现MQ的大致有两种主流方式：AMQP、JMS。 2.2.1. 1.2.1. AMQP AMQP是一种协议，更准确的说是一种binary wire-level protocol（链接协议）。这是其和JMS的本质差别，AMQP不从API层进行限定，而是直接定义网络交换的数据格式。 2.2.2. 1.2.2. JMS JMS即Java消息服务（JavaMessage Service）应用程序接口，是一个Java平台中关于面向消息中间件（MOM）的API，用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。 2.2.3. 1.2.3. AMQP 与 JMS 区别 JMS是定义了统一的接口，来对消息操作进行统一；AMQP是通过规定协议来统一数据交互的格式 JMS限定了必须使用Java语言；AMQP只是协议，不规定实现方式，因此是跨语言的。 JMS规定了两种消息模式；而AMQP的消息模式更加丰富 2.3. 1.3. 消息队列产品 市场上常见的消息队列有如下： ActiveMQ：基于JMS ZeroMQ：基于C语言开发 RabbitMQ：基于AMQP协议，erlang语言开发，稳定性好 RocketMQ：基于JMS，阿里巴巴产品 Kafka：类似MQ的产品；分布式消息系统，高吞吐量 2.4. 1.4. RabbitMQ RabbitMQ是由erlang语言开发，基于AMQP（Advanced Message Queue 高级消息队列协议）协议实现的消息队列，它是一种应用程序之间的通信方法，消息队列在分布式系统开发中应用非常广泛。 RabbitMQ官方地址：http://www.rabbitmq.com/ RabbitMQ提供了6种模式：简单模式，work模式，Publish/Subscribe发布与订阅模式，Routing路由模式，Topics主题模式，RPC远程调用模式（远程调用，不太算MQ；暂不作介绍）； 官网对应模式介绍：https://www.rabbitmq.com/getstarted.html 3. 2. 安装及配置RabbitMQ 详细查看 资料/软件/安装RabbitMQ.md 文档。 4. 3. RabbitMQ入门 4.1. 3.1. 搭建示例工程 4.1.1. 3.1.1. 创建工程 4.1.2. 3.1.2. 添加依赖 往heima-rabbitmq的pom.xml文件中添加如下依赖： com.rabbitmq amqp-client 5.6.0 4.2. 3.2. 编写生产者 编写消息生产者com.itheima.rabbitmq.simple.Producer package com.itheima.rabbitmq.simple; import com.rabbitmq.client.Channel; import com.rabbitmq.client.Connection; import com.rabbitmq.client.ConnectionFactory; public class Producer { static final String QUEUE_NAME = \"simple_queue\"; public static void main(String[] args) throws Exception { //创建连接工厂 ConnectionFactory connectionFactory = new ConnectionFactory(); //主机地址;默认为 localhost connectionFactory.setHost(\"localhost\"); //连接端口;默认为 5672 connectionFactory.setPort(5672); //虚拟主机名称;默认为 / connectionFactory.setVirtualHost(\"/itcast\"); //连接用户名；默认为guest connectionFactory.setUsername(\"heima\"); //连接密码；默认为guest connectionFactory.setPassword(\"heima\"); //创建连接 Connection connection = connectionFactory.newConnection(); // 创建频道 Channel channel = connection.createChannel(); // 声明（创建）队列 /** * 参数1：队列名称 * 参数2：是否定义持久化队列 * 参数3：是否独占本次连接 * 参数4：是否在不使用的时候自动删除队列 * 参数5：队列其它参数 */ channel.queueDeclare(QUEUE_NAME, true, false, false, null); // 要发送的信息 String message = \"你好；小兔子！\"; /** * 参数1：交换机名称，如果没有指定则使用默认Default Exchage * 参数2：路由key,简单模式可以传递队列名称 * 参数3：消息其它属性 * 参数4：消息内容 */ channel.basicPublish(\"\", QUEUE_NAME, null, message.getBytes()); System.out.println(\"已发送消息：\" + message); // 关闭资源 channel.close(); connection.close(); } } 在执行上述的消息发送之后；可以登录rabbitMQ的管理控制台，可以发现队列和其消息： 4.3. 3.3. 编写消费者 抽取创建connection的工具类com.itheima.rabbitmq.util.ConnectionUtil； package com.itheima.rabbitmq.util; import com.rabbitmq.client.Connection; import com.rabbitmq.client.ConnectionFactory; public class ConnectionUtil { public static Connection getConnection() throws Exception { //创建连接工厂 ConnectionFactory connectionFactory = new ConnectionFactory(); //主机地址;默认为 localhost connectionFactory.setHost(\"localhost\"); //连接端口;默认为 5672 connectionFactory.setPort(5672); //虚拟主机名称;默认为 / connectionFactory.setVirtualHost(\"/itcast\"); //连接用户名；默认为guest connectionFactory.setUsername(\"heima\"); //连接密码；默认为guest connectionFactory.setPassword(\"heima\"); //创建连接 return connectionFactory.newConnection(); } } 编写消息的消费者com.itheima.rabbitmq.simple.Consumer package com.itheima.rabbitmq.simple; import com.itheima.rabbitmq.util.ConnectionUtil; import com.rabbitmq.client.*; import java.io.IOException; public class Consumer { public static void main(String[] args) throws Exception { Connection connection = ConnectionUtil.getConnection(); // 创建频道 Channel channel = connection.createChannel(); // 声明（创建）队列 /** * 参数1：队列名称 * 参数2：是否定义持久化队列 * 参数3：是否独占本次连接 * 参数4：是否在不使用的时候自动删除队列 * 参数5：队列其它参数 */ channel.queueDeclare(Producer.QUEUE_NAME, true, false, false, null); //创建消费者；并设置消息处理 DefaultConsumer consumer = new DefaultConsumer(channel){ @Override /** * consumerTag 消息者标签，在channel.basicConsume时候可以指定 * envelope 消息包的内容，可从中获取消息id，消息routingkey，交换机，消息和重传标志(收到消息失败后是否需要重新发送) * properties 属性信息 * body 消息 */ public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException { //路由key System.out.println(\"路由key为：\" + envelope.getRoutingKey()); //交换机 System.out.println(\"交换机为：\" + envelope.getExchange()); //消息id System.out.println(\"消息id为：\" + envelope.getDeliveryTag()); //收到的消息 System.out.println(\"接收到的消息为：\" + new String(body, \"utf-8\")); } }; //监听消息 /** * 参数1：队列名称 * 参数2：是否自动确认，设置为true为表示消息接收到自动向mq回复接收到了，mq接收到回复会删除消息，设置为false则需要手动确认 * 参数3：消息接收到后回调 */ channel.basicConsume(Producer.QUEUE_NAME, true, consumer); //不关闭资源，应该一直监听消息 //channel.close(); //connection.close(); } } 4.4. 3.4. 小结 上述的入门案例中中其实使用的是如下的简单模式： 在上图的模型中，有以下概念： P：生产者，也就是要发送消息的程序 C：消费者：消息的接受者，会一直等待消息到来。 queue：消息队列，图中红色部分。类似一个邮箱，可以缓存消息；生产者向其中投递消息，消费者从其中取出消息。 5. 4. AMQP 5.1. 4.1. 相关概念介绍 AMQP 一个提供统一消息服务的应用层标准高级消息队列协议，是应用层协议的一个开放标准，为面向消息的中间件设计。 AMQP是一个二进制协议，拥有一些现代化特点：多信道、协商式，异步，安全，扩平台，中立，高效。 RabbitMQ是AMQP协议的Erlang的实现。 概念 说明 连接Connection 一个网络连接，比如TCP/IP套接字连接。 会话Session 端点之间的命名对话。在一个会话上下文中，保证“恰好传递一次”。 信道Channel 多路复用连接中的一条独立的双向数据流通道。为会话提供物理传输介质。 客户端Client AMQP连接或者会话的发起者。AMQP是非对称的，客户端生产和消费消息，服务器存储和路由这些消息。 服务节点Broker 消息中间件的服务节点；一般情况下可以将一个RabbitMQ Broker看作一台RabbitMQ 服务器。 端点 AMQP对话的任意一方。一个AMQP连接包括两个端点（一个是客户端，一个是服务器）。 消费者Consumer 一个从消息队列里请求消息的客户端程序。 生产者Producer 一个向交换机发布消息的客户端应用程序。 5.2. 4.2. RabbitMQ运转流程 在入门案例中： 生产者发送消息 生产者创建连接（Connection），开启一个信道（Channel），连接到RabbitMQ Broker； 声明队列并设置属性；如是否排它，是否持久化，是否自动删除； 将路由键（空字符串）与队列绑定起来； 发送消息至RabbitMQ Broker； 关闭信道； 关闭连接； 消费者接收消息 消费者创建连接（Connection），开启一个信道（Channel），连接到RabbitMQ Broker 向Broker 请求消费相应队列中的消息，设置相应的回调函数； 等待Broker回应闭关投递响应队列中的消息，消费者接收消息； 确认（ack，自动确认）接收到的消息； RabbitMQ从队列中删除相应已经被确认的消息； 关闭信道； 关闭连接； 5.3. 4.3. 生产者流转过程说明 客户端与代理服务器Broker建立连接。会调用newConnection() 方法,这个方法会进一步封装Protocol Header 0-9-1 的报文头发送给Broker ，以此通知Broker 本次交互采用的是AMQPO-9-1 协议，紧接着Broker 返回Connection.Start 来建立连接，在连接的过程中涉及Connection.Start/.Start-OK 、Connection.Tune/.Tune-Ok ，Connection.Open/ .Open-Ok 这6 个命令的交互。 客户端调用connection.createChannel方法。此方法开启信道，其包装的channel.open命令发送给Broker,等待channel.basicPublish方法，对应的AMQP命令为Basic.Publish,这个命令包含了content Header 和content Body()。content Header 包含了消息体的属性，例如:投递模式，优先级等，content Body 包含了消息体本身。 客户端发送完消息需要关闭资源时，涉及到Channel.Close和Channl.Close-Ok 与Connetion.Close和Connection.Close-Ok的命令交互。 5.4. 4.4. 消费者流转过程说明 消费者客户端与代理服务器Broker建立连接。会调用newConnection() 方法,这个方法会进一步封装Protocol Header 0-9-1 的报文头发送给Broker ，以此通知Broker 本次交互采用的是AMQPO-9-1 协议，紧接着Broker 返回Connection.Start 来建立连接，在连接的过程中涉及Connection.Start/.Start-OK 、Connection.Tune/.Tune-Ok ，Connection.Open/ .Open-Ok 这6 个命令的交互。 消费者客户端调用connection.createChannel方法。和生产者客户端一样，协议涉及Channel . Open/Open-Ok命令。 在真正消费之前，消费者客户端需要向Broker 发送Basic.Consume 命令(即调用channel.basicConsume 方法〉将Channel 置为接收模式，之后Broker 回执Basic . Consume - Ok 以告诉消费者客户端准备好消费消息。 Broker 向消费者客户端推送(Push) 消息，即Basic.Deliver 命令，这个命令和Basic.Publish 命令一样会携带Content Header 和Content Body。 消费者接收到消息并正确消费之后，向Broker 发送确认，即Basic.Ack 命令。 客户端发送完消息需要关闭资源时，涉及到Channel.Close和Channl.Close-Ok 与Connetion.Close和Connection.Close-Ok的命令交互。 6. 5. RabbitMQ工作模式 6.1. 4.1. Work queues工作队列模式 6.1.1. 4.1.1. 模式说明 Work Queues与入门程序的简单模式相比，多了一个或一些消费端，多个消费端共同消费同一个队列中的消息。 应用场景：对于 任务过重或任务较多情况使用工作队列可以提高任务处理的速度。 6.1.2. 4.1.2. 代码 Work Queues与入门程序的简单模式的代码是几乎一样的；可以完全复制，并复制多一个消费者进行多个消费者同时消费消息的测试。 1）生产者 package com.itheima.rabbitmq.work; import com.itheima.rabbitmq.util.ConnectionUtil; import com.rabbitmq.client.Channel; import com.rabbitmq.client.Connection; import com.rabbitmq.client.ConnectionFactory; public class Producer { static final String QUEUE_NAME = \"work_queue\"; public static void main(String[] args) throws Exception { //创建连接 Connection connection = ConnectionUtil.getConnection(); // 创建频道 Channel channel = connection.createChannel(); // 声明（创建）队列 /** * 参数1：队列名称 * 参数2：是否定义持久化队列 * 参数3：是否独占本次连接 * 参数4：是否在不使用的时候自动删除队列 * 参数5：队列其它参数 */ channel.queueDeclare(QUEUE_NAME, true, false, false, null); for (int i = 1; i 2）消费者1 package com.itheima.rabbitmq.work; import com.itheima.rabbitmq.util.ConnectionUtil; import com.rabbitmq.client.*; import java.io.IOException; public class Consumer1 { public static void main(String[] args) throws Exception { Connection connection = ConnectionUtil.getConnection(); // 创建频道 Channel channel = connection.createChannel(); // 声明（创建）队列 /** * 参数1：队列名称 * 参数2：是否定义持久化队列 * 参数3：是否独占本次连接 * 参数4：是否在不使用的时候自动删除队列 * 参数5：队列其它参数 */ channel.queueDeclare(Producer.QUEUE_NAME, true, false, false, null); //一次只能接收并处理一个消息 channel.basicQos(1); //创建消费者；并设置消息处理 DefaultConsumer consumer = new DefaultConsumer(channel){ @Override /** * consumerTag 消息者标签，在channel.basicConsume时候可以指定 * envelope 消息包的内容，可从中获取消息id，消息routingkey，交换机，消息和重传标志(收到消息失败后是否需要重新发送) * properties 属性信息 * body 消息 */ public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException { try { //路由key System.out.println(\"路由key为：\" + envelope.getRoutingKey()); //交换机 System.out.println(\"交换机为：\" + envelope.getExchange()); //消息id System.out.println(\"消息id为：\" + envelope.getDeliveryTag()); //收到的消息 System.out.println(\"消费者1-接收到的消息为：\" + new String(body, \"utf-8\")); Thread.sleep(1000); //确认消息 channel.basicAck(envelope.getDeliveryTag(), false); } catch (InterruptedException e) { e.printStackTrace(); } } }; //监听消息 /** * 参数1：队列名称 * 参数2：是否自动确认，设置为true为表示消息接收到自动向mq回复接收到了，mq接收到回复会删除消息，设置为false则需要手动确认 * 参数3：消息接收到后回调 */ channel.basicConsume(Producer.QUEUE_NAME, false, consumer); } } 3）消费者2 package com.itheima.rabbitmq.work; import com.itheima.rabbitmq.util.ConnectionUtil; import com.rabbitmq.client.*; import java.io.IOException; public class Consumer2 { public static void main(String[] args) throws Exception { Connection connection = ConnectionUtil.getConnection(); // 创建频道 Channel channel = connection.createChannel(); // 声明（创建）队列 /** * 参数1：队列名称 * 参数2：是否定义持久化队列 * 参数3：是否独占本次连接 * 参数4：是否在不使用的时候自动删除队列 * 参数5：队列其它参数 */ channel.queueDeclare(Producer.QUEUE_NAME, true, false, false, null); //一次只能接收并处理一个消息 channel.basicQos(1); //创建消费者；并设置消息处理 DefaultConsumer consumer = new DefaultConsumer(channel){ @Override /** * consumerTag 消息者标签，在channel.basicConsume时候可以指定 * envelope 消息包的内容，可从中获取消息id，消息routingkey，交换机，消息和重传标志(收到消息失败后是否需要重新发送) * properties 属性信息 * body 消息 */ public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException { try { //路由key System.out.println(\"路由key为：\" + envelope.getRoutingKey()); //交换机 System.out.println(\"交换机为：\" + envelope.getExchange()); //消息id System.out.println(\"消息id为：\" + envelope.getDeliveryTag()); //收到的消息 System.out.println(\"消费者2-接收到的消息为：\" + new String(body, \"utf-8\")); Thread.sleep(1000); //确认消息 channel.basicAck(envelope.getDeliveryTag(), false); } catch (InterruptedException e) { e.printStackTrace(); } } }; //监听消息 /** * 参数1：队列名称 * 参数2：是否自动确认，设置为true为表示消息接收到自动向mq回复接收到了，mq接收到回复会删除消息，设置为false则需要手动确认 * 参数3：消息接收到后回调 */ channel.basicConsume(Producer.QUEUE_NAME, false, consumer); } } 6.1.3. 4.1.3. 测试 启动两个消费者，然后再启动生产者发送消息；到IDEA的两个消费者对应的控制台查看是否竞争性的接收到消息。 6.1.4. 4.1.4. 小结 在一个队列中如果有多个消费者，那么消费者之间对于同一个消息的关系是竞争的关系。 6.2. 4.2. 订阅模式类型 订阅模式示例图： 前面2个案例中，只有3个角色： P：生产者，也就是要发送消息的程序 C：消费者：消息的接受者，会一直等待消息到来。 queue：消息队列，图中红色部分 而在订阅模型中，多了一个exchange角色，而且过程略有变化： P：生产者，也就是要发送消息的程序，但是不再发送到队列中，而是发给X（交换机） C：消费者，消息的接受者，会一直等待消息到来。 Queue：消息队列，接收消息、缓存消息。 Exchange：交换机，图中的X。一方面，接收生产者发送的消息。另一方面，知道如何处理消息，例如递交给某个特别队列、递交给所有队列、或是将消息丢弃。到底如何操作，取决于Exchange的类型。Exchange有常见以下3种类型： Fanout：广播，将消息交给所有绑定到交换机的队列 Direct：定向，把消息交给符合指定routing key 的队列 Topic：通配符，把消息交给符合routing pattern（路由模式） 的队列 Exchange（交换机）只负责转发消息，不具备存储消息的能力，因此如果没有任何队列与Exchange绑定，或者没有符合路由规则的队列，那么消息会丢失！ 6.3. 4.3. Publish/Subscribe发布与订阅模式 6.3.1. 4.3.1. 模式说明 发布订阅模式： 1、每个消费者监听自己的队列。 2、生产者将消息发给broker，由交换机将消息转发到绑定此交换机的每个队列，每个绑定交换机的队列都将接收 到消息 6.3.2. 4.3.2. 代码 1）生产者 package com.itheima.rabbitmq.ps; import com.itheima.rabbitmq.util.ConnectionUtil; import com.rabbitmq.client.BuiltinExchangeType; import com.rabbitmq.client.Channel; import com.rabbitmq.client.Connection; /** * 发布与订阅使用的交换机类型为：fanout */ public class Producer { //交换机名称 static final String FANOUT_EXCHAGE = \"fanout_exchange\"; //队列名称 static final String FANOUT_QUEUE_1 = \"fanout_queue_1\"; //队列名称 static final String FANOUT_QUEUE_2 = \"fanout_queue_2\"; public static void main(String[] args) throws Exception { //创建连接 Connection connection = ConnectionUtil.getConnection(); // 创建频道 Channel channel = connection.createChannel(); /** * 声明交换机 * 参数1：交换机名称 * 参数2：交换机类型，fanout、topic、direct、headers */ channel.exchangeDeclare(FANOUT_EXCHAGE, BuiltinExchangeType.FANOUT); // 声明（创建）队列 /** * 参数1：队列名称 * 参数2：是否定义持久化队列 * 参数3：是否独占本次连接 * 参数4：是否在不使用的时候自动删除队列 * 参数5：队列其它参数 */ channel.queueDeclare(FANOUT_QUEUE_1, true, false, false, null); channel.queueDeclare(FANOUT_QUEUE_2, true, false, false, null); //队列绑定交换机 channel.queueBind(FANOUT_QUEUE_1, FANOUT_EXCHAGE, \"\"); channel.queueBind(FANOUT_QUEUE_2, FANOUT_EXCHAGE, \"\"); for (int i = 1; i 2）消费者1 package com.itheima.rabbitmq.ps; import com.itheima.rabbitmq.util.ConnectionUtil; import com.rabbitmq.client.*; import java.io.IOException; public class Consumer1 { public static void main(String[] args) throws Exception { Connection connection = ConnectionUtil.getConnection(); // 创建频道 Channel channel = connection.createChannel(); //声明交换机 channel.exchangeDeclare(Producer.FANOUT_EXCHAGE, BuiltinExchangeType.FANOUT); // 声明（创建）队列 /** * 参数1：队列名称 * 参数2：是否定义持久化队列 * 参数3：是否独占本次连接 * 参数4：是否在不使用的时候自动删除队列 * 参数5：队列其它参数 */ channel.queueDeclare(Producer.FANOUT_QUEUE_1, true, false, false, null); //队列绑定交换机 channel.queueBind(Producer.FANOUT_QUEUE_1, Producer.FANOUT_EXCHAGE, \"\"); //创建消费者；并设置消息处理 DefaultConsumer consumer = new DefaultConsumer(channel){ @Override /** * consumerTag 消息者标签，在channel.basicConsume时候可以指定 * envelope 消息包的内容，可从中获取消息id，消息routingkey，交换机，消息和重传标志(收到消息失败后是否需要重新发送) * properties 属性信息 * body 消息 */ public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException { //路由key System.out.println(\"路由key为：\" + envelope.getRoutingKey()); //交换机 System.out.println(\"交换机为：\" + envelope.getExchange()); //消息id System.out.println(\"消息id为：\" + envelope.getDeliveryTag()); //收到的消息 System.out.println(\"消费者1-接收到的消息为：\" + new String(body, \"utf-8\")); } }; //监听消息 /** * 参数1：队列名称 * 参数2：是否自动确认，设置为true为表示消息接收到自动向mq回复接收到了，mq接收到回复会删除消息，设置为false则需要手动确认 * 参数3：消息接收到后回调 */ channel.basicConsume(Producer.FANOUT_QUEUE_1, true, consumer); } } 3）消费者2 package com.itheima.rabbitmq.ps; import com.itheima.rabbitmq.util.ConnectionUtil; import com.rabbitmq.client.*; import java.io.IOException; public class Consumer2 { public static void main(String[] args) throws Exception { Connection connection = ConnectionUtil.getConnection(); // 创建频道 Channel channel = connection.createChannel(); //声明交换机 channel.exchangeDeclare(Producer.FANOUT_EXCHAGE, BuiltinExchangeType.FANOUT); // 声明（创建）队列 /** * 参数1：队列名称 * 参数2：是否定义持久化队列 * 参数3：是否独占本次连接 * 参数4：是否在不使用的时候自动删除队列 * 参数5：队列其它参数 */ channel.queueDeclare(Producer.FANOUT_QUEUE_2, true, false, false, null); //队列绑定交换机 channel.queueBind(Producer.FANOUT_QUEUE_2, Producer.FANOUT_EXCHAGE, \"\"); //创建消费者；并设置消息处理 DefaultConsumer consumer = new DefaultConsumer(channel){ @Override /** * consumerTag 消息者标签，在channel.basicConsume时候可以指定 * envelope 消息包的内容，可从中获取消息id，消息routingkey，交换机，消息和重传标志(收到消息失败后是否需要重新发送) * properties 属性信息 * body 消息 */ public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException { //路由key System.out.println(\"路由key为：\" + envelope.getRoutingKey()); //交换机 System.out.println(\"交换机为：\" + envelope.getExchange()); //消息id System.out.println(\"消息id为：\" + envelope.getDeliveryTag()); //收到的消息 System.out.println(\"消费者2-接收到的消息为：\" + new String(body, \"utf-8\")); } }; //监听消息 /** * 参数1：队列名称 * 参数2：是否自动确认，设置为true为表示消息接收到自动向mq回复接收到了，mq接收到回复会删除消息，设置为false则需要手动确认 * 参数3：消息接收到后回调 */ channel.basicConsume(Producer.FANOUT_QUEUE_2, true, consumer); } } 6.3.3. 4.3.3. 测试 启动所有消费者，然后使用生产者发送消息；在每个消费者对应的控制台可以查看到生产者发送的所有消息；到达广播的效果。 在执行完测试代码后，其实到RabbitMQ的管理后台找到Exchanges选项卡，点击 fanout_exchange 的交换机，可以查看到如下的绑定： 6.3.4. 4.3.4. 小结 交换机需要与队列进行绑定，绑定之后；一个消息可以被多个消费者都收到。 发布订阅模式与工作队列模式的区别 1、工作队列模式不用定义交换机，而发布/订阅模式需要定义交换机。 2、发布/订阅模式的生产方是面向交换机发送消息，工作队列模式的生产方是面向队列发送消息(底层使用默认交换机)。 3、发布/订阅模式需要设置队列和交换机的绑定，工作队列模式不需要设置，实际上工作队列模式会将队列绑 定到默认的交换机 。 6.4. 4.4. Routing路由模式 6.4.1. 4.4.1. 模式说明 路由模式特点： 队列与交换机的绑定，不能是任意绑定了，而是要指定一个RoutingKey（路由key） 消息的发送方在 向 Exchange发送消息时，也必须指定消息的 RoutingKey。 Exchange不再把消息交给每一个绑定的队列，而是根据消息的Routing Key进行判断，只有队列的Routingkey与消息的 Routing key完全一致，才会接收到消息 图解： P：生产者，向Exchange发送消息，发送消息时，会指定一个routing key。 X：Exchange（交换机），接收生产者的消息，然后把消息递交给 与routing key完全匹配的队列 C1：消费者，其所在队列指定了需要routing key 为 error 的消息 C2：消费者，其所在队列指定了需要routing key 为 info、error、warning 的消息 6.4.2. 4.4.2. 代码 在编码上与 Publish/Subscribe发布与订阅模式 的区别是交换机的类型为：Direct，还有队列绑定交换机的时候需要指定routing key。 1）生产者 package com.itheima.rabbitmq.routing; import com.itheima.rabbitmq.util.ConnectionUtil; import com.rabbitmq.client.BuiltinExchangeType; import com.rabbitmq.client.Channel; import com.rabbitmq.client.Connection; /** * 路由模式的交换机类型为：direct */ public class Producer { //交换机名称 static final String DIRECT_EXCHAGE = \"direct_exchange\"; //队列名称 static final String DIRECT_QUEUE_INSERT = \"direct_queue_insert\"; //队列名称 static final String DIRECT_QUEUE_UPDATE = \"direct_queue_update\"; public static void main(String[] args) throws Exception { //创建连接 Connection connection = ConnectionUtil.getConnection(); // 创建频道 Channel channel = connection.createChannel(); /** * 声明交换机 * 参数1：交换机名称 * 参数2：交换机类型，fanout、topic、direct、headers */ channel.exchangeDeclare(DIRECT_EXCHAGE, BuiltinExchangeType.DIRECT); // 声明（创建）队列 /** * 参数1：队列名称 * 参数2：是否定义持久化队列 * 参数3：是否独占本次连接 * 参数4：是否在不使用的时候自动删除队列 * 参数5：队列其它参数 */ channel.queueDeclare(DIRECT_QUEUE_INSERT, true, false, false, null); channel.queueDeclare(DIRECT_QUEUE_UPDATE, true, false, false, null); //队列绑定交换机 channel.queueBind(DIRECT_QUEUE_INSERT, DIRECT_EXCHAGE, \"insert\"); channel.queueBind(DIRECT_QUEUE_UPDATE, DIRECT_EXCHAGE, \"update\"); // 发送信息 String message = \"新增了商品。路由模式；routing key 为 insert \" ; /** * 参数1：交换机名称，如果没有指定则使用默认Default Exchage * 参数2：路由key,简单模式可以传递队列名称 * 参数3：消息其它属性 * 参数4：消息内容 */ channel.basicPublish(DIRECT_EXCHAGE, \"insert\", null, message.getBytes()); System.out.println(\"已发送消息：\" + message); // 发送信息 message = \"修改了商品。路由模式；routing key 为 update\" ; /** * 参数1：交换机名称，如果没有指定则使用默认Default Exchage * 参数2：路由key,简单模式可以传递队列名称 * 参数3：消息其它属性 * 参数4：消息内容 */ channel.basicPublish(DIRECT_EXCHAGE, \"update\", null, message.getBytes()); System.out.println(\"已发送消息：\" + message); // 关闭资源 channel.close(); connection.close(); } } 2）消费者1 package com.itheima.rabbitmq.routing; import com.itheima.rabbitmq.util.ConnectionUtil; import com.rabbitmq.client.*; import java.io.IOException; public class Consumer1 { public static void main(String[] args) throws Exception { Connection connection = ConnectionUtil.getConnection(); // 创建频道 Channel channel = connection.createChannel(); //声明交换机 channel.exchangeDeclare(Producer.DIRECT_EXCHAGE, BuiltinExchangeType.DIRECT); // 声明（创建）队列 /** * 参数1：队列名称 * 参数2：是否定义持久化队列 * 参数3：是否独占本次连接 * 参数4：是否在不使用的时候自动删除队列 * 参数5：队列其它参数 */ channel.queueDeclare(Producer.DIRECT_QUEUE_INSERT, true, false, false, null); //队列绑定交换机 channel.queueBind(Producer.DIRECT_QUEUE_INSERT, Producer.DIRECT_EXCHAGE, \"insert\"); //创建消费者；并设置消息处理 DefaultConsumer consumer = new DefaultConsumer(channel){ @Override /** * consumerTag 消息者标签，在channel.basicConsume时候可以指定 * envelope 消息包的内容，可从中获取消息id，消息routingkey，交换机，消息和重传标志(收到消息失败后是否需要重新发送) * properties 属性信息 * body 消息 */ public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException { //路由key System.out.println(\"路由key为：\" + envelope.getRoutingKey()); //交换机 System.out.println(\"交换机为：\" + envelope.getExchange()); //消息id System.out.println(\"消息id为：\" + envelope.getDeliveryTag()); //收到的消息 System.out.println(\"消费者1-接收到的消息为：\" + new String(body, \"utf-8\")); } }; //监听消息 /** * 参数1：队列名称 * 参数2：是否自动确认，设置为true为表示消息接收到自动向mq回复接收到了，mq接收到回复会删除消息，设置为false则需要手动确认 * 参数3：消息接收到后回调 */ channel.basicConsume(Producer.DIRECT_QUEUE_INSERT, true, consumer); } } 3）消费者2 package com.itheima.rabbitmq.routing; import com.itheima.rabbitmq.util.ConnectionUtil; import com.rabbitmq.client.*; import java.io.IOException; public class Consumer2 { public static void main(String[] args) throws Exception { Connection connection = ConnectionUtil.getConnection(); // 创建频道 Channel channel = connection.createChannel(); //声明交换机 channel.exchangeDeclare(Producer.DIRECT_EXCHAGE, BuiltinExchangeType.DIRECT); // 声明（创建）队列 /** * 参数1：队列名称 * 参数2：是否定义持久化队列 * 参数3：是否独占本次连接 * 参数4：是否在不使用的时候自动删除队列 * 参数5：队列其它参数 */ channel.queueDeclare(Producer.DIRECT_QUEUE_UPDATE, true, false, false, null); //队列绑定交换机 channel.queueBind(Producer.DIRECT_QUEUE_UPDATE, Producer.DIRECT_EXCHAGE, \"update\"); //创建消费者；并设置消息处理 DefaultConsumer consumer = new DefaultConsumer(channel){ @Override /** * consumerTag 消息者标签，在channel.basicConsume时候可以指定 * envelope 消息包的内容，可从中获取消息id，消息routingkey，交换机，消息和重传标志(收到消息失败后是否需要重新发送) * properties 属性信息 * body 消息 */ public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException { //路由key System.out.println(\"路由key为：\" + envelope.getRoutingKey()); //交换机 System.out.println(\"交换机为：\" + envelope.getExchange()); //消息id System.out.println(\"消息id为：\" + envelope.getDeliveryTag()); //收到的消息 System.out.println(\"消费者2-接收到的消息为：\" + new String(body, \"utf-8\")); } }; //监听消息 /** * 参数1：队列名称 * 参数2：是否自动确认，设置为true为表示消息接收到自动向mq回复接收到了，mq接收到回复会删除消息，设置为false则需要手动确认 * 参数3：消息接收到后回调 */ channel.basicConsume(Producer.DIRECT_QUEUE_UPDATE, true, consumer); } } 6.4.3. 4.4.3. 测试 启动所有消费者，然后使用生产者发送消息；在消费者对应的控制台可以查看到生产者发送对应routing key对应队列的消息；到达按照需要接收的效果。 在执行完测试代码后，其实到RabbitMQ的管理后台找到Exchanges选项卡，点击 direct_exchange 的交换机，可以查看到如下的绑定： 6.4.4. 4.4.4. 小结 Routing模式要求队列在绑定交换机时要指定routing key，消息会转发到符合routing key的队列。 6.5. 4.5. Topics通配符模式 6.5.1. 4.5.1. 模式说明 Topic类型与Direct相比，都是可以根据RoutingKey把消息路由到不同的队列。只不过Topic类型Exchange可以让队列在绑定Routing key 的时候使用通配符！ Routingkey 一般都是有一个或多个单词组成，多个单词之间以”.”分割，例如： item.insert 通配符规则： #：匹配一个或多个词 *：匹配不多不少恰好1个词 举例： item.#：能够匹配item.insert.abc 或者 item.insert item.*：只能匹配item.insert 图解： 红色Queue：绑定的是usa.# ，因此凡是以 usa.开头的routing key 都会被匹配到 黄色Queue：绑定的是#.news ，因此凡是以 .news结尾的 routing key 都会被匹配 6.5.2. 4.5.2. 代码 1）生产者 使用topic类型的Exchange，发送消息的routing key有3种： item.insert、item.update、item.delete： package com.itheima.rabbitmq.topic; import com.itheima.rabbitmq.util.ConnectionUtil; import com.rabbitmq.client.BuiltinExchangeType; import com.rabbitmq.client.Channel; import com.rabbitmq.client.Connection; /** * 通配符Topic的交换机类型为：topic */ public class Producer { //交换机名称 static final String TOPIC_EXCHAGE = \"topic_exchange\"; //队列名称 static final String TOPIC_QUEUE_1 = \"topic_queue_1\"; //队列名称 static final String TOPIC_QUEUE_2 = \"topic_queue_2\"; public static void main(String[] args) throws Exception { //创建连接 Connection connection = ConnectionUtil.getConnection(); // 创建频道 Channel channel = connection.createChannel(); /** * 声明交换机 * 参数1：交换机名称 * 参数2：交换机类型，fanout、topic、topic、headers */ channel.exchangeDeclare(TOPIC_EXCHAGE, BuiltinExchangeType.TOPIC); // 发送信息 String message = \"新增了商品。Topic模式；routing key 为 item.insert \" ; channel.basicPublish(TOPIC_EXCHAGE, \"item.insert\", null, message.getBytes()); System.out.println(\"已发送消息：\" + message); // 发送信息 message = \"修改了商品。Topic模式；routing key 为 item.update\" ; channel.basicPublish(TOPIC_EXCHAGE, \"item.update\", null, message.getBytes()); System.out.println(\"已发送消息：\" + message); // 发送信息 message = \"删除了商品。Topic模式；routing key 为 item.delete\" ; channel.basicPublish(TOPIC_EXCHAGE, \"item.delete\", null, message.getBytes()); System.out.println(\"已发送消息：\" + message); // 关闭资源 channel.close(); connection.close(); } } 2）消费者1 接收两种类型的消息：更新商品和删除商品 package com.itheima.rabbitmq.topic; import com.itheima.rabbitmq.util.ConnectionUtil; import com.rabbitmq.client.*; import java.io.IOException; public class Consumer1 { public static void main(String[] args) throws Exception { Connection connection = ConnectionUtil.getConnection(); // 创建频道 Channel channel = connection.createChannel(); //声明交换机 channel.exchangeDeclare(Producer.TOPIC_EXCHAGE, BuiltinExchangeType.TOPIC); // 声明（创建）队列 /** * 参数1：队列名称 * 参数2：是否定义持久化队列 * 参数3：是否独占本次连接 * 参数4：是否在不使用的时候自动删除队列 * 参数5：队列其它参数 */ channel.queueDeclare(Producer.TOPIC_QUEUE_1, true, false, false, null); //队列绑定交换机 channel.queueBind(Producer.TOPIC_QUEUE_1, Producer.TOPIC_EXCHAGE, \"item.update\"); channel.queueBind(Producer.TOPIC_QUEUE_1, Producer.TOPIC_EXCHAGE, \"item.delete\"); //创建消费者；并设置消息处理 DefaultConsumer consumer = new DefaultConsumer(channel){ @Override /** * consumerTag 消息者标签，在channel.basicConsume时候可以指定 * envelope 消息包的内容，可从中获取消息id，消息routingkey，交换机，消息和重传标志(收到消息失败后是否需要重新发送) * properties 属性信息 * body 消息 */ public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException { //路由key System.out.println(\"路由key为：\" + envelope.getRoutingKey()); //交换机 System.out.println(\"交换机为：\" + envelope.getExchange()); //消息id System.out.println(\"消息id为：\" + envelope.getDeliveryTag()); //收到的消息 System.out.println(\"消费者1-接收到的消息为：\" + new String(body, \"utf-8\")); } }; //监听消息 /** * 参数1：队列名称 * 参数2：是否自动确认，设置为true为表示消息接收到自动向mq回复接收到了，mq接收到回复会删除消息，设置为false则需要手动确认 * 参数3：消息接收到后回调 */ channel.basicConsume(Producer.TOPIC_QUEUE_1, true, consumer); } } 3）消费者2 接收所有类型的消息：新增商品，更新商品和删除商品。 package com.itheima.rabbitmq.topic; import com.itheima.rabbitmq.util.ConnectionUtil; import com.rabbitmq.client.*; import java.io.IOException; public class Consumer2 { public static void main(String[] args) throws Exception { Connection connection = ConnectionUtil.getConnection(); // 创建频道 Channel channel = connection.createChannel(); //声明交换机 channel.exchangeDeclare(Producer.TOPIC_EXCHAGE, BuiltinExchangeType.TOPIC); // 声明（创建）队列 /** * 参数1：队列名称 * 参数2：是否定义持久化队列 * 参数3：是否独占本次连接 * 参数4：是否在不使用的时候自动删除队列 * 参数5：队列其它参数 */ channel.queueDeclare(Producer.TOPIC_QUEUE_2, true, false, false, null); //队列绑定交换机 channel.queueBind(Producer.TOPIC_QUEUE_2, Producer.TOPIC_EXCHAGE, \"item.*\"); //创建消费者；并设置消息处理 DefaultConsumer consumer = new DefaultConsumer(channel){ @Override /** * consumerTag 消息者标签，在channel.basicConsume时候可以指定 * envelope 消息包的内容，可从中获取消息id，消息routingkey，交换机，消息和重传标志(收到消息失败后是否需要重新发送) * properties 属性信息 * body 消息 */ public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException { //路由key System.out.println(\"路由key为：\" + envelope.getRoutingKey()); //交换机 System.out.println(\"交换机为：\" + envelope.getExchange()); //消息id System.out.println(\"消息id为：\" + envelope.getDeliveryTag()); //收到的消息 System.out.println(\"消费者2-接收到的消息为：\" + new String(body, \"utf-8\")); } }; //监听消息 /** * 参数1：队列名称 * 参数2：是否自动确认，设置为true为表示消息接收到自动向mq回复接收到了，mq接收到回复会删除消息，设置为false则需要手动确认 * 参数3：消息接收到后回调 */ channel.basicConsume(Producer.TOPIC_QUEUE_2, true, consumer); } } 6.5.3. 4.5.3. 测试 启动所有消费者，然后使用生产者发送消息；在消费者对应的控制台可以查看到生产者发送对应routing key对应队列的消息；到达按照需要接收的效果；并且这些routing key可以使用通配符。 在执行完测试代码后，其实到RabbitMQ的管理后台找到Exchanges选项卡，点击 topic_exchange 的交换机，可以查看到如下的绑定： 6.5.4. 4.5.4. 小结 Topic主题模式可以实现 Publish/Subscribe发布与订阅模式 和 Routing路由模式 的功能；只是Topic在配置routing key 的时候可以使用通配符，显得更加灵活。 6.6. 4.6. 模式总结 RabbitMQ工作模式： 1、简单模式 HelloWorld 一个生产者、一个消费者，不需要设置交换机（使用默认的交换机） 2、工作队列模式 Work Queue 一个生产者、多个消费者（竞争关系），不需要设置交换机（使用默认的交换机） 3、发布订阅模式 Publish/subscribe 需要设置类型为fanout的交换机，并且交换机和队列进行绑定，当发送消息到交换机后，交换机会将消息发送到绑定的队列 4、路由模式 Routing 需要设置类型为direct的交换机，交换机和队列进行绑定，并且指定routing key，当发送消息到交换机后，交换机会根据routing key将消息发送到对应的队列 5、通配符模式 Topic 需要设置类型为topic的交换机，交换机和队列进行绑定，并且指定通配符方式的routing key，当发送消息到交换机后，交换机会根据routing key将消息发送到对应的队列 7. 5. Spring 整合RabbitMQ 7.1. 5.1. 搭建生产者工程 7.1.1. 5.1.1. 创建工程 7.1.2. 5.1.2. 添加依赖 修改pom.xml文件内容为如下： 4.0.0 com.itheima spring-rabbitmq-producer 1.0-SNAPSHOT org.springframework spring-context 5.1.7.RELEASE org.springframework.amqp spring-rabbit 2.1.8.RELEASE junit junit 4.12 org.springframework spring-test 5.1.7.RELEASE 7.1.3. 5.1.3. 配置整合 创建spring-rabbitmq-producer\\src\\main\\resources\\properties\\rabbitmq.properties连接参数等配置文件； rabbitmq.host=192.168.12.135 rabbitmq.port=5672 rabbitmq.username=heima rabbitmq.password=heima rabbitmq.virtual-host=/itcast 创建 spring-rabbitmq-producer\\src\\main\\resources\\spring\\spring-rabbitmq.xml 整合配置文件； 7.1.4. 5.1.4. 发送消息 创建测试文件 spring-rabbitmq-producer\\src\\test\\java\\com\\itheima\\rabbitmq\\ProducerTest.java @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(locations = \"classpath:spring/spring-rabbitmq.xml\") public class ProducerTest { @Autowired private RabbitTemplate rabbitTemplate; /** * 只发队列消息 * 默认交换机类型为 direct * 交换机的名称为空，路由键为队列的名称 */ @Test public void queueTest(){ //路由键与队列同名 rabbitTemplate.convertAndSend(\"spring_queue\", \"只发队列spring_queue的消息。\"); } /** * 发送广播 * 交换机类型为 fanout * 绑定到该交换机的所有队列都能够收到消息 */ @Test public void fanoutTest(){ /** * 参数1：交换机名称 * 参数2：路由键名（广播设置为空） * 参数3：发送的消息内容 */ rabbitTemplate.convertAndSend(\"spring_fanout_exchange\", \"\", \"发送到spring_fanout_exchange交换机的广播消息\"); } /** * 通配符 * 交换机类型为 topic * 匹配路由键的通配符，*表示一个单词，#表示多个单词 * 绑定到该交换机的匹配队列能够收到对应消息 */ @Test public void topicTest(){ /** * 参数1：交换机名称 * 参数2：路由键名 * 参数3：发送的消息内容 */ rabbitTemplate.convertAndSend(\"spring_topic_exchange\", \"heima.bj\", \"发送到spring_topic_exchange交换机heima.bj的消息\"); rabbitTemplate.convertAndSend(\"spring_topic_exchange\", \"heima.bj.1\", \"发送到spring_topic_exchange交换机heima.bj.1的消息\"); rabbitTemplate.convertAndSend(\"spring_topic_exchange\", \"heima.bj.2\", \"发送到spring_topic_exchange交换机heima.bj.2的消息\"); rabbitTemplate.convertAndSend(\"spring_topic_exchange\", \"itcast.cn\", \"发送到spring_topic_exchange交换机itcast.cn的消息\"); } } 7.2. 5.2. 搭建消费者工程 7.2.1. 5.2.1. 创建工程 7.2.2. 5.2.2. 添加依赖 修改pom.xml文件内容为如下： 4.0.0 com.itheima spring-rabbitmq-consumer 1.0-SNAPSHOT org.springframework spring-context 5.1.7.RELEASE org.springframework.amqp spring-rabbit 2.1.8.RELEASE 7.2.3. 5.2.3. 配置整合 创建spring-rabbitmq-consumer\\src\\main\\resources\\properties\\rabbitmq.properties连接参数等配置文件； rabbitmq.host=192.168.12.135 rabbitmq.port=5672 rabbitmq.username=heima rabbitmq.password=heima rabbitmq.virtual-host=/itcast 创建 spring-rabbitmq-consumer\\src\\main\\resources\\spring\\spring-rabbitmq.xml 整合配置文件； 7.2.4. 5.2.4. 消息监听器 1）队列监听器 创建 spring-rabbitmq-consumer\\src\\main\\java\\com\\itheima\\rabbitmq\\listener\\SpringQueueListener.java public class SpringQueueListener implements MessageListener { public void onMessage(Message message) { try { String msg = new String(message.getBody(), \"utf-8\"); System.out.printf(\"接收路由名称为：%s，路由键为：%s，队列名为：%s的消息：%s \\n\", message.getMessageProperties().getReceivedExchange(), message.getMessageProperties().getReceivedRoutingKey(), message.getMessageProperties().getConsumerQueue(), msg); } catch (Exception e) { e.printStackTrace(); } } } 2）广播监听器1 创建 spring-rabbitmq-consumer\\src\\main\\java\\com\\itheima\\rabbitmq\\listener\\FanoutListener1.java public class FanoutListener1 implements MessageListener { public void onMessage(Message message) { try { String msg = new String(message.getBody(), \"utf-8\"); System.out.printf(\"广播监听器1：接收路由名称为：%s，路由键为：%s，队列名为：%s的消息：%s \\n\", message.getMessageProperties().getReceivedExchange(), message.getMessageProperties().getReceivedRoutingKey(), message.getMessageProperties().getConsumerQueue(), msg); } catch (Exception e) { e.printStackTrace(); } } } 3）广播监听器2 创建 spring-rabbitmq-consumer\\src\\main\\java\\com\\itheima\\rabbitmq\\listener\\FanoutListener2.java public class FanoutListener2 implements MessageListener { public void onMessage(Message message) { try { String msg = new String(message.getBody(), \"utf-8\"); System.out.printf(\"广播监听器2：接收路由名称为：%s，路由键为：%s，队列名为：%s的消息：%s \\n\", message.getMessageProperties().getReceivedExchange(), message.getMessageProperties().getReceivedRoutingKey(), message.getMessageProperties().getConsumerQueue(), msg); } catch (Exception e) { e.printStackTrace(); } } } 4）星号通配符监听器 创建 spring-rabbitmq-consumer\\src\\main\\java\\com\\itheima\\rabbitmq\\listener\\TopicListenerStar.java public class TopicListenerStar implements MessageListener { public void onMessage(Message message) { try { String msg = new String(message.getBody(), \"utf-8\"); System.out.printf(\"通配符*监听器：接收路由名称为：%s，路由键为：%s，队列名为：%s的消息：%s \\n\", message.getMessageProperties().getReceivedExchange(), message.getMessageProperties().getReceivedRoutingKey(), message.getMessageProperties().getConsumerQueue(), msg); } catch (Exception e) { e.printStackTrace(); } } } 5）井号通配符监听器 创建 spring-rabbitmq-consumer\\src\\main\\java\\com\\itheima\\rabbitmq\\listener\\TopicListenerWell.java public class TopicListenerWell implements MessageListener { public void onMessage(Message message) { try { String msg = new String(message.getBody(), \"utf-8\"); System.out.printf(\"通配符#监听器：接收路由名称为：%s，路由键为：%s，队列名为：%s的消息：%s \\n\", message.getMessageProperties().getReceivedExchange(), message.getMessageProperties().getReceivedRoutingKey(), message.getMessageProperties().getConsumerQueue(), msg); } catch (Exception e) { e.printStackTrace(); } } } 6）井号通配符监听器2 创建 spring-rabbitmq-consumer\\src\\main\\java\\com\\itheima\\rabbitmq\\listener\\TopicListenerWell2.java public class TopicListenerWell2 implements MessageListener { public void onMessage(Message message) { try { String msg = new String(message.getBody(), \"utf-8\"); System.out.printf(\"通配符#监听器2：接收路由名称为：%s，路由键为：%s，队列名为：%s的消息：%s \\n\", message.getMessageProperties().getReceivedExchange(), message.getMessageProperties().getReceivedRoutingKey(), message.getMessageProperties().getConsumerQueue(), msg); } catch (Exception e) { e.printStackTrace(); } } } 8. 6. Spring Boot整合RabbitMQ 8.1. 6.1. 简介 在Spring项目中，可以使用Spring-Rabbit去操作RabbitMQ https://github.com/spring-projects/spring-amqp 尤其是在spring boot项目中只需要引入对应的amqp启动器依赖即可，方便的使用RabbitTemplate发送消息，使用注解接收消息。 一般在开发过程中： 生产者工程： application.yml文件配置RabbitMQ相关信息； 在生产者工程中编写配置类，用于创建交换机和队列，并进行绑定 注入RabbitTemplate对象，通过RabbitTemplate对象发送消息到交换机 消费者工程： application.yml文件配置RabbitMQ相关信息 创建消息处理类，用于接收队列中的消息并进行处理 8.2. 5.2. 搭建生产者工程 8.2.1. 5.2.1. 创建工程 创建生产者工程springboot-rabbitmq-producer 8.2.2. 5.2.2. 添加依赖 修改pom.xml文件内容为如下： 4.0.0 org.springframework.boot spring-boot-starter-parent 2.1.4.RELEASE com.itheima springboot-rabbitmq-producer 1.0-SNAPSHOT org.springframework.boot spring-boot-starter-amqp org.springframework.boot spring-boot-starter-test 8.2.3. 5.2.3. 启动类 package com.itheima.rabbitmq; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; @SpringBootApplication public class ProducerApplication { public static void main(String[] args) { SpringApplication.run(ProducerApplication.class); } } 8.2.4. 5.2.4. 配置RabbitMQ 1）配置文件 创建application.yml，内容如下： spring: rabbitmq: host: localhost port: 5672 virtual-host: /itcast username: heima password: heima 2）绑定交换机和队列 创建RabbitMQ队列与交换机绑定的配置类com.itheima.rabbitmq.config.RabbitMQConfig package com.itheima.rabbitmq.config; import org.springframework.amqp.core.*; import org.springframework.beans.factory.annotation.Qualifier; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration public class RabbitMQConfig { //交换机名称 public static final String ITEM_TOPIC_EXCHANGE = \"item_topic_exchange\"; //队列名称 public static final String ITEM_QUEUE = \"item_queue\"; //声明交换机 @Bean(\"itemTopicExchange\") public Exchange topicExchange(){ return ExchangeBuilder.topicExchange(ITEM_TOPIC_EXCHANGE).durable(true).build(); } //声明队列 @Bean(\"itemQueue\") public Queue itemQueue(){ return QueueBuilder.durable(ITEM_QUEUE).build(); } //绑定队列和交换机 @Bean public Binding itemQueueExchange(@Qualifier(\"itemQueue\") Queue queue, @Qualifier(\"itemTopicExchange\") Exchange exchange){ return BindingBuilder.bind(queue).to(exchange).with(\"item.#\").noargs(); } } 8.3. 5.3. 搭建消费者工程 8.3.1. 5.3.1. 创建工程 创建消费者工程springboot-rabbitmq-consumer 8.3.2. 5.3.2. 添加依赖 修改pom.xml文件内容为如下： 4.0.0 org.springframework.boot spring-boot-starter-parent 2.1.4.RELEASE com.itheima springboot-rabbitmq-consumer 1.0-SNAPSHOT org.springframework.boot spring-boot-starter-amqp 8.3.3. 5.3.3. 启动类 package com.itheima.rabbitmq; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; @SpringBootApplication public class ConsumerApplication { public static void main(String[] args) { SpringApplication.run(ConsumerApplication.class); } } 8.3.4. 5.3.4. 配置RabbitMQ 创建application.yml，内容如下： spring: rabbitmq: host: localhost port: 5672 virtual-host: /itcast username: heima password: heima 8.3.5. 5.3.5. 消息监听处理类 编写消息监听器com.itheima.rabbitmq.listener.MyListener package com.itheima.rabbitmq.listener; import org.springframework.amqp.rabbit.annotation.RabbitListener; import org.springframework.stereotype.Component; @Component public class MyListener { /** * 监听某个队列的消息 * @param message 接收到的消息 */ @RabbitListener(queues = \"item_queue\") public void myListener1(String message){ System.out.println(\"消费者接收到的消息为：\" + message); } } 8.4. 5.4. 测试 在生产者工程springboot-rabbitmq-producer中创建测试类，发送消息： package com.itheima.rabbitmq; import com.itheima.rabbitmq.config.RabbitMQConfig; import org.junit.Test; import org.junit.runner.RunWith; import org.springframework.amqp.rabbit.core.RabbitTemplate; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; import org.springframework.test.context.junit4.SpringRunner; @RunWith(SpringRunner.class) @SpringBootTest public class RabbitMQTest { @Autowired private RabbitTemplate rabbitTemplate; @Test public void test(){ rabbitTemplate.convertAndSend(RabbitMQConfig.ITEM_TOPIC_EXCHANGE, \"item.insert\", \"商品新增，routing key 为item.insert\"); rabbitTemplate.convertAndSend(RabbitMQConfig.ITEM_TOPIC_EXCHANGE, \"item.update\", \"商品修改，routing key 为item.update\"); rabbitTemplate.convertAndSend(RabbitMQConfig.ITEM_TOPIC_EXCHANGE, \"item.delete\", \"商品删除，routing key 为item.delete\"); } } 先运行上述测试程序（交换机和队列才能先被声明和绑定），然后启动消费者；在消费者工程springboot-rabbitmq-consumer中控制台查看是否接收到对应消息。 另外；也可以在RabbitMQ的管理控制台中查看到交换机与队列的绑定： Copyright © MISIN 2022 | 豫ICP备2021006345号-1 all right reserved，powered by Gitbook该文件修订时间： 2022-11-10 11:29:30 "},"4.流行框架/4.RabbitMQ/RabbitMQ安装说明文档.html":{"url":"4.流行框架/4.RabbitMQ/RabbitMQ安装说明文档.html","title":"RabbitMQ安装说明文档","keywords":"","body":"1.1.1. 注意: 请使用资料里提供的CentOS-7-x86_64-DVD-1810.iso 安装虚拟机.1.2. 1. 安装依赖环境1.3. 2. 安装Erlang1.4. 3. 安装RabbitMQ1.5. 4. 开启管理界面及配置1.6. 5. 启动1.7. 6. 配置虚拟主机及用户1.7.1. 6.1. 用户角色1.7.2. 6.2. Virtual Hosts配置1.1.1. 注意: 请使用资料里提供的CentOS-7-x86_64-DVD-1810.iso 安装虚拟机. 1.2. 1. 安装依赖环境 在线安装依赖环境： yum install build-essential openssl openssl-devel unixODBC unixODBC-devel make gcc gcc-c++ kernel-devel m4 ncurses-devel tk tc xz 1.3. 2. 安装Erlang 上传 erlang-18.3-1.el7.centos.x86_64.rpm socat-1.7.3.2-5.el7.lux.x86_64.rpm rabbitmq-server-3.6.5-1.noarch.rpm # 安装 rpm -ivh erlang-18.3-1.el7.centos.x86_64.rpm 如果出现如下错误 说明gblic 版本太低。我们可以查看当前机器的gblic 版本 strings /lib64/libc.so.6 | grep GLIBC 当前最高版本2.12，需要2.15.所以需要升级glibc 使用yum更新安装依赖 sudo yum install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gcc make -y 下载rpm包 wget http://copr-be.cloud.fedoraproject.org/results/mosquito/myrepo-el6/epel-6-x86_64/glibc-2.17-55.fc20/glibc-utils-2.17-55.el6.x86_64.rpm & wget http://copr-be.cloud.fedoraproject.org/results/mosquito/myrepo-el6/epel-6-x86_64/glibc-2.17-55.fc20/glibc-static-2.17-55.el6.x86_64.rpm & wget http://copr-be.cloud.fedoraproject.org/results/mosquito/myrepo-el6/epel-6-x86_64/glibc-2.17-55.fc20/glibc-2.17-55.el6.x86_64.rpm & wget http://copr-be.cloud.fedoraproject.org/results/mosquito/myrepo-el6/epel-6-x86_64/glibc-2.17-55.fc20/glibc-common-2.17-55.el6.x86_64.rpm & wget http://copr-be.cloud.fedoraproject.org/results/mosquito/myrepo-el6/epel-6-x86_64/glibc-2.17-55.fc20/glibc-devel-2.17-55.el6.x86_64.rpm & wget http://copr-be.cloud.fedoraproject.org/results/mosquito/myrepo-el6/epel-6-x86_64/glibc-2.17-55.fc20/glibc-headers-2.17-55.el6.x86_64.rpm & wget http://copr-be.cloud.fedoraproject.org/results/mosquito/myrepo-el6/epel-6-x86_64/glibc-2.17-55.fc20/nscd-2.17-55.el6.x86_64.rpm & 安装rpm包 sudo rpm -Uvh *-2.17-55.el6.x86_64.rpm —force —nodeps 安装完毕后再查看glibc版本,发现glibc版本已经到2.17了 strings /lib64/libc.so.6 | grep GLIBC 1.4. 3. 安装RabbitMQ # 安装 rpm -ivh socat-1.7.3.2-5.el7.lux.x86_64.rpm # 安装 rpm -ivh rabbitmq-server-3.6.5-1.noarch.rpm 1.5. 4. 开启管理界面及配置 # 开启管理界面 rabbitmq-plugins enable rabbitmq_management # 修改默认配置信息 vim /usr/lib/rabbitmq/lib/rabbitmq_server-3.6.5/ebin/rabbit.app # 比如修改密码、配置等等，例如：loopback_users 中的 >,只保留guest 1.6. 5. 启动 service rabbitmq-server start # 启动服务 service rabbitmq-server stop # 停止服务 service rabbitmq-server restart # 重启服务 设置配置文件 cd /usr/share/doc/rabbitmq-server-3.6.5/ cp rabbitmq.config.example /etc/rabbitmq/rabbitmq.config 1.7. 6. 配置虚拟主机及用户 1.7.1. 6.1. 用户角色 RabbitMQ在安装好后，可以访问http://ip地址:15672 ；其自带了guest/guest的用户名和密码；如果需要创建自定义用户；那么也可以登录管理界面后，如下操作： 角色说明： 1、 超级管理员(administrator) 可登陆管理控制台，可查看所有的信息，并且可以对用户，策略(policy)进行操作。 2、 监控者(monitoring) 可登陆管理控制台，同时可以查看rabbitmq节点的相关信息(进程数，内存使用情况，磁盘使用情况等) 3、 策略制定者(policymaker) 可登陆管理控制台, 同时可以对policy进行管理。但无法查看节点的相关信息(上图红框标识的部分)。 4、 普通管理者(management) 仅可登陆管理控制台，无法看到节点信息，也无法对策略进行管理。 5、 其他 无法登陆管理控制台，通常就是普通的生产者和消费者。 1.7.2. 6.2. Virtual Hosts配置 像mysql拥有数据库的概念并且可以指定用户对库和表等操作的权限。RabbitMQ也有类似的权限管理；在RabbitMQ中可以虚拟消息服务器Virtual Host，每个Virtual Hosts相当于一个相对独立的RabbitMQ服务器，每个VirtualHost之间是相互隔离的。exchange、queue、message不能互通。 相当于mysql的db。Virtual Name一般以/开头。 6.2.1. 创建Virtual Hosts 6.2.2. 设置Virtual Hosts权限 Copyright © MISIN 2022 | 豫ICP备2021006345号-1 all right reserved，powered by Gitbook该文件修订时间： 2022-11-10 14:03:10 "},"4.流行框架/4.RabbitMQ/RabbitMQ集群搭建.html":{"url":"4.流行框架/4.RabbitMQ/RabbitMQ集群搭建.html","title":"RabbitMQ集群搭建","keywords":"","body":"1. 3.RabbitMQ集群搭建1.1.1. 3.1 集群方案的原理1.1.2. 3.2 单机多实例部署1.1.3. 3.3 集群管理1.1.4. 3.4 RabbitMQ镜像集群配置1.1.5. 3.5 负载均衡-HAProxy1. 3.RabbitMQ集群搭建 摘要：实际生产应用中都会采用消息队列的集群方案，如果选择RabbitMQ那么有必要了解下它的集群方案原理 一般来说，如果只是为了学习RabbitMQ或者验证业务工程的正确性那么在本地环境或者测试环境上使用其单实例部署就可以了，但是出于MQ中间件本身的可靠性、并发性、吞吐量和消息堆积能力等问题的考虑，在生产环境上一般都会考虑使用RabbitMQ的集群方案。 1.1.1. 3.1 集群方案的原理 RabbitMQ这款消息队列中间件产品本身是基于Erlang编写，Erlang语言天生具备分布式特性（通过同步Erlang集群各节点的magic cookie来实现）。因此，RabbitMQ天然支持Clustering。这使得RabbitMQ本身不需要像ActiveMQ、Kafka那样通过ZooKeeper分别来实现HA方案和保存集群的元数据。集群是保证可靠性的一种方式，同时可以通过水平扩展以达到增加消息吞吐量能力的目的。 1.1.2. 3.2 单机多实例部署 由于某些因素的限制，有时候你不得不在一台机器上去搭建一个rabbitmq集群，这个有点类似zookeeper的单机版。真实生成环境还是要配成多机集群的。有关怎么配置多机集群的可以参考其他的资料，这里主要论述如何在单机中配置多个rabbitmq实例。 主要参考官方文档：https://www.rabbitmq.com/clustering.html 首先确保RabbitMQ运行没有问题 [root@super ~]# rabbitmqctl status Status of node rabbit@super ... [{pid,10232}, {running_applications, [{rabbitmq_management,”RabbitMQ Management Console”,”3.6.5”}, {rabbitmq_web_dispatch,”RabbitMQ Web Dispatcher”,”3.6.5”}, {webmachine,”webmachine”,”1.10.3”}, {mochiweb,”MochiMedia Web Server”,”2.13.1”}, {rabbitmq_management_agent,”RabbitMQ Management Agent”,”3.6.5”}, {rabbit,”RabbitMQ”,”3.6.5”}, {os_mon,”CPO CXC 138 46”,”2.4”}, {syntax_tools,”Syntax tools”,”1.7”}, {inets,”INETS CXC 138 49”,”6.2”}, {amqp_client,”RabbitMQ AMQP Client”,”3.6.5”}, {rabbit_common,[],”3.6.5”}, {ssl,”Erlang/OTP SSL application”,”7.3”}, {public_key,”Public key infrastructure”,”1.1.1”}, {asn1,”The Erlang ASN1 compiler version 4.0.2”,”4.0.2”}, {ranch,”Socket acceptor pool for TCP protocols.”,”1.2.1”}, {mnesia,”MNESIA CXC 138 12”,”4.13.3”}, {compiler,”ERTS CXC 138 10”,”6.0.3”}, {crypto,”CRYPTO”,”3.6.3”}, {xmerl,”XML parser”,”1.3.10”}, {sasl,”SASL CXC 138 11”,”2.7”}, {stdlib,”ERTS CXC 138 10”,”2.8”}, {kernel,”ERTS CXC 138 10”,”4.2”}]}, {os,{unix,linux}}, {erlang_version, “Erlang/OTP 18 [erts-7.3] [source] [64-bit] [async-threads:64] [hipe] [kernel-poll:true]\\n”}, {memory, [{total,56066752}, {connection_readers,0}, {connection_writers,0}, {connection_channels,0}, {connection_other,2680}, {queue_procs,268248}, {queue_slave_procs,0}, {plugins,1131936}, {other_proc,18144280}, {mnesia,125304}, {mgmt_db,921312}, {msg_index,69440}, {other_ets,1413664}, {binary,755736}, {code,27824046}, {atom,1000601}, {other_system,4409505}]}, {alarms,[]}, {listeners,[{clustering,25672,”::”},{amqp,5672,”::”}]}, {vm_memory_high_watermark,0.4}, {vm_memory_limit,411294105}, {disk_free_limit,50000000}, {disk_free,13270233088}, {file_descriptors, [{total_limit,924},{total_used,6},{sockets_limit,829},{sockets_used,0}]}, {processes,[{limit,1048576},{used,262}]}, {run_queue,0}, {uptime,43651}, {kernel,{net_ticktime,60}}] 停止rabbitmq服务 [root@super sbin]# service rabbitmq-server stop Stopping rabbitmq-server: rabbitmq-server. 启动第一个节点： [root@super sbin]# RABBITMQ_NODE_PORT=5673 RABBITMQ_NODENAME=rabbit1 rabbitmq-server start RabbitMQ 3.6.5. Copyright (C) 2007-2016 Pivotal Software, Inc. ## ## Licensed under the MPL. See http://www.rabbitmq.com/ ## ## ########## Logs: /var/log/rabbitmq/rabbit1.log ###### ## /var/log/rabbitmq/rabbit1-sasl.log ########## Starting broker... completed with 6 plugins. 启动第二个节点： web管理插件端口占用,所以还要指定其web插件占用的端口号。 [root@super ~]# RABBITMQ_NODE_PORT=5674 RABBITMQ_SERVER_START_ARGS=“-rabbitmq_management listener [{port,15674}]” RABBITMQ_NODENAME=rabbit2 rabbitmq-server start RabbitMQ 3.6.5. Copyright (C) 2007-2016 Pivotal Software, Inc. ## ## Licensed under the MPL. See http://www.rabbitmq.com/ ## ## ########## Logs: /var/log/rabbitmq/rabbit2.log ###### ## /var/log/rabbitmq/rabbit2-sasl.log ########## Starting broker... completed with 6 plugins. 结束命令： rabbitmqctl -n rabbit1 stop rabbitmqctl -n rabbit2 stop rabbit1操作作为主节点： [root@super ~]# rabbitmqctl -n rabbit1 stop_app Stopping node rabbit1@super ... [root@super ~]# rabbitmqctl -n rabbit1 reset Resetting node rabbit1@super ... [root@super ~]# rabbitmqctl -n rabbit1 start_app Starting node rabbit1@super ... [root@super ~]# rabbit2操作为从节点： [root@super ~]# rabbitmqctl -n rabbit2 stop_app Stopping node rabbit2@super ... [root@super ~]# rabbitmqctl -n rabbit2 reset Resetting node rabbit2@super ... [root@super ~]# rabbitmqctl -n rabbit2 join_cluster rabbit1@‘super’ ###’’内是主机名换成自己的 Clustering node rabbit2@super with rabbit1@super ... [root@super ~]# rabbitmqctl -n rabbit2 start_app Starting node rabbit2@super ... 查看集群状态： [root@super ~]# rabbitmqctl cluster_status -n rabbit1 Cluster status of node rabbit1@super ... [{nodes,[{disc,[rabbit1@super,rabbit2@super]}]}, {running_nodes,[rabbit2@super,rabbit1@super]}, {cluster_name,>}, {partitions,[]}, {alarms,[{rabbit2@super,[]},{rabbit1@super,[]}]}] web监控： 1.1.3. 3.3 集群管理 rabbitmqctl join_cluster {cluster_node} [–ram] 将节点加入指定集群中。在这个命令执行前需要停止RabbitMQ应用并重置节点。 rabbitmqctl cluster_status 显示集群的状态。 rabbitmqctl change_cluster_node_type {disc|ram} 修改集群节点的类型。在这个命令执行前需要停止RabbitMQ应用。 rabbitmqctl forget_cluster_node [–offline] 将节点从集群中删除，允许离线执行。 rabbitmqctl update_cluster_nodes {clusternode} 在集群中的节点应用启动前咨询clusternode节点的最新信息，并更新相应的集群信息。这个和join_cluster不同，它不加入集群。考虑这样一种情况，节点A和节点B都在集群中，当节点A离线了，节点C又和节点B组成了一个集群，然后节点B又离开了集群，当A醒来的时候，它会尝试联系节点B，但是这样会失败，因为节点B已经不在集群中了。 rabbitmqctl cancel_sync_queue [-p vhost] {queue} 取消队列queue同步镜像的操作。 rabbitmqctl set_cluster_name {name} 设置集群名称。集群名称在客户端连接时会通报给客户端。Federation和Shovel插件也会有用到集群名称的地方。集群名称默认是集群中第一个节点的名称，通过这个命令可以重新设置。 1.1.4. 3.4 RabbitMQ镜像集群配置 上面已经完成RabbitMQ默认集群模式，但并不保证队列的高可用性，尽管交换机、绑定这些可以复制到集群里的任何一个节点，但是队列内容不会复制。虽然该模式解决一项目组节点压力，但队列节点宕机直接导致该队列无法应用，只能等待重启，所以要想在队列节点宕机或故障也能正常应用，就要复制队列内容到集群里的每个节点，必须要创建镜像队列。 镜像队列是基于普通的集群模式的，然后再添加一些策略，所以你还是得先配置普通集群，然后才能设置镜像队列，我们就以上面的集群接着做。 设置的镜像队列可以通过开启的网页的管理端Admin->Policies，也可以通过命令。 rabbitmqctl set_policy my_ha “^” ‘{“ha-mode”:”all”}’ Name:策略名称 Pattern：匹配的规则，如果是匹配所有的队列，是^. Definition:使用ha-mode模式中的all，也就是同步所有匹配的队列。问号链接帮助文档。 1.1.5. 3.5 负载均衡-HAProxy HAProxy提供高可用性、负载均衡以及基于TCP和HTTP应用的代理，支持虚拟主机，它是免费、快速并且可靠的一种解决方案,包括Twitter，Reddit，StackOverflow，GitHub在内的多家知名互联网公司在使用。HAProxy实现了一种事件驱动、单一进程模型，此模型支持非常大的并发连接数。 3.5.1 安装HAProxy //下载依赖包 yum install gcc vim wget //上传haproxy源码包 //解压 tar -zxvf haproxy-1.6.5.tar.gz -C /usr/local //进入目录、进行编译、安装 cd /usr/local/haproxy-1.6.5 make TARGET=linux31 PREFIX=/usr/local/haproxy make install PREFIX=/usr/local/haproxy mkdir /etc/haproxy //赋权 groupadd -r -g 149 haproxy useradd -g haproxy -r -s /sbin/nologin -u 149 haproxy //创建haproxy配置文件 mkdir /etc/haproxy vim /etc/haproxy/haproxy.cfg 3.5.2 配置HAProxy 配置文件路径：/etc/haproxy/haproxy.cfg #logging options global log 127.0.0.1 local0 info maxconn 5120 chroot /usr/local/haproxy uid 99 gid 99 daemon quiet nbproc 20 pidfile /var/run/haproxy.pid defaults log global mode tcp option tcplog option dontlognull retries 3 option redispatch maxconn 2000 contimeout 5s clitimeout 60s srvtimeout 15s #front-end IP for consumers and producters listen rabbitmq_cluster bind 0.0.0.0:5672 mode tcp #balance url_param userid #balance url_param session_id check_post 64 #balance hdr(User-Agent) #balance hdr(host) #balance hdr(Host) use_domain_only #balance rdp-cookie #balance leastconn #balance source //ip balance roundrobin server node1 127.0.0.1:5673 check inter 5000 rise 2 fall 2 server node2 127.0.0.1:5674 check inter 5000 rise 2 fall 2 listen stats bind 172.16.98.133:8100 mode http option httplog stats enable stats uri /rabbitmq-stats stats refresh 5s 启动HAproxy负载 /usr/local/haproxy/sbin/haproxy -f /etc/haproxy/haproxy.cfg //查看haproxy进程状态 ps -ef | grep haproxy 访问如下地址对mq节点进行监控 http://172.16.98.133:8100/rabbitmq-stats 代码中访问mq集群地址，则变为访问haproxy地址:5672 Copyright © MISIN 2022 | 豫ICP备2021006345号-1 all right reserved，powered by Gitbook该文件修订时间： 2022-11-10 14:03:40 "},"4.流行框架/5.docker/docker 私有仓库.html":{"url":"4.流行框架/5.docker/docker 私有仓库.html","title":"docker 私有仓库","keywords":"","body":"1.1. Docker 私有仓库1.1.1. 一、私有仓库搭建1.1.2. 二、将镜像上传至私有仓库1.1.3. 三、 从私有仓库拉取镜像1.1. Docker 私有仓库 1.1.1. 一、私有仓库搭建 # 1、拉取私有仓库镜像 docker pull registry # 2、启动私有仓库容器 docker run -id --name=registry -p 5000:5000 registry # 3、打开浏览器 输入地址http://私有仓库服务器ip:5000/v2/_catalog，看到{\"repositories\":[]} 表示私有仓库 搭建成功 # 4、修改daemon.json vim /etc/docker/daemon.json # 在上述文件中添加一个key，保存退出。此步用于让 docker 信任私有仓库地址；注意将私有仓库服务器ip修改为自己私有仓库服务器真实ip {\"insecure-registries\":[\"私有仓库服务器ip:5000\"]} # 5、重启docker 服务 systemctl restart docker docker start registry 1.1.2. 二、将镜像上传至私有仓库 # 1、标记镜像为私有仓库的镜像 docker tag centos:7 私有仓库服务器IP:5000/centos:7 # 2、上传标记的镜像 docker push 私有仓库服务器IP:5000/centos:7 1.1.3. 三、 从私有仓库拉取镜像 #拉取镜像 docker pull 私有仓库服务器ip:5000/centos:7 Copyright © MISIN 2022 | 豫ICP备2021006345号-1 all right reserved，powered by Gitbook该文件修订时间： 2019-12-13 16:02:18 "},"4.流行框架/5.docker/docker-compose.html":{"url":"4.流行框架/5.docker/docker-compose.html","title":"Docker Compose","keywords":"","body":"1.1. Docker Compose1.1.1. 一、安装Docker Compose1.1.2. 二、卸载Docker Compose1.1.3. 三、 使用docker compose编排nginx+springboot项目1.1. Docker Compose 1.1.1. 一、安装Docker Compose # Compose目前已经完全支持Linux、Mac OS和Windows，在我们安装Compose之前，需要先安装Docker。下面我 们以编译好的二进制包方式安装在Linux系统中。 curl -L https://github.com/docker/compose/releases/download/1.22.0/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose # 设置文件可执行权限 chmod +x /usr/local/bin/docker-compose # 查看版本信息 docker-compose -version 1.1.2. 二、卸载Docker Compose # 二进制包方式安装的，删除二进制文件即可 rm /usr/local/bin/docker-compose 1.1.3. 三、 使用docker compose编排nginx+springboot项目 创建docker-compose目录 mkdir ~/docker-compose cd ~/docker-compose 编写 docker-compose.yml 文件 version: '3' services: nginx: image: nginx ports: - 80:80 links: - app volumes: - ./nginx/conf.d:/etc/nginx/conf.d app: image: app expose: - \"8080\" 创建./nginx/conf.d目录 mkdir -p ./nginx/conf.d 在./nginx/conf.d目录下 编写itheima.conf文件 server { listen 80; access_log off; location / { proxy_pass http://app:8080; } } 在~/docker-compose 目录下 使用docker-compose 启动容器 docker-compose up 测试访问 http://192.168.149.135/hello Copyright © MISIN 2022 | 豫ICP备2021006345号-1 all right reserved，powered by Gitbook该文件修订时间： 2019-12-13 16:02:18 "},"4.流行框架/5.docker/dockerfile.html":{"url":"4.流行框架/5.docker/dockerfile.html","title":"Dockerfile","keywords":"","body":"1.1. Dockerfile1.1. Dockerfile 关键字 作用 备注 FROM 指定父镜像 指定dockerfile基于那个image构建 MAINTAINER 作者信息 用来标明这个dockerfile谁写的 LABEL 标签 用来标明dockerfile的标签 可以使用Label代替Maintainer 最终都是在docker image基本信息中可以查看 RUN 执行命令 执行一段命令 默认是/bin/sh 格式: RUN command 或者 RUN [\"command\" , \"param1\",\"param2\"] CMD 容器启动命令 提供启动容器时候的默认命令 和ENTRYPOINT配合使用.格式 CMD command param1 param2 或者 CMD [\"command\" , \"param1\",\"param2\"] ENTRYPOINT 入口 一般在制作一些执行就关闭的容器中会使用 COPY 复制文件 build的时候复制文件到image中 ADD 添加文件 build的时候添加文件到image中 不仅仅局限于当前build上下文 可以来源于远程服务 ENV 环境变量 指定build时候的环境变量 可以在启动的容器的时候 通过-e覆盖 格式ENV name=value ARG 构建参数 构建参数 只在构建的时候使用的参数 如果有ENV 那么ENV的相同名字的值始终覆盖arg的参数 VOLUME 定义外部可以挂载的数据卷 指定build的image那些目录可以启动的时候挂载到文件系统中 启动容器的时候使用 -v 绑定 格式 VOLUME [\"目录\"] EXPOSE 暴露端口 定义容器运行的时候监听的端口 启动容器的使用-p来绑定暴露端口 格式: EXPOSE 8080 或者 EXPOSE 8080/udp WORKDIR 工作目录 指定容器内部的工作目录 如果没有创建则自动创建 如果指定/ 使用的是绝对地址 如果不是/开头那么是在上一条workdir的路径的相对路径 USER 指定执行用户 指定build或者启动的时候 用户 在RUN CMD ENTRYPONT执行的时候的用户 HEALTHCHECK 健康检查 指定监测当前容器的健康监测的命令 基本上没用 因为很多时候 应用本身有健康监测机制 ONBUILD 触发器 当存在ONBUILD关键字的镜像作为基础镜像的时候 当执行FROM完成之后 会执行 ONBUILD的命令 但是不影响当前镜像 用处也不怎么大 STOPSIGNAL 发送信号量到宿主机 该STOPSIGNAL指令设置将发送到容器的系统调用信号以退出。 SHELL 指定执行脚本的shell 指定RUN CMD ENTRYPOINT 执行命令的时候 使用的shell Copyright © MISIN 2022 | 豫ICP备2021006345号-1 all right reserved，powered by Gitbook该文件修订时间： 2019-12-13 16:02:20 "},"4.流行框架/5.docker/docker应用部署.html":{"url":"4.流行框架/5.docker/docker应用部署.html","title":"docker应用部署","keywords":"","body":"1.1. Docker 应用部署1.1.1. 一、部署MySQL1.1.2. 二、部署Tomcat1.1.3. 三、部署Nginx1.1.4. 四、部署Redis1.1. Docker 应用部署 1.1.1. 一、部署MySQL 搜索mysql镜像 docker search mysql 拉取mysql镜像 docker pull mysql:5.6 创建容器，设置端口映射、目录映射 # 在/root目录下创建mysql目录用于存储mysql数据信息 mkdir ~/mysql cd ~/mysql docker run -id \\ -p 3307:3306 \\ —name=c_mysql \\ -v $PWD/conf:/etc/mysql/conf.d \\ -v $PWD/logs:/logs \\ -v $PWD/data:/var/lib/mysql \\ -e MYSQL_ROOT_PASSWORD=123456 \\ mysql:5.6 参数说明： -p 3307:3306：将容器的 3306 端口映射到宿主机的 3307 端口。 -v $PWD/conf:/etc/mysql/conf.d：将主机当前目录下的 conf/my.cnf 挂载到容器的 /etc/mysql/my.cnf。配置目录 -v $PWD/logs:/logs：将主机当前目录下的 logs 目录挂载到容器的 /logs。日志目录 -v $PWD/data:/var/lib/mysql ：将主机当前目录下的data目录挂载到容器的 /var/lib/mysql 。数据目录 -e MYSQL_ROOT_PASSWORD=123456：初始化 root 用户的密码。 进入容器，操作mysql docker exec –it c_mysql /bin/bash 使用外部机器连接容器中的mysql 1.1.2. 二、部署Tomcat 搜索tomcat镜像 docker search tomcat 拉取tomcat镜像 docker pull tomcat 创建容器，设置端口映射、目录映射 # 在/root目录下创建tomcat目录用于存储tomcat数据信息 mkdir ~/tomcat cd ~/tomcat docker run -id —name=c_tomcat \\ -p 8080:8080 \\ -v $PWD:/usr/local/tomcat/webapps \\ tomcat 参数说明： -p 8080:8080：将容器的8080端口映射到主机的8080端口 -v $PWD:/usr/local/tomcat/webapps：将主机中当前目录挂载到容器的webapps 使用外部机器访问tomcat 1.1.3. 三、部署Nginx 搜索nginx镜像 docker search nginx 拉取nginx镜像 docker pull nginx 创建容器，设置端口映射、目录映射 # 在/root目录下创建nginx目录用于存储nginx数据信息 mkdir ~/nginx cd ~/nginx mkdir conf cd conf # 在~/nginx/conf/下创建nginx.conf文件,粘贴下面内容 vim nginx.conf user nginx; worker_processes 1; error_log /var/log/nginx/error.log warn; pid /var/run/nginx.pid; events { worker_connections 1024; } http { include /etc/nginx/mime.types; default_type application/octet-stream; log_format main ‘$remote_addr - $remote_user [$time_local] “$request” ‘ ‘$status $body_bytes_sent “$http_referer” ‘ ‘”$http_user_agent” “$http_x_forwarded_for”’; access_log /var/log/nginx/access.log main; sendfile on; #tcp_nopush on; keepalive_timeout 65; #gzip on; include /etc/nginx/conf.d/*.conf; } docker run -id —name=c_nginx \\ -p 80:80 \\ -v $PWD/conf/nginx.conf:/etc/nginx/nginx.conf \\ -v $PWD/logs:/var/log/nginx \\ -v $PWD/html:/usr/share/nginx/html \\ nginx 参数说明： -p 80:80：将容器的 80端口映射到宿主机的 80 端口。 -v $PWD/conf/nginx.conf:/etc/nginx/nginx.conf：将主机当前目录下的 /conf/nginx.conf 挂载到容器的 :/etc/nginx/nginx.conf。配置目录 -v $PWD/logs:/var/log/nginx：将主机当前目录下的 logs 目录挂载到容器的/var/log/nginx。日志目录 使用外部机器访问nginx 1.1.4. 四、部署Redis 搜索redis镜像 docker search redis 拉取redis镜像 docker pull redis:5.0 创建容器，设置端口映射 docker run -id --name=c_redis -p 6379:6379 redis:5.0 使用外部机器连接redis ./redis-cli.exe -h 192.168.149.135 -p 6379 Copyright © MISIN 2022 | 豫ICP备2021006345号-1 all right reserved，powered by Gitbook该文件修订时间： 2022-11-10 14:05:39 "},"4.流行框架/5.docker/安装docker.html":{"url":"4.流行框架/5.docker/安装docker.html","title":"安装docker","keywords":"","body":"1.1.1. 一、安装Docker1.1.1. 一、安装Docker # 1、yum 包更新到最新 yum update # 2、安装需要的软件包， yum-util 提供yum-config-manager功能，另外两个是devicemapper驱动依赖的 yum install -y yum-utils device-mapper-persistent-data lvm2 # 3、 设置yum源 yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo # 4、 安装docker，出现输入的界面都按 y yum install -y docker-ce # 5、 查看docker版本，验证是否验证成功 docker -v Copyright © MISIN 2022 | 豫ICP备2021006345号-1 all right reserved，powered by Gitbook该文件修订时间： 2019-12-13 16:02:20 "},"4.流行框架/6.ElasticSearch/day01资料/Elasticsearch 安装.html":{"url":"4.流行框架/6.ElasticSearch/day01资料/Elasticsearch 安装.html","title":"Elasticsearch 安装","keywords":"","body":"1. 1 ElasticSearch 安装1.1. 1.1 ElasticSearch安装1.2. 1.2 访问elasticsearch2. 2 Elasticsearch辅助插件安装2.1. 2.1 Postman安装2.2. 2.2 Kibana安装2.3. 2.3 head安装2.3.1. 2.3.1 Node安装2.3.2. 2.3.2 grunt安装2.3.3. 2.3.3 head安装1. 1 ElasticSearch 安装 1.1. 1.1 ElasticSearch安装 1、上传ElasticSearch安装包 alt+p # 打开sftp窗口 # 上传es安装包 put e:/software/elasticsearch-7.4.0-linux-x86_64.tar.gz 2、执行解压操作 ，如下图 # 将elasticsearch-7.4.0-linux-x86_64.tar.gz解压到opt文件夹下. -C 大写 tar -zxvf elasticsearch-7.4.0-linux-x86_64.tar.gz -C /opt 3、创建普通用户 因为安全问题，Elasticsearch 不允许root用户直接运行，所以要创建新用户，在root用户中创建新用户,执行如下命令： useradd itheima # 新增itheima用户 passwd itheima # 为itheima用户设置密码 5、为新用户授权，如下图 chown -R itheima:itheima /opt/elasticsearch-7.4.0 #文件夹所有者 将 /opt/elasticsearch-7.4.0文件夹授权给itheima用户，由上图可见，我们的文件夹权限赋给了itheima 6、修改elasticsearch.yml文件 vim /opt/elasticsearch-7.4.0/config/elasticsearch.yml # ======================== Elasticsearch Configuration ========================= cluster.name: my-application node.name: node-1 network.host: 0.0.0.0 http.port: 9200 cluster.initial_master_nodes: [\"node-1\"] cluster.name：配置elasticsearch的集群名称，默认是elasticsearch。建议修改成一个有意义的名称 node.name：节点名，elasticsearch会默认随机指定一个名字，建议指定一个有意义的名称，方便管理 network.host：设置为0.0.0.0允许外网访问 http.port：Elasticsearch的http访问端口 cluster.initial_master_nodes：初始化新的集群时需要此配置来选举master 7、修改配置文件 新创建的itheima用户最大可创建文件数太小，最大虚拟内存太小，切换到root用户，编辑下列配置文件， 添加类似如下内容 # 切换到root用户 su root #1. ===最大可创建文件数太小======= vim /etc/security/limits.conf # 在文件末尾中增加下面内容 itheima soft nofile 65536 itheima hard nofile 65536 # ===== vim /etc/security/limits.d/20-nproc.conf # 在文件末尾中增加下面内容 itheima soft nofile 65536 itheima hard nofile 65536 * hard nproc 4096 # 注：* 代表Linux所有用户名称 #2. ===最大虚拟内存太小======= vim /etc/sysctl.conf # 在文件中增加下面内容 vm.max_map_count=655360 # 重新加载，输入下面命令： sysctl -p 8、启动elasticsearch su itheima # 切换到itheima用户启动 cd /opt/elasticsearch-7.4.0/bin ./elasticsearch #启动 通过上图我们可以看到elasticsearch已经成功启动 1.2. 1.2 访问elasticsearch 1、在访问elasticsearch前，请确保防火墙是关闭的，执行命令： #暂时关闭防火墙 systemctl stop firewalld # 或者 #永久设置防火墙状态 systemctl enable firewalld.service #打开防火墙永久性生效，重启后不会复原 systemctl disable firewalld.service #关闭防火墙，永久性生效，重启后不会复原 浏览器输入http://192.168.149.135:9200/，如下图 此时elasticsearch已成功启动： 重点几个关注下即可: number\" : \"7.4.0\" 表示elasticsearch版本 lucene_version\" : \"8.2.0\" 表示lucene版本 name ： 默认启动的时候指定了 ES 实例名称 cluster_name ： 默认名为 elasticsearch 2. 2 Elasticsearch辅助插件安装 2.1. 2.1 Postman安装 1、什么是Postman Postman是一个http模拟请求的工具。 官网介绍：“Modern software is built on APIs，Postman helps you develop APIs faster” 看得出来，它是一个专门测试 API 的工具，Postman 提供功能强大的 Web API 和 HTTP 请求的调试，它能够发送任何类型的HTTP 请求 (GET, POST, PUT, DELETE…)，并且能附带任何数量的参数和 Headers。不仅如此，它还提供测试数据和环境配置数据的导入导出。 进入官网www.getpostman.com，下载 2.2. 2.2 Kibana安装 1、什么是Kibana Kibana是一个针对Elasticsearch的开源分析及可视化平台，用来搜索、查看交互存储在Elasticsearch索引中的数据。使用Kibana，可以通过各种图表进行高级数据分析及展示。 Kibana让海量数据更容易理解。它操作简单，基于浏览器的用户界面可以快速创建仪表板（dashboard）实时显示Elasticsearch查询动态。 2、上传kibana CRT中克隆一个窗口，上传Kibana put ‪E:\\software\\kibana-7.4.0-linux-x86_64.tar.gz 2、解压kibana tar -xzf kibana-7.4.0-linux-x86_64.tar.gz -C /opt 解压到当前目录（/opt）下 3、修改kibana配置 vim /opt/kibana-7.4.0-linux-x86_64/config/kibana.yml server.port: 5601 server.host: \"0.0.0.0\" server.name: \"kibana-itcast\" elasticsearch.hosts: [\"http://127.0.0.1:9200\"] elasticsearch.requestTimeout: 99999 server.port：http访问端口 server.host：ip地址，0.0.0.0表示可远程访问 server.name：kibana服务名 elasticsearch.hosts：elasticsearch地址 elasticsearch.requestTimeout：请求elasticsearch超时时间，默认为30000，此处可根据情况设置 4、启动kibana 由于kibana不建议使用root用户启动，如果用root启动，需要加--allow-root参数 # 切换到kibana的bin目录 cd /opt/kibana-7.4.0-linux-x86_64/bin # 启动 ./kibana --allow-root 启动成功。 5、访问kibana 1.浏览器输入http://192.168.149.135:5601/，如下图： http://192.168.149.135:5601/ 看到这个界面，说明Kibanan已成功安装。 Discover：可视化查询分析器 Visualize：统计分析图表 Dashboard：自定义主面板（添加图表） Timelion：Timelion是一个kibana时间序列展示组件（暂时不用） Dev Tools：Console控制台（同CURL/POSTER，操作ES代码工具，代码提示，很方便） Management：管理索引库(index)、已保存的搜索和可视化结果(save objects)、设置 kibana 服务器属性。 2.3. 2.3 head安装 Tips: 课后扩展内容 head简介 ead插件是ES的一个可视化管理插件，用来监视ES的状态，并通过head客户端和ES服务进行交互，比如创建映射、创建索引等。 在登陆和访问head插件地址和ElasticSearch前需要事先在服务器上安装和配置好ElasticSearch以及head插件。安装完后，默认head插件的web端口为9100，ElasticSearch服务的端口为9200，使用浏览器访问head地址，如http://IP地址:9100/，推荐使用Chrome浏览器，head插件对Chrome浏览器兼容更佳。进入head页面后将ElasticSearch连接输入框中填写正确的ElasticSearch服务地址，就可以监控ElasticSearch运行信息 2.3.1. 2.3.1 Node安装 1) 什么是Node 简单的说 Node.js 就是运行在服务端的 JavaScript。Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。Node.js 的包管理器 npm，是全球最大的开源库生态系统。 2) 下载Node 上一节我们已经安装好了Elasticsearch，接下来我们来安装head插件，由于elasticsearch-head插件是由nodejs语言编写，所以安装elasticsearch-head前需要先安装nodejs。 首先，执行以下命令安装nodejs和grunt 打开虚拟机，执行wget命令下载Node，如下图： wget https://nodejs.org/dist/v10.15.2/node-v10.15.2-linux-x64.tar.xz 3）解压Node包 tar xvf node-v10.15.2-linux-x64.tar.xz 4）设置软连接 解压文件的 bin 目录底下包含了 node、npm 等命令，我们可以使用 ln 命令来设置软连接： ln -s bin/npm /usr/local/bin/ ln -s bin/node /usr/local/bin/ 在/etc/profile中配置好path环境变量 vi ~/.bash_profile export NODE_HOME=/opt/nodejs/node-v10.15.2-linux-x64 export PATH=$PATH:$NODE_HOME/bin 保存退出，使文件生效 source ~/.bash_profile 查看node安装版本，执行 node -v 验证安装如下图： 2.3.2. 2.3.2 grunt安装 安装grunt（运行在Node.js上面的任务管理器（task runner）），为了获得Grunt的更多产品特性，需要全局安装Grunt's 命令行接口（CLI），使用npm进行安装，如下： npm install -g grunt-cli 查看grunt版本 输出grunt版本信息，表示安装成功。 2.3.3. 2.3.3 head安装 1) 执行命令安装git git yum install git -y 2) 切换到/opt目录下,执行下面的克隆命令 git clone git://github.com/mobz/elasticsearch-head.git 3) 进入到elasticsearch-head目录 cd elasticsearch-head 4) 运行 在运行之前我们需要修改下elasticsearch.yml，因为ES默认不开启跨域访问，需要添加以下配置： #开启cors跨域访问支持，默认为false http.cors.enabled: true #跨域访问允许的域名地址，(允许所有域名)以上使用正则 http.cors.allow-origin: \"*\" 然后开始执行运行命令： npm run start 5) 访问head 浏览器输入ip:port:9100，如下图 看到这个界面说明我们的head插件成功安装并且成功连接Elasticsearch。 Copyright © MISIN 2022 | 豫ICP备2021006345号-1 all right reserved，powered by Gitbook该文件修订时间： 2020-06-11 10:13:58 "},"4.流行框架/6.ElasticSearch/day01资料/ik分词器安装.html":{"url":"4.流行框架/6.ElasticSearch/day01资料/ik分词器安装.html","title":"ik分词器安装","keywords":"","body":"1. IK分词器安装1.1.1. 1、环境准备1.1.2. 2、安装IK分词器1.1.3. 3、使用IK分词器1. IK分词器安装 1.1.1. 1、环境准备 Elasticsearch 要使用 ik，就要先构建 ik 的 jar包，这里要用到 maven 包管理工具，而 maven 需要java 环境，而 Elasticsearch 内置了jdk， 所以可以将JAVA_HOME设置为Elasticsearch 内置的jdk 1）设置JAVA_HOME vim /etc/profile # 在profile文件末尾添加 #java environment export JAVA_HOME=/opt/elasticsearch-7.4.0/jdk export PATH=$PATH:${JAVA_HOME}/bin # 保存退出后，重新加载profile source /etc/profile 2）下载maven安装包 wget http://mirror.cc.columbia.edu/pub/software/apache/maven/maven-3/3.1.1/binaries/apache-maven-3.1.1-bin.tar.gz 3）解压maven安装包 tar xzf apache-maven-3.1.1-bin.tar.gz 4）设置软连接 ln -s apache-maven-3.1.1 maven 5）设置path 打开文件 vim /etc/profile.d/maven.sh 将下面的内容复制到文件，保存 export MAVEN_HOME=/opt/maven export PATH=${MAVEN_HOME}/bin:${PATH} 设置好Maven的路径之后，需要运行下面的命令使其生效 source /etc/profile.d/maven.sh 6）验证maven是否安装成功 mvn -v 1.1.2. 2、安装IK分词器 1）下载IK wget https://github.com/medcl/elasticsearch-analysis-ik/archive/v7.4.0.zip 执行如下图： 2）解压IK 由于这里是zip包不是gz包，所以我们需要使用unzip命令进行解压，如果本机环境没有安装unzip，请执行： yum install zip yum install unzip 解压IK unzip v7.4.0.zip 3）编译jar包 # 切换到 elasticsearch-analysis-ik-7.4.0目录 cd elasticsearch-analysis-ik-7.4.0/ #打包 mvn package 4） jar包移动 package执行完毕后会在当前目录下生成target/releases目录，将其中的elasticsearch-analysis-ik-7.4.0.zip。拷贝到elasticsearch目录下的新建的目录plugins/analysis-ik，并解压 #切换目录 cd /opt/elasticsearch-7.4.0/plugins/ #新建目录 mkdir analysis-ik cd analysis-ik #执行拷贝 cp -R /opt/elasticsearch-analysis-ik-7.4.0/target/releases/elasticsearch-analysis-ik-7.4.0.zip /opt/elasticsearch-7.4.0/plugins/analysis-ik #执行解压 unzip /opt/elasticsearch-7.4.0/plugins/analysis-ik/elasticsearch-analysis-ik-7.4.0.zip 5）拷贝辞典 将elasticsearch-analysis-ik-7.4.0目录下的config目录中的所有文件 拷贝到elasticsearch的config目录 cp -R /opt/elasticsearch-analysis-ik-7.4.0/config/* /opt/elasticsearch-7.4.0/config 记得一定要重启Elasticsearch！！！ 1.1.3. 3、使用IK分词器 IK分词器有两种分词模式：ik_max_word和ik_smart模式。 1、ik_max_word 会将文本做最细粒度的拆分，比如会将“乒乓球明年总冠军”拆分为“乒乓球、乒乓、球、明年、总冠军、冠军。 #方式一ik_max_word GET /_analyze { \"analyzer\": \"ik_max_word\", \"text\": \"乒乓球明年总冠军\" } ik_max_word分词器执行如下： { \"tokens\" : [ { \"token\" : \"乒乓球\", \"start_offset\" : 0, \"end_offset\" : 3, \"type\" : \"CN_WORD\", \"position\" : 0 }, { \"token\" : \"乒乓\", \"start_offset\" : 0, \"end_offset\" : 2, \"type\" : \"CN_WORD\", \"position\" : 1 }, { \"token\" : \"球\", \"start_offset\" : 2, \"end_offset\" : 3, \"type\" : \"CN_CHAR\", \"position\" : 2 }, { \"token\" : \"明年\", \"start_offset\" : 3, \"end_offset\" : 5, \"type\" : \"CN_WORD\", \"position\" : 3 }, { \"token\" : \"总冠军\", \"start_offset\" : 5, \"end_offset\" : 8, \"type\" : \"CN_WORD\", \"position\" : 4 }, { \"token\" : \"冠军\", \"start_offset\" : 6, \"end_offset\" : 8, \"type\" : \"CN_WORD\", \"position\" : 5 } ] } 2、ik_smart 会做最粗粒度的拆分，比如会将“乒乓球明年总冠军”拆分为乒乓球、明年、总冠军。 #方式二ik_smart GET /_analyze { \"analyzer\": \"ik_smart\", \"text\": \"乒乓球明年总冠军\" } ik_smart分词器执行如下： { \"tokens\" : [ { \"token\" : \"乒乓球\", \"start_offset\" : 0, \"end_offset\" : 3, \"type\" : \"CN_WORD\", \"position\" : 0 }, { \"token\" : \"明年\", \"start_offset\" : 3, \"end_offset\" : 5, \"type\" : \"CN_WORD\", \"position\" : 1 }, { \"token\" : \"总冠军\", \"start_offset\" : 5, \"end_offset\" : 8, \"type\" : \"CN_WORD\", \"position\" : 2 } ] } 由此可见 使用ik_smart可以将文本\"text\": \"乒乓球明年总冠军\"分成了【乒乓球】【明年】【总冠军】 这样看的话，这样的分词效果达到了我们的要求。 Copyright © MISIN 2022 | 豫ICP备2021006345号-1 all right reserved，powered by Gitbook该文件修订时间： 2020-06-11 10:13:56 "},"4.流行框架/6.ElasticSearch/day02资料/ElasticSearch集群搭建.html":{"url":"4.流行框架/6.ElasticSearch/day02资料/ElasticSearch集群搭建.html","title":"ElasticSearch集群搭建","keywords":"","body":"1. 一、ElasticSearch 集群1.1. 1.1 搭建集群1.2. 1.2 使用Kibana配置和管理集群1. 一、ElasticSearch 集群 1.1. 1.1 搭建集群 Elasticsearch如果做集群的话Master节点至少三台服务器或者三个Master实例加入相同集群，三个Master节点最多只能故障一台Master节点，如果故障两个Master节点，Elasticsearch将无法组成集群.会报错，Kibana也无法启动，因为Kibana无法获取集群中的节点信息。 由于，我们使用只有一台虚拟机，所以我们在虚拟机中安装三个ES实例，搭建伪集群，而ES启动比较耗内存，所以先设置虚拟机的内存3G和CPU个数4个 1.1.1 整体步骤 步骤如下： 拷贝opt目录下的elasticsearch-7.4.0安装包3个，分别命名： elasticsearch-7.4.0-itcast1 elasticsearch-7.4.0-itcast2 elasticsearch-7.4.0-itcast3 然后修改elasticsearch.yml文件件。 然后启动启动itcast1、itcast2、itcast3三个节点。 打开浏览器输⼊：http://192.168.149.135:9200/_cat/health?v ,如果返回的node.total是3，代表集 群搭建成功 在此，需要我们特别注意的是，像本文这样单服务器多节点（ 3 个节点）的情况，仅供测试使用，集群环境如下： cluster name node name IP Addr http端口 / 通信端口 itcast-es itcast1 192.168.149.135 9201 / 9700 itcast-es itcast2 192.168.149.135 9202 / 9800 itcast-es itcast3 192.168.149.135 9203 / 9900 1.1.2 拷贝副本 拷贝opt目录下的elasticsearch-7.4.0安装包3个，打开虚拟机到opt目录 执行 拷贝三份 cd /opt cp -r elasticsearch-7.4.0 elasticsearch-7.4.0-itcast1 cp -r elasticsearch-7.4.0 elasticsearch-7.4.0-itcast2 cp -r elasticsearch-7.4.0 elasticsearch-7.4.0-itcast3 1.1. 3 修改elasticsearch.yml配置文件 1)、创建日志目录 cd /opt mkdir logs mkdir data # 授权给itheima用户 chown -R itheima:itheima ./logs chown -R itheima:itheima ./data chown -R itheima:itheima ./elasticsearch-7.4.0-itcast1 chown -R itheima:itheima ./elasticsearch-7.4.0-itcast2 chown -R itheima:itheima ./elasticsearch-7.4.0-itcast3 打开elasticsearch.yml配置，分别配置下面三个节点的配置文件 vim /opt/elasticsearch-7.4.0-itcast1/config/elasticsearch.yml vim /opt/elasticsearch-7.4.0-itcast2/config/elasticsearch.yml vim /opt/elasticsearch-7.4.0-itcast3/config/elasticsearch.yml 2)、下面是elasticsearch-7.4.0-itcast1配置文件 cluster.name: itcast-es node.name: itcast-1 node.master: true node.data: true node.max_local_storage_nodes: 3 network.host: 0.0.0.0 http.port: 9201 transport.tcp.port: 9700 discovery.seed_hosts: [\"localhost:9700\",\"localhost:9800\",\"localhost:9900\"] cluster.initial_master_nodes: [\"itcast-1\", \"itcast-2\",\"itcast-3\"] path.data: /opt/data path.logs: /opt/logs #集群名称 cluster.name: itcast-es #节点名称 node.name: itcast-1 #是不是有资格主节点 node.master: true #是否存储数据 node.data: true #最大集群节点数 node.max_local_storage_nodes: 3 #ip地址 network.host: 0.0.0.0 #端口 http.port: 9201 #内部节点之间沟通端口 transport.tcp.port: 9700 #es7.x 之后新增的配置，节点发现 discovery.seed_hosts: [\"localhost:9700\",\"localhost:9800\",\"localhost:9900\"] #es7.x 之后新增的配置，初始化一个新的集群时需要此配置来选举master cluster.initial_master_nodes: [\"itcast-1\", \"itcast-2\",\"itcast-3\"] #数据和存储路径 path.data: /opt/data path.logs: /opt/logs 3)、下面是elasticsearch-7.4.0-itcast2配置文件 cluster.name: itcast-es node.name: itcast-2 node.master: true node.data: true node.max_local_storage_nodes: 3 network.host: 0.0.0.0 http.port: 9202 transport.tcp.port: 9800 discovery.seed_hosts: [\"localhost:9700\",\"localhost:9800\",\"localhost:9900\"] cluster.initial_master_nodes: [\"itcast-1\", \"itcast-2\",\"itcast-3\"] path.data: /opt/data path.logs: /opt/logs #集群名称 cluster.name: itcast-es #节点名称 node.name: itcast-2 #是不是有资格主节点 node.master: true #是否存储数据 node.data: true #最大集群节点数 node.max_local_storage_nodes: 3 #ip地址 network.host: 0.0.0.0 #端口 http.port: 9202 #内部节点之间沟通端口 transport.tcp.port: 9800 #es7.x 之后新增的配置，节点发现 discovery.seed_hosts: [\"localhost:9700\",\"localhost:9800\",\"localhost:9900\"] #es7.x 之后新增的配置，初始化一个新的集群时需要此配置来选举master cluster.initial_master_nodes: [\"itcast-1\", \"itcast-2\",\"itcast-3\"] #数据和存储路径 path.data: /opt/data path.logs: /opt/logs 4)、下面是elasticsearch-7.4.0-itcast3 配置文件 cluster.name: itcast-es node.name: itcast-3 node.master: true node.data: true node.max_local_storage_nodes: 3 network.host: 0.0.0.0 http.port: 9203 transport.tcp.port: 9900 discovery.seed_hosts: [\"localhost:9700\",\"localhost:9800\",\"localhost:9900\"] cluster.initial_master_nodes: [\"itcast-1\", \"itcast-2\",\"itcast-3\"] path.data: /opt/data path.logs: /opt/logs #集群名称 cluster.name: itcast-es #节点名称 node.name: itcast-3 #是不是有资格主节点 node.master: true #是否存储数据 node.data: true #最大集群节点数 node.max_local_storage_nodes: 3 #ip地址 network.host: 0.0.0.0 #端口 http.port: 9203 #内部节点之间沟通端口 transport.tcp.port: 9900 #es7.x 之后新增的配置，节点发现 discovery.seed_hosts: [\"localhost:9700\",\"localhost:9800\",\"localhost:9900\"] #es7.x 之后新增的配置，初始化一个新的集群时需要此配置来选举master cluster.initial_master_nodes: [\"itcast-1\", \"itcast-2\",\"itcast-3\"] #数据和存储路径 path.data: /opt/data path.logs: /opt/logs 1.1.4 执行授权 在root用户下执行 chown -R itheima:itheima /opt/elasticsearch-7.4.0-itcast1 chown -R itheima:itheima /opt/elasticsearch-7.4.0-itcast2 chown -R itheima:itheima /opt/elasticsearch-7.4.0-itcast3 如果有的日志文件授权失败，可使用(也是在root下执行) cd /opt/elasticsearch-7.4.0-itcast1/logs chown -R itheima:itheima ./* cd /opt/elasticsearch-7.4.0-itcast2/logs chown -R itheima:itheima ./* cd /opt/elasticsearch-7.4.0-itcast3/logs chown -R itheima:itheima ./* 1.1.5 启动三个节点 启动之前，设置ES的JVM占用内存参数，防止内存不足错误 vim /opt/elasticsearch-7.4.0-itcast1/bin/elasticsearch 可以发现，ES启动时加载/config/jvm.options文件 vim /opt/elasticsearch-7.4.0-itcast1/config/jvm.options 默认情况下，ES启动JVM最小内存1G，最大内存1G -xms:最小内存 -xmx:最大内存 修改为256m 启动成功访问节点一： 可以从日志中看到：master not discovered yet。还没有发现主节点 访问集群状态信息 http://192.168.149.135:9201/_cat/health?v 不成功 启动成功访问节点二: 可以从日志中看到：master not discovered yet。还没有发现主节点master node changed.已经选举出主节点itcast-2 访问集群状态信息 http://192.168.149.135:9201/_cat/health?v 成功 健康状况结果解释： cluster 集群名称 status 集群状态 green代表健康； yellow代表分配了所有主分片，但至少缺少一个副本，此时集群数据仍旧完整； red 代表部分主分片不可用，可能已经丢失数据。 node.total代表在线的节点总数量 node.data代表在线的数据节点的数量 shards 存活的分片数量 pri 存活的主分片数量 正常情况下 shards的数量是pri的两倍。 relo迁移中的分片数量，正常情况为 0 init 初始化中的分片数量 正常情况为 0 unassign未分配的分片 正常情况为 0 pending_tasks准备中的任务，任务指迁移分片等 正常情况为 0 max_task_wait_time任务最长等待时间 active_shards_percent正常分片百分比 正常情况为 100% 启动成功访问节点三 访问集群状态信息 http://192.168.149.135:9201/_cat/health?v 成功 可以看到节点已经变为3个，至此，ES集群已经搭建成功~ 1.2. 1.2 使用Kibana配置和管理集群 1.2.1 集群配置 因为之前我们在单机演示的时候也使用到了Kibana，我们先复制出来一个Kibana，然后修改它的集群配置 cd /opt/ cp -r kibana-7.4.0-linux-x86_64 kibana-7.4.0-linux-x86_64-cluster # 由于 kibana 中文件众多，此处会等待大约1分钟的时间 修改Kibana的集群配置 vim kibana-7.4.0-linux-x86_64-cluster/config/kibana.yml 加入下面的配置 elasticsearch.hosts: [\"http://localhost:9201\",\"http://localhost:9202\",\"http://localhost:9203\"] 启动Kibana sh kibana --allow-root 1.2.2 管理集群 1、打开Kibana，点开 Stack Monitoring 集群监控 2、点击【Nodes】查看节点详细信息 在上图可以看到，第一个红框处显示【Green】，绿色，表示集群处理健康状态 第二个红框是我们集群的三个节点，注意，itcast-3旁边是星星，表示是主节点 Copyright © MISIN 2022 | 豫ICP备2021006345号-1 all right reserved，powered by Gitbook该文件修订时间： 2020-06-11 10:01:32 "},"4.流行框架/6.ElasticSearch/day02资料/数据准备.html":{"url":"4.流行框架/6.ElasticSearch/day02资料/数据准备.html","title":"数据准备","keywords":"","body":"1.1. 查询数据准备1.1.1. 一、创建索引1.1.2. 二、添加文档1.1. 查询数据准备 1.1.1. 一、创建索引 PUT goods { \"mappings\": { \"properties\": { \"title\": { \"type\": \"text\", \"analyzer\": \"ik_smart\" }, \"price\": { \"type\": \"double\" }, \"createTime\": { \"type\": \"date\" }, \"categoryName\": { \"type\": \"keyword\" }, \"brandName\": { \"type\": \"keyword\" }, \"spec\": { \"type\": \"object\" }, \"saleNum\": { \"type\": \"integer\" }, \"stock\": { \"type\": \"integer\" } } } } title:商品标题 price:商品价格 createTime:创建时间 categoryName:分类名称。如：家电，手机 brandName:品牌名称。如：华为，小米 spec: 商品规格。如： spec:{\"屏幕尺寸\",\"5寸\"，\"内存大小\",\"128G\"} saleNum:销量 stock:库存量 1.1.2. 二、添加文档 POST goods/_doc/1 { \"title\":\"小米手机\", \"price\":1000, \"createTime\":\"2019-12-01\", \"categoryName\":\"手机\", \"brandName\":\"小米\", \"saleNum\":3000, \"stock\":10000, \"spec\":{ \"网络制式\":\"移动4G\", \"屏幕尺寸\":\"4.5\" } } Copyright © MISIN 2022 | 豫ICP备2021006345号-1 all right reserved，powered by Gitbook该文件修订时间： 2020-06-11 10:01:20 "},"4.流行框架/6.ElasticSearch/day02资料/脚本.html":{"url":"4.流行框架/6.ElasticSearch/day02资料/脚本.html","title":"脚本","keywords":"","body":" # 默认情况下，es一次展示10条数据,通过from和size来控制分页 # 查询结果详解 GET goods/_search { \"query\": { \"match_all\": {} }, \"from\": 0, \"size\": 100 } GET goods # term查询 GET goods/_search { \"query\": { \"term\": { \"title\": { \"value\": \"华为\" } } } } # match查询 GET goods/_search { \"query\": { \"match\": { \"title\": \"华为手机\" } }, \"size\": 500 } GET goods/_search { \"query\": { \"match\": { \"title\": { \"query\": \"华为手机\", \"operator\": \"and\" } } } } GET _analyze { \"analyzer\": \"ik_smart\", \"text\": \"施华洛世奇\" } # wildcard 查询。查询条件分词，模糊查询 GET goods/_search { \"query\": { \"wildcard\": { \"title\": { \"value\": \"华*\" } } } } # 正则查询 GET goods/_search { \"query\": { \"regexp\": { \"title\": \"\\\\w+(.)*\" } } } # 前缀查询 GET goods/_search { \"query\": { \"prefix\": { \"brandName\": { \"value\": \"三\" } } } } # 范围查询 GET goods/_search { \"query\": { \"range\": { \"price\": { \"gte\": 2000, \"lte\": 3000 } } }, \"sort\": [ { \"price\": { \"order\": \"desc\" } } ] } # queryString GET goods/_search { \"query\": { \"query_string\": { \"fields\": [\"title\",\"categoryName\",\"brandName\"], \"query\": \"华为 AND 手机\" } } } GET goods/_search { \"query\": { \"simple_query_string\": { \"fields\": [\"title\",\"categoryName\",\"brandName\"], \"query\": \"华为 AND 手机\" } } } # boolquery GET goods/_search { \"query\": { \"bool\": { \"must\": [ { \"term\": { \"brandName\": { \"value\": \"华为\" } } } ], \"filter\":[ { \"term\": { \"title\": \"手机\" } }, { \"range\":{ \"price\": { \"gte\": 2000, \"lte\": 3000 } } } ] } } } GET goods/_search { \"query\": { \"bool\": { \"filter\": [ { \"term\": { \"brandName\": { \"value\": \"华为\" } } } ] } } } # 聚合查询 # 指标聚合 聚合函数 GET goods/_search { \"query\": { \"match\": { \"title\": \"手机\" } }, \"aggs\": { \"max_price\": { \"max\": { \"field\": \"price\" } } } } # 桶聚合 分组 GET goods/_search { \"query\": { \"match\": { \"title\": \"手机\" } }, \"aggs\": { \"goods_brands\": { \"terms\": { \"field\": \"brandName\", \"size\": 100 } } } } GET goods/_search { \"query\": { \"match\": { \"title\": \"电视\" } }, \"highlight\": { \"fields\": { \"title\": { \"pre_tags\": \"\", \"post_tags\": \"\" } } } } # -------重建索引----------- # 新建student_index_v1。索引名称必须全部小写 PUT student_index_v1 { \"mappings\": { \"properties\": { \"birthday\":{ \"type\": \"date\" } } } } GET student_index_v1 PUT student_index_v1/_doc/1 { \"birthday\":\"1999-11-11\" } GET student_index_v1/_search PUT student_index_v1/_doc/1 { \"birthday\":\"1999年11月11日\" } # 业务变更了，需要改变birthday字段的类型为text # 1. 创建新的索引 student_index_v2 # 2. 将student_index_v1 数据拷贝到 student_index_v2 # 创建新的索引 student_index_v2 PUT student_index_v2 { \"mappings\": { \"properties\": { \"birthday\":{ \"type\": \"text\" } } } } # 将student_index_v1 数据拷贝到 student_index_v2 # _reindex 拷贝数据 POST _reindex { \"source\": { \"index\": \"student_index_v1\" }, \"dest\": { \"index\": \"student_index_v2\" } } GET student_index_v2/_search PUT student_index_v2/_doc/2 { \"birthday\":\"1999年11月11日\" } # 思考： 现在java代码中操作es，还是使用的实student_index_v1老的索引名称。 # 1. 改代码（不推荐） # 2. 索引别名（推荐） # 步骤： # 0. 先删除student_index_v1 # 1. 给student_index_v2起个别名 student_index_v1 # 先删除student_index_v1 DELETE student_index_v1 # 给student_index_v2起个别名 student_index_v1 POST student_index_v2/_alias/student_index_v1 GET student_index_v1/_search GET student_index_v2/_search Copyright © MISIN 2022 | 豫ICP备2021006345号-1 all right reserved，powered by Gitbook该文件修订时间： 2020-06-11 10:01:24 "},"4.流行框架/6.ElasticSearch/1.Elasticsearch.html":{"url":"4.流行框架/6.ElasticSearch/1.Elasticsearch.html","title":"1.Elasticsearch","keywords":"","body":"1.1. 1-今日内容1.2. 2-初识ElasticSearch1.2.1. 2.1-基于数据库查询的问题1.2.2. 2.2-倒排索引1.2.3. 2.3-ES存储和查询的原理1.2.4. 2.4-ES概念详解1.3. 3-安装ElasticSearch1.3.1. 3.1-ES安装1.3.2. 3.2-ES辅助工具安装1.4. 4-ElasticSearch核心概念1.5. 5-脚本操作ES1.5.1. 5.1-RESTful风格介绍1.5.2. 5.2-操作索引1.5.3. 5.3-ES数据类型1.5.4. 5.4-操作映射2. 创建索引并添加映射2.1.1. 5.5-操作文档2.2. 6-分词器2.2.1. 6.1分词器-介绍2.2.2. 6.2-ik分词器安装2.2.3. 6.3-ik分词器使用2.2.4. 6.4使用IK分词器-查询文档2.3. 7-ElasticSearch JavaApi-2.3.1. 7.1SpringBoot整合ES2.3.2. 7.2-创建索引2.3.3. 7.3-查询、删除、判断索引2.3.4. 7.4-添加文档2.3.5. 7.5-修改、查询、删除文档1.1. 1-今日内容 初识 ElasticSearch 安装 ElasticSearch ElasticSearch 核心概念 操作 ElasticSearch ElasticSearch JavaAPI 1.2. 2-初识ElasticSearch 1.2.1. 2.1-基于数据库查询的问题 1.2.2. 2.2-倒排索引 倒排索引：将文档进行分词，形成词条和id的对应关系即为反向索引。 以唐诗为例，所处包含“前”的诗句 正向索引：由《静夜思》-->窗前明月光--->“前”字 反向索引：“前”字-->窗前明月光-->《静夜思》 反向索引的实现就是对诗句进行分词，分成单个的词，由词推据，即为反向索引 “床前明月光”--> 分词 将一段文本按照一定的规则，拆分为不同的词条（term） 1.2.3. 2.3-ES存储和查询的原理 index（索引）：相当于mysql的库 映射：相当于mysql 的表结构 document(文档)：相当于mysql的表中的数据 数据库查询存在的问题： 性能低：使用模糊查询，左边有通配符，不会走索引，会全表扫描，性能低 功能弱：如果以”华为手机“作为条件，查询不出来数据 Es使用倒排索引，对title 进行分词 使用“手机”作为关键字查询 生成的倒排索引中，词条会排序，形成一颗树形结构，提升词条的查询速度 使用“华为手机”作为关键字查询 华为：1,3 手机：1,2,3 1.2.4. 2.4-ES概念详解 •ElasticSearch是一个基于Lucene的搜索服务器 •是一个分布式、高扩展、高实时的搜索与数据分析引擎 •基于RESTful web接口 •Elasticsearch是用Java语言开发的，并作为Apache许可条款下的开放源码发布，是一种流行的企业级搜索引擎 •官网：https://www.elastic.co/ 应用场景 •搜索：海量数据的查询 •日志数据分析 •实时数据分析 1.3. 3-安装ElasticSearch 1.3.1. 3.1-ES安装 参见ElasticSearch-ES安装.md 查看elastic是否启动 ps -ef|grep elastic 1.3.2. 3.2-ES辅助工具安装 参见ElasticSearch-ES安装.md 后台启动 nohup ../bin/kibana & 1.4. 4-ElasticSearch核心概念 索引（index） ElasticSearch存储数据的地方，可以理解成关系型数据库中的数据库概念。 映射（mapping） mapping定义了每个字段的类型、字段所使用的分词器等。相当于关系型数据库中的表结构。 文档（document） Elasticsearch中的最小数据单元，常以json格式显示。一个document相当于关系型数据库中的一行数据。 倒排索引 一个倒排索引由文档中所有不重复词的列表构成，对于其中每个词，对应一个包含它的文档id列表。 类型（type） 一种type就像一类表。如用户表、角色表等。在Elasticsearch7.X默认type为_doc \\- ES 5.x中一个index可以有多种type。 \\- ES 6.x中一个index只能有一种type。 \\- ES 7.x以后，将逐步移除type这个概念，现在的操作已经不再使用，默认_doc 1.5. 5-脚本操作ES 1.5.1. 5.1-RESTful风格介绍 1.ST（Representational State Transfer），表述性状态转移，是一组架构约束条件和原则。满足这些约束条件和原则的应用程序或设计就是RESTful。就是一种定义接口的规范。 2.基于HTTP。 3.使用XML格式定义或JSON格式定义。 4.每一个URI代表1种资源。 5.客户端使用GET、POST、PUT、DELETE 4个表示操作方式的动词对服务端资源进行操作： GET：用来获取资源 POST：用来新建资源（也可以用于更新资源） PUT：用来更新资源 DELETE：用来删除资源 1.5.2. 5.2-操作索引 PUT http://ip:端口/索引名称 查询 GET http://ip:端口/索引名称 # 查询单个索引信息 GET http://ip:端口/索引名称1,索引名称2... # 查询多个索引信息 GET http://ip:端口/_all # 查询所有索引信息 •删除索引 DELETE http://ip:端口/索引名称 •关闭、打开索引 POST http://ip:端口/索引名称/_close POST http://ip:端口/索引名称/_open 1.5.3. 5.3-ES数据类型 简单数据类型 字符串 聚合：相当于mysql 中的sum（求和） text：会分词，不支持聚合 keyword：不会分词，将全部内容作为一个词条，支持聚合 数值 布尔：boolean 二进制：binary 范围类型 integer_range, float_range, long_range, double_range, date_range 日期:date 复杂数据类型 •数组：[ ] Nested: nested (for arrays of JSON objects 数组类型的JSON对象) •对象：{ } Object: object(for single JSON objects 单个JSON对象) 1.5.4. 5.4-操作映射 PUT person GET person #添加映射 PUT /person/_mapping { \"properties\":{ \"name\":{ \"type\":\"text\" }, \"age\":{ \"type\":\"integer\" } } } 2. 创建索引并添加映射 #创建索引并添加映射 PUT /person1 { \"mappings\": { \"properties\": { \"name\": { \"type\": \"text\" }, \"age\": { \"type\": \"integer\" } } } } GET person1/_mapping 添加字段 #添加字段 PUT /person1/_mapping { \"properties\": { \"name\": { \"type\": \"text\" }, \"age\": { \"type\": \"integer\" } } } 2.1.1. 5.5-操作文档 •添加文档，指定id POST /person1/_doc/2 { \"name\":\"张三\", \"age\":18, \"address\":\"北京\" } GET /person1/_doc/1 •添加文档，不指定id #添加文档，不指定id POST /person1/_doc/ { \"name\":\"张三\", \"age\":18, \"address\":\"北京\" } #查询所有文档 GET /person1/_search #删除指定id文档 DELETE /person1/_doc/1 2.2. 6-分词器 2.2.1. 6.1分词器-介绍 •IKAnalyzer是一个开源的，基于java语言开发的轻量级的中文分词工具包 •是一个基于Maven构建的项目 •具有60万字/秒的高速处理能力 •支持用户词典扩展定义 •下载地址：https://github.com/medcl/elasticsearch-analysis-ik/archive/v7.4.0.zip 安装包在资料文件夹中提供 2.2.2. 6.2-ik分词器安装 参见 ik分词器安装.md 执行如下命令时如果出现 打包失败（501码）将maven镜像换成阿里云的 mvn package /opt/apache-maven-3.1.1/conf/setting.xml alimaven aliyun maven http://maven.aliyun.com/nexus/content/groups/public/ central 2.2.3. 6.3-ik分词器使用 IK分词器有两种分词模式：ik_max_word和ik_smart模式。 1、ik_max_word 会将文本做最细粒度的拆分，比如会将“乒乓球明年总冠军”拆分为“乒乓球、乒乓、球、明年、总冠军、冠军。 #方式一ik_max_word GET /_analyze { \"analyzer\": \"ik_max_word\", \"text\": \"乒乓球明年总冠军\" } ik_max_word分词器执行如下： { \"tokens\" : [ { \"token\" : \"乒乓球\", \"start_offset\" : 0, \"end_offset\" : 3, \"type\" : \"CN_WORD\", \"position\" : 0 }, { \"token\" : \"乒乓\", \"start_offset\" : 0, \"end_offset\" : 2, \"type\" : \"CN_WORD\", \"position\" : 1 }, { \"token\" : \"球\", \"start_offset\" : 2, \"end_offset\" : 3, \"type\" : \"CN_CHAR\", \"position\" : 2 }, { \"token\" : \"明年\", \"start_offset\" : 3, \"end_offset\" : 5, \"type\" : \"CN_WORD\", \"position\" : 3 }, { \"token\" : \"总冠军\", \"start_offset\" : 5, \"end_offset\" : 8, \"type\" : \"CN_WORD\", \"position\" : 4 }, { \"token\" : \"冠军\", \"start_offset\" : 6, \"end_offset\" : 8, \"type\" : \"CN_WORD\", \"position\" : 5 } ] } 2、ik_smart 会做最粗粒度的拆分，比如会将“乒乓球明年总冠军”拆分为乒乓球、明年、总冠军。 #方式二ik_smart GET /_analyze { \"analyzer\": \"ik_smart\", \"text\": \"乒乓球明年总冠军\" } ik_smart分词器执行如下： { \"tokens\" : [ { \"token\" : \"乒乓球\", \"start_offset\" : 0, \"end_offset\" : 3, \"type\" : \"CN_WORD\", \"position\" : 0 }, { \"token\" : \"明年\", \"start_offset\" : 3, \"end_offset\" : 5, \"type\" : \"CN_WORD\", \"position\" : 1 }, { \"token\" : \"总冠军\", \"start_offset\" : 5, \"end_offset\" : 8, \"type\" : \"CN_WORD\", \"position\" : 2 } ] } 由此可见 使用ik_smart可以将文本\"text\": \"乒乓球明年总冠军\"分成了【乒乓球】【明年】【总冠军】 这样看的话，这样的分词效果达到了我们的要求。 2.2.4. 6.4使用IK分词器-查询文档 •词条查询：term ​ 词条查询不会分析查询条件，只有当词条和查询字符串完全匹配时才匹配搜索 •全文查询：match ​ 全文查询会分析查询条件，先将查询条件进行分词，然后查询，求并集 1.创建索引，添加映射，并指定分词器为ik分词器 PUT person2 { \"mappings\": { \"properties\": { \"name\": { \"type\": \"keyword\" }, \"address\": { \"type\": \"text\", \"analyzer\": \"ik_max_word\" } } } } 2.添加文档 POST /person2/_doc/1 { \"name\":\"张三\", \"age\":18, \"address\":\"北京海淀区\" } POST /person2/_doc/2 { \"name\":\"李四\", \"age\":18, \"address\":\"北京朝阳区\" } POST /person2/_doc/3 { \"name\":\"王五\", \"age\":18, \"address\":\"北京昌平区\" } 3.查询映射 GET person2 4.查看分词效果 GET _analyze { \"analyzer\": \"ik_max_word\", \"text\": \"北京海淀\" } 5.词条查询：term 查询person2中匹配到\"北京\"两字的词条 GET /person2/_search { \"query\": { \"term\": { \"address\": { \"value\": \"北京\" } } } } 6.全文查询：match ​ 全文查询会分析查询条件，先将查询条件进行分词，然后查询，求并集 GET /person2/_search { \"query\": { \"match\": { \"address\":\"北京昌平\" } } } 2.3. 7-ElasticSearch JavaApi- 2.3.1. 7.1SpringBoot整合ES ①搭建SpringBoot工程 ②引入ElasticSearch相关坐标 org.elasticsearch.client elasticsearch-rest-high-level-client 7.4.0 org.elasticsearch.client elasticsearch-rest-client 7.4.0 org.elasticsearch elasticsearch 7.4.0 ③测试 ElasticSearchConfig @Configuration @ConfigurationProperties(prefix=\"elasticsearch\") public class ElasticSearchConfig { private String host; private int port; public String getHost() { return host; } public void setHost(String host) { this.host = host; } public int getPort() { return port; } public void setPort(int port) { this.port = port; } @Bean public RestHighLevelClient client(){ return new RestHighLevelClient(RestClient.builder( new HttpHost(host,port,\"http\") )); } } ElasticsearchDay01ApplicationTests 注意：使用@Autowired注入RestHighLevelClient 如果报红线，则是因为配置类所在的包和测试类所在的包，包名不一致造成的 @SpringBootTest class ElasticsearchDay01ApplicationTests { @Autowired RestHighLevelClient client; /** * 测试 */ @Test void contextLoads() { System.out.println(client); } } 2.3.2. 7.2-创建索引 1.添加索引 /** * 添加索引 * @throws IOException */ @Test public void addIndex() throws IOException { //1.使用client获取操作索引对象 IndicesClient indices = client.indices(); //2.具体操作获取返回值 //2.1 设置索引名称 CreateIndexRequest createIndexRequest=new CreateIndexRequest(\"itheima\"); CreateIndexResponse createIndexResponse = indices.create(createIndexRequest, RequestOptions.DEFAULT); //3.根据返回值判断结果 System.out.println(createIndexResponse.isAcknowledged()); } 2.添加索引，并添加映射 /** * 添加索引，并添加映射 */ @Test public void addIndexAndMapping() throws IOException { //1.使用client获取操作索引对象 IndicesClient indices = client.indices(); //2.具体操作获取返回值 //2.具体操作，获取返回值 CreateIndexRequest createIndexRequest = new CreateIndexRequest(\"itcast\"); //2.1 设置mappings String mapping = \"{\\n\" + \" \\\"properties\\\" : {\\n\" + \" \\\"address\\\" : {\\n\" + \" \\\"type\\\" : \\\"text\\\",\\n\" + \" \\\"analyzer\\\" : \\\"ik_max_word\\\"\\n\" + \" },\\n\" + \" \\\"age\\\" : {\\n\" + \" \\\"type\\\" : \\\"long\\\"\\n\" + \" },\\n\" + \" \\\"name\\\" : {\\n\" + \" \\\"type\\\" : \\\"keyword\\\"\\n\" + \" }\\n\" + \" }\\n\" + \" }\"; createIndexRequest.mapping(mapping,XContentType.JSON); CreateIndexResponse createIndexResponse = indices.create(createIndexRequest, RequestOptions.DEFAULT); //3.根据返回值判断结果 System.out.println(createIndexResponse.isAcknowledged()); } 2.3.3. 7.3-查询、删除、判断索引 查询索引 /** * 查询索引 */ @Test public void queryIndex() throws IOException { IndicesClient indices = client.indices(); GetIndexRequest getRequest=new GetIndexRequest(\"itcast\"); GetIndexResponse response = indices.get(getRequest, RequestOptions.DEFAULT); Map mappings = response.getMappings(); //iter 提示foreach for (String key : mappings.keySet()) { System.out.println(key+\"===\"+mappings.get(key).getSourceAsMap()); } } 删除索引 /** * 删除索引 */ @Test public void deleteIndex() throws IOException { IndicesClient indices = client.indices(); DeleteIndexRequest deleteRequest=new DeleteIndexRequest(\"itheima\"); AcknowledgedResponse delete = indices.delete(deleteRequest, RequestOptions.DEFAULT); System.out.println(delete.isAcknowledged()); } 索引是否存在 /** * 索引是否存在 */ @Test public void existIndex() throws IOException { IndicesClient indices = client.indices(); GetIndexRequest getIndexRequest=new GetIndexRequest(\"itheima\"); boolean exists = indices.exists(getIndexRequest, RequestOptions.DEFAULT); System.out.println(exists); } 2.3.4. 7.4-添加文档 1.添加文档,使用map作为数据 @Test public void addDoc1() throws IOException { Map map=new HashMap<>(); map.put(\"name\",\"张三\"); map.put(\"age\",\"18\"); map.put(\"address\",\"北京二环\"); IndexRequest request=new IndexRequest(\"itcast\").id(\"1\").source(map); IndexResponse response = client.index(request, RequestOptions.DEFAULT); System.out.println(response.getId()); } 2.添加文档,使用对象作为数据 @Test public void addDoc2() throws IOException { Person person=new Person(); person.setId(\"2\"); person.setName(\"李四\"); person.setAge(20); person.setAddress(\"北京三环\"); String data = JSON.toJSONString(person); IndexRequest request=new IndexRequest(\"itcast\").id(person.getId()).source(data,XContentType.JSON); IndexResponse response = client.index(request, RequestOptions.DEFAULT); System.out.println(response.getId()); } 2.3.5. 7.5-修改、查询、删除文档 1.修改文档：添加文档时，如果id存在则修改，id不存在则添加 /** * 修改文档：添加文档时，如果id存在则修改，id不存在则添加 */ @Test public void UpdateDoc() throws IOException { Person person=new Person(); person.setId(\"2\"); person.setName(\"李四\"); person.setAge(20); person.setAddress(\"北京三环车王\"); String data = JSON.toJSONString(person); IndexRequest request=new IndexRequest(\"itcast\").id(person.getId()).source(data,XContentType.JSON); IndexResponse response = client.index(request, RequestOptions.DEFAULT); System.out.println(response.getId()); } 2.根据id查询文档 /** * 根据id查询文档 */ @Test public void getDoc() throws IOException { //设置查询的索引、文档 GetRequest indexRequest=new GetRequest(\"itcast\",\"2\"); GetResponse response = client.get(indexRequest, RequestOptions.DEFAULT); System.out.println(response.getSourceAsString()); } 3.根据id删除文档 /** * 根据id删除文档 */ @Test public void delDoc() throws IOException { //设置要删除的索引、文档 DeleteRequest deleteRequest=new DeleteRequest(\"itcast\",\"1\"); DeleteResponse response = client.delete(deleteRequest, RequestOptions.DEFAULT); System.out.println(response.getId()); } Copyright © MISIN 2022 | 豫ICP备2021006345号-1 all right reserved，powered by Gitbook该文件修订时间： 2022-11-10 11:35:02 "},"4.流行框架/6.ElasticSearch/ElasticSearch-2.html":{"url":"4.流行框架/6.ElasticSearch/ElasticSearch-2.html","title":"Elastic Search 2","keywords":"","body":"1.1. 01-今日内容1.2. 02-ElasticSearch高级操作1.2.1. 2.1-bulk批量操作-脚本1.2.2. 2.2-bulk批量操作-JavaAPI1.2.3. 2.3-导入数据-分析&创建索引1.2.4. 2.4-导入数据-代码实现1.2.5. 2.5-导入数据-代码实现-详解（选放）1.3. 3-ElasticSearch查询1.3.1. 3.1-matchAll-脚本1.3.2. 3.2-matchAll-JavaAPI1.3.3. 3.3-termQuery1.3.4. 3.4-matchQuery1.3.5. 3.5-模糊查询-脚本1.3.6. 3.5.1-wildcard查询1.3.7. 3.5.2正则查询1.3.8. 3.5.3前缀查询1.3.9. 3.6-模糊查询-JavaAPI1.3.10. 3.7-范围&排序查询1.3.11. 3.8-queryString查询1.3.12. 3.9-布尔查询-脚本1.3.13. 3.10-布尔查询-JavaAPI1.3.14. 3.11-聚合查询-脚本1.3.15. 3.12-聚合查询-JavaAPI1.3.16. 3.13-高亮查询-脚本1.3.17. 3.14-高亮查询-JavaAPI1.3.18. 3.15-重建索引&索引别名1.4. 4-ElasticSearch 集群1.4.1. 4.1-集群介绍1.4.2. 4.2-ES集群相关概念1.4.3. 4.3-集群搭建1.4.4. 4.4-kibina管理集群1.4.5. 4.5-JavaAPI 访问集群1.4.6. 4.6-分片配置1.4.7. 4.7-路由原理1.4.8. 4.8-脑裂1.4.9. 30-ElasticSearch 集群-集群扩容1.1. 01-今日内容 ElasticSearch 高级操作 ElasticSearch 集群管理 1.2. 02-ElasticSearch高级操作 1.2.1. 2.1-bulk批量操作-脚本 脚本： 测试用的5号文档 POST /person1/_doc/5 { \"name\":\"张三5号\", \"age\":18, \"address\":\"北京海淀区\" } 批量操作文本 #批量操作 #1.删除5号 #新增8号 #更新2号 name为2号 POST _bulk {\"delete\":{\"_index\":\"person1\",\"_id\":\"5\"}} {\"create\":{\"_index\":\"person1\",\"_id\":\"8\"}} {\"name\":\"八号\",\"age\":18,\"address\":\"北京\"} {\"update\":{\"_index\":\"person1\",\"_id\":\"2\"}} {\"doc\":{\"name\":\"2号\"}} 结果 { \"took\" : 51, \"errors\" : true, \"items\" : [ { \"delete\" : { \"_index\" : \"person1\", \"_type\" : \"_doc\", \"_id\" : \"5\", \"_version\" : 2, \"result\" : \"deleted\", \"_shards\" : { \"total\" : 2, \"successful\" : 1, \"failed\" : 0 }, \"_seq_no\" : 6, \"_primary_term\" : 2, \"status\" : 200 } }, { \"create\" : { \"_index\" : \"person1\", \"_type\" : \"_doc\", \"_id\" : \"8\", \"_version\" : 1, \"result\" : \"created\", \"_shards\" : { \"total\" : 2, \"successful\" : 1, \"failed\" : 0 }, \"_seq_no\" : 7, \"_primary_term\" : 2, \"status\" : 201 } }, { \"update\" : { \"_index\" : \"person1\", \"_type\" : \"_doc\", \"_id\" : \"2\", \"_version\" : 2, \"result\" : \"updated\", \"_shards\" : { \"total\" : 2, \"successful\" : 1, \"failed\" : 0 }, \"_seq_no\" : 10, \"_primary_term\" : 2, \"status\" : 200 } } ] } 1.2.2. 2.2-bulk批量操作-JavaAPI /** * Bulk 批量操作 */ @Test public void test2() throws IOException { //创建bulkrequest对象，整合所有操作 BulkRequest bulkRequest =new BulkRequest(); /* # 1. 删除5号记录 # 2. 添加6号记录 # 3. 修改3号记录 名称为 “三号” */ //添加对应操作 //1. 删除5号记录 DeleteRequest deleteRequest=new DeleteRequest(\"person1\",\"5\"); bulkRequest.add(deleteRequest); //2. 添加6号记录 Map map=new HashMap<>(); map.put(\"name\",\"六号\"); IndexRequest indexRequest=new IndexRequest(\"person1\").id(\"6\").source(map); bulkRequest.add(indexRequest); //3. 修改3号记录 名称为 “三号” Map mapUpdate=new HashMap<>(); mapUpdate.put(\"name\",\"三号\"); UpdateRequest updateRequest=new UpdateRequest(\"person1\",\"3\").doc(mapUpdate); bulkRequest.add(updateRequest); //执行批量操作 BulkResponse response = client.bulk(bulkRequest, RequestOptions.DEFAULT); System.out.println(response.status()); } 1.2.3. 2.3-导入数据-分析&创建索引 PUT goods { \"mappings\": { \"properties\": { \"title\": { \"type\": \"text\", \"analyzer\": \"ik_smart\" }, \"price\": { \"type\": \"double\" }, \"createTime\": { \"type\": \"date\" }, \"categoryName\": { \"type\": \"keyword\" }, \"brandName\": { \"type\": \"keyword\" }, \"spec\": { \"type\": \"object\" }, \"saleNum\": { \"type\": \"integer\" }, \"stock\": { \"type\": \"integer\" } } } } 1.2.4. 2.4-导入数据-代码实现 /** * 从Mysql 批量导入 elasticSearch */ @Test public void test3() throws IOException { //1.查询所有数据，mysql List goodsList = goodsMapper.findAll(); //2.bulk导入 BulkRequest bulkRequest=new BulkRequest(); //2.1 循环goodsList，创建IndexRequest添加数据 for (Goods goods : goodsList) { //2.2 设置spec规格信息 Map的数据 specStr:{} String specStr = goods.getSpecStr(); //将json格式字符串转为Map集合 Map map = JSON.parseObject(specStr, Map.class); //设置spec map goods.setSpec(map); //将goods对象转换为json字符串 String data = JSON.toJSONString(goods); IndexRequest indexRequest=new IndexRequest(\"goods\").source(data,XContentType.JSON); bulkRequest.add(indexRequest); } BulkResponse response = client.bulk(bulkRequest, RequestOptions.DEFAULT); System.out.println(response.status()); } 1.2.5. 2.5-导入数据-代码实现-详解（选放） 转换成JSON的原因： #spec配置的数据类型是JSON对象，所以当存放字符串的时候报错 \"spec\": { \"type\": \"object\" }, 错误信息 1.3. 3-ElasticSearch查询 1.3.1. 3.1-matchAll-脚本 # 默认情况下，es一次展示10条数据,通过from和size来控制分页 # 查询结果详解 GET goods/_search { \"query\": { \"match_all\": {} }, \"from\": 0, \"size\": 100 } GET goods 1.3.2. 3.2-matchAll-JavaAPI /** * 查询所有 * 1. matchAll * 2. 将查询结果封装为Goods对象，装载到List中 * 3. 分页。默认显示10条 */ @Test public void matchAll() throws IOException { //2. 构建查询请求对象，指定查询的索引名称 SearchRequest searchRequest=new SearchRequest(\"goods\"); //4. 创建查询条件构建器SearchSourceBuilder SearchSourceBuilder sourceBuilder=new SearchSourceBuilder(); //6. 查询条件 QueryBuilder queryBuilder= QueryBuilders.matchAllQuery(); //5. 指定查询条件 sourceBuilder.query(queryBuilder); //3. 添加查询条件构建器 SearchSourceBuilder searchRequest.source(sourceBuilder); // 8 . 添加分页信息 不设置 默认10条 // sourceBuilder.from(0); // sourceBuilder.size(100); //1. 查询,获取查询结果 SearchResponse searchResponse = client.search(searchRequest, RequestOptions.DEFAULT); //7. 获取命中对象 SearchHits SearchHits hits = searchResponse.getHits(); //7.1 获取总记录数 Long total= hits.getTotalHits().value; System.out.println(\"总数：\"+total); //7.2 获取Hits数据 数组 SearchHit[] hits1 = hits.getHits(); //获取json字符串格式的数据 List goodsList = new ArrayList<>(); for (SearchHit searchHit : hits1) { String sourceAsString = searchHit.getSourceAsString(); //转为java对象 Goods goods = JSON.parseObject(sourceAsString, Goods.class); goodsList.add(goods); } for (Goods goods : goodsList) { System.out.println(goods); } } 设置条件的疑问点 1.3.3. 3.3-termQuery term查询和字段类型有关系，首先回顾一下ElasticSearch两个数据类型 ElasticSearch两个数据类型 text：会分词，不支持聚合 keyword：不会分词，将全部内容作为一个词条，支持聚合 term查询：不会对查询条件进行分词。 GET goods/_search { \"query\": { \"term\": { \"title\": { \"value\": \"华为\" } } } } term查询，查询text类型字段时，只有其中的单词相匹配都会查到，text字段会对数据进行分词 例如：查询title 为“华为”的，title type 为text 查询categoryName 字段时，categoryName字段为keyword ,keyword：不会分词，将全部内容作为一个词条, 即完全匹配，才能查询出结果 GET goods/_search { \"query\": { \"term\": { \"categoryName\": { \"value\": \"华为手机\" } } } } 1.3.4. 3.4-matchQuery match查询： •会对查询条件进行分词。 •然后将分词后的查询条件和词条进行等值匹配 •默认取并集（OR） # match查询 GET goods/_search { \"query\": { \"match\": { \"title\": \"华为手机\" } }, \"size\": 500 } match 的默认搜索（or 并集） 例如：华为手机，会分词为 “华为”，“手机” 只要出现其中一个词条都会搜索到 match的 and（交集） 搜索 例如：例如：华为手机，会分词为 “华为”，“手机” 但要求“华为”，和“手机”同时出现在词条中 总结： term query会去倒排索引中寻找确切的term，它并不知道分词器的存在。这种查询适合keyword 、numeric、date match query知道分词器的存在。并且理解是如何被分词的 1.3.5. 3.5-模糊查询-脚本 1.3.6. 3.5.1-wildcard查询 wildcard查询：会对查询条件进行分词。还可以使用通配符 ?（任意单个字符） 和 * （0个或多个字符） \"*华*\" 包含华字的 \"华*\" 华字后边多个字符 \"华?\" 华字后边多个字符 \"*华\"或\"?华\" 会引发全表（全索引）扫描 注意效率问题 # wildcard 查询。查询条件分词，模糊查询 GET goods/_search { \"query\": { \"wildcard\": { \"title\": { \"value\": \"华*\" } } } } 1.3.7. 3.5.2正则查询 \\W：匹配包括下划线的任何单词字符，等价于 [A-Z a-z 0-9_] 开头的反斜杠是转义符 +号多次出现 (.)*为任意字符 正则查询取决于正则表达式的效率 GET goods/_search { \"query\": { \"regexp\": { \"title\": \"\\\\w+(.)*\" } } } 1.3.8. 3.5.3前缀查询 对keyword类型支持比较好 # 前缀查询 对keyword类型支持比较好 GET goods/_search { \"query\": { \"prefix\": { \"brandName\": { \"value\": \"三\" } } } } 1.3.9. 3.6-模糊查询-JavaAPI //模糊查询 WildcardQueryBuilder query = QueryBuilders.wildcardQuery(\"title\", \"华*\");//华后多个字符 //正则查询 RegexpQueryBuilder query = QueryBuilders.regexpQuery(\"title\", \"\\\\w+(.)*\"); //前缀查询 PrefixQueryBuilder query = QueryBuilders.prefixQuery(\"brandName\", \"三\"); 1.3.10. 3.7-范围&排序查询 # 范围查询 GET goods/_search { \"query\": { \"range\": { \"price\": { \"gte\": 2000, \"lte\": 3000 } } }, \"sort\": [ { \"price\": { \"order\": \"desc\" } } ] } //范围查询 以price 价格为条件 RangeQueryBuilder query = QueryBuilders.rangeQuery(\"price\"); //指定下限 query.gte(2000); //指定上限 query.lte(3000); sourceBuilder.query(query); //排序 价格 降序排列 sourceBuilder.sort(\"price\",SortOrder.DESC); 1.3.11. 3.8-queryString查询 queryString 多条件查询 •会对查询条件进行分词。 •然后将分词后的查询条件和词条进行等值匹配 •默认取并集（OR） •可以指定多个查询字段 query_string：识别query中的连接符（or 、and） # queryString GET goods/_search { \"query\": { \"query_string\": { \"fields\": [\"title\",\"categoryName\",\"brandName\"], \"query\": \"华为 AND 手机\" } } } simple_query_string：不识别query中的连接符（or 、and），查询时会将 “华为”、\"and\"、“手机”分别进行查询 GET goods/_search { \"query\": { \"simple_query_string\": { \"fields\": [\"title\",\"categoryName\",\"brandName\"], \"query\": \"华为 AND 手机\" } } } query_string：有default_operator连接符的脚本 GET goods/_search { \"query\": { \"query_string\": { \"fields\": [\"title\",\"brandName\",\"categoryName\"], \"query\": \"华为手机 \" , \"default_operator\": \"AND\" } } } java代码 QueryStringQueryBuilder query = QueryBuilders.queryStringQuery(\"华为手机\").field(\"title\").field(\"categoryName\") .field(\"brandName\").defaultOperator(Operator.AND); simple_query_string：有default_operator连接符的脚本 GET goods/_search { \"query\": { \"simple_query_string\": { \"fields\": [\"title\",\"brandName\",\"categoryName\"], \"query\": \"华为手机 \" , \"default_operator\": \"OR\" } } } 注意：query中的or and 是查询时 匹配条件是否同时出现----or 出现一个即可，and 两个条件同时出现 default_operator的or and 是对结果进行 并集（or）、交集（and） 1.3.12. 3.9-布尔查询-脚本 boolQuery：对多个查询条件连接。连接方式： •must（and）：条件必须成立 •must_not（not）：条件必须不成立 •should（or）：条件可以成立 •filter：条件必须成立，性能比must高。不会计算得分 得分:即条件匹配度,匹配度越高，得分越高 # boolquery #must和filter配合使用时，max_score（得分）是显示的 #must 默认数组形式 GET goods/_search { \"query\": { \"bool\": { \"must\": [ { \"term\": { \"brandName\": { \"value\": \"华为\" } } } ], \"filter\":[ { \"term\": { \"title\": \"手机\" } }, { \"range\":{ \"price\": { \"gte\": 2000, \"lte\": 3000 } } } ] } } } #filter 单独使用 filter可以是单个条件，也可多个条件（数组形式） GET goods/_search { \"query\": { \"bool\": { \"filter\": [ { \"term\": { \"brandName\": { \"value\": \"华为\" } } } ] } } } 1.3.13. 3.10-布尔查询-JavaAPI 布尔查询：boolQuery 查询品牌名称为:华为 查询标题包含：手机 查询价格在：2000-3000 must 、filter为连接方式 term、match为不同的查询方式 //1.构建boolQuery BoolQueryBuilder boolQuery = QueryBuilders.boolQuery(); //2.构建各个查询条件 //2.1 查询品牌名称为:华为 TermQueryBuilder termQueryBuilder = QueryBuilders.termQuery(\"brandName\", \"华为\"); boolQuery.must(termQueryBuilder); //2.2. 查询标题包含：手机 MatchQueryBuilder matchQuery = QueryBuilders.matchQuery(\"title\", \"手机\"); boolQuery.filter(matchQuery); //2.3 查询价格在：2000-3000 RangeQueryBuilder rangeQuery = QueryBuilders.rangeQuery(\"price\"); rangeQuery.gte(2000); rangeQuery.lte(3000); boolQuery.filter(rangeQuery); sourceBuilder.query(boolQuery); 1.3.14. 3.11-聚合查询-脚本 •指标聚合：相当于MySQL的聚合函数。max、min、avg、sum等 •桶聚合：相当于MySQL的 group by 操作。不要对text类型的数据进行分组，会失败。 # 聚合查询 # 指标聚合 聚合函数 GET goods/_search { \"query\": { \"match\": { \"title\": \"手机\" } }, \"aggs\": { \"max_price\": { \"max\": { \"field\": \"price\" } } } } # 桶聚合 分组 GET goods/_search { \"query\": { \"match\": { \"title\": \"手机\" } }, \"aggs\": { \"goods_brands\": { \"terms\": { \"field\": \"brandName\", \"size\": 100 } } } } 1.3.15. 3.12-聚合查询-JavaAPI 聚合查询：桶聚合，分组查询 查询title包含手机的数据 查询品牌列表 /** * 聚合查询：桶聚合，分组查询 * 1. 查询title包含手机的数据 * 2. 查询品牌列表 */ @Test public void testAggQuery() throws IOException { SearchRequest searchRequest=new SearchRequest(\"goods\"); SearchSourceBuilder sourceBuilder=new SearchSourceBuilder(); //1. 查询title包含手机的数据 MatchQueryBuilder queryBuilder = QueryBuilders.matchQuery(\"title\", \"手机\"); sourceBuilder.query(queryBuilder); //2. 查询品牌列表 只展示前100条 AggregationBuilder aggregation=AggregationBuilders.terms(\"goods_brands\").field(\"brandName\").size(100); sourceBuilder.aggregation(aggregation); searchRequest.source(sourceBuilder); SearchResponse searchResponse = client.search(searchRequest, RequestOptions.DEFAULT); //7. 获取命中对象 SearchHits SearchHits hits = searchResponse.getHits(); //7.1 获取总记录数 Long total= hits.getTotalHits().value; System.out.println(\"总数：\"+total); // aggregations 对象 Aggregations aggregations = searchResponse.getAggregations(); //将aggregations 转化为map Map aggregationMap = aggregations.asMap(); //通过key获取goods_brands 对象 使用Aggregation的子类接收 buckets属性在Terms接口中体现 // Aggregation goods_brands1 = aggregationMap.get(\"goods_brands\"); Terms goods_brands =(Terms) aggregationMap.get(\"goods_brands\"); //获取buckets 数组集合 List buckets = goods_brands.getBuckets(); Mapmap=new HashMap<>(); //遍历buckets key 属性名，doc_count 统计聚合数 for (Terms.Bucket bucket : buckets) { System.out.println(bucket.getKey()); map.put(bucket.getKeyAsString(),bucket.getDocCount()); } System.out.println(map); } 1.3.16. 3.13-高亮查询-脚本 高亮三要素： •高亮字段 •前缀 •后缀 默认前后缀 ：em 手机 GET goods/_search { \"query\": { \"match\": { \"title\": \"电视\" } }, \"highlight\": { \"fields\": { \"title\": { \"pre_tags\": \"\", \"post_tags\": \"\" } } } } 1.3.17. 3.14-高亮查询-JavaAPI 实施步骤： 高亮查询： 1. 设置高亮 高亮字段 前缀 后缀 2. 将高亮了的字段数据，替换原有数据 /** * * 高亮查询： * 1. 设置高亮 * * 高亮字段 * * 前缀 * * 后缀 * 2. 将高亮了的字段数据，替换原有数据 */ @Test public void testHighLightQuery() throws IOException { SearchRequest searchRequest = new SearchRequest(\"goods\"); SearchSourceBuilder sourceBulider = new SearchSourceBuilder(); // 1. 查询title包含手机的数据 MatchQueryBuilder query = QueryBuilders.matchQuery(\"title\", \"手机\"); sourceBulider.query(query); //设置高亮 HighlightBuilder highlighter = new HighlightBuilder(); //设置三要素 highlighter.field(\"title\"); //设置前后缀标签 highlighter.preTags(\"\"); highlighter.postTags(\"\"); //加载已经设置好的高亮配置 sourceBulider.highlighter(highlighter); searchRequest.source(sourceBulider); SearchResponse searchResponse = client.search(searchRequest, RequestOptions.DEFAULT); SearchHits searchHits = searchResponse.getHits(); //获取记录数 long value = searchHits.getTotalHits().value; System.out.println(\"总记录数：\"+value); List goodsList = new ArrayList<>(); SearchHit[] hits = searchHits.getHits(); for (SearchHit hit : hits) { String sourceAsString = hit.getSourceAsString(); //转为java Goods goods = JSON.parseObject(sourceAsString, Goods.class); // 获取高亮结果，替换goods中的title Map highlightFields = hit.getHighlightFields(); HighlightField HighlightField = highlightFields.get(\"title\"); Text[] fragments = HighlightField.fragments(); //highlight title替换 替换goods中的title goods.setTitle(fragments[0].toString()); goodsList.add(goods); } for (Goods goods : goodsList) { System.out.println(goods); } } 1.3.18. 3.15-重建索引&索引别名 #查询别名 默认别名无法查看，默认别名同索引名 GET goods/_alias/ #结果 { \"goods\" : { \"aliases\" : { } } } 1.新建student_index_v1索引 # -------重建索引----------- # 新建student_index_v1。索引名称必须全部小写 PUT student_index_v1 { \"mappings\": { \"properties\": { \"birthday\":{ \"type\": \"date\" } } } } #查看 student_index_v1 结构 GET student_index_v1 #添加数据 PUT student_index_v1/_doc/1 { \"birthday\":\"1999-11-11\" } #查看数据 GET student_index_v1/_search #添加数据 PUT student_index_v1/_doc/1 { \"birthday\":\"1999年11月11日\" } 2.重建索引:将student_index_v1 数据拷贝到 student_index_v2 # 业务变更了，需要改变birthday字段的类型为text # 1. 创建新的索引 student_index_v2 # 2. 将student_index_v1 数据拷贝到 student_index_v2 # 创建新的索引 student_index_v2 PUT student_index_v2 { \"mappings\": { \"properties\": { \"birthday\":{ \"type\": \"text\" } } } } # 将student_index_v1 数据拷贝到 student_index_v2 # _reindex 拷贝数据 POST _reindex { \"source\": { \"index\": \"student_index_v1\" }, \"dest\": { \"index\": \"student_index_v2\" } } GET student_index_v2/_search PUT student_index_v2/_doc/2 { \"birthday\":\"1999年11月11日\" } 3.创建索引库别名： 注意：DELETE student_index_v1 这一操作将删除student_index_v1索引库，并不是删除别名 # 思考： 现在java代码中操作es，还是使用的实student_index_v1老的索引名称。 # 1. 改代码（不推荐） # 2. 索引别名（推荐） # 步骤： # 0. 先删除student_index_v1 # 1. 给student_index_v2起个别名 student_index_v1 # 先删除student_index_v1 #DELETE student_index_v1 这一操作将删除student_index_v1索引库 #索引库默认的别名与索引库同名，无法删除 # 给student_index_v1起个别名 student_index_v11 POST student_index_v2/_alias/student_index_v11 #测试删除命令 POST /_aliases { \"actions\": [ {\"remove\": {\"index\": \"student_index_v1\", \"alias\": \"student_index_v11\"}} ] } # 给student_index_v2起个别名 student_index_v1 POST student_index_v2/_alias/student_index_v1 #查询别名 GET goods/_alias/ GET student_index_v1/_search GET student_index_v2/_search 1.4. 4-ElasticSearch 集群 1.4.1. 4.1-集群介绍 集群和分布式： ​ 集群：多个人做一样的事。 ​ 分布式：多个人做不一样的事 集群解决的问题： ​ 让系统高可用 ​ 分担请求压力 分布式解决的问题： ​ 分担存储和计算的压力，提速 ​ 解耦 集群和分布式架构往往是并存的 1.4.2. 4.2-ES集群相关概念 es 集群: •ElasticSearch 天然支持分布式 •ElasticSearch 的设计隐藏了分布式本身的复杂性 ES集群相关概念: •集群（cluster）：一组拥有共同的 cluster name 的 节点。 •节点（node) ：集群中的一个 Elasticearch 实例 •索引（index) ：es存储数据的地方。相当于关系数据库中的database概念 •分片（shard）：索引可以被拆分为不同的部分进行存储，称为分片。在集群环境下，一个索引的不同分片可以拆分到不同的节点中 •主分片（Primary shard）：相对于副本分片的定义。 •副本分片（Replica shard）每个主分片可以有一个或者多个副本，数据和主分片一样。 1.4.3. 4.3-集群搭建 参见ElasticSearch 集群-集群搭建.md 1.4.4. 4.4-kibina管理集群 vim kibana-7.4.0-linux-x86_64-cluster/config/kibana.yml kibana.yml #支持中文 i18n.locale: \"zh-CN\" #5602避免与之前的冲突 server.port: 5602 server.host: \"0.0.0.0\" server.name: \"kibana-itcast-cluster\" elasticsearch.hosts: [\"http://localhost:9201\",\"http://localhost:9202\",\"http://localhost:9203\"] elasticsearch.requestTimeout: 99999 1.4.5. 4.5-JavaAPI 访问集群 PUT cluster_test { \"mappings\": { \"properties\": { \"name\":{ \"type\": \"text\" } } } } GET cluster_test GET cluster_test/_search POST /cluster_test/_doc/1 { \"name\":\"张三\" } 测试类 @Resource(name=\"clusterClient\") RestHighLevelClient clusterClient; /** * 测试集群 * @throws IOException */ @Test public void testCluster() throws IOException { //设置查询的索引、文档 GetRequest indexRequest=new GetRequest(\"cluster_test\",\"1\"); GetResponse response = clusterClient.get(indexRequest, RequestOptions.DEFAULT); System.out.println(response.getSourceAsString()); } ElasticSearchConfig private String host1; private int port1; private String host2; private int port2; private String host3; private int port3; //get/set ... @Bean(\"clusterClient\") public RestHighLevelClient clusterClient(){ return new RestHighLevelClient(RestClient.builder( new HttpHost(host1,port1,\"http\"), new HttpHost(host2,port2,\"http\"), new HttpHost(host3,port3,\"http\") )); } application.yml elasticsearch: host: 192.168.140.130 port: 9200 host1: 192.168.140.130 port1: 9201 host2: 192.168.140.130 port2: 9202 host3: 192.168.140.130 port3: 9203 1.4.6. 4.6-分片配置 •在创建索引时，如果不指定分片配置，则默认主分片1，副本分片1。 •在创建索引时，可以通过settings设置分片 分片配置 #分片配置 #\"number_of_shards\": 3, 主分片数量 #\"number_of_replicas\": 1 主分片备份数量，每一个主分片有一个备份 # 3个主分片+3个副分片=6个分片 PUT cluster_test1 { \"settings\": { \"number_of_shards\": 3, \"number_of_replicas\": 1 }, \"mappings\": { \"properties\": { \"name\":{ \"type\": \"text\" } } } } 1.三个节点正常运行（0、1、2分片标号） 2.itcast-3 挂掉 3.将挂掉节点的分片，自平衡到其他节点 4.itcast-3 恢复正常后，节点分片将自平衡回去（并不一定是原来的分片） 分片与自平衡 •当节点挂掉后，挂掉的节点分片会自平衡到其他节点中 注意：分片数量一旦确定好，不能修改。 索引分片推荐配置方案： 1.每个分片推荐大小10-30GB 2.分片数量推荐 = 节点数量 * 1~3倍 思考：比如有1000GB数据，应该有多少个分片？多少个节点 1.每个分片20GB 则可以分为40个分片 2.分片数量推荐 = 节点数量 * 1~3倍 --> 40/2=20 即20个节点 1.4.7. 4.7-路由原理 路由原理 •文档存入对应的分片，ES计算分片编号的过程，称为路由。 •Elasticsearch 是怎么知道一个文档应该存放到哪个分片中呢？ •查询时，根据文档id查询文档， Elasticsearch 又该去哪个分片中查询数据呢？ •路由算法 ：shard_index = hash(id) % number_of_primary_shards 查询id为5的文档：假如hash(5)=17 ，根据算法17%3=2 1.4.8. 4.8-脑裂 ElasticSearch 集群正常状态： • 一个正常es集群中只有一个主节点（Master），主节点负责管理整个集群。如创建或删除索引，跟踪哪些节点是群集的一部分，并决定哪些分片分配给相关的节点。 •集群的所有节点都会选择同一个节点作为主节点。 脑裂现象： •脑裂问题的出现就是因为从节点在选择主节点上出现分歧导致一个集群出现多个主节点从而使集群分裂，使得集群处于异常状态。 脑裂产生的原因： 1.网络原因：网络延迟 ​ •一般es集群会在内网部署，也可能在外网部署，比如阿里云。 ​ •内网一般不会出现此问题，外网的网络出现问题的可能性大些。 2.节点负载 ​ •主节点的角色既为master又为data。数据访问量较大时，可能会导致Master节点停止响应（假死状态）。 ​ JVM内存回收 •当Master节点设置的JVM内存较小时，引发JVM的大规模内存回收，造成ES进程失去响应。 避免脑裂： 1.网络原因：discovery.zen.ping.timeout 超时时间配置大一点。默认是3S 2.节点负载：角色分离策略 ​ •候选主节点配置为 ​ •node.master: true ​ •node.data: false ​ •数据节点配置为 ​ •node.master: false ​ •node.data: true 3.JVM内存回收：修改 config/jvm.options 文件的 -Xms 和 -Xmx 为服务器的内存一半。 1.4.9. 30-ElasticSearch 集群-集群扩容 按照集群搭建步骤再复制Es节点进行配置，参见ElasticSearch 集群-集群搭建.md Copyright © MISIN 2022 | 豫ICP备2021006345号-1 all right reserved，powered by Gitbook该文件修订时间： 2022-11-10 11:36:00 "},"5.大数据基础增强/1.Linux实战/day01/day01.html":{"url":"5.大数据基础增强/1.Linux实战/day01/day01.html","title":"Day 01","keywords":"","body":"1. 一、操作系统概述1.1. 目标1.2. 1 操作系统(Operation System, OS)1.3. 2 不同应用利于的主流操作系统1.3.1. 2.1 桌面操作系统1.3.2. 2.2 服务器操作系统1.3.3. 2.3 嵌入式操作系统1.3.4. 2.4 移动设备操作系统1.4. 2 发展史1.5. 3 内核1.6. 4 发行版2. 二、系统安装2.1. 目标2.2. 1 VM虚拟机2.2.1. 1.1 概述2.2.2. 1.2 安装虚拟机2.2.3. 1.3 配置网卡2.2.4. 目标2.3. 2 centos是linux的发行版2.3.1. 2.1 目标2.3.2. 2.2 路径2.3.3. 2.4 实现2.4. 4 远程连接工具2.4.1. 4.1 secureCRT软件2.4.2. 4.2 winSCP2.5. 5 快照(备份)2.5.1. 5.1 目标2.5.2. 5.2 备份系统2.5.3. 5.3 恢复到快照状态3. 三、命令概述3.1. 1.学习Linux终端命令的原因3.2. 2.Linux终端命令格式3.3. 目标3.3.1. 2.1 终端命令格式3.3.2. 2.2 查阅命令帮助信息4. 四、文件和目录常用命令4.1. 目标4.2. 1.查看目录内容4.2.1. 1.1 终端使用技巧4.2.2. 1.2 ls命令说明4.2.3. 1.3 ls常用选项4.2.4. 1.4 ls 和通配符的使用4.3. 2.切换目录4.3.1. 2.1 cd4.3.2. 2.2 相对路径和绝对路径4.4. 3.创建和删除操作4.4.1. 3.1 touch4.4.2. 3.2 mkdir4.4.3. 3.3 rm4.5. 4.拷贝和移动文件4.5.1. 4.1 tree (扩展)4.5.2. 4.2 cp4.5.3. 4.3 mv (move)4.6. 5.查看文件内容4.6.1. 准备工作4.6.2. 5.1 cat4.6.3. 5.2 less4.6.4. 5.3 head4.6.5. 5.4 tail4.6.6. 5.5 grep(重点重点重点)4.7. 6 其他4.7.1. 6.1 管道 | (入门)4.7.2. 6.2 echo 文字内容4.7.3. 6.3 重定向 >(覆盖) 和 >> (追加)4.7.4. 6.4 && 和 ||4.7.5. 6.5 软链接(类似与 快捷方式)[TOC] 1. 一、操作系统概述 1.1. 目标 了解 操作系统 的作用 1.2. 1 操作系统(Operation System, OS) 操作系统作为接口的示意图: 没有安装操作系统的计算机, 通常被称为 裸机 如果想在 裸机 上运行自己所编写的程序, 就必须用机器语言书写程序 如果计算机上安装了操作系统, 就可以在操作系统上安装支持的高级语言环境,用于高级语言开发 1.3. 2 不同应用利于的主流操作系统 桌面操作系统 服务器操作系统 嵌入式操作系统 移动设备操作系统 1.3.1. 2.1 桌面操作系统 Window 系列 用户群体大 macOS 细节处理的更好, 没有windows软件丰富, 价格高 Linux 应用软件少 1.3.2. 2.2 服务器操作系统 Linux 安全、稳定、免费 占有率高 Windows Server 付费 占有率低 1.3.3. 2.3 嵌入式操作系统 Linux 1.3.4. 2.4 移动设备操作系统 IOS Android (基于Linux) 华为鸿蒙(基于linux) . 1.4. 2 发展史 . linux 创始人: 林纳斯 托瓦兹 linux 诞生于: 1991年 作者上大学期间 诞生原因: 因为创始人 经常需要浏览新闻和处理邮件, 为了方便 读写 和 下载, 所以开发了 文件系统, 当时 21岁. linux是开源免费 后来经过全世界网友的支持, 现在能够兼容多种硬件 1.5. 3 内核 内核(kernel) 是系统的心脏, 是运行程序和管理磁盘和打印机等硬件设备的核心程序. Linux内核版本 稳定版 具有工业级强度, 可以广泛的应用和部署. 开发版 由于要试验各种解决方案, 所以变化很快 内核源码网址: http:www.kernet.ort 所有来自全世界的对linux源码的修改最终都会汇总到这个网站, 由 Linus 领导的开源社区对其进行甄别和修改, 最终决定是否进入到 LInux主线内核源码中 1.6. 4 发行版 redhat：目前，全球最大的linux发行厂商，功能全面、稳定。 Redhat 被 IBM 收购! ubuntu：目前，是linux桌面操作系统做的最好的。 centos：免费版的redhat，centos 基于 redhat 发行版基础之上，再重新编译发布的版本。 目前 centos 已经被 Redhat 公司收购，但是依然免费 2. 二、系统安装 2.1. 目标 1: 使用 VM 虚拟机 模拟 电脑硬件 2: 在虚拟的 电脑上 安装 centOS 操作系统( linux 发行版) 3: 为了让别人能够访问操作, 配置 网络环境 4: 使用远程客户端 CRT 和 WinSCP 操作 linux操作系统 5: 防止操作系统 意外损坏, 及时备份(快照) 2.2. 1 VM虚拟机 2.2.1. 1.1 概述 虚拟机 (Virtual Machine) 指通过 软件模拟 的具有完整硬件系统功能的. 运行在一个完全隔离环境中的完整计算机系统 虚拟系统通过生成现有操作系统的全新虚拟镜像, 具有真实操作系统完全一样的功能. 进入虚拟系统后, 所有操作都是在这个独立全新的独立的虚拟系统里面进行, 可以独立安装运行软件, 保存数据, 不会对真正的系统产生任何影响 而且现有在系统与虚拟镜像之间灵活切换的一类操作系统 2.2.2. 1.2 安装虚拟机 详情请参考 资料 的word文档! 2.2.3. 1.3 配置网卡 2.2.4. 目标 了解桥接 和 NAT 的 联网原理 配置虚拟机的网卡信息 a. 网络原理 桥接原理 因为 虚拟机的linux系统的ip地址是固定的, 更换路由器后导致无法使用, 所以 不推荐使用 NAT原理 如果宿主电脑可以上网, 内部的虚拟机也可以上网就好了 NAT原理本质上就是 虚拟机实现了交换机的功能, linux系统的IP地址就不会随宿主电脑的ip地址更改而更改 推荐使用这种方式 b. 确保 VMnet8 已经启动 c. 设置VMnet8的ip地址 网关: 192.168.100.1 d. 确保所有关于VMWare的服务都开启 e 配置虚拟机的网卡 核查 配置子网ip和子网掩码 再次确认 2.3. 2 centos是linux的发行版 2.3.1. 2.1 目标 在虚拟机上 安装centos系统 模拟 机房的一台服务器 2.3.2. 2.2 路径 第一步: 理解安装步骤 第二步: 使用VM虚拟机 准备 硬件环境 第三步: 在硬件环境 安装CentOs镜像 第四步: 理解centos的文件和目录 2.3.3. 2.4 实现 2.4.1 理解安装步骤 2.4.2 使用VM虚拟机 准备 硬件环境 请参考资料中 word 文档 2.4.3 在硬件环境 安装CentOs镜像 请参考资料中 word 文档 2.4.4 配置网卡信息 目标 能够让 宿主机 和 新装的centOS 相互通信 第一步: 了解 网卡 和ip地址的概念 网卡是一个专门负责网络通讯的硬件设备 ip地址是设置在网卡上的地址信息 我们可以把 电脑 比作 手机, 网卡 相当于 手机卡槽, ip地址 相当于 手机号 IP地址 每台联网的电脑上都有IP地址, 是保证电脑之间正常通讯的重要设置 注意: 每台电脑的IP地址不能相同, 否则 会出现IP地址冲突, 并且没有办法正常通讯 第二步: 查看网卡信息 ifconfig 和 ping 序号 命令 对应英文 作用 01 ifconfig configuration a newwork interface 查看/配置计算机当前的网卡信息 02 ping ip地址 ping 检测到目标ip地址 的连接是否正常 03 service network restart 重启网卡服务 第三步: 通过 setup 命令设置网卡信息 # 开始设置网卡信息 setup 重启网卡服务 测试能否上网, 注意: 前提是 宿主机必须能够上网 2.4.5 理解centos的文件和目录 windows 系统 可以拥有多个盘符, 如 C盘、D盘、E盘 Linux 没有盘符 这个概念, 只有一个根目录 /, 所有文件都在它下面 Linux主要目录 速查表 /lsdt： found系统修复用的 /bin： 二进制命令所在的目录 /boot ： 系统引导程序所需要的文件目录，引导系统开机 /dev ：设备软件目录，磁盘，光驱， /etc ： 系统配置，启动程序 /home：普通用户的家目录，目录默认数据存放目录 /lib： 启动系统和运行命令所需的共享库文件和内核模块存放 /mnt：临时挂载储存设备的挂载点，u盘插入光驱无法使用，需要挂载然后使用 /opt：额外的应用软件包 /proc：操作系统运行时，进程信息和内核信息存放在这里 /root：Linux超级权限用户root的家目录 /sbin：和管理系统相关的命令，【超级管理员用】 /tmp：临时文件目录，这个目录被当作回收站使用 /usr：用户或系统软件应用程序目录 /var：存放系统日志的目录 注意：一般不要 操作 非自己创建的目录和文件，否则可能导致服务器崩溃。 2.4. 4 远程连接工具 2.4.1. 4.1 secureCRT软件 secureCRT是Windows上 登录 服务器主机的软件 主要是 通过命令行操作服务器 a.安装 双击 下一步 就可以了 b.配置连接 linux系统 . . . . c. 修改主题和字体大小 . d. 常用快捷键 tab键：命令或者路径提示及补全; ctrl+c：放弃当前输入，终止当前任务或程序； ctrl+l：清屏； ctrl+shift+c：复制； ctrl+shift+v：粘贴； alt+b ：打开connect窗口 了解 alt+1/2/3/4/5… ：切换会话窗口 了解 2.4.2. 4.2 winSCP 它的主要功能就是在本地与远程计算机间 进行 文件 上传和下载 使用 鼠标拖拽 即可完成 2.5. 5 快照(备份) 2.5.1. 5.1 目标 快照就是 备份系统, 防止意外损坏, 降低损失 2.5.2. 5.2 备份系统 a. 右键目标centos系统 -> 快照 -> 快照管理器 b. 拍摄快照 2.5.3. 5.3 恢复到快照状态 a. 右键目标centos系统 -> 快照 -> 恢复到指定快照即可 3. 三、命令概述 3.1. 1.学习Linux终端命令的原因 Linux刚面世时并没有图形界面, 所有的操作全靠命令完成, 如 磁盘操作、文件存取、目录操作、进程管理、文件权限 设定等 在职场中，大量的 服务器维护工作 都是在 远程 通过SSH客户端 来完成的， 并没有图形界面， 所有的维护工作都需要通过命令来完成 在职场中， 作为后端程序员， 必须要或多或少的掌握一些Linux常用的终端命令 Linux发行版本的命令大概有200多个， 但是常用的命令只有10多个而已 学习终端命令的技巧： 不需要死记硬背， 对于常用命令， 用的多了， 自然就记住了。 不要尝试一次学会所有的命令， 有些命令是非常不常用的，临时遇到， 临时百度就可以 3.2. 2.Linux终端命令格式 3.3. 目标 了解终端命令格式 常用Linux命令体验 知道如何查阅终端命令帮助信息 3.3.1. 2.1 终端命令格式 command [-options] [parameter] 说明: command : 命令名, 相应功能的英文单词或单词的缩写 [-options] : 选项, 可用来对命令进行控制, 也可以省略 parameter : 传给命令的参数, 可以是 零个、一个 或者 多个 常用Linux命令的基本使用 序号 命令 对应英文 作用 01 ls list 查看当前目录下的内容 02 pwd print working derectory 查看当前所在文件夹 03 cd [目录名] change directory 切换文件夹 04 touch [文件名] touch 如果文件不存在, 新建文件 05 mkdir [目录名] make directory 创建目录 06 rm [文件名] remove 删除指定的文件名 07 clear clear 清屏 3.3.2. 2.2 查阅命令帮助信息 因为一个命令有很多可选项, 死记硬背肯定不行, 所以需要借助手册查阅. 2.2.1 --help 帮助信息 command --help 说明: 显示 command 命令的帮助信息 缺点: 虽然可以查询命令的帮助信息, 但是没有提供 翻页、搜索功能. 2.2.2 man 手册 man command 说明: 查询command命令的使用手册 man 时 manual 的缩写, 是Linux提供的一个手册, 包含了绝大部分的命令、函数的详细使用说明. 使用 man 时的操作键: 操作键 功能 空格键 显示手册的下一屏 Enter键 一次滚动首页也得一行 b(back) 回滚一屏 f(forward) 前滚一屏 q (quit) 退出 /word 搜索word字符串 n(next) 搜索下一个 N 搜索上一个 提醒: 现阶段只需要 知道 通过以下两种方式可以查询命令的帮助信息 先学习 常用命令 及 常用参数 的使用即可, 工作中如果遇到问题可以借助 网络搜索 4. 四、文件和目录常用命令 4.1. 目标 查看目录内容 ls 切换目录 cd 创建和删除操作 touch rm mkdir 拷贝和移动文件 cp mv 查看文件内容 cat less grep 其他 echo 重定向 > 和 >> 管道 | 4.2. 1.查看目录内容 4.2.1. 1.1 终端使用技巧 1> 自动补全 在敲出 文件/ 目录 / 命令 的前几个字母之后, 按下 tab键 如果还存在其他 文件 / 目录 / 命令, 再按一下tab键, 系统会提示可能存在的命令 2> 曾经使用过的命令 使用 上 / 下 光标键可以在曾经使用过的命令之间来回切换 如果想要退出选择, 并且不想执行当前选中的命令, 可以按 ctrl + c 4.2.2. 1.2 ls命令说明 ls 是英文单词list的简写, 其功能为列出目录的内容,是用户最常用的命令之一 因为需要编辑服务器上的文件, 所以需要先确认指定目录下 是否存在 linux 下文件和目录的特点 linux文件 或者 目录 名称最长可以 256 个字符 以 . 开头的文件为隐藏文件, 需要用 -a 参数才能显示 . 代表当前目录 .. 代表上一级目录 演练目标: 1 创建文件 01.txt 2 创建隐藏文件 02.txt 3 罗列隐藏文件和非隐藏文件 [root@node01 export]# touch 01.txt [root@node01 export]# touch .02.txt [root@node01 export]# ls 01.txt [root@node01 export]# ls -a . .. 01.txt .02.txt 4.2.3. 1.3 ls常用选项 如果 只使用ls命令 就只能看到当前目录下 非隐藏 文件。 如果想增强功能，就需要学习更多的选项 选项 英文 含义 -a all 显示指定目录下所有子目录与文件, 包含隐藏文件 -l 以列表方式显示文件的详细信息 -h human-readable 配合 -l 以人性化的方式显示文件大小 演练目标: 1 切换到 /usr/tmp 清空内容 2 创建隐藏文件 非隐藏文件 目录 3 查看当前目录内容 (缺点: 隐藏文件看不到) 4 查看当前目录所有内容 (既包含隐藏, 也包含非隐藏) 5 查看目录内容的详细信息(查看文件类型、权限、大小等 缺点：文件大小没有单位) 6 简化合并 查看目录内容的详细信息 [root@node01 tmp]# cd /usr/tmp && rm -rf * [root@node01 tmp]# ll total 0 [root@node01 tmp]# touch 01.txt .02.txt [root@node01 tmp]# ls 01.txt [root@node01 tmp]# ls -a . .. 01.txt .02.txt [root@node01 tmp]# ll total 0 -rw-r--r--. 1 root root 0 Jul 10 21:04 01.txt [root@node01 tmp]# ll -a total 8 drwxrwxrwt. 2 root root 4096 Jul 10 21:04 . drwxr-xr-x. 20 root root 4096 Jul 10 19:10 .. -rw-r--r--. 1 root root 0 Jul 10 21:04 01.txt -rw-r--r--. 1 root root 0 Jul 10 21:04 .02.txt 计算机中文件大小的表示方式(科普) 单温 英文 含义 字节 B(byte) 在计算机中作为一个数字单元,一般为8位二进制数 千 K(Kibibyte) 1KB = 1024 B, 千字节( 1024 = 2的10次方) 兆 M(Mebibyte) 1MB = 1024 KB, 百万字节 千兆 G(Gigabytee) 1GB = 1024 MB, 十亿字节, 千兆字节 太 T(Terabyte) 1 TB = 1024 GB, 万亿字节, 太字节 拍 P(Petabyte) 1 PB = 1024 PB, 百万亿字节, 拍字节 4.2.4. 1.4 ls 和通配符的使用 准备工作 # 切换到临时目录(先使用, 稍候讲解) cd /usr/tmp # 清空目录内容(先使用, 稍候讲解) rm -rf * # 创建文件 touch a23.txt 11.txt 111.txt 112.txt 123.txt 223.txt 323.txt 423.txt 523.txt # 查看目录内容 ls 通配符 含义 * 代表 任意个数 的字符 ? 代表任意一个字符, 且只能是一个 需求1: 1 查看以 1 开头的文件或目录 2 查看以 3.txt 结尾的 文件或目录 3 查看含有3的文件列表 4 查看第二个字符是2的文件 [root@node01 tmp]# ls 1* 111.txt 112.txt 11.txt 123.txt [root@node01 tmp]# ls *3.txt 123.txt 223.txt 323.txt 423.txt 523.txt a23.txt [root@node01 tmp]# ls *3* 123.txt 223.txt 323.txt 423.txt 523.txt a23.txt [root@node01 tmp]# ls ?2* 123.txt 223.txt 323.txt 423.txt 523.txt a23.txt 通配符 含义 [abc] 匹配a、b、c中任意一个 [a-f] 匹配从a到f范围内的任意一个字符 需求2: 1 查看 第一个字符是 1到5, 以23.txt结尾 的 目录或文件名 [root@node01 tmp]# ls [1-5]*23.txt 123.txt 223.txt 323.txt 423.txt 523.txt 4.3. 2.切换目录 4.3.1. 2.1 cd cd 是英文单词 change directory 的缩写, 其功能为 更改当前的工作目录, 也是用户最常用的命令之一 注意: linux的所有 目录 和 文件名 都是大小写敏感的 命令 含义 cd 目录 切换到指定目录下 cd .. 切换到上级目录 cd - 可以在最近的两次目录之间切换 cd ~ 切换到家目录(root用户家目录是 /root, 其他用户的家目录是 /home/用户名) 需求: 1 查看当前所在目录 2 切换到 /usr/local 3 切换到 上一级目录 /usr 4 后退到上一次访问的目录中 [root@node01 tmp]# pwd /usr/tmp [root@node01 tmp]# cd /usr/local [root@node01 local]# pwd /usr/local [root@node01 local]# cd ../ [root@node01 usr]# pwd /usr [root@node01 usr]# cd - /usr/local 4.3.2. 2.2 相对路径和绝对路径 2.2.1 目标 : 通过 路径 找到 目标 2.2.2 如何分步骤实现: ​ 第一步: 使用相对路径定位目标 ​ 第二步: 使用绝对路径定位目标 2.2.3 第一步: 使用相对路径定位目标 特征: 相对路径 输入路径时, 最前面不是以 \"/\" 开始的, 表示相对 当前目录 所在的位置 缺点: 参照工作目录 发生变化 相对路径也要发生变化 需求1: 当前工作目录是 /usr, 使用相对路径 切换到 /usr/tmp 目录下 需求2: 当前工作目录是 /root, 使用相对路径 切换到 /usr/tmp 目录下 [root@node01 tmp]# cd /usr [root@node01 usr]# pwd /usr [root@node01 usr]# cd ./tmp [root@node01 tmp]# pwd /usr/tmp [root@node01 tmp]# cd ~ [root@node01 ~]# pwd /root [root@node01 ~]# cd ../usr/tmp [root@node01 tmp]# pwd /usr/tmp 2.2.4 第二步: 使用绝对路径定位目标 特征: 绝对路径 在输入路径时, 最前面是以 / 开始的, 表示 从 根目录 开始的具体目录位置 优点: 定位准确, 不会因为 工作目录变化 而变化 需求1: 当前工作目录是 /usr, 使用绝对路径 切换到 /usr/tmp 目录下 需求2: 当前工作目录是 /root, 使用绝对路径 切换到 /usr/tmp 目录下 [root@node01 ~]# cd /usr [root@node01 usr]# cd /usr/tmp [root@node01 tmp]# pwd /usr/tmp [root@node01 tmp]# cd /root [root@node01 ~]# pwd /root [root@node01 ~]# cd /usr/tmp [root@node01 tmp]# pwd /usr/tmp 2.2.5 小总结 相对路径 在输入路径时, 最前面不是以 / 开始的 , 表示相对 当前目录 所在的目录位置 绝对路径 在输入路径时, 最前面是以 / 开始的, 表示 从 根目录 开始的具体目录位置 4.4. 3.创建和删除操作 4.4.1. 3.1 touch 3.1.1 目标 通过 touch 命令 创建文件 3.1.2 路径 第一步: 创建一个空白文件 第二步: 修改文件的末次修改日期 3.1.3 实现 3.1.3.1 第一步: 创建一个空白文件 touch 不存在的文件 3.1.3.2 第二步: 修改文件的末次访问时间 touch 存在的文件 3.1.4 小结 通过 touch 文件名 创建文件 和 修改文件的末次访问时间 4.4.2. 3.2 mkdir 3.2.1 目标: 通过 mkdir 命令 创建目录 3.2.2 路径: 第一步: 创建 没有层级关系的目录 第二步: 创建 有层级关系的目录 3.2.3 实现 yum -y install tree 3.2.3.1 第一步: 创建 没有层级关系的目录 mkdir 目录名 3.2.3.2 第二步: 创建 有层级关系 的目录 mkdir -p 目录1/目录2/目录3 创建一个新的目录 选项 英文 含义 -p parent 可以递归创建目录 # 创建压缩包目录 mkdir -p /export/softwares mkdir -p /export/servers mkdir -p /export/data 3.2.4 小结 通过 mkdir -p 目录名 命令 创建目录 注意: 新建目录的名称 不能与当前目录中 已有的目录或文件 同名 4.4.3. 3.3 rm 3.3.1 目标 通过 rm -rf 文件/目录 命令实现删除 文件和目录的功能, rm 对应的英文是 remove 含义: 删除 3.3.2 路径 第一步: 删除文件 (有提示) 第二步: 删除文件 (取消提示) 第三步: 删除目录 第四步: rm 结合 通配符 3.3.3 实现 准备工作 cd /usr/tmp rm -rf * touch 1.txt 2.txt 3.txt 4.txt 5.txt mkdir -p aaa/bbb/ccc mkdir -p x1 3.3.3.1 第一步: 删除文件 (有提示) rm 文件 [root@node01 tmp]# ll total 8 -rw-r--r--. 1 root root 0 Jul 10 21:20 1.txt -rw-r--r--. 1 root root 0 Jul 10 21:20 2.txt -rw-r--r--. 1 root root 0 Jul 10 21:20 3.txt -rw-r--r--. 1 root root 0 Jul 10 21:20 4.txt -rw-r--r--. 1 root root 0 Jul 10 21:20 5.txt drwxr-xr-x. 3 root root 4096 Jul 10 21:20 aaa drwxr-xr-x. 2 root root 4096 Jul 10 21:20 x1 [root@node01 tmp]# rm 1.txt rm: remove regular empty file `1.txt'? y [root@node01 tmp]# ll total 8 -rw-r--r--. 1 root root 0 Jul 10 21:20 2.txt -rw-r--r--. 1 root root 0 Jul 10 21:20 3.txt -rw-r--r--. 1 root root 0 Jul 10 21:20 4.txt -rw-r--r--. 1 root root 0 Jul 10 21:20 5.txt drwxr-xr-x. 3 root root 4096 Jul 10 21:20 aaa drwxr-xr-x. 2 root root 4096 Jul 10 21:20 x1 3.3.3.2 第二步: 删除文件 (取消提示) rm -f 文件 参数 英文 含义 -f force (强制) 强制删除,忽略不存在的文件, 无需提示 [root@node01 tmp]# ll total 8 -rw-r--r--. 1 root root 0 Jul 10 21:20 3.txt -rw-r--r--. 1 root root 0 Jul 10 21:20 4.txt -rw-r--r--. 1 root root 0 Jul 10 21:20 5.txt drwxr-xr-x. 3 root root 4096 Jul 10 21:20 aaa drwxr-xr-x. 2 root root 4096 Jul 10 21:20 x1 3.3.3.3 第三步: 删除有内容的目录 rm -rf 目录 参数 英文 含义 -r recursive (递归) 递归地删除目录下的内容, 删除文件夹 时必须加此参数 [root@node01 tmp]# rm aaa/ rm: cannot remove `aaa/': Is a directory [root@node01 tmp]# rm -r aaa/ rm: descend into directory `aaa'? y rm: descend into directory `aaa/bbb'? y rm: remove directory `aaa/bbb/ccc'? y rm: remove directory `aaa/bbb'? y rm: remove directory `aaa'? y [root@node01 tmp]# ll total 4 -rw-r--r--. 1 root root 0 Jul 10 21:20 3.txt -rw-r--r--. 1 root root 0 Jul 10 21:20 4.txt -rw-r--r--. 1 root root 0 Jul 10 21:20 5.txt drwxr-xr-x. 2 root root 4096 Jul 10 21:20 x1 3.3.3.4 第四步: rm 结合 通配符 * ? [abc][a-z] rm -rf *.txt 3.3.4 小结 通过 rm -rf 文件/目录 完成删除 文件或目录的功能. 注意: 使用 rm 命令要小心, 因为文件删除后不能恢复 4.5. 4.拷贝和移动文件 序号 命令 对应英文 作用 01 tree [目录名] tree 以树状图 列出目录中的内容 02 cp 源文件 目标文件 copy 复制文件或者目录 03 mv 源文件 目标文件 move 移动文件或目录 或者 重命名 4.5.1. 4.1 tree (扩展) 4.2.1 目标 通过 tree 命令可以以树状图列出文件目录结构. 4.2.2 路径 第一步: 以树形结构显示目录中的文件和目录 第二步: 只显示 当前目录中的目录 第三步: 显示指定的两层 4.2.3 实现 准备工作 # 创建目录 mkdir -p /export/aaa/bbb/ccc # 创建文件 touch /export/aaa/01.txt /export/aaa/02.txt touch /export/aaa/bbb/03.txt /export/aaa/bbb/04.txt touch /export/aaa/bbb/ccc/05.txt /export/aaa/bbb/ccc/06.txt 默认没有安装 tree 组件, 需要联网时安装: # 安装 tree组件 yum -y install tree # 卸载 tree组件 yum -y remove tree 4.2.3.1 第一步: 以树形结构显示目录中的文件和目录 tree [目录] 如果指定目录, 就显示指定目录的内容 如果不指定目录,就显示当前目录的内容 4.2.3.2 第二步: 只显示 当前目录中的目录 tree -d [目录] 选项 英文 含义 -d derictory (目录) 只显示目录, 不显示文件 4.2.3.3 第三步: 显示指定的两层 tree -L n [目录] 选项 英文 含义 -L level (层级) 显示几层目录 4.2.4 小结 通过 tree 目录 命令可以以树状图列出文件目录结构. [root@node01 ~]# tree /export /export ├── 01.txt └── aaa ├── 01.txt ├── 02.txt └── bbb ├── 03.txt ├── 04.txt └── ccc ├── 05.txt └── 06.txt 3 directories, 7 files [root@node01 ~]# tree -d . 0 directories [root@node01 ~]# tree -d /export /export └── aaa └── bbb └── ccc 3 directories [root@node01 ~]# tree -L 2 /export /export ├── 01.txt └── aaa ├── 01.txt ├── 02.txt └── bbb 2 directories, 3 files 4.5.2. 4.2 cp 4.2.1 目标 通过 cp 实现复制将指定的 文件 或 目录 复制到 两一个 文件 或 目录中 4.2.2 路径 第一步: 备份指定文件 第二步: 将文件复制到目录中 第三步: 将文件复制到另一个文件中, 实现覆盖效果 第四步: 复制目录 到指定 目录中 4.2.3 实现 4.2.3.1 第一步: 备份指定文件 cp 文件1 备份文件名 [root@node01 export]# cp 01.txt 01.txt_bak [root@node01 export]# ll total 4 -rw-r--r--. 1 root root 0 Jul 10 21:02 01.txt -rw-r--r--. 1 root root 0 Jul 10 22:45 01.txt_bak drwxr-xr-x. 3 root root 4096 Jul 10 21:24 aaa 4.2.3.2 第二步: 将文件复制到目录中 cp 文件1 目录/ [root@node01 export]# mkdir -p x1 [root@node01 export]# tree . ├── 01.txt ├── 01.txt_bak ├── aaa │ ├── 01.txt │ ├── 02.txt │ └── bbb │ ├── 03.txt │ ├── 04.txt │ └── ccc │ ├── 05.txt │ └── 06.txt └── x1 4 directories, 8 files [root@node01 export]# cp 01.txt ./x1/01.txt_bak2 [root@node01 export]# tree . ├── 01.txt ├── 01.txt_bak ├── aaa │ ├── 01.txt │ ├── 02.txt │ └── bbb │ ├── 03.txt │ ├── 04.txt │ └── ccc │ ├── 05.txt │ └── 06.txt └── x1 └── 01.txt_bak2 4.2.3.3 第三步: 将文件复制到另一个文件中, 实现覆盖效果 cp 文件1 文件2(存在的) [root@node01 export]# cp /etc/profile ./01.txt cp: overwrite `./01.txt'? y [root@node01 export]# ll total 12 -rw-r--r--. 1 root root 1841 Jul 10 22:47 01.txt -rw-r--r--. 1 root root 0 Jul 10 22:45 01.txt_bak drwxr-xr-x. 3 root root 4096 Jul 10 21:24 aaa drwxr-xr-x. 2 root root 4096 Jul 10 22:45 x1 4.2.3.4 第四步: 复制目录 到指定 目录中 cp -r 目录1/ 目录2/ 命令 英文 作用 -r recursive (递归) 递归复制目标目录的内容 [root@node01 export]# tree . ├── 01.txt ├── 01.txt_bak ├── aaa │ ├── 01.txt │ ├── 02.txt │ └── bbb │ ├── 03.txt │ ├── 04.txt │ └── ccc │ ├── 05.txt │ └── 06.txt └── x1 └── 01.txt_bak2 4 directories, 9 files [root@node01 export]# cp aaa/ x1/ cp: omitting directory `aaa/' [root@node01 export]# cp -r aaa/ x1/ [root@node01 export]# tree . ├── 01.txt ├── 01.txt_bak ├── aaa │ ├── 01.txt │ ├── 02.txt │ └── bbb │ ├── 03.txt │ ├── 04.txt │ └── ccc │ ├── 05.txt │ └── 06.txt └── x1 ├── 01.txt_bak2 └── aaa ├── 01.txt ├── 02.txt └── bbb ├── 03.txt ├── 04.txt └── ccc ├── 05.txt └── 06.txt 7 directories, 15 files 4.2.4 小结 cp命令的功能是将给出的 文件 或 目录 复制到另一个 文件 或 目录中 4.5.3. 4.3 mv (move) 4.3.1 目标 通过mv 命令可以用来 移动 文件 或 目录, 也可以给 文件或目录重命名 4.3.2 路径 第一步: 将文件 移动 另一个目录中 第二步: 重命名 第三步: 将目录移动到 另一个目录中 4.3.3 实现 4.3.3.1 第一步: 将文件 移动 另一个目录中 mv 文件 目录/ [root@node01 export]# mv 01.txt_bak x1/ [root@node01 export]# tree . ├── 0001.txt ├── aaa │ ├── 01.txt │ ├── 02.txt │ └── bbb │ ├── 03.txt │ ├── 04.txt │ └── ccc │ ├── 05.txt │ └── 06.txt └── x1 └── 01.txt_bak 4.3.3.2 第二步: 重命名 mv 旧文件名 新文件名 [root@node01 export]# ll total 12 -rw-r--r--. 1 root root 1841 Jul 10 22:47 01.txt -rw-r--r--. 1 root root 0 Jul 10 22:45 01.txt_bak drwxr-xr-x. 3 root root 4096 Jul 10 21:24 aaa drwxr-xr-x. 2 root root 4096 Jul 10 22:48 x1 [root@node01 export]# mv 01.txt 0001.txt [root@node01 export]# ll total 12 -rw-r--r--. 1 root root 1841 Jul 10 22:47 0001.txt -rw-r--r--. 1 root root 0 Jul 10 22:45 01.txt_bak drwxr-xr-x. 3 root root 4096 Jul 10 21:24 aaa drwxr-xr-x. 2 root root 4096 Jul 10 22:48 x1 4.3.3.3 第三步: 将目录移动 到 另一个目录中 mv 被移动目录 目标目录 [root@node01 export]# mv -r aaa/ x1/ mv: invalid option -- 'r' Try `mv --help' for more information. [root@node01 export]# mv aaa/ x1/ [root@node01 export]# tree . ├── 0001.txt └── x1 ├── 01.txt_bak └── aaa ├── 01.txt ├── 02.txt └── bbb ├── 03.txt ├── 04.txt └── ccc ├── 05.txt └── 06.txt 4.3.4 小结 mv 可以用来 移动 文件 或 目录, 也可以给 文件或目录重命名 4.6. 5.查看文件内容 序号 命令 对应英文 作用 01 cat 文件名 concatenate 查看小文件内容 02 less -N 文件名 less 分频 显示大文件内容 03 head -n 文件名 查看文件的前一部分 04 tail -n 文件名 查看文件的最后部分 05 grep 关键字 文件名 grep 根据关键词, 搜索文本文件内容 4.6.1. 准备工作 # 清空指定目录内容 cd /export/ rm -rf * # 复制 /etc/passwd 文件 到 /export/ 目录中 cp /etc/passwd /export/ # 复制 /etc/profile 文件 到 /export/ 目录中 cp /etc/profile /export/ # 罗列目录中内容 tree /export 4.6.2. 5.1 cat 5.1.1 目标 通过 cat 会一次显示所有的内容, 适合 查看内容较少 的文本文件 5.1.2 路径 第一步: 显示文件内容 第二步: 显示文件内容(显示行号 包含空行) 第三步: 显示文件内容(显示行号 排除空行) 5.1.3 实现 5.1.3.1 第一步: 显示文件内容(不显示行号) cat 文件名 5.1.3.2 第二步: 显示文件内容(显示行号 包含空行) cat -n 文件名 参数 英文 含义 -n number 显示行号 缺点: 空行也显示行号 5.1.3.3 第三步: 显示文件内容(显示行号 排除空行) cat -b 文件名 参数 英文 含义 -b number-nonblank 非空行 显示行号 nl 文件名 也可以实现 非空行显示行号的效果 命令 英文 含义 nl 文件 number lines of files 查看文件内容 且 非空行显示行号 5.1.4 小结 通过 cat 文件名 查看 小文件内容 准备工作 # >> 重定向这个命令, 为了课程需要 我们先用, 后面我们会讲 # 将文件 /etc/profile 的内容 追加到 /export/01.txt目录中 cat /etc/profile >> /export/01.txt cat /etc/profile >> /export/01.txt cat /etc/profile >> /export/01.txt cat /etc/profile >> /export/01.txt cat /etc/profile >> /export/01.txt 4.6.3. 5.2 less 5.2.1 目标 通过 less [参数] 文件名 命令可以用于分屏显示文件内容, 每次只显示一页内容 less 命令适合查看 内容较多 的文本文件 5.2.2 路径 第一步 : 分屏显示文件内容 第二步 : 根据关键词搜索内容 5.2.3 实现 5.2.3.1 第一步 : 分屏显示文件内容 命令 作用 less -N 文件名 分屏展示文件内容, 适合 大文件 参数 英文 含义 -N number 显示文件内容 且 显示行号 使用 less 的操作键: 操作键 功能 空格键 显示手册页的下一屏幕 Enter 键 一次滚动手册页的一行 b 回滚一屏 f 向前一屏 q 退出 /word 搜索word字符串 5.2.3.2 第二步: 根据关键词 搜索 # 根据关键词搜索 /word 操作键 功能 n 向下找 N 向上找 5.2.4 小结 less 命令适合查看 内容较多 的文本文件 准备工作 # 准备一个26个字母的文件, 使用 WINscp客户端 上传到 /export/ 目录下 4.6.4. 5.3 head 5.3.1 目标 通过 head 命令查看文档的前几行内容 5.3.2 路径 第一步: 查看文件的前5行内容 5.3.3 实现 5.3.3.1 第一步:查看文件的前5行内容 head -n 数字 文件 参数 英文 含义 -n number 表示显示前几行内容 5.3.4 小结 通过 head 命令查看文档的前几行内容 4.6.5. 5.4 tail 5.4.1 目标 需求: 查看文档(日志)的后几行内容 5.4.2 路径 第一步: 查看文档的最后10行内容 第二步: 动态显示文档的最后内容,一般用来查看日志 第三步: 动态显示文档的最后10行内容 5.4.3 实现 第一步: 查看文档的最后10行内容 tail -10 文件 第二步: 动态显示文档的最后内容,一般用来查看日志 tail -f 文件名 第三步: 动态显示文档的最后100行内容 tail -100f 文件名 5.4.4 小结 通过 tail -10f 文件 命令 查看文档(日志)的后几行内容 4.6.6. 5.5 grep(重点重点重点) 5.5.1 目标 通过 grep 命令 搜索存在 关键字 的行 5.5.2 路径 第一步: 搜索 存在关键字 的行 第二步: 搜索 存在关键字 的行 且 显示行号 第三步: 忽略大小写 搜索 存在关键字 的行 第四步: 搜索 不存在关键字 的行 第五步: 搜索 以关键字开始 的行 或 以关键字结尾 的行 5.5.3 实现 5.5.3.1 第一步: 搜索 存在关键字 的行 grep 关键字 文件名 5.5.3.2 第二步: 搜索 存在关键字 的行 且 显示行号 grep -n 关键字 文件名 选项 英文 含义 -n number 显示匹配行和行号 5.5.3.3 第三步: 忽略大小写 搜索 存在关键字 的行 grep -i 关键字 文件名 选项 英文 含义 -i ignore-case 忽略大小写 5.5.3.4 搜索 不存在关键字 的行 grep -v 关键字 文件名 选项 英文 含义 -v invert-match 显示 不包含关键字 的所有行 5.5.3.5 第五步: 搜索 以关键字开始 的行 或 以关键字结尾 的行 grep 正则 文件名 参数 含义 ^a 行首,搜索以a开头的行 ke$ 行尾,搜索以ke结束的行 5.3.4 小结 通过 grep 命令 搜索存在 关键字 的行 4.7. 6 其他 4.7.1. 6.1 管道 | (入门) 6.1.1 目标 通过 命令1 | 命令2 可以将命令1的结果 通过 命令2 作进一步的处理 6.1.2 路径 第一步 : 过滤 /etc/ 目录下 以 pro 开头的文件 第二步 : 搜索 存在关键字 的行数 6.1.3 实现 第一步 : 过滤 /etc/ 目录下 以 pro 开头的文件 ls /etc/ | grep ^pro 第二步 : 搜索存在关键字的行数 ls /etc | grep ^pro | wc -l 英文 作用 命令: wc [参数] [文件] 打印文件的行数, 单词数, 字节数 参数: -l line 行 显示 行数 6.1.4 小结 通过 命令1 | 命令2 可以将命令1的结果 通过 命令2 作进一步的处理 4.7.2. 6.2 echo 文字内容 echo string 将字符串输出到控制台 , 通常回和 重定向 联合使用 echo hello # 如果字符串有空格, 为了避免歧义 请增加 双引号 或者 单引号 echo \"hello world\" 4.7.3. 6.3 重定向 >(覆盖) 和 >> (追加) 6.2.1 目标 默认情况下 命令的结果 输出到 控制台 通过 重定向 可以将结果 输出到文件 6.2.2 路径 第一步: 将 命令的成功结果 覆盖 指定文件内容 第二步: 将 命令的成功结果 追加 指定文件的后面 6.2.3 实现 第一步: 将命令的成功结果 覆盖 指定文件内容 echo 2222 > 01.txt 命令 作用 结果 > 文件名 > 表示输出, 会覆盖文件的原有内容 第二步: 将命令的成功结果 追加 指定文件的后面 echo 3333333 >> 01.txt 命令 作用 命令 >> 文件名 >> 表示追加, 会将内容追加到已有文件的末尾 第三步: 将 命令的失败结果 追加 指定文件的后面 cat 不存在的目录 &>> error.log 命令 作用 命令 &>> 文件 &>> 表示不区分错误类型 都放到 日志中 6.2.4 小结 通过 命令 > 文件 将命令的成功结果 覆盖 指定文件内容 通过 命令 >> 文件 将命令的成功结果 追加 指定文件的后面 通过 命令 &>> 文件 将 命令的失败结果 追加 指定文件的后面 4.7.4. 6.4 && 和 || 6.4.1 目标 如果 创建 目录 成功, 就提示 创建成功 如果 创建 目录 失败, 就提示 创建失败 6.4.2 实现 第一步: 如果 创建 目录 成功, 就提示 创建成功 命令 作用 命令1 && 命令2 如果 命令1执行成功了, 才执行 命令2 mkdir -p 正确目录 && echo \"提示创建目录成功\" 1 启动tomcat 2 查看tomcat日志 启动tomcat && 查看tomcat日志 第二步: 如果 创建 目录 失败, 就提示 创建失败 命令 作用 命令1 \\ \\ 命令2 如果 命令1 执行失败了, 才执行 命令2 mkdir 错误目录 || echo \"提示创建目录失败\" (cd a1/b1/c1 || mkdir -p a1/b1/c1) && cd a1/b1/d1 随堂练习 1 如果创建目录成功, 就切换到指定目录 2 如果创建文件成功, 就罗列新建文件 所在目录的内容 6.4.3 小结: 通过 命令1 && 命令2 实现 如果 命令1 执行成功, 就执行 命令2的效果 通过 命令1 || 命令2 实现 如果 命令1 执行失败, 就执行 命令2的效果 准备工作 # 清空/export目录中内容 cd /export && rm -rf * # 1 创建目录 mkdir -p /export/aaa/bbb/ccc/ddd/eee # 2 创建文件 touch /export/aaa/bbb/ccc/ddd/eee/01.txt /export/aaa/bbb/ccc/ddd/eee/02.txt # 3 切换到 /export/aaa/bbb/ccc/ddd/eee/ 目录下 且 查看内容 # 3.1 cd /export/aaa/bbb/ccc/ddd/eee/ && ll # 3.2 软链接(快捷方式) cd 软链接 && ll 4.7.5. 6.5 软链接(类似与 快捷方式) 在linux中 文件名 和 内容 是两个文件, 分开的! 创建软链接的原理, 如下 6.5.1 目标 因为 某些文件和目录 的 路径很深, 所以 需要增加 软链接(快捷方式) 6.5.2 实现 语法如下: 命令 英文 作用 ln -s 目标文件绝对路径 快捷方式路径 link 给目标文件增加一个软链接, 通俗讲就是快捷方式 6.5.3 小结 通过 ln -s 源文件的绝对路径 快捷方式路径 给 目标文件 增加 快捷方式 注意: 必须 增加 -s , 否则 就变成了 硬链接(了解), 原理如下 Copyright © MISIN 2022 | 豫ICP备2021006345号-1 all right reserved，powered by Gitbook该文件修订时间： 2020-11-01 04:22:46 "},"5.大数据基础增强/1.Linux实战/day02_打包压缩_vim编辑器_系统管理_用户权限/day02.html":{"url":"5.大数据基础增强/1.Linux实战/day02_打包压缩_vim编辑器_系统管理_用户权限/day02.html","title":"Day 02","keywords":"","body":"1.1.1. 准备工作2. 一、搜索命令3. 1.find 搜索3.1. 1.1 目标3.2. 1.2 路径3.3. 1.3 实现 : 在指定目录中 根据名称 搜索3.3.1. 命令格式3.4. 1.3 小结4. 解压缩命令4.1. 1.目标4.2. 2 路径4.3. 3.实现4.3.1. 3.1 第一步: 打包 和 解包4.3.2. 3.2 第二步: 使用gzip格式 压缩 和 解压缩4.3.3. 小结4.3.4. 3.3 第三步: 使用 bzip2 格式 压缩 和 解压缩4.3.5. 小结5. VI编辑器_终端编辑器(重点重点重点)6. 目标7. 1 简介7.1. 1.1 学习vi的目的7.2. 1.2 vi 和 vim7.2.1. 1.2.1 VI7.2.2. 1.2.2 VIM8. 2 打开和新建文件8.1. 2.1 打开文件并且定位行8.2. 2.2 异常处理8.3. 2.3 VI三种工作模式8.4. 2.4 末行模式命令9. 4 常用命令9.1. 命令线路图9.2. 学习提示9.3. 4.1 移动9.3.1. 1) 上 下 左 右9.3.2. 2) 行内移动9.3.3. 3) 行数移动9.3.4. 4) 屏幕移动9.4. 4.2 移动(程序)9.4.1. 1) 段落移动9.4.2. 2) 括号切换9.4.3. 3) 标记9.5. 4.3 选中文本(可视模式)9.6. 4.4 撤销和恢复撤销(保命指令)9.7. 4.5 删除文本9.8. 4.6 复制和剪切9.9. 4.7 替换9.10. 4.8 缩排和重复执行9.11. 4.9 查找9.12. 4.10 查找并替换9.13. 4.11 插入命令(重点重点重点)9.14. 4.12 练习9.14.1. 演练1 -- 编辑命令 和 数字连用9.14.2. 演练2 -- 利用 可视块 给多行代码增加注释9.14.3. 演练3: 坦克大战案例(另存为 备份)10. 用户权限相关命令10.1. 目标10.2. 01.用户和权限的基本概念10.2.1. 1.1 基本概念10.2.2. 1.2 组10.2.3. 1.3 ls -l 扩展10.3. 02.组管理 终端命令10.4. 03.用户管理 终端命令10.4.1. 3.1 创建用户 / 设置密码 / 删除用户10.4.2. 3.2 查看用户信息10.4.3. 3.3 su 切换用户10.4.4. 3.4 sudo10.4.5. 3.4.1 给 指定用户 授予 权限10.4.6. 3.4.2 使用 用户 lisi 登录, 操作管理员命令10.5. 04.修改用户权限10.6. 4.1 方式一: 修改用户权限10.6.1. 目标演练:10.7. 4.2 方式二10.7.1. 目标演练:10.8. 4.3 方式三: 简化方式二10.8.1. 目标演练:11. 系统信息相关命令12. 目标13. 1.时间和日期13.1. 1.1 date 时间13.1.1. 第一步: 显示当前时间13.1.2. 第二步: 设置系统时间13.2. 1.2 cal 日历14. 02.磁盘信息15. 03.进程信息[TOC] 1.1.1. 准备工作 # 切换目录到 /export/ 且 清空内容 cd /export/ && rm -rf /export/* && tree # 新增目录 且 切换目录 且 新增文件 mkdir -p /export/aaa/bbb/ccc/ddd/eee/ touch /export/aaa/bbb/ccc/ddd/eee/abc.txt touch /export/aaa/123.txt touch /export/aaa/312.txt # 查看 /export 目录中的内容 tree /export 2. 一、搜索命令 3. 1.find 搜索 3.1. 1.1 目标 通过find命令 在特定目录下(包含它的后代目录) 搜索 符合条件的文件 3.2. 1.2 路径 第一步: 搜索指定目录下, 文件是 abc.txt的文件 第二步: 搜索指定目录下, 文件名 包含 1 的文件 第三步: 搜索指定目录下,所有以.txt 为扩展名的文件 第四步: 搜索指定目录下, 以数字1开头的文件 3.3. 1.3 实现 : 在指定目录中 根据名称 搜索 select * from 表名 [where 条件] 3.3.1. 命令格式 序号 命令格式 作用 01 find [路径] -name '*.txt' 查找指定路径下扩展名是 .txt的文件, 包括子目录 如果省略路径, 表示在当前文件夹下查找 之前学习的通配符, 在使用find命令时同时可用 第一步: 搜索指定目录下, 文件是 abc.txt的文件 # ===================实现目标============================ # 方式一: 指定全目录 find /export/ -name 'abc.txt' # 方式二: 当前目录 find . -name 'abc.txt' # 方式三: 当前目录 可以 省略 不写 find -name 'abc.txt' 第二步: 搜索指定目录下, 文件名 包含 1 的文件 # =================实现目录=============== find /export/ -name \"*1*\" 第三步: 搜索指定目录下,所有以.txt 为扩展名的文件 find /export/ -name \"*.txt\" 第四步: 搜索指定目录下, 以数字1开头的文件 find /export -name \"1*\" 3.4. 1.3 小结 通过 find [path] -name \"*1*\" 完成根据名称搜索文件 4. 解压缩命令 准备工作 # 清空指定目录内容 cd /export/ && rm -rf * # 创建测试文件 touch 1.txt 2.txt 3.txt # 创建有内容的测试目录 mkdir -p /export/aaa/ touch /export/aaa/4.txt /export/aaa/5.txt # 查看结果 tree /export 4.1. 1.目标 从第三方 下载 压缩包, 解压缩后 安装到 服务器上 通过 打包压缩 备份文件 jar : java rar java项目的压缩包 war : web rar web项目的压缩包 4.2. 2 路径 2.1 第一步: 打包 和 解包 2.2 第二步: 打包压缩 和 解包解压缩 4.3. 3.实现 4.3.1. 3.1 第一步: 打包 和 解包 3.1.1 打包 类似将 冬天的衣服 放到 袋 打包之后的大文件 需要以 .tar 结尾. tar 打包命令格式 # 将 一系列文件 打包成 一个大文件 tar -cvf 打包名.tar 被打包的目录 tar -cvf 打包名.tar 被打包的文件1 被打包的文件2 被打包的文件3 tar 选项说明 命令 英文 含义 c create 生成档案文件, 创建打包文件 v verbosely(啰嗦的) 像 '唐僧' 一样报告进度 f file 指定档案的文件名称, f后面一定是 .tar 文件, 所以必须放到左后 练习1: 将1.txt、2.txt、3.txt 打包成 123.tar文件 练习2: 将有内容的aaa目录 打包成 aaa.tar 文件 [root@node01 export]# tar -cvf 123.tar 1.txt 2.txt 3.txt 1.txt 2.txt 3.txt [root@node01 export]# ll total 16 -rw-r--r--. 1 root root 10240 Jul 31 06:04 123.tar -rw-r--r--. 1 root root 0 Jul 31 06:03 1.txt -rw-r--r--. 1 root root 0 Jul 31 06:03 2.txt -rw-r--r--. 1 root root 0 Jul 31 06:03 3.txt drwxr-xr-x. 2 root root 4096 Jul 31 06:03 aaa [root@node01 export]# tar -cvf aaa.tar aaa/ aaa/ aaa/4.txt aaa/5.txt [root@node01 export]# ll total 28 -rw-r--r--. 1 root root 10240 Jul 31 06:04 123.tar -rw-r--r--. 1 root root 0 Jul 31 06:03 1.txt -rw-r--r--. 1 root root 0 Jul 31 06:03 2.txt -rw-r--r--. 1 root root 0 Jul 31 06:03 3.txt drwxr-xr-x. 2 root root 4096 Jul 31 06:03 aaa -rw-r--r--. 1 root root 10240 Jul 31 06:04 aaa.tar [root@node01 export]# rm -rf *.txt aaa [root@node01 export]# ll total 24 -rw-r--r--. 1 root root 10240 Jul 31 06:04 123.tar -rw-r--r--. 1 root root 10240 Jul 31 06:04 aaa.tar [root@node01 export]# [root@node01 export]# tree . ├── 123.tar └── aaa.tar 3.1.2 解包 类似将 冬天的衣服 从 袋子里取出来 tar 解包命令格式 # 将一个打包后的 分解成 一系列小文件, 分解位置为 当前目录 tar -xvf 打包名.tar # 将一个打包后的 分解成 一系列小文件, 分解位置为 指定目录 tar -xvf 打包名.tar -C 解包路径位置 命令 英文 含义 x extract (提取) 解包 C (大写C) directory (目录) 默认保存到当前目录, 通过-C 更改解压目录, 注意: 解压目录必须存在 练习1: 将 123.tar 解压到 当前目录中 练习2: 将 aaa.tar 解包到 /export/test/a1/b1/c1/ 目录中 [root@node01 export]# ll total 24 -rw-r--r--. 1 root root 10240 Jul 31 06:04 123.tar -rw-r--r--. 1 root root 10240 Jul 31 06:04 aaa.tar [root@node01 export]# tar -xvf 123.tar 1.txt 2.txt 3.txt [root@node01 export]# ll total 24 -rw-r--r--. 1 root root 10240 Jul 31 06:04 123.tar -rw-r--r--. 1 root root 0 Jul 31 06:03 1.txt -rw-r--r--. 1 root root 0 Jul 31 06:03 2.txt -rw-r--r--. 1 root root 0 Jul 31 06:03 3.txt -rw-r--r--. 1 root root 10240 Jul 31 06:04 aaa.tar [root@node01 export]# mkdir -p /export/test/a1/b1/c1 [root@node01 export]# tree . ├── 123.tar ├── 1.txt ├── 2.txt ├── 3.txt ├── aaa.tar └── test └── a1 └── b1 └── c1 4 directories, 5 files [root@node01 export]# tar -xvf aaa.tar -C /export/test/a1/b1/c1 aaa/ aaa/4.txt aaa/5.txt [root@node01 export]# tree . ├── 123.tar ├── 1.txt ├── 2.txt ├── 3.txt ├── aaa.tar └── test └── a1 └── b1 └── c1 └── aaa ├── 4.txt └── 5.txt 小结 打包: tar -cvf 打包之后的文件名.tar 被打包的目录或文件名 解包: tar -xvf 打包之后的文件名.tar [ -C 指定解包位置 ] 准备工作 # 清空指定目录内容 cd /export/ && rm -rf * # 创建测试文件 touch 1.txt 2.txt 3.txt # 创建有内容的测试目录 mkdir -p /export/aaa/ touch /export/aaa/4.txt /export/aaa/5.txt # 查看结果 tree /export 4.3.2. 3.2 第二步: 使用gzip格式 压缩 和 解压缩 打包 和 压缩 是两件事 类似与 先将冬天衣服放到压缩袋, 再抽取里面的空气 在 Linux 中, 最常用的压缩文件格式是 xxx.tar.gz 在 tar 命令中有一个选项 -z 可以调用 gzip , 从而可以方便的实现压缩和解压缩的功能 命令格式如下 # 压缩文件 tar -zcvf 打包压缩文件名.tar.gz 被压缩的文件/目录 # 解压缩文件(记忆敲门: 至孝潍坊) tar -zxvf 打包文件.tar.gz # 解压缩到指定路径 tar -zxvf 打包文件.tar.gz -C 目录路径 tar 的选项说明 命令 英文 含义 z gzip 使用gzip压缩和解压缩 j bzip2 使用bzip2压缩和解压缩 需求1: 将1.txt、2.txt、3.txt 打包压缩成 123.tar.gz文件(gzip压缩格式) 需求2: 将有内容的aaa目录 打包成 aaa.tar.gz 文件(gzip压缩格式) 需求3: 将 123.tar.gz 解压到 当前目录中(gzip压缩格式) 需求4: 将 aaa.tar.gz 解包到 /export/bbb 目录中(gzip压缩格式) 需求1和需求2答案 [root@node01 export]# tree . ├── 1.txt ├── 2.txt ├── 3.txt └── aaa ├── 4.txt └── 5.txt 1 directory, 5 files [root@node01 export]# tar -zcvf 123.tar.gz 1.txt 2.txt 3.txt 1.txt 2.txt 3.txt [root@node01 export]# tar -zcvf aaa.tar.gz aaa/ aaa/ aaa/4.txt aaa/5.txt [root@node01 export]# ll total 12 -rw-r--r--. 1 root root 122 Jul 31 06:11 123.tar.gz -rw-r--r--. 1 root root 0 Jul 31 06:10 1.txt -rw-r--r--. 1 root root 0 Jul 31 06:10 2.txt -rw-r--r--. 1 root root 0 Jul 31 06:10 3.txt drwxr-xr-x. 2 root root 4096 Jul 31 06:10 aaa -rw-r--r--. 1 root root 142 Jul 31 06:11 aaa.tar.gz 清空无用内容 [root@node01 export]# tree . ├── 123.tar.gz ├── 1.txt ├── 2.txt ├── 3.txt ├── aaa │ ├── 4.txt │ └── 5.txt └── aaa.tar.gz 1 directory, 7 files [root@node01 export]# rm -rf *.txt aaa/ [root@node01 export]# tree . ├── 123.tar.gz └── aaa.tar.gz 需求3和需求4 答案 [root@node01 export]# tree . ├── 123.tar.gz ├── 1.txt ├── 2.txt ├── 3.txt └── aaa.tar.gz 0 directories, 5 files [root@node01 export]# mkdir -p /export/bbb [root@node01 export]# tar -zxvf aaa.tar.gz -C /export/bbb/ aaa/ aaa/4.txt aaa/5.txt [root@node01 export]# tree . ├── 123.tar.gz ├── 1.txt ├── 2.txt ├── 3.txt ├── aaa.tar.gz └── bbb └── aaa ├── 4.txt └── 5.txt 4.3.3. 小结 打包压缩: tar -zcvf 打包之后的文件名.tar.gz 被打包压缩的目录或文件名 解包解压缩: tar -zxvf 打包之后的文件名.tar.gz [ -C 指定解包位置 ] 准备工作 # 清空指定目录内容 cd /export/ && rm -rf * # 创建测试文件 touch 1.txt 2.txt 3.txt # 创建有内容的测试目录 mkdir -p /export/aaa/ touch /export/aaa/4.txt /export/aaa/5.txt # 查看结果 tree /export 4.3.4. 3.3 第三步: 使用 bzip2 格式 压缩 和 解压缩 bzip 是压缩的第二种方式 类似与 先将冬天衣服放到压缩袋, 再抽取里面的空气 在 Linux 中, bzip2 压缩文件格式是 xxx.tar.bz2 在 tar 命令中有一个选项 -j 可以调用 bzip2 , 从而可以方便的实现压缩和解压缩的功能 命令格式如下 # 压缩文件 tar -jcvf 打包压缩文件名.tar.bz2 被压缩的文件/目录 # 解压缩文件 (绩效潍坊) tar -jxvf 打包文件.tar.bz2 # 解压缩到指定路径 tar -jxvf 打包文件.tar.bz2 -C 目录路径 tar 的选项说明 命令 英文 含义 z gzip 使用gzip压缩和解压缩 j bzip2 使用bzip2压缩和解压缩 练习1: 将1.txt、2.txt、3.txt 打包压缩成 123.tar.bz2文件(bzip2压缩格式) 练习2: 将有内容的aaa目录 打包成 aaa.tar.bz2 文件(bzip2压缩格式) 练习3: 将 123.tar.bz2 解压到 当前目录中(bzip2压缩格式) 练习4: 将 aaa.tar.bz2 解压到 /export/bbb 目录中(bzip2压缩格式) 需求1和需求2答案 [root@node01 export]# tar -jcvf 123.tar.bz2 1.txt 2.txt 3.txt 1.txt 2.txt 3.txt [root@node01 export]# tar -jcvf aaa.tar.bz2 aaa/ aaa/ aaa/4.txt aaa/5.txt [root@node01 export]# tree . ├── 123.tar.bz2 ├── 1.txt ├── 2.txt ├── 3.txt ├── aaa │ ├── 4.txt │ └── 5.txt └── aaa.tar.bz2 清空内容 [root@node01 export]# rm -rf *.txt [root@node01 export]# rm -rf aaa/ [root@node01 export]# tree . ├── 123.tar.bz2 └── aaa.tar.bz2 需求3和需求4答案 [root@node01 export]# tar -jxvf 123.tar.bz2 1.txt 2.txt 3.txt [root@node01 export]# mkdir -p /export/bbb [root@node01 export]# tar -jxvf aaa.tar.bz2 -C /export/bbb/ aaa/ aaa/4.txt aaa/5.txt [root@node01 export]# tree . ├── 123.tar.bz2 ├── 1.txt ├── 2.txt ├── 3.txt ├── aaa.tar.bz2 └── bbb └── aaa ├── 4.txt └── 5.txt 4.3.5. 小结 打包压缩: tar -jcvf 打包之后的文件名.tar.bz2 被打包压缩的目录或文件名 解包解压缩: tar -jxvf 打包之后的文件名.tar.bz2 [ -C 指定解包位置 ] 关机 halt 重启 reboot 5. VI编辑器_终端编辑器(重点重点重点) 6. 目标 vi简介 打开和新建文件 三种工作模式 常用命令查询 7. 1 简介 7.1. 1.1 学习vi的目的 在工作中, 要对 服务器上的 文件进行 简单 的修改, 可以使用 ssh 登录到远程服务器上, 并且使用 vi编辑器 进行简单的编辑即可 需要修改的文件包括 源代码 配置文件 例如: tomcat服务器的配置文件 例如: 网卡信息的配置文件 在没有图形界面的环境下, 要编辑文件, vi是最佳选择 每一个使用linux的程序员,都应该或多或少的学习一些vi的常用命令 7.2. 1.2 vi 和 vim 在很多linux发行版中, 直接把vi做成vim的 软连接 7.2.1. 1.2.1 VI vi是 visual interface的简称, 是linux中最经典的文本编辑器 vi 的核心设计思想 让程序员的手指始终保持在键盘的 核心区域, 就能完成所有的编辑操作 vi的特点 只能是编辑 文本内容, 不能对 字体 段落进行排版 不支持鼠标操作 没有菜单 只有命令 vi编辑器在 系统管理 服务器管理 编辑文件时, 其功能永远不是图形界面的编辑器能比拟的 7.2.2. 1.2.2 VIM vim = vi improved viM 是从vi发展出来的文本编辑器, 支持代码补全、编译 及 错误跳转等方便编程的功能提别丰富, 在程序员中被广泛使用, 被称为编辑器之神 8. 2 打开和新建文件 在终端中输入vim在后面跟上 文件名 即可 vim 文件名 如果文件已经存在, 会直接打开该文件 如果文件不存在, 保存且退出时 就会新建一个文件 1 vim 没有的文件名 2 编辑内容 2.1 编写类 2.2 输出一行语句 2.3 复制粘贴 2.2内容 19次 2.4 保存且退出 3 查看 注意: 本节重点是 打开 和 新建文件, 其他命令后面会一一讲解 [root@node01 export]# cd /export/ && rm -rf * [root@node01 export]# vim Hello.java public class Hello { public static void main(String[] args) { System.out.println(\"Hello World!\"); // 1 将光标移动到上一行, 按 yy // 2 按 ESC 键 退出编辑模式 // 3 按 19p System.out.println(\"Hello World!\"); System.out.println(\"Hello World!\"); System.out.println(\"Hello World!\"); System.out.println(\"Hello World!\"); System.out.println(\"Hello World!\"); System.out.println(\"Hello World!\"); System.out.println(\"Hello World!\"); System.out.println(\"Hello World!\"); System.out.println(\"Hello World!\"); System.out.println(\"Hello World!\"); System.out.println(\"Hello World!\"); System.out.println(\"Hello World!\"); System.out.println(\"Hello World!\"); System.out.println(\"Hello World!\"); System.out.println(\"Hello World!\"); System.out.println(\"Hello World!\"); System.out.println(\"Hello World!\"); System.out.println(\"Hello World!\"); System.out.println(\"Hello World!\"); // 1 按 ESC 退出编辑模式 // 2 按 : 进入莫行模式 // 3 输入 wq(write quit)保存且退出 按回车键执行 } } 8.1. 2.1 打开文件并且定位行 在日常工作中, 有可能会遇到打开一个文件, 并定位到指定行的情况 例如: 在开发是, 知道某一行代码有错误, 可以 快速定位 到出错误代码的位置 这个时候, 可以使用以下命令打开文件 vim 文件名 +行数 [root@node01 export]# vim Hello.java +10 8.2. 2.2 异常处理 如果 vi 异常退出, 在磁盘上可能会保存有 交换文件 下次再使用 vi 编辑文件时, 会看到以下屏幕信息, 按下字母 d 删除交换文件即可 提示: 按下键盘时, 注意关闭输入法 如何产生 编辑文件, 没有退出, 关闭回话窗口 . 8.3. 2.3 VI三种工作模式 VI有三种工作模式 命令模式 打开文件首先进入命令模式, 是使用vi的入口 通过 命令 对文件进行常规的编辑操作, 例如 定位 翻页 复制 粘贴 删除 ... ... 在其他图形编辑器下, 通过 快捷键 或者 鼠标 实现的操作, 都在 命令模式 下实现 末行模式 -- 执行 保存 退出等操作 要退出 vi 返回到控制台, 需要在莫行模式下输入命令 末行模式 是 vi 的出口 编辑模式 -- 正常的编辑文字 工作模式切换 8.4. 2.4 末行模式命令 命令 英文 功能 w write 保存 q quit 退出,如果没有保存,不允许退出 q! quit 强行退出,不保存退出 wq write & quit 保存且退出(莫行模式) x 保存并退出(莫行模式) ZZ 保存并退出(命令模式) 9. 4 常用命令 9.1. 命令线路图 重复次数 在命令模式下, 先输入一个数字, 再加上一个命令, 可以让该命令 重复执行n次, 如: 19p 移动和选择(多练) vi之所以快, 关键在于 能够快速定位到要编辑的代码行 移动命令 能够和 编辑操作 组合使用 编辑操作 删除 复制 粘贴 替换 缩排 撤销和重复 查到替换 编辑 9.2. 学习提示 vi命令较多, 不要期望一下子全部都记住, 个别命令忘记了, 只是会影响编辑速度而已 . 在使用vi命令时, 注意 关闭中文输入法 9.3. 4.1 移动 要熟练使用vi, 首先应该学会怎么在 命令模式下 快速移动光标 编辑操作命令 能够和移动命令一起使用 9.3.1. 1) 上 下 左 右 命令 功能 手指 h 向左 食指 j 向下 食指 k 向上 中指 l 向右 无名指 9.3.2. 2) 行内移动 命令 英文 功能 w word 向后移动一个单词 b back 向前移动一个单词 0 行首 ^ 行首, 第一个不是空白字符的位置 $ 行尾 9.3.3. 3) 行数移动 命令 英文 功能 gg go 文件顶部 G go 文件末尾 数字gg go 移动到 数字 对应行数 数字G go 移动到 数字 对应行数 : 数字 移动到数字对应的 行数 9.3.4. 4) 屏幕移动 命令 英文 功能 Ctrl + b back 向上翻页 Ctrl + f forward 向下翻页 H Head 屏幕顶部 M Middle 屏幕中间 L Low 屏幕底部 9.4. 4.2 移动(程序) 9.4.1. 1) 段落移动 vim中使用 空行 来区分段落 程序开发时, 通常 一段功能相关的代码会写在一起 -- 之间没有空行 | 命令 | 功能 | | ---- | ------ | | { | 上一段 | | } | 下一段 | 9.4.2. 2) 括号切换 在程序世界中, ()、[]、{}使用率很高, 而且 都是成对出现的. | 命令 | 功能 | | ---- | -------------- | | % | 括号匹配及切换 | 9.4.3. 3) 标记 在开发时, 某一块代码可能需要稍后处理, 例如: 编辑、查看 此时先试用 m 增加一个标记, 这样可以 在需要时快速的跳转回来 或者 执行其他编辑操作 标记名称 可以是 a~z 或者 A~Z 之间的任意 一个 字母 添加了标记的 行如果删除, 标记同时被删除 如果 在其他行添加了相同名称的标记, 之前添加的标记也会被替换掉 命令 英文 功能 mx mark 添加编辑x, x是a~z 或者 A~Z的任意一个字母 'x 直接定位到标记x所在的位置 9.5. 4.3 选中文本(可视模式) 学习 复制 命令前, 应该先学会 怎么样选中 要复制的代码 在 vi 中要选择文本, 需要显示 visual 命令切换到 可视模式 vi 中提供了 三种 可视模式, 可以方便程序员的选择 选中文本的方式 按 ESC 可以放弃选中, 返回到 命令模式 命令 模式 功能 v 可视模式 从光标位置开始按照正常模式选择文本 V 可视化模式 选中光标经过的完整行 Ctrl + v 可是块模式 垂直方向选中文本 可视模式下, 可以和 移动命令 连用, 例如 ggVG 能够 选中所有的内容 9.6. 4.4 撤销和恢复撤销(保命指令) 在学习编辑命令之前,先要知道怎样撤销之前一次 错误的 编辑操作 命令 英文 功能 u undo 撤销上次的命令(ctrl + z) Ctrl + r uredo 10dd恢复撤销的命令 9.7. 4.5 删除文本 命令 英文 功能 x cut 删除光标所在的字符,或者选中的文字 d(移动命令) delete 删除移动命令对应的内容 dd delete 删除光标所在行, 可以ndd删除多行 D delete 删除至行尾 提示: 如果使用 可视模式 已经选中了一段文本, 那么无论使用 d 还是 x, 都可以删除选中文本 删除命令可以和移动命令连用, 以下是常见的组合命令(扩展): 命令 作用 dw 从光标位置删除到单词末尾 d0 从光标位置删除到一行的起始位置 d} 从光标位置删除到段落末尾 ndd 从光标位置向下连续删除 n 行 d'a 从光标所在行 删除到 标记a 之间的所有代码 9.8. 4.6 复制和剪切 vi 中提供有一个 被复制文本的缓冲区 复制 命令会将选中的文字保存在缓冲区 删除 命令删除的文字会被保存在缓冲区 在需要的位置, 使用 粘贴 命令可以将缓冲对的文字插入到光标所在的位置 命令 英文 功能 y(复制命令) copy 复制 yy copy 复制一行,可以nyy复制多行 d(剪切命令) delete 剪切 dd(剪切) delete 剪切一行, 可以 ndd 剪切n行 p paste 粘贴 提示: 命令 d 、x 类似于图形界面的 剪切操作 -- ctrl + x 命令 y 类似于 图形界面的 复制操作 -- Ctrl + 命令 p 类似于图形界面的 粘贴操作 -- Ctrl + v vi中的文本缓冲区只有一个,如果后续做过 复制、剪切操作, 之前缓冲区中的内容会被替换. 注意 vi中的 文本缓冲区 和 系统的 剪切板 不是同一个 所以在其他软件中使用 Ctrl + C 复制的内容, 不能再 vi 中通过 p 命令粘贴 可以在 编辑模式 下使用 鼠标右键粘贴 9.9. 4.7 替换 命令 英文 功能 工作模式 r replace 替换当前字符 命令模式 R replace 替换当前行光标后的字符 替换模式 R 命令可以进入 替换模式, 替换完成后, 按下ESC , 按下 ESC 可以回到 命令模式 替换命令 的作用就是不用进入 编辑模式, 对文件进行 轻量级的修改 9.10. 4.8 缩排和重复执行 命令 功能 >> 向右增加缩进 向左减少缩进 . 重复上次命令 缩进命令 在开发程序时, 统一增加代码的缩进 比较有用! 一次性 在选中代码前增加 4 个空格, 就叫做 增加缩进 一次性 在选中代码前删除 4 个空格, 就叫做 较少缩进 在 可视模式 下, 缩排命令 主需要使用 一个 > 或者 在程序中, 缩进 通常用来表示代码的归属关系 前面空格越少, 代码的级别越高 前面空格越多, 代码的级别越低 9.11. 4.9 查找 常规查找 命令 功能 /str 查找str 查找到指定内容之后, 使用 Next 查找下一个出现的位置 n : 查找下一个 N : 查找上一个 如果不想看到高亮显示, 可以随便查找一个文件中不存在的内容即可 单词快速匹配 命令 功能 * 向后查找当前光标所在单词 # 向前查找当前光标所在单词 在开发中, 通过单词快速匹配, 可以快速看到这个单词在其他位置使用过 9.12. 4.10 查找并替换 在 vi 中查找和替换命令需要在 末行模式 下执行 记忆命令格式 :%s///g 1) 全局替换 一次向 替换文件中的 所有出现的旧文本 命令格式如下 :%s/旧文本/新文本/g 2) 可视区域替换 先选中 要替换文字的 范围 命令格式如下 :s/旧文本/新文本/g 3) 确认替换： c confirm 确认 如果把末尾的 g 改成 gc 在替换的时候, 会有提示! 推荐使用 命令格式如下 :%s/旧文本/新文本/gc y - yes 替换 n - no 不替换 a - all 替换所有 q -quit 退出替换 l - last 最后一个, 并把光标移动到行首 ^E 向下滚屏 ^Y 向上滚屏 9.13. 4.11 插入命令(重点重点重点) 在 vi 中除了常用 i 进入编辑模式 外, 还提供了一下命令同样可以进入编辑模式 命令 英文 功能 常用 i insert 在当前字符前插入文本 常用 I insert 在行首插入文本 较常用 a append 在当前字符后添加文本 A append 在行末添加文本 较常用 o 在当前行后面插入一空行 常用 O 在当前行前面插入一空行 常用 9.14. 4.12 练习 9.14.1. 演练1 -- 编辑命令 和 数字连用 在开发中, 可能会遇到连续输入 N 个同样的字符 例如: ********** 连续10个星号 要实现这个效果可以在 命令模式 下： 输入 10, 表示要重复10次 输入 i 进入 编辑模式 输入 * 也就是重复的文字 按下 ESC 返回 命令模式, 返回之后 vi 就会把 第 2、3 两步的操作重复 10 次 提示： 正常开发时， 在 进入编辑模式之前，不要按数字 9.14.2. 演练2 -- 利用 可视块 给多行代码增加注释 在开发中， 可能会遇到一次向给多行代码 增加注释 的情况 在java中， 要给代码增加注释， 可以在代码 前增加一个 // 要实现这个效果可以在 命令模式 下 移动到要添加注释的 第1行代码, 按 ^ 来到行首 按 Ctrl + v 进入 可视化 模式 使用 j 向下连续选中要添加的代码行 输入 I 进入编辑模式 , 并在 行首插入, 注意: 一定要使用 I 输入 // 也就是 注释符号 按下 ESC 返回到 命令::模式, 返回之后 vi 会在之前选中的每一行代码 前 插入 // 9.14.3. 演练3: 坦克大战案例(另存为 备份) 已经学习过的 末行命令 命令 英文 功能 :w 文件 另存为 :w write 保存(ctrl + s) :q quit 退出, 如果没有保存,不允许退出 :q! quit 强行退出, 不保存退出 :wq write & quit 保存并退出 :x 保存并退出 在实际开发中, 可以使用 w 命令 阶段性的备份代码 10. 用户权限相关命令 10.1. 目标 理解 用户 和 权限 的基本概念 用户管理 终端命令 组管理 终端命令 修改权限 终端命令 10.2. 01.用户和权限的基本概念 10.2.1. 1.1 基本概念 用户 是Linux系统工作中重要的一环, 用户管理包括 用户 与 组 管理 在Linux系统中, 不论是由本级或是远程登录系统, 每个系统都必须拥有一个账号, 并且对于不同的系统资源拥有不同的使用权限 对 文件 / 目录 的权限包括: 序号 权限 英文 缩写 数字序号 01 读 read r 4 02 写 write w 2 03 执行 execute x 1 04 无权限 - 0 在 Linux中 ,可以指定 每一个用户 针对 不同的文件或者目录 的 不同权限 10.2.2. 1.2 组 为了方便用户管理, 提出了 组 的概念, 如下图所示 10.2.3. 1.3 ls -l 扩展 ls -l 可以查看文件夹下文件的详细信息, 从左到右 依次是: 权限, 第一个字符如果是 d 表示目录 硬链接数, 通俗的讲就是有多少种方式, 可以访问当前目录和文件 拥有者, 家目录下 文件 / 木兰路 的拥有者通常都是 当前用户 组, 在linux中, 很多时候, 会出现组名 和 用户名 相同的情况, 后续会讲 大小 时间 名称 10.3. 02.组管理 终端命令 本质: 给 同一类型用户 分配权限 序号 命令 作用 01 groupadd 组名 添加组 02 groupdel 组名 删除组 03 cat /etc/group 确认组信息 04 chgrp 组名 文件/目录名 修改文件/目录的所属组 提示: 组信息保存在 /etc/group 文件中 /etc 目录是专门用来保存 系统配置信息 的目录 在实际应用中, 可以预先针对 组 设置好权限, 然后 将不同的用户添加到对应的组中, 从而不用依次为每一个用户设置权限 chgrp : change group 演练目标 在 指定目录下 创建 aaa 目录 新建 dev 组 将 aaa 目录的组修改为 dev [root@node01 export]# mkdir -p aaa/ [root@node01 export]# ll total 4 drwxr-xr-x. 2 root root 4096 Jul 31 06:48 aaa [root@node01 export]# chgrp dev aaa/ [root@node01 export]# ll total 4 drwxr-xr-x. 2 root dev 4096 Jul 31 06:48 aaa 10.4. 03.用户管理 终端命令 10.4.1. 3.1 创建用户 / 设置密码 / 删除用户 命令 作用 说明 useradd -m -g 组 新建用户名 添加新用户 -m 自动建立用户家目录 -g 指定用户所在的组, 否则会建立一个和同名的组 passwd 用户名 设置用户密码 如果是普通用户,直接用 passwd可以修改自己的账号密码 userdel -r 用户名 删除用户 -r 选项会自动删除用户家目录 cat /etc/passwd \\ grep 用户名 确认用户信息 新建用户后,用户信息会保存在 /etc/passwd文件夹中 提示: 创建用时, 如果忘记添加 -m 选项指定新用户的家目录 -- 最简单的方式就是删除用户,重新创建 创建用户时, 默认会创建一个和用户名同名的组名 用户信息保存在 /etc/passwd 文件中 /etc/passwd 文件存放的是用户的信息, 由6个分好组成的7个信息, 分别是 用户名 密码 (x, 表示加密的密码) UID (用户标志) GID(组标志) 用户全名或本地账号 家目录 登录使用的Shell, 就是登录之后, 使用的终端命令 需求 1 创建用户 zhangsan, 指定归属于 dev 组 2 设置用户 zhangsan 的密码 3 查看配置文件中是否增加用户 zhangsan 观察 zhangsan 的家目录是否创建 4 删除 zhangsan 用户 [root@node01 export]# useradd -m -g dev zhangsan [root@node01 export]# passwd zhangsan Changing password for user zhangsan. New password: BAD PASSWORD: it is too simplistic/systematic BAD PASSWORD: is too simple Retype new password: passwd: all authentication tokens updated successfully. [root@node01 export]# cat /etc/passwd | grep zhangsan zhangsan:x:500:500::/home/zhangsan:/bin/bash [root@node01 export]# tree /home /home └── zhangsan [root@node01 export]# userdel -r zhangsan [root@node01 export]# cat /etc/passwd | grep zhangsan [root@node01 export]# tree /home /home 10.4.2. 3.2 查看用户信息 序号 命令 作用 01 id [用户名] 查看用户UID 和 GID 信息 02 who 查看当前所有登录的用户列表 03 whoami 查看当前登录用户的账户名 [root@node01 ~]# useradd -m -g dev lisi [root@node01 ~]# passwd lisi Changing password for user lisi. New password: BAD PASSWORD: it is too simplistic/systematic BAD PASSWORD: is too simple Retype new password: passwd: all authentication tokens updated successfully. [root@node01 ~]# id lisi uid=500(lisi) gid=500(dev) groups=500(dev) [root@node01 ~]# who root pts/0 2019-07-31 07:02 (192.168.100.2) [root@node01 ~]# whoami root 10.4.3. 3.3 su 切换用户 因为 普通用户 不能使用某些权限, 所以需要 切换用户 序号 命令 作用 说明 01 su - 用户名 切换用户, 并且企划目录 - 可以切换到用户家目录, 否则保持位置不变 02 exit 退出当前登录用户 su 不接用户名, 可以切换到 root , 但是不推荐使用, 因为不安全 exit 示意图如下: [lisi@node01 ~]$ whoami lisi [lisi@node01 ~]$ su - root Password: [root@node01 ~]# whoami root [root@node01 ~]# exit logout [lisi@node01 ~]$ whoami lisi 10.4.4. 3.4 sudo 虽然 通过 su -u root 可以切换到 root用户, 但是 存在严重的 安全隐患 linux系统中的 root 账号通常 用于系统的维护和管理, 对操作系统的所有资源 具有访问权限 如果不小心使用 rm -rf ... ... , 就可能将系统搞瘫痪 在大多数版本的linux中, 都不推荐 直接只用 root 账号登录系统 sudo 命令用来以其他身份来执行命令, 预设的身份为 root 用户使用 sudo 时, 必须先输入密码, 之后5分钟的有效期限, 超过期限则必须重新输入密码 提示: 若其未经授权的用户企图使用 sudo, 则会发出警告邮件给管理员 10.4.5. 3.4.1 给 指定用户 授予 权限 本质: 通知 服务器 给 特定用户 分配 临时管理员权限 vim /etc/sudoers # 默认存在: root用户 具备所有的权限 root ALL=(ALL) ALL # 授予 lisi 用户 所有的权限 lisi ALL=(ALL) ALL 10.4.6. 3.4.2 使用 用户 lisi 登录, 操作管理员命令 本质: 使用临时管理员权限 # 不切换root用户, 也可以完成 添加用户的功能 sudo useradd -m -g dev zhaoliu [lisi@node01 ~]$ sudo useradd -m -g dev zhaoliu We trust you have received the usual lecture from the local System Administrator. It usually boils down to these three things: #1) Respect the privacy of others. #2) Think before you type. #3) With great power comes great responsibility. [sudo] password for lisi: [lisi@node01 ~]$ sudo cat /etc/passwd | grep zhaoliu zhaoliu:x:501:500::/home/zhaoliu:/bin/bash 准备工作: 使用root用户操作 # 清空目录中的内容 rm -rf /export/* # 创建测试目录 mkdir -p /export/aaa/ # 创建测试文件 touch /export/aaa/01.txt /export/aaa/02.txt # 查看指定目录内容 tree /export 10.5. 04.修改用户权限 序号 命令 作用 01 chmod 修改权限 10.6. 4.1 方式一: 修改用户权限 chmod 可以修改 用户/组 对 文件/目录 的权限 命令格式如下: chmod +/- rwx 文件名|目录名 提示: 已上方式会一次向修改 拥有者 / 组权限 10.6.1. 目标演练: # 1. 使用 root 删除目录的可读 可写 可执行权限 # 2. 使用 其他用户如 lisi 无法切换到 这个目录 # 3. 使用 root 增加目录的执行权限, 再次 使用 lisi 切换到目录试试 答案:# 1. 使用 root 删除目录的可读 可写 可执行权限 [root@node01 export]# ll total 4 drwxr-xr-x. 2 root root 4096 Jul 31 07:10 aaa [root@node01 export]# chmod -rwx aaa/ [root@node01 export]# ll total 4 d---------. 2 root root 4096 Jul 31 07:10 aaa 需求2答案: 使用 其他用户如 lisi 无法切换到 这个目录 [lisi@node01 ~]$ cd /export/ [lisi@node01 export]$ ll total 4 d---------. 2 root root 4096 Jul 31 07:10 aaa [lisi@node01 export]$ cd aaa/ -bash: cd: aaa/: Permission denied 需求3答案: 使用 root 增加目录的执行权限, 再次 使用 lisi 切换到目录试试 [root@node01 export]# chmod +x aaa/ [root@node01 export]# ll total 4 d--x--x--x. 2 root root 4096 Jul 31 07:10 aaa [lisi@node01 export]$ cd aaa/ [lisi@node01 aaa]$ pwd /export/aaa 10.7. 4.2 方式二 虽然 方式一 直接修改文件|目录的 读|写|执行 权限, 但是不能精确到 拥有者|组|其他 权限 命令格式如下:( u 表示所属用户 / g 表示所属组 / o 表示其他) chmod -R u=rwx,g=rx,o=rwx 文件|目录 序号 权限 英文 缩写 数字序号 01 读 read r 4 02 写 write w 2 03 执行 execute x 1 04 无权限 - 0 10.7.1. 目标演练: # 1 使用root用户给 所属用户分配 可读、可写、可执行 权限, 所属组 分配 可读、可执行 权限, 其他人 分配 可读、可执行 权限 [root@node01 export]# chmod u=rwx,g=rx,o=rx aaa/ [root@node01 export]# ll total 4 drwxr-xr-x. 2 root root 4096 Jul 31 07:10 aaa 10.8. 4.3 方式三: 简化方式二 命令格式如下: chmod -R 755 文件|目录 说明 第一个数字 是 拥有者权限, 第二个数字 是 组权限, 第三个数字 是 其他用户权限 常用数字组合有( u 表示用户 / g 表示组 / o 表示其他) 777 ===> u=rwx, g=rwx, o=rwx 755 ===> u=rwx, g=rx, o=rx 644 ===> u=rw, g=r, o=r 10.8.1. 目标演练: # 1 使用root用户给 所属用户分配 可读、可写、可执行 权限, 所属组 分配 可读、可执行 权限, 其他人 分配 可读、可执行 权限 [root@node01 export]# chmod 755 bbb/ [root@node01 export]# ll total 8 drwxr-xr-x. 2 root root 4096 Jul 31 07:10 aaa drwxr-xr-x. 3 root root 4096 Jul 31 07:19 bbb 11. 系统信息相关命令 本节内容主要是为了方便通过远程终端维护服务器时, 查看服务器上当前 系统日期和时间 / 磁盘空间占用情况 /程序执行情况 本小结学习终端命令都是查询命令, 通过这些命令对系统资源的使用情况有个了解 12. 目标 时间和日期 date cal 磁盘和目录空间 df du 进程信息 ps top kill 13. 1.时间和日期 13.1. 1.1 date 时间 命令 作用 date 查看系统时间(默认) date +\"%Y-%m-%d %H:%M:%S\" 查看系统时间(指定格式) date -s \"时间字符串\" 设置系统时间 13.1.1. 第一步: 显示当前时间 # 显示时间 date # 按照指定格式显示时间 date +\"%Y-%m-%d %H:%M:%S\" 13.1.2. 第二步: 设置系统时间 date -s \"时间字符串\" [root@node01 export]# date Wed Jul 31 07:20:31 CST 2019 [root@node01 export]# date +\"%Y-%m-%d %H:%M:%S\" 2019-07-31 07:20:49 [root@node01 export]# date -s '2019-07-31 20:21:49' Wed Jul 31 20:21:49 CST 2019 [root@node01 export]# date +\"%Y-%m-%d %H:%M:%S\" 2019-07-31 20:21:52 13.2. 1.2 cal 日历 序号 命令 作用 01 cal 查看当前月的日历 02 cal -y 查看当前年的日历 03 cal 2020 查看2020年的日历 04 cal 10 2020 查看2020年10月的日历 14. 02.磁盘信息 序号 命令 作用 01 df -h disk free 显示磁盘剩余空间 02 du -h [目录名] disk usage 显示目录下的目录大小 03 free -h 查看内存使用率 选项说明 参数 含义 -h 以人性化的方式显示文件的大小 15. 03.进程信息 所谓 进程, 通俗的说就是 当前正在执行的一个进程 序号 命令 作用 01 ps aux process status 查看进程的详细情况 02 top 动态显示运行中进程并且排序 03 kill [-9] 进程代号 终止指定代号的进程 -9 表示强行终止 ps 默认只会显示当前用户通过终端启动的应用程序 ps 选项说明功能 | 选项 | 含义 | | ---- | --------------------------------------- | | a | 显示终端上的所有进程,包括其他用户的进程 | | u | 显示进程的详细状态 | | x | 显示没有控制终端的进程 | 提示: 使用kill命令时, 最好只终止由当前用户开启的进程, 而不要终止root身份开启的进程, 否则可能导致系统崩溃 要退出 top 可以直接输入 q Copyright © MISIN 2022 | 豫ICP备2021006345号-1 all right reserved，powered by Gitbook该文件修订时间： 2020-11-01 04:20:44 "},"5.大数据基础增强/1.Linux实战/day03/day03.html":{"url":"5.大数据基础增强/1.Linux实战/day03/day03.html","title":"Day 03","keywords":"","body":"1. | 管道相关命令1.1. 目标2. 1 cut2.1. 1.1 目标2.2. 1.2 路径2.3. 1.3 实现2.3.1. 第一步: 截取出1.txt文件中前2行的第5个字符2.3.2. 第二步: 截取出1.txt文件中前2行以”:”进行分割的第1,2,3段内容2.4. 1.3 小结3. 2 sort 的 工作原理3.1. 2.1 目标3.2. 2.2 路径3.3. 2.3 实现3.3.1. 第一步: 对字符串排序3.3.2. 第二步: 去重排序3.3.3. 第三步: 对数值排序3.3.4. 第四步: 对成绩排序3.4. 2.4 小结4. 3 wc命令4.1. 3.1 目标4.2. 3.2 路径4.3. 3.3 实现4.3.1. 第一步: 显示指定文件 字节数, 单词数, 行数 信息.4.3.2. 第二步: 只显示 文件 的行数4.3.3. 第三步: 统计多个文件的 行数 单词数 字节数4.3.4. 第四步: 查看 /etc 目录下 有多少个 子内容4.4. 3.4 小结5. 4 uniq5.1. 4.1 目标5.2. 4.2路径5.3. 4.3 实现5.3.1. 第一步：实现去重效果5.3.2. 第二步：不但去重，还要 统计出现的次数5.4. 4.4 小结6. 5 tee6.1. 5.1 目标6.2. 5.2 实现6.2.1. 将去重统计的结果 放到 a.txt、b.txt、c.txt 文件中6.3. 5.3 小结7. 6 tr7.1. 6.1 目标7.2. 6.2 路径7.3. 6.3 实现7.3.1. 第一步: 实现 替换效果7.3.2. 第二步: 实现删除效果7.3.3. 第三步: 单词计数7.4. 6.4 小结8. 7 split8.1. 7.1 目标8.2. 7.2 路径8.3. 7.3 实现8.3.1. 第一步: 按 字节 将 大文件 切分成 若干小文件8.3.2. 第二步: 按 行数 将 大文件 切分成 若干小文件8.4. 7.4 小结9. 8 awk(重点重点重点)9.1. 8.1 目标9.2. 8.2 步骤9.3. 8.3 实现9.3.1. 第一步: 搜索含有 zhang 和 li 的学生成绩9.3.2. 第二步: 指定分割符, 根据下标显示内容9.3.3. 第三步: 指定分割符, 根据下标显示内容9.3.4. 第四步: 调用 awk 提供的函数9.3.5. 第五步: if语句 查询及格的学生信息9.3.6. 第六步: 段内容 求指定学科平均分9.4. 8.4 小结10. 9 sed10.1. 9.1 目标10.2. 9.2 路径10.3. 9.3 实现10.3.1. 第一步: 实现 查询 功能10.3.2. 第二步: 实现 删除 功能10.3.3. 第三步: 实现 修改 功能10.3.4. 第四步: 实现 替换 功能10.3.5. 第五步: 对 原文件 进行操作10.3.6. 第六步: 综合 练习11. 2. Shell 编程11.1. 2.1 简介11.1.1. shell 解释器11.2. 2.2快速入门11.2.1. 1 编写脚本11.2.2. 2 执行shell脚本11.3. 2.3 shell变量11.3.1. 1 简介11.3.2. 2 使用变量11.3.3. 3 删除变量11.3.4. 4 只读变量11.4. 2.4 字符串11.4.1. 1 单引号11.4.2. 2 双引号11.4.3. 3 获取字符串长度11.4.4. 4 截取子字符串11.4.5. 5 查找子字符串11.5. 2.5 传递参数11.6. 2.6 Shell算术运算符11.6.1. 1 简介11.6.2. 2 例子11.7. 2.7 流程控制11.7.1. 1 if else11.7.2. 关系运算符11.7.3. 2 for 循环11.7.4. 3 while 语句11.7.5. 4 无限循环11.7.6. 5 case(switch)11.7.7. 6 跳出循环11.8. 2.8 函数使用11.9. 2.9 数组11.9.1. 1 定义数组11.9.2. 2 读取数组11.9.3. 3 遍历数组11.10. 2.10 加载其它文件的变量11.10.1. 1 简介11.10.2. 2 练习1. | 管道相关命令 1.1. 目标 cut sort wc uniq tee tr split awk sed grep 准备数据 zhangsan 68 99 26 lisi 98 66 96 wangwu 38 33 86 zhaoliu 78 44 36 maq 88 22 66 zhouba 98 44 46 以上是成绩表信息 使用 逗号 分割, 第一列 是 姓名, 第二列是 语文成绩, 第三列是 数学成绩, 第四列是 英语成绩 需求1: 按照 数学成绩排名, 取出前三名 需求2: 显示 学生的数学成绩 需求3: 显示 数学平均分 需求4: 如何将大文件 切割成 若干小文件 准备工作 cd /export/ && rm -rf * vim 1.txt 111:aaa:bbb:ccc 222:ddd:eee:fff 333:ggg:hhh 444:iii 2. 1 cut 2.1. 1.1 目标 cut 根据条件 从命令结果中 提取 对应内容 2.2. 1.2 路径 第一步: 截取出1.txt文件中前2行的第5个字符 第二步: 截取出1.txt文件中前2行以”:”进行分割的第1,2,3段内容(方式二) 2.3. 1.3 实现 2.3.1. 第一步: 截取出1.txt文件中前2行的第5个字符 命令 含义 cut 动作 文件 从指定文件 截取内容 参数 参数 英文 含义 -c characters 按字符选取内容 答案： head -2 1.txt | cut -c 5 . [root@node01 export]# cut -c 5 1.txt a d g i [root@node01 export]# cat 1.txt 111:aaa:bbb:ccc 222:ddd:eee:fff 333:ggg:hhh 444:iii [root@node01 export]# cat 1.txt | cut -c 5 a d g i [root@node01 export]# head -2 1.txt 111:aaa:bbb:ccc 222:ddd:eee:fff [root@node01 export]# head -2 1.txt | cut -c 5 a d 2.3.2. 第二步: 截取出1.txt文件中前2行以”:”进行分割的第1,2,3段内容 参数 英文 含义 -d '分隔符' delimiter 指定分隔符 -f n1,n2 fields 分割以后显示第几段内容, 使用 , 分割 范围控制 范围 含义 n 只显示第n项 n- 显示 从第n项 一直到行尾 n-m 显示 从第n项 到 第m项(包括m) 答案： head -2 1.txt | cut -d ':' -f 1,2,3 或者 head -2 1.txt | cut -d ':' -f 1-3 2.4. 1.3 小结 通过 cut 动作 目标文件 可以根据条件 提取对应内容 3. 2 sort 的 工作原理 3.1. 2.1 目标 sort可针对文本文件的内容，以行为单位来排序。 3.2. 2.2 路径 第一步: 对字符串排序 第二步: 去重排序 第三步: 对数值排序 第四步: 对成绩排序 3.3. 2.3 实现 3.3.1. 第一步: 对字符串排序 准备工作 cd /export vim 2.txt banana apple pear orange pear . [root@node01 export]# cat 2.txt banana apple pear orange pear [root@node01 export]# sort 2.txt apple banana orange pear pear [root@node01 export]# cat 2.txt | sort apple banana orange pear pear 3.3.2. 第二步: 去重排序 参数 英文 含义 -u unique 去掉重复的 它的作用很简单，就是在输出行中去除重复行。 . [root@node01 export]# cat 2.txt banana apple pear orange pear [root@node01 export]# sort 2.txt apple banana orange pear pear You have new mail in /var/spool/mail/root [root@node01 export]# sort -u 2.txt apple banana orange pear [root@node01 export]# cat 2.txt | sort -u apple banana orange pear 3.3.3. 第三步: 对数值排序 参数 英文 含义 -n numeric-sort 按照数值大小排序 -r reverse 使次序颠倒 准备数据 cd /export/ vim 3.txt 1 3 5 7 11 2 4 6 10 8 9 默认按照字符串排序 [root@node01 export]# sort 3.txt 1 10 11 2 3 4 5 6 7 8 9 [root@node01 export]# cat 3.txt | sort 1 10 11 2 3 4 5 6 7 8 9 升序 [root@node01 export]# sort -n 3.txt 1 2 3 4 5 6 7 8 9 10 11 [root@node01 export]# cat 3.txt | sort -n 1 2 3 4 5 6 7 8 9 10 11 倒序 [root@node01 export]# cat 3.txt | sort -n -r 11 10 9 8 7 6 5 4 3 2 1 合并式 [root@node01 export]# cat 3.txt | sort -nr 11 10 9 8 7 6 5 4 3 2 1 3.3.4. 第四步: 对成绩排序 参数 英文 含义 -t field-separator 指定字段分隔符 -k key 根据那一列排序 准备工作 cd /export vim 4.txt zhangsan 68 99 26 lisi 98 66 96 wangwu 38 33 86 zhaoliu 78 44 36 maqi 88 22 66 zhouba 98 44 46 练习: 根据第二段成绩 进行倒序显示 所有内容 [root@node01 export]# cat 4.txt zhangsan 68 99 26 lisi 98 66 96 wangwu 38 33 86 zhaoliu 78 44 36 maqi 88 22 66 zhouba 98 44 46 [root@node01 export]# cat 4.txt | sort -t ' ' -k 2 wangwu 38 33 86 zhangsan 68 99 26 zhaoliu 78 44 36 maqi 88 22 66 zhouba 98 44 46 lisi 98 66 96 [root@node01 export]# cat 4.txt | sort -t ' ' -k 2 -n -r zhouba 98 44 46 lisi 98 66 96 maqi 88 22 66 zhaoliu 78 44 36 zhangsan 68 99 26 wangwu 38 33 86 . 3.4. 2.4 小结 通过 sort 选项 文件 可以对文件内容进行排序 4. 3 wc命令 4.1. 3.1 目标 显示指定文件 字节数, 单词数, 行数 信息. 4.2. 3.2 路径 第一步: 显示指定文件 字节数, 单词数, 行数 信息. 第二步: 只显示 文件 的行数 第三步: 统计多个文件的 行数 单词数 字节数 第四步: 查看 /etc 目录下 有多少个 子内容 4.3. 3.3 实现 4.3.1. 第一步: 显示指定文件 字节数, 单词数, 行数 信息. 命令 含义 wc 文件名 显示指定文件 字节数, 单词数, 行数 信息 准备工作 cd /export/ vim 5.txt 111 222 bbb 333 aaa bbb 444 aaa bbb ccc 555 aaa bbb ccc ddd 666 aaa bbb ccc ddd eee 练习: 显示指定文件 字节数, 单词数, 行数 信息. . [root@node01 export]# wc 5.txt 6 21 85 5.txt [root@node01 export]# cat 5.txt 111 222 bbb 333 aaa bbb 444 aaa bbb ccc 555 aaa bbb ccc ddd 666 aaa bbb ccc ddd eee [root@node01 export]# cat 5.txt | wc 6 21 85 4.3.2. 第二步: 只显示 文件 的行数 参数 英文 含义 -c bytes 字节数 -w words 单词数 -l lines 行数 . [root@node01 export]# cat 5.txt 111 222 bbb 333 aaa bbb 444 aaa bbb ccc 555 aaa bbb ccc ddd 666 aaa bbb ccc ddd eee You have new mail in /var/spool/mail/root [root@node01 export]# cat 5.txt | wc 6 21 85 [root@node01 export]# cat 5.txt | wc -l 6 4.3.3. 第三步: 统计多个文件的 行数 单词数 字节数 . [root@node01 export]# wc 2.txt 3.txt 4.txt 5.txt 5 5 30 2.txt 11 11 24 3.txt 6 24 94 4.txt 6 21 85 5.txt 28 61 233 total [root@node01 export]# wc *.txt 5 5 30 2.txt 11 11 24 3.txt 6 24 94 4.txt 6 21 85 5.txt 28 61 233 total 4.3.4. 第四步: 查看 /etc 目录下 有多少个 子内容 . ll /etc | wc -l 4.4. 3.4 小结 通过 wc 文件 就可以 统计 文件的 字节数、单词数、行数. 5. 4 uniq uniq 命令用于检查及删除文本文件中重复出现的行，一般与 sort 命令结合使用。 5.1. 4.1 目标 uniq 命令用于检查及删除文本文件中重复出现的行，一般与 sort 命令结合使用。 5.2. 4.2路径 第一步：实现去重效果 第二步：不但去重，还要 统计出现的次数 5.3. 4.3 实现 5.3.1. 第一步：实现去重效果 命令 英文 含义 uniq [参数] 文件 unique 唯一 去除重复行 准备工作 cd /export/ vim 6.txt 张三 98 李四 100 王五 90 赵六 95 麻七 70 李四 100 王五 90 赵六 95 麻七 70 需求: 实现去重效果 ​ [root@node01 export]# cat 6.txt 张三 98 李四 100 王五 90 赵六 95 麻七 70 李四 100 王五 90 赵六 95 麻七 70 [root@node01 export]# cat 6.txt | sort 张三 98 李四 100 李四 100 王五 90 王五 90 赵六 95 赵六 95 麻七 70 麻七 70 [root@node01 export]# cat 6.txt | sort | uniq 张三 98 李四 100 王五 90 赵六 95 麻七 70 5.3.2. 第二步：不但去重，还要 统计出现的次数 参数 英文 含义 -c count 统计每行内容出现的次数 . [root@node01 export]# cat 6.txt | sort | uniq -c 1 张三 98 2 李四 100 2 王五 90 2 赵六 95 2 麻七 70 5.4. 4.4 小结 通过 uniq [选项] 文件 就可以完成 去重行 和 统计次数 6. 5 tee 6.1. 5.1 目标 通过 tee 可以将命令结果 通过管道 输出到 多个文件中 6.2. 5.2 实现 命令 含义 命令结果 \\ tee 文件1 文件2 文件3 通过 tee 可以将命令结果 通过管道 输出到 多个文件中 6.2.1. 将去重统计的结果 放到 a.txt、b.txt、c.txt 文件中 [root@node01 export]# ls 2.txt 3.txt 4.txt 5.txt 6.txt [root@node01 export]# cat 6.txt | sort | uniq -c | tee a.txt b.txt c.txt 1 张三 98 2 李四 100 2 王五 90 2 赵六 95 2 麻七 70 [root@node01 export]# ls 2.txt 3.txt 4.txt 5.txt 6.txt a.txt b.txt c.txt [root@node01 export]# cat a.txt 1 张三 98 2 李四 100 2 王五 90 2 赵六 95 2 麻七 70 6.3. 5.3 小结 通过 tee 可以将命令结果 通过管道 输出到 多个文件中 7. 6 tr 7.1. 6.1 目标 通过 tr 命令用于 替换 或 删除 文件中的字符。 7.2. 6.2 路径 第一步: 实现 替换 效果 第二步: 实现 删除 效果 第三步: 完成 单词计数 案例 7.3. 6.3 实现 7.3.1. 第一步: 实现 替换效果 命令 英文 含义 命令结果 \\ tr 被替换的字符 新字符 translate 实现 替换效果 准备工作 cd /export vim 7.txt itheima HELLO abc1d4e5f 需求: # 将 小写i 替换成 大写 I # 把 小写 的转换为大写 # 把 大写 转成 小写 [root@node01 export]# cat 7.txt itheima HELLO abc1d4e5f [root@node01 export]# cat 7.txt | tr 'i' 'I' ItheIma HELLO abc1d4e5f [root@node01 export]# cat 7.txt | tr [a-z] [A-Z] ITHEIMA HELLO ABC1D4E5F You have new mail in /var/spool/mail/root [root@node01 export]# cat 7.txt | tr [A-Z] [a-z] itheima hello abc1d4e5f 7.3.2. 第二步: 实现删除效果 命令 英文 含义 命令结果 \\ tr -d 被删除的字符 delete 删除指定的字符 需求: 删除abc1d4e5f中的数字 . echo 'abc1d4e5f' | tr -d [0-9] 7.3.3. 第三步: 单词计数 准备工作 cd /export vim 8.txt hello,world,hadoop hive,sqoop,flume,hello kitty,tom,jerry,world hadoop 分析: 1 将, 换成 换行 2 排序 3 去重 4 计数 -------- 查看文件内容 [root@node01 export]# cat 8.txt hello,world,hadoop hive,sqoop,flume,hello kitty,tom,jerry,world hadoop -------- 将 逗号, 替换成 换行符 [root@node01 export]# cat 8.txt | tr ',' '\\n' hello world hadoop hive sqoop flume hello kitty tom jerry world hadoop -------- 排序 [root@node01 export]# cat 8.txt | tr ',' '\\n' | sort flume hadoop hadoop hello hello hive jerry kitty sqoop tom world world -------- 去重 [root@node01 export]# cat 8.txt | tr ',' '\\n' | sort | uniq flume hadoop hello hive jerry kitty sqoop tom world -------- 计数 [root@node01 export]# cat 8.txt | tr ',' '\\n' | sort | uniq -c 1 flume 2 hadoop 2 hello 1 hive 1 jerry 1 kitty 1 sqoop 1 tom 2 world [root@node01 export]# 7.4. 6.4 小结 通过 tr [选项] 字符1 字符2 可以 实现 替换 和 删除 效果 准备工作 # 清空目录内容 cd /export/ && rm -rf * # 查看 /etc目录下 以.conf以结尾的文件的内容 cat -n /etc/*.conf # 将命令结果 追加到 /export/v.txt 文件中 cat -n /etc/*.conf >> /export/v.txt # 查看文件内容 ls # 查看新文件的行数 wc -l v.txt 8. 7 split 8.1. 7.1 目标 通过 split 命令将大文件 切分成 若干小文件 8.2. 7.2 路径 第一步: 按 字节 将 大文件 切分成 若干小文件 第二步: 按 行数 将 大文件 切分成 若干小文件 8.3. 7.3 实现 8.3.1. 第一步: 按 字节 将 大文件 切分成 若干小文件 命令 英文 含义 split -b 10k 文件 byte 将大文件切分成若干10KB的小文件 [root@node01 export]# ll -h total 108K -rw-r--r-- 1 root root 105K Jul 12 20:35 v.txt [root@node01 export]# split -b 20k v.txt [root@node01 export]# ll total 216 -rw-r--r-- 1 root root 106538 Jul 12 20:35 v.txt -rw-r--r-- 1 root root 20480 Jul 12 20:39 xaa -rw-r--r-- 1 root root 20480 Jul 12 20:39 xab -rw-r--r-- 1 root root 20480 Jul 12 20:39 xac -rw-r--r-- 1 root root 20480 Jul 12 20:39 xad -rw-r--r-- 1 root root 20480 Jul 12 20:39 xae -rw-r--r-- 1 root root 4138 Jul 12 20:39 xaf 8.3.2. 第二步: 按 行数 将 大文件 切分成 若干小文件 命令 英文 含义 split -l 1000 文件 lines 将大文件切分成若干1000行 的小文件 # 清空不用的内容 [root@node01 export]# rm -rf x* # 罗列当前目录中内容 [root@node01 export]# ls v.txt # 查看指定文件的行数: 共 2780行 [root@node01 export]# wc -l v.txt 2780 v.txt # 按照行数 每个文件1000行 进行切割 [root@node01 export]# split -l 1000 v.txt # 查看当前文件下每个文件的行数 [root@node01 export]# wc -l * 2780 v.txt 1000 xaa 1000 xab 780 xac 8.4. 7.4 小结 通过 split 选项 文件名 命令将大文件 切分成 若干小文件 准备工作1: # 清空指定目录内容 cd /export && rm -rf * # 新建文件 vim score.txt zhangsan 68 99 26 lisi 98 66 96 wangwu 38 33 86 zhaoliu 78 44 36 maq 88 22 66 zhouba 98 44 46 9. 8 awk(重点重点重点) 9.1. 8.1 目标 通过 awk 实现 模糊查询, 按需提取字段, 还可以进行 判断 和 简单的运算等. 9.2. 8.2 步骤 第一步: 模糊查询 第二步: 指定分割符, 根据下标显示内容 第三步: 指定输出字段的分割符 第四步: 调用 awk 提供的函数 第五步: 通过if语句判断$4是否及格 第六步: 段内容 求和 9.3. 8.3 实现 9.3.1. 第一步: 搜索含有 zhang 和 li 的学生成绩 命令 含义 awk '/搜索字符/' score.txt 模糊查询 # 查看文档内容 [root@node01 export]# cat score.txt zhangsan 68 99 26 lisi 98 66 96 wangwu 38 33 86 zhaoliu 78 44 36 maq 88 22 66 zhouba 98 44 46 # 搜索含有 zhang 和 li 的学生成绩 [root@node01 export]# cat score.txt | awk '/zhang|li/' zhangsan 68 99 26 lisi 98 66 96 zhaoliu 78 44 36 9.3.2. 第二步: 指定分割符, 根据下标显示内容 命令 含义 awk -F ',' '{print $1, $2, $3}' 文件 操作1.txt文件, 根据 逗号 分割, 打印 第一段 第二段 第三段 内容 选项 选项 英文 含义 -F ',' field-separator 使用 指定字符 分割 $ + 数字 获取第几段内容 $0 获取 当前行 内容 NF field 表示当前行共有多少个字段 $NF 代表 最后一个字段 $(NF-1) 代表 倒数第二个字段 NR 代表 处理的是第几行 [root@node01 export]# cat score.txt zhangsan 68 99 26 lisi 98 66 96 wangwu 38 33 86 zhaoliu 78 44 36 maq 88 22 66 zhouba 98 44 46 [root@node01 export]# cat score.txt | awk -F ' ' '{print $1,$2,$3}' zhangsan 68 99 lisi 98 66 wangwu 38 33 zhaoliu 78 44 maq 88 22 zhouba 98 44 9.3.3. 第三步: 指定分割符, 根据下标显示内容 命令 含义 awk -F ' ' '{OFS=\"===\"}{print $1, $2, $3}' 1.txt 操作1.txt文件, 根据 逗号 分割, 打印 第一段 第二段 第三段 内容 选项 选项 英文 含义 OFS=\"字符\" output field separator 向外输出时的段分割字符串 转义序列 含义 \\b 退格 \\f 换页 \\n 换行 \\r 回车 \\t 制表符 # 查看文档内容 [root@node01 export]# cat score.txt zhangsan 68 99 26 lisi 98 66 96 wangwu 38 33 86 zhaoliu 78 44 36 maq 88 22 66 zhouba 98 44 46 # 按照 === 进行分割, 打印 第一段 第二段 第三段 [root@node01 export]# cat score.txt | awk -F ' ' '{OFS=\"===\"}{print $1,$2,$3}' zhangsan===68===99 lisi===98===66 wangwu===38===33 zhaoliu===78===44 maq===88===22 zhouba===98===44 # 按照 制表符tab 进行分割, 打印 第一段 第二段 第三段 [root@node01 export]# cat score.txt | awk -F ' ' '{OFS=\"\\t\"}{print $1,$2,$3}' zhangsan 68 99 lisi 98 66 wangwu 38 33 zhaoliu 78 44 maq 88 22 zhouba 98 44 9.3.4. 第四步: 调用 awk 提供的函数 命令 含义 awk -F ',' '{print toupper($2)}' 1.txt 操作1.txt文件, 根据 逗号 分割, 打印 第一段 第二段 第三段 内容 常用函数如下: 函数名 含义 作用 toupper() upper 字符 转成 大写 tolower() lower 字符 转成小写 length() length 返回 字符长度 [root@node01 export]# cat score.txt zhangsan 68 99 26 lisi 98 66 96 wangwu 38 33 86 zhaoliu 78 44 36 maq 88 22 66 zhouba 98 44 46 # 打印第一段内容 [root@node01 export]# cat score.txt | awk -F ' ' '{print $1}' zhangsan lisi wangwu zhaoliu maq zhouba # 将第一段内容转成大写 且 显示 [root@node01 export]# cat score.txt | awk -F ' ' '{print toupper($1)}' ZHANGSAN LISI WANGWU ZHAOLIU MAQ ZHOUBA 9.3.5. 第五步: if语句 查询及格的学生信息 命令 含义 awk -F ',' '{if($4>60) print $1, $4 }' score.txt 如果及格,就显示 $1, $4 awk -F ',' '{if($4>60) print $1, $4, \"及格\"; else print $1, $4, \"不及格\"}' score.txt 显示 姓名, $4, 是否及格 选项 参数 含义 if($0 ~ \"aa\") print $0 如果这一行包含 \"aa\", 就打印这一行内容 if($1 ~ \"aa\") print $0 如果第一段 包含 \"aa\", 就打印这一行内容 if($1 == \"lisi\") print $0 如果第一段 等于 \"lisi\", 就打印这一行内容 [root@node01 export]# cat score.txt zhangsan 68 99 26 lisi 98 66 96 wangwu 38 33 86 zhaoliu 78 44 36 maq 88 22 66 zhouba 98 44 46 # 打印及格的同学信息 [root@node01 export]# cat score.txt | awk -F ' ' '{if($4>60) print $1,$4,\"及格\"}' lisi 96 及格 wangwu 86 及格 maq 66 及格 # 显示学生的及格状态 [root@node01 export]# cat score.txt | awk -F ' ' '{if($4>60) print $1,$4,\"及格\"; else print $1,$4,\"不及格\"}' zhangsan 26 不及格 lisi 96 及格 wangwu 86 及格 zhaoliu 36 不及格 maq 66 及格 zhouba 46 不及格 9.3.6. 第六步: 段内容 求指定学科平均分 命令 含义 awk 'BEGIN{初始化操作}{每行都执行} END{结束时操作}' 文件名 BEGIN{ 这里面放的是执行前的语句 }{这里面放的是处理每一行时要执行的语句}END {这里面放的是处理完所有的行后要执行的语句 } # 查看文档内容 [root@node01 export]# cat score.txt zhangsan 68 99 26 lisi 98 66 96 wangwu 38 33 86 zhaoliu 78 44 36 maq 88 22 66 zhouba 98 44 46 # 查看总分 [root@node01 export]# cat score.txt | awk -F ' ' 'BEGIN{}{total=total+$4} END{print total}' 356 # 查看总分, 总人数 [root@node01 export]# cat score.txt | awk -F ' ' 'BEGIN{}{total=total+$4} END{print total, NR}' 356 6 # 查看总分, 总人数, 平均分 [root@node01 export]# cat score.txt | awk -F ' ' 'BEGIN{}{total=total+$4} END{print total, NR, (total/NR)}' 356 6 59.3333 9.4. 8.4 小结 通过 awk 动作 文件名 更加灵活的解析文件. 准备工作 cd /export | rm -rf * vim 1.txt aaa java root bbb hello ccc rt ddd root nologin eee rtt fff ROOT nologin ggg rttt 10. 9 sed 10.1. 9.1 目标 通过 sed 可以实现 过滤 和 替换 的功能. 10.2. 9.2 路径 第一步: 实现 查询 功能 第二步: 实现 删除 功能 第三步: 实现 修改 功能 第四步: 实现 替换 功能 第五步: 对 原文件 进行操作 第六步: 综合 练习 10.3. 9.3 实现 10.3.1. 第一步: 实现 查询 功能 命令 含义 sed 可选项 目标文件 对目标文件 进行 过滤查询 或 替换 可选参数 可选项 英文 含义 p print 打印 $ 代表 最后一行 -n 仅显示处理后的结果 -e expression 根据表达式 进行处理 练习1 列出 1.txt的 3~5行 的数据 # 查看所有内容 [root@node01 export]# cat 1.txt aaa java root bbb hello ccc rt ddd root nologin eee rtt fff ROOT nologin ggg rttt # 查看前3~5行内容 [root@node01 export]# cat 1.txt | sed -n -e '3,5p' ccc rt ddd root nologin eee rtt 练习2 列出01.txt的所有数据 # 查看文件所有内容 [root@node01 export]# cat 1.txt aaa java root bbb hello ccc rt ddd root nologin eee rtt fff ROOT nologin ggg rttt # 查看文件所有内容, $代表最后一行 [root@node01 export]# cat 1.txt | sed -n -e '1,$p' aaa java root bbb hello ccc rt ddd root nologin eee rtt fff ROOT nologin ggg rttt 练习3 列出01.txt的3-5行数据 且 显示行号 可选项 含义 = 打印当前行号 [root@node01 export]# sed -n -e '3,5=' -e '3,5p' 1.txt 3 ccc rt 4 ddd root nologin 5 eee rtt [root@node01 export]# cat 1.txt aaa java root bbb hello ccc rt ddd root nologin eee rtt fff ROOT nologin ggg rttt [root@node01 export]# cat -n 1.txt 1 aaa java root 2 bbb hello 3 ccc rt 4 ddd root nologin 5 eee rtt 6 fff ROOT nologin 7 ggg rttt [root@node01 export]# cat -n 1.txt | sed -n -e '3,5p' 3 ccc rt 4 ddd root nologin 5 eee rtt 练习4: 查找 1.txt 中包含 root 行 答案： [root@node01 export]# cat 1.txt aaa java root bbb hello ccc rt ddd root nologin eee rtt fff ROOT nologin ggg rttt [root@node01 export]# cat 1.txt | sed -n -e '/root/p' aaa java root ddd root nologin [root@node01 export]# cat 1.txt | grep root aaa java root ddd root nologin 练习5 列出01.txt中包含root的内容，root不区分大小写,并显示行号 可选项 英文 含义 I ignore 忽略大小写 答案： [root@node01 export]# cat -n 1.txt | sed -n -e '/root/Ip' 1 aaa java root 4 ddd root nologin 6 fff ROOT nologin [root@node01 export]# cat -n 1.txt | grep -i root 1 aaa java root 4 ddd root nologin 6 fff ROOT nologin 练习6 查找出1.txt中 字母r后面是多个t的行，并显示行号 可选项 英文 含义 -r regexp-extended 识别正则 答案： # 显示所有 且 显示行号 [root@node01 export]# cat -n 1.txt 1 aaa java root 2 bbb hello 3 ccc rt 4 ddd root nologin 5 eee rtt 6 fff ROOT nologin 7 ggg rttt # 搜索匹配的行 [root@node01 export]# cat -n 1.txt | sed -n -r -e '/r+t/p' 3 ccc rt 5 eee rtt 7 ggg rttt 10.3.2. 第二步: 实现 删除 功能 练习1 删除01.txt中前3行数据，并显示行号 可选项 英文 含义 d delete 删除指定内容 答案： # 打印所有内容 且 显示行号 [root@node01 export]# nl 1.txt 1 aaa java root 2 bbb hello 3 ccc rt 4 ddd root nologin 5 eee rtt 6 fff ROOT nologin 7 ggg rttt [root@node01 export]# nl 1.txt | sed -e '1,3d' 4 ddd root nologin 5 eee rtt 6 fff ROOT nologin 7 ggg rttt 练习2 保留1.txt中前3行数据，并显示行号 答案： [root@node01 export]# nl 1.txt | sed -e '4,$d' 1 aaa java root 2 bbb hello 3 ccc rt # 显示前三行内容 [root@node01 export]# head -3 1.txt aaa java root bbb hello ccc rt # 显示前三行内容 且带 序号 [root@node01 export]# head -3 1.txt | nl 1 aaa java root 2 bbb hello 3 ccc rt # 显示所有 [root@node01 export]# nl 1.txt 1 aaa java root 2 bbb hello 3 ccc rt 4 ddd root nologin 5 eee rtt 6 fff ROOT nologin 7 ggg rttt # 显示前三行内容 且带 序号 [root@node01 export]# nl 1.txt | head -3 1 aaa java root 2 bbb hello 3 ccc rt 10.3.3. 第三步: 实现 修改 功能 练习1: 在01.txt的第二行 下面 添加aaaaa,并显示行号 参数 英文 含义 i insert 目标前面 插入内容 a append 目标后面 追加内容 答案： [root@node01 export]# nl 1.txt 1 aaa java root 2 bbb hello 3 ccc rt 4 ddd root nologin 5 eee rtt 6 fff ROOT nologin 7 ggg rttt [root@node01 export]# nl 1.txt | sed -e '2a aaaaaa' 1 aaa java root 2 bbb hello aaaaaa 3 ccc rt 4 ddd root nologin 5 eee rtt 6 fff ROOT nologin 7 ggg rttt 练习2 在1.txt的第1行前添加bbbbb，并显示行号 答案： [root@node01 export]# nl 1.txt 1 aaa java root 2 bbb hello 3 ccc rt 4 ddd root nologin 5 eee rtt 6 fff ROOT nologin 7 ggg rttt [root@node01 export]# nl 1.txt | sed -e '1i bbbbbbbbb' bbbbbbbbb 1 aaa java root 2 bbb hello 3 ccc rt 4 ddd root nologin 5 eee rtt 6 fff ROOT nologin 7 ggg rttt 10.3.4. 第四步: 实现 替换 功能 练习1 把1.txt中的nologin替换成为huawei,并显示行号 英文 含义 s/oldString/newString/ replace 替换 答案： [root@node01 export]# nl 1.txt 1 aaa java root 2 bbb hello 3 ccc rt 4 ddd root nologin 5 eee rtt 6 fff ROOT nologin 7 ggg rttt [root@node01 export]# nl 1.txt | sed -e 's/root/huawei/' 1 aaa java huawei 2 bbb hello 3 ccc rt 4 ddd huawei nologin 5 eee rtt 6 fff ROOT nologin 7 ggg rttt 练习2 把01.txt中的1,2行替换为aaa,并显示行号 选项 英文 2c 新字符串 replace 使用新字符串 替换 选中的行 答案： [root@node01 export]# nl 1.txt 1 aaa java root 2 bbb hello 3 ccc rt 4 ddd root nologin 5 eee rtt 6 fff ROOT nologin 7 ggg rttt [root@node01 export]# nl 1.txt | sed -e '2c aaaa' 1 aaa java root aaaa 3 ccc rt 4 ddd root nologin 5 eee rtt 6 fff ROOT nologin 7 ggg rttt 10.3.5. 第五步: 对 原文件 进行操作 练习1 在01.txt中把nologin替换为 huawei 参数 英文 含义 -i in-place 替换原有文件内容 答案： # 备份原始文件内容 cp 1.txt 2.txt # 原文件内容 [root@node01 export]# cat 1.txt aaa java root bbb hello ccc rt ddd root nologin eee rtt fff ROOT nologin ggg rttt # 替换 [root@node01 export]# sed -i -e 's/nologin/huawei/' 1.txt # 观察变化 [root@node01 export]# cat 1.txt aaa java root bbb hello ccc rt ddd root huawei eee rtt fff ROOT huawei ggg rttt 练习2 在01.txt文件中第2、3行替换为aaaaaa 答案： # 原文件内容 [root@node01 export]# cat 1.txt aaa java root bbb hello ccc rt ddd root huawei eee rtt fff ROOT huawei ggg rttt # 替换 [root@node01 export]# sed -i -e '2,3c aaaaaaa' 1.txt # 观察变化 [root@node01 export]# cat 1.txt aaa java root aaaaaaa ddd root huawei eee rtt fff ROOT huawei ggg rttt 注意：在进行操作之前，最好是对数据进行备份，放置操作失误，数据无法恢复！ 练习3 删除01.txt中前2行数据，并且删除原文件中的数据 答案： # 查看原文件内容 [root@node01 export]# cat 2.txt aaa java root aaaaaaa ddd root huawei eee rtt fff ROOT huawei ggg rttt # 删除1,2行内容 [root@node01 export]# sed -i -e '1,2d' 2.txt # 查看原文件内容 [root@node01 export]# cat 2.txt ddd root huawei eee rtt fff ROOT huawei ggg rttt 10.3.6. 第六步: 综合 练习 练习1 获取ip地址 符号 含义 ^ 表示开始 ^aaa 表示以 aaa 开始 $ 表示结尾 bbb$ 表示以 bbb 结尾 .* 表示任意 ^.* 表示以 任意字符开始 答案： # 查看网卡信息 [root@node01 export]# ifconfig eth0 eth0 Link encap:Ethernet HWaddr 00:0C:29:DF:0A:6A inet addr:192.168.100.204 Bcast:192.168.100.255 Mask:255.255.255.0 inet6 addr: fe80::20c:29ff:fedf:a6a/64 Scope:Link UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1 RX packets:12999 errors:0 dropped:0 overruns:0 frame:0 TX packets:7353 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:1000 RX bytes:1334125 (1.2 MiB) TX bytes:1333707 (1.2 MiB) # 根据关键 搜索行 [root@node01 export]# ifconfig eth0 | grep 'inet addr:' inet addr:192.168.100.204 Bcast:192.168.100.255 Mask:255.255.255.0 # 去掉ip地址以前的部分 [root@node01 export]# ifconfig eth0 | grep 'inet addr:' | sed -e 's/^.*addr://' 192.168.100.204 Bcast:192.168.100.255 Mask:255.255.255.0 # 去掉ip地址以后的部分 [root@node01 export]# ifconfig eth0 | grep 'inet addr:' | sed -e 's/^.*addr://' | sed -e 's/Bcast:.*$//' 192.168.100.204 练习2 从 2.txt 中提出数据，匹配出包含root的内容，再把nologin替换为itheima 答案： [root@node01 export]# nl 2.txt 1 aaa java root 2 bbb hello 3 ccc rt 4 ddd root nologin 5 eee rtt 6 fff ROOT nologin 7 ggg rttt # 匹配含有root内容的行 [root@node01 export]# nl 2.txt | grep root 1 aaa java root 4 ddd root nologin # 匹配含有root内容的行 且 忽略大小写 [root@node01 export]# nl 2.txt | grep -i root 1 aaa java root 4 ddd root nologin 6 fff ROOT nologin # 将nologin 替换成 itheima [root@node01 export]# nl 2.txt | grep -i root | sed -e 's/nologin/itheima/' 1 aaa java root 4 ddd root itheima 6 fff ROOT itheima nl 01.txt | grep 'root' | sed -e 's/nologin/itheima/' 或者 nl 01.txt | sed -n -e '/root/p' | sed -e 's/nologin/itheima/' 或者 nl 01.txt | sed -n -e '/root/{s/nologin/itheima/p}' #只显示替换内容的行 练习3 从2.txt中提出数据，删除前2行，并把nologin替换为itheima,并显示行号 答案： [root@node01 export]# nl 2.txt 1 aaa java root 2 bbb hello 3 ccc rt 4 ddd root nologin 5 eee rtt 6 fff ROOT nologin 7 ggg rttt # 删除前两行内容 [root@node01 export]# nl 2.txt | sed -e '1,2d' 3 ccc rt 4 ddd root nologin 5 eee rtt 6 fff ROOT nologin 7 ggg rttt # 替换内容 [root@node01 export]# nl 2.txt | sed -e '1,2d' | sed -e 's/nologin/itheima/' 3 ccc rt 4 ddd root itheima 5 eee rtt 6 fff ROOT itheima 7 ggg rttt 11. 2. Shell 编程 11.1. 2.1 简介 Shell 是一个用 C 语言编写的程序，通过 Shell 用户可以访问操作系统内核服务。 Shell 既是一种命令语言，又是一种程序设计语言。 Shell script 是一种为 shell 编写的脚本程序。Shell 编程一般指 shell脚本编程，不是指开发 shell 自身。 Shell 编程跟 java、php 编程一样，只要有一个能编写代码的文本编辑器和一个能解释执行的脚本解释器就可以了。 Linux 的 Shell 解释器 种类众多，一个系统可以存在多个 shell解释器，可以通过 cat /etc/shells 命令查看系统中安装的 shell解释器。 Bash 由于易用和免费，在日常工作中被广泛使用。同时，Bash 也是大多数Linux 系统默认的 Shell。 11.1.1. shell 解释器 java 需要 虚拟机解释器, 同理 shell脚本也需要 解析器 [root@node04 shells]# cat /etc/shells /bin/sh /bin/bash /sbin/nologin /bin/dash /bin/tcsh /bin/csh . 11.2. 2.2快速入门 11.2.1. 1 编写脚本 新建 /export/01.sh 文件 #!/bin/bash echo 'hello world' #!是一个约定的标记，它告诉系统这个脚本需要什么解释器来执行，即使用哪一种 Shell。 echo 命令用于向窗口输出文本。 11.2.2. 2 执行shell脚本 执行方式一 [root@node04 shells]# /bin/sh 01.sh hello world [root@node04 shells]# /bin/bash 01.sh hello world 问题: bash 和 sh 是什么关系? sh 是 bash 的 快捷方式 3.2 执行方式二 方式一的简化方式 [root@node04 shells]# bash hello.sh hello world [root@node04 shells]# sh hello.sh hello world 3.2.1 问题: 请思考 为什么可以省略 /bin/ 因为 PATH环境变量中增加了 /bin/目录, 所以 使用/bin/sh等类似指令时, 可以省略 /bin 3.3 执行方式三 ./文件名 [root@node04 shells]# ll 总用量 4 -rw-r--r--. 1 root root 32 3月 14 00:20 01.sh [root@node04 shells]# ./01.sh -bash: ./01.sh: 权限不够 3.3.1 权限不够怎么办? [root@node04 shells]# chmod 755 01.sh [root@node04 shells]# ll 总用量 4 -rwxr-xr-x. 1 root root 32 3月 14 00:20 01.sh # 再次执行: [root@node04 shells]# ./01.sh hello world! 11.3. 2.3 shell变量 11.3.1. 1 简介 在shell脚本中, 定义变量时，变量名不加美元符号（$），如： your_name=\"runoob.com\" 注意 : 变量名和等号之间不能有空格，这可能和你熟悉的所有编程语言都不一样。 同时，变量名的命名须遵循如下规则： 命名只能使用英文字母，数字和下划线，首个字符不能以数字开头。 中间不能有空格，可以使用下划线（_）。 不能使用标点符号。 不能使用bash里的关键字（可用help命令查看保留关键字）。 有效的 Shell 变量名示例如下： RUNOOB LD_LIBRARY_PATH _var var2 无效的变量命名： ?var=123 user*name=runoob 除了显式地直接赋值，还可以用语句给变量赋值，如： for file in `ls /etc` 或 for file in $(ls /etc) 以上语句将 /etc 下目录的文件名循环出来。 ​ 11.3.2. 2 使用变量 使用一个定义过的变量，只要在变量名前面加美元符号即可，如： your_name=\"zhangsan\" echo $your_name echo ${your_name} 变量名外面的花括号是可选的，加不加都行，加花括号是为了帮助解释器识别变量的边界，比如下面这种情况： for skill in java php python; do echo \"I am good at ${skill}Script\" done 如果不给skill变量加花括号，写成echo \"I am good at $skillScript\"，解释器就会把$skillScript当成一个变量（其值为空），代码执行结果就不是我们期望的样子了。 推荐给所有变量加上花括号，这是个好的编程习惯。 已定义的变量，可以被重新定义，如： your_name=\"tom\" echo $your_name your_name=\"alibaba\" echo $your_name 这样写是合法的，但注意，第二次赋值的时候不能写$your_name=\"alibaba\"，使用变量的时候才加美元符（$）。 [root@node01 export]# yourname=zhangsan [root@node01 export]# echo $yourname zhangsan [root@node01 export]# echo ${yourname} zhangsan [root@node01 export]# echo \"$yourname喜欢吃香蕉\" zhangsan喜欢吃香蕉 [root@node01 export]# echo \"$yournamelikebanana\" [root@node01 export]# echo \"${yourname}likebanana\" zhangsanlikebanana 11.3.3. 3 删除变量 使用 unset 命令可以删除变量。语法： unset variable_name 变量被删除后不能再次使用。unset 命令不能删除只读变量。 实例 #!/bin/sh myUrl=\"http://www.runoob.com\" unset myUrl echo $myUrl 以上实例执行将没有任何输出。 11.3.4. 4 只读变量 使用 readonly 命令可以将变量定义为只读变量，只读变量的值不能被改变。 下面的例子尝试更改只读变量，结果报错： #!/bin/bash myUrl=\"http://www.google.com\" readonly myUrl myUrl=\"http://www.runoob.com\" 运行脚本，结果如下： /bin/sh: NAME: This variable is read only. 11.4. 2.4 字符串 ​ 字符串是shell编程中最常用最有用的数据类型（除了数字和字符串，也没啥其它类型好用了），字符串可以用单引号，也可以用双引号，也可以不用引号。 11.4.1. 1 单引号 skill='java' echo '$skill' 输出结果为: $skill 单引号字符串的限制： 单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的； 单引号字串中不能出现单独一个的单引号（对单引号使用转义符后也不行），但可成对出现，作为字符串拼接使用。 11.4.2. 2 双引号 skill='java' echo \"$skill\" 输出结果为： I am goot at java 双引号的优点： 双引号里可以有变量 双引号里可以出现转义字符 11.4.3. 3 获取字符串长度 skill='java' echo ${skill} # 输出结果: java echo ${#skill} # 输出结果: 4 [root@node01 export]# echo ${skill} java [root@node01 export]# echo ${#skill} 4 11.4.4. 4 截取子字符串 substring(2) substring(2,3) 以下实例从字符串第 2 个字符开始截取 4 个字符： str=\"I am goot at $skill\" echo ${str:2} # 输出结果为: am goot at java echo ${str:2:2} # 输出结果为: am 11.4.5. 5 查找子字符串 查找字符 i 或 o 的位置(哪个字母先出现就计算哪个)： str=\"I am goot at $skill\" echo `expr index \"$str\" am` # 输出是: 3 注意： 以上脚本中 ` 是反引号(Esc下面的)，而不是单引号 '，不要看错了哦。 11.5. 2.5 传递参数 我们可以在执行 Shell 脚本时，向脚本传递参数，脚本内获取参数的格式为：$n。 n 代表一个数字，1 为执行脚本的第一个参数，2 为执行脚本的第二个参数，以此类推…… 实例 以下实例我们向脚本传递三个参数，并分别输出，其中 $0 为执行的文件名： vim /export/sh/param.sh #!/bin/bash echo \"Shell 传递参数实例！\"; echo \"执行的文件名：$0\"; echo \"第一个参数为：$1\"; echo \"第二个参数为：$2\"; echo \"第三个参数为：$3\"; 为脚本设置可执行权限，并执行脚本，输出结果如下所示： $ chmod 755 param.sh $ ./param.sh 1 2 3 Shell 传递参数实例！ 执行的文件名：./param.sh 第一个参数为：1 第二个参数为：2 第三个参数为：3 另外，还有几个特殊字符用来处理参数： 参数处理 说明 $# 传递到脚本的参数个数 $* 以一个单字符串显示所有向脚本传递的参数。 如\"$*\"用「\"」括起来的情况、以\"$1 $2 … $n\"的形式输出所有参数。 $$ 脚本运行的当前进程ID号 $! 后台运行的最后一个进程的ID号 $@ 与$*相同，但是使用时加引号，并在引号中返回每个参数。 如\"$@\"用「\"」括起来的情况、以\"$1\" \"$2\" … \"$n\" 的形式输出所有参数。 $- 显示Shell使用的当前选项，与set命令功能相同。 $? 显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。 #!/bin/bash echo \"Shell 传递参数实例！\"; echo \"第一个参数为：$1\"; echo \"参数个数为：$#\"; echo \"传递的参数作为一个字符串显示：$*\"; 执行脚本，输出结果如下所示： $ chmod +x test.sh $ ./test.sh 1 2 3 Shell 传递参数实例！ 第一个参数为：1 参数个数为：3 传递的参数作为一个字符串显示：1 2 3 $* 与 $@ 区别： 相同点：都是引用所有参数。 不同点：只有在双引号中体现出来。假设在脚本运行时写了三个参数 1、2、3，，则 \" * \" 等价于 \"1 2 3\"（传递了一个参数），而 \"@\" 等价于 \"1\" \"2\" \"3\"（传递了三个参数）。 #!/bin/bash echo \"-- $* 演示 ---\" for i in \"$*\"; do echo $i done echo \"-- $@ 演示 ---\" for i in \"$@\"; do echo $i done 执行脚本，输出结果如下所示： $ chmod +x test.sh $ ./test.sh 1 2 3 -- $* 演示 --- 1 2 3 -- $@ 演示 --- 1 2 3 11.6. 2.6 Shell算术运算符 11.6.1. 1 简介 Shell 和其他编程一样，支持包括：算术、关系、布尔、字符串等运算符。 原生 bash 不支持 简单的数学运算，但是可以通过其他命令来实现，例如expr。 expr 是一款表达式计算工具，使用它能完成表达式的求值操作。 例如，两个数相加： val=`expr 2 + 2` echo $val i=2+2 注意： 表达式和运算符之间要有空格，例如 2+2 是不对的，必须写成 2 + 2。 完整的表达式要被 ` 包含，注意不是单引号，在 Esc 键下边。 下表列出了常用的算术运算符，假定变量 a 为 10，变量 b 为 20： 运算符 说明 举例 + 加法 expr $a + $b 结果为 30。 - 减法 expr $a - $b 结果为 -10。 * 乘法 expr $a \\* $b 结果为 200。 / 除法 expr $b / $a 结果为 2。 % 取余 expr $b % $a 结果为 0。 = 赋值 a=$b 将把变量 b 的值赋给 a。 == 相等。用于比较两个数字，相同则返回 true。 [ $a == $b ] 返回 false。 != 不相等。用于比较两个数字，不相同则返回 true。 [ $a != $b ] 返回 true。 注意：条件表达式要放在方括号之间，并且要有空格，例如: [$a==$b] 是错误的，必须写成 [ $a == $b ]。 11.6.2. 2 例子 #!/bin/bash a=4 b=20 #加法运算 each expr $a + $b #减法运算 echo expr $a - $b #乘法运算，注意*号前面需要反斜杠 echo expr $a \\* $b #除法运算 echo $a / $b 此外，还可以通过(())、$(())、$[]进行算术运算。 ((a++)) echo \"a = $a\" c=$((a + b)) d=$[a + b] echo \"c = $c\" echo \"d = $d\" 11.7. 2.7 流程控制 11.7.1. 1 if else 1.1 if if 语句语法格式： if condition; then command1 command2 ... commandN fi demo [root@hadoop01 export]# cat if_test.sh #!/bin/bash a=20 if [ $a -gt 10 ]; then echo \"a 大于 10\" fi 末尾的fi就是if倒过来拼写，后面还会遇到类似的。 1.2 if else if else 语法格式： if condition; then command1 command2 ... commandN else command fi 1.3 if else-if else if else-if else 语法格式： if condition1; then command1 elif condition2; then command2 else commandN fi 以下实例判断两个变量是否相等： 11.7.2. 关系运算符 关系运算符只支持数字，不支持字符串，除非字符串的值是数字。 下表列出了常用的关系运算符，假定变量 a 为 10，变量 b 为 20： 运算符 说明 英文 举例 -eq 检测两个数是否相等，相等返回 true。 equal [ $a -eq $b ] 返回 false。 -ne 检测两个数是否不相等，不相等返回 true。 not equal [ $a -ne $b ] 返回 true。 -gt 检测左边的数是否大于右边的，如果是，则返回 true。 greater than [ $a -gt $b ] 返回 false。 -lt 检测左边的数是否小于右边的，如果是，则返回 true。 less than [ $a -lt $b ] 返回 true。 -ge 检测左边的数是否大于等于右边的，如果是，则返回 true。 Greater than or equal to [ $a -ge $b ] 返回 false。 -le 检测左边的数是否小于等于右边的，如果是，则返回 true。 Less than or equal to [ $a -le $b ] 返回 true。 案例: [root@hadoop01 export]# cat if_test.sh #!/bin/bash a=20 b=10 # 需求1: 判断 a 是否 100 if [ $a > 100 ]; then echo \"$a 大于 100\" fi # 需求2: 判断 a 是否等于 b if [ $a -eq $b ]; then echo \"$a 等于 $b\" else echo \"$a 不等于 $b\" fi # 需求3: 判断 a 与 b 比较 if [ $a -lt $b ]; then echo \"$a 小于 $b\" elif [ $a -eq $b ]; then echo \"$a 等于 $b\" else echo \"$a 大于 $b\" fi # 需求4: 判断 (a + 10) 和 (b * b) 比较大小 if test $[ a + 10 ] -gt $[ b * b ]; then echo \"(a+10) 大于 (b * b)\" else echo \"(a+10) 小于或等于 (b*b)\" fi 11.7.3. 2 for 循环 2.1 格式 for variable in (list); do command command ... done 2.2 随堂练习 # 需求1: 遍历 1~5 # 需求2: 遍历 1~100 # 需求3: 遍历 1~100之间的奇数 # 需求4: 遍历 根目录 下的内容 代码如下: [root@hadoop01 export]# cat for_test.sh #!/bin/bash # 需求1: 遍历 1~5 for i in 1 2 3 4 5; do echo $i; done for i in {1..5}; do echo $i done for(( i=1; i11.7.4. 3 while 语句 while循环用于不断执行一系列命令，也用于从输入文件中读取数据；命令通常为测试条件。其格式为： while condition; do command done 需求: 计算 1~100 的和 初始值; i=1 和值: sum=0; while i ​ sum = sum + i; ​ i++; 打印 sum的值 #!/bin/bash sum=0 i=1 while [ $i -le 100 ]; do sum=$[ sum + i] i=$[ i + 1 ] done echo $sum 运行脚本，输出： 5050 使用中使用了 Bash let 命令，它用于执行一个或多个表达式，变量计算中不需要加上 $ 来表示变量，具体可查阅：Bash let 命令。 11.7.5. 4 无限循环 无限循环语法格式： while true; do command done 需求: 每隔1秒 打印一次当前时间 #!/bin/bash while true; do date sleep 1 done 11.7.6. 5 case(switch) Shell case语句为多选择语句。可以用case语句匹配一个值与一个模式，如果匹配成功，执行相匹配的命令。case语句格式如下： case 值 in 模式1) command1 command2 ... commandN ;; 模式2） command1 command2 ... commandN ;; esac case工作方式如上所示。取值后面必须为单词in，每一模式必须以右括号结束。取值可以为变量或常数。匹配发现取值符合某一模式后，其间所有命令开始执行直至 ;;。 取值将检测匹配的每一个模式。一旦模式匹配，则执行完匹配模式相应命令后不再继续其他模式。如果无一匹配模式，使用星号 * 捕获该值，再执行后面的命令。 下面的脚本提示输入1到4，与每一种模式进行匹配： echo '输入 1 到 4 之间的数字:' read aNum case $aNum in 1) echo '你选择了 1' ;; 2) echo '你选择了 2' ;; 3) echo '你选择了 3' ;; 4) echo '你选择了 4' ;; *) echo '你没有输入 1 到 4 之间的数字' ;; esac 输入不同的内容，会有不同的结果，例如： 输入 1 到 4 之间的数字: 你输入的数字为: 3 你选择了 3 ​ 11.7.7. 6 跳出循环 在循环过程中，有时候需要在未达到循环结束条件时强制跳出循环，Shell使用两个命令来实现该功能：break和continue。 6.1 break命令 break命令允许跳出所有循环（终止执行后面的所有循环）。 需求: 执行死循环 每隔1秒打印当前时间, 执行10次停止 #!/bin/bash # 需求: 执行死循环 每隔1秒打印当前时间, 执行10次停止 i=0; while true; do sleep 1 echo $i `date +\"%Y-%m-%d %H:%M:%S\"` i=$[ i + 1] if [ $i -eq 10 ]; then break fi done 6.2 continue continue命令与break命令类似，只有一点差别，它不会跳出所有循环，仅仅跳出当前循环。 需求: 打印 1~30, 注意 跳过3的倍数 #!/bin/bash # 需求: 打印 1~30, 注意 跳过3的倍数 for i in {1..30}; do if test $[ i % 3 ] -eq 0; then continue fi echo $i done 11.8. 2.8 函数使用 1 函数的快速入门 格式 [ function ] funname() { action; [return int;] } 可以带function fun() 定义，也可以直接fun() 定义,不带任何参数。 参数返回，可以显示加：return 返回，如果不加，将以最后一条命令运行结果，作为返回值。 return后跟数值n(0-255) 快速入门 #!/bin/bash demoFun () { echo \"这是我的第一个 shell 函数!\" } echo \"-----函数开始执行-----\" demoFun echo \"-----函数执行完毕-----\" 2 传递参数给函数 在Shell中，调用函数时可以向其传递参数。在函数体内部，通过 $n 的形式来获取参数的值，例如，$1表示第一个参数，$2表示第二个参数... 带参数的函数示例： #!/bin/bash funWithParam(){ echo \"第一个参数为 $1 !\" echo \"第二个参数为 $2 !\" echo \"第十个参数为 $10 !\" echo \"第十个参数为 ${10} !\" echo \"第十一个参数为 ${11} !\" echo \"参数总数有 $# 个!\" echo \"作为一个字符串输出所有参数 $* !\" } funWithParam 1 2 3 4 5 6 7 8 9 34 73 输出结果： 第一个参数为 1 ! 第二个参数为 2 ! 第十个参数为 10 ! 第十个参数为 34 ! 第十一个参数为 73 ! 参数总数有 11 个! 作为一个字符串输出所有参数 1 2 3 4 5 6 7 8 9 34 73 ! 注意，$10 不能获取第十个参数，获取第十个参数需要${10}。当n>=10时，需要使用${n}来获取参数。 另外，还有几个特殊字符用来处理参数： 参数处理 说明 $# 传递到脚本的参数个数 $* 以一个单字符串显示所有向脚本传递的参数 $$ 脚本运行的当前进程ID号 $! 后台运行的最后一个进程的ID号 $@ 与$*相同，但是使用时加引号，并在引号中返回每个参数。 $- 显示Shell使用的当前选项，与set命令功能相同。 $? 显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。 0 1 2 11.9. 2.9 数组 11.9.1. 1 定义数组 数组中可以存放多个值。Bash Shell 只支持一维数组（不支持多维数组），初始化时不需要定义数组大小 与大部分编程语言类似，数组元素的下标由0开始。 Shell 数组用括号来表示，元素用\"空格\"符号分割开，语法格式如下： array_name=(value1 value2 value3 ... valuen) 1.1 实例 #!/bin/bash my_array=(A B \"C\" D) 我们也可以使用下标来定义数组: array_name[0]=value0 array_name[1]=value1 array_name[2]=value2 11.9.2. 2 读取数组 读取数组元素值的一般格式是： ${array_name[index]} 2.1 实例 #!/bin/bash my_array=(A B \"C\" D) echo \"第一个元素为: ${my_array[0]}\" echo \"第二个元素为: ${my_array[1]}\" echo \"第三个元素为: ${my_array[2]}\" echo \"第四个元素为: ${my_array[3]}\" 执行脚本，输出结果如下所示： $ chmod +x test.sh $ ./test.sh 第一个元素为: A 第二个元素为: B 第三个元素为: C 第四个元素为: D 2.2 获取数组中的所有元素 使用@ 或 * 可以获取数组中的所有元素，例如： #!/bin/bash my_array[0]=A my_array[1]=B my_array[2]=C my_array[3]=D echo \"数组的元素为: ${my_array[*]}\" echo \"数组的元素为: ${my_array[@]}\" 执行脚本，输出结果如下所示： $ chmod +x test.sh $ ./test.sh 数组的元素为: A B C D 数组的元素为: A B C D 2.3 获取数组的长度 获取数组长度的方法与获取字符串长度的方法相同，例如： #!/bin/bash my_array[0]=A my_array[1]=B my_array[2]=C my_array[3]=D echo \"数组元素个数为: ${#my_array[*]}\" echo \"数组元素个数为: ${#my_array[@]}\" 执行脚本，输出结果如下所示： $ chmod +x test.sh $ ./test.sh 数组元素个数为: 4 数组元素个数为: 4 11.9.3. 3 遍历数组 3.1 方式一 #!/bin/bash my_arr=(AA BB CC) for var in ${my_arr[*]} do echo $var done 3.2 方式二 my_arr=(AA BB CC) my_arr_num=${#my_arr[*]} for((i=0;i11.10. 2.10 加载其它文件的变量 11.10.1. 1 简介 和其他语言一样，Shell 也可以包含外部脚本。这样可以很方便的封装一些公用的代码作为一个独立的文件。 Shell 文件包含的语法格式如下： . filename # 注意点号(.)和文件名中间有一空格 或 source filename 11.10.2. 2 练习 定义两个文件 test1.sh和test2.sh，在test1中定义一个变量arr=(java c++ shell),在test2中对arr进行循环打印输出。 第一步: vim test1.sh #!/bin/bash my_arr=(AA BB CC) 第二步: vim test2.sh #!/bin/bash source ./test1.sh # 加载test1.sh 的文件内容 for var in ${my_arr[*]} do echo $var done 第三步: 执行 test2.sh sh test2.sh 好处 : ​ 1. 数据源 和 业务处理 分离 ​ 2. 复用 代码扩展性更强 Copyright © MISIN 2022 | 豫ICP备2021006345号-1 all right reserved，powered by Gitbook该文件修订时间： 2020-11-01 04:20:44 "},"Windows文件批量重命名.html":{"url":"Windows文件批量重命名.html","title":"Windows文件批量重命名","keywords":"","body":"1.1. Windows文件批量重命名1.1.1. 在重命名文件夹下新建批处理文件1.1.2. 使用sublime编辑文件a.txt1.1.3. 双击运行1.1. Windows文件批量重命名 1.1.1. 在重命名文件夹下新建批处理文件 chcp 65001 dir /s/b >>a.txt 1.1.2. 使用sublime编辑文件a.txt 1.全选复制一份 2.编辑原文件（将其变成需要变成的文件名，目录路径全部去除） 去除之后在行首行末添加双引号并在行首添加\" ^匹配行首 $匹配行尾 //打开正则表达式并匹配地址 ^[^ \\\\]*\\\\ 3.将复制的文件粘贴至行首并用双引号封住，在之前添加ren 4.修改文件格式为bat 1.1.3. 双击运行 Copyright © MISIN 2022 | 豫ICP备2021006345号-1 all right reserved，powered by Gitbook该文件修订时间： 2022-11-11 16:35:29 "},"nopay_over_wall.html":{"url":"nopay_over_wall.html","title":"YOU CAN TRY IT","keywords":"","body":"1.1.1. 翻墙第一步，GitHub打开下工具。1.1.2. 第二步找节点1.1.3. 第三步，筛选节点1.1.4. 扩展1.1.5. 重要：善用google搜索，大部分问题用Google搜索都可以解决1.1.1. 翻墙第一步，GitHub打开下工具。 没有理论，只有操作，因为我也不懂，反正里面有工具下载就完了，具体了解原理和注意事项可以看YouTube主电丸科技AK的视频中第一个系列的视频（翻出去之后才可以看） 硬核翻墙/科学上网系列 查看完整播放列表 这里我使用的是v2rayN-Core这个软件手机上和windows系统上都可以下载到如果是第一次用就用windows电脑先着手吧！后面我会写到怎样实现星星之火的燎原 https://github.com/2dust/v2rayN/releases 可以在这里下载，我不知道为什么即使翻墙翻出去了还是很慢，不过第一次用也可以凑合一下，如果想快一点可以把下载下来之后存起来，以防什么时候用到了。 尽量升级到最新版，旧版本老出问题，网不好，之前说还是很慢就是因为那 也可以用百度云链接：https://pan.baidu.com/s/1YcmnrhAKSG58pq5_-yPvZg 提取码：6666 蓝奏云链接：https://wwi.lanzoup.com/iJy390isnkje 这一个很小是我在GitHub上面的开源项目找到的可以搜freefan找到看里面写的，还不错，但是因为好像不是官方版。所以如果一直用的话，可以谨慎一点下载一个官方版（我没有试，因为我觉得反正我没钱他要骗就让他骗吧。。。）链接：https://github.com/2dust/v2rayN/releases 这里工具就这几个，ios系统可以下载一个小火箭，不过要自己购买的话需要自己花钱还需要apple id，挺麻烦的如果想知道怎么弄可以看这个网站（需要翻墙）：https://applezz.com/shadowrocket/ios/。我比较推荐用安卓或者windows，5G手机流量够用的话网速也可以达到很快又比较方便。 1.1.2. 第二步找节点 找节点我现在主要知道两种方法，反正一旦翻出去之后你可能会在很多地方发现新的节点，尽量远离那种有关反动言论和邪教啥的就好了，GitHub上有一个星挺多的直接翻墙挂在了一个谷歌浏览器上，反正我个人觉得尽量不要用，毕竟整个浏览器信息万一都被人监控着总觉得有点心里发怵，最重要的是整个浏览器都是反动网站书签。 这里想简单陈述下我的观点：对于我来说我想翻墙仅仅是因为我想去开阔自己的眼界，不想被局限在一种思想之中。对于那些有关抹黑国家的事我当然不会说完全相信他就是假的，也当然不会相信他完全就是真的。只要不是自己亲身经历的事情他就一定带着某种立场上的夸大或贬低，而对于一件事情也都应该去辩证的看待，而墙内墙外就好像是一件事情的正反面一样。还有就是人非圣贤，孰能无过，而这句话我认为同时适用于党和国家。我认为重在有则改之无则加勉。 第一个就是GitHub上面搜，也是我所知道的从墙内免费出来的唯一方式 在github上直接搜索翻墙或者节点即可，然后根据star数和recently update最近更新数排序就好在里面找订阅链接和节点 这里可以试看以下三个链接： https://github.com/ermaozi/get_subscribe https://github.com/Pawdroid/Free-servers https://github.com/freefq/free 其中的订阅链接就是直接订阅一堆，直接在软件中更新订阅就可以直接更新一堆了，但是可能缺点就是大部分人用这种方法，所以这种节点普遍速度慢吧！ 而订阅节点就是可以直接复制一条或者多条然后在软件中批量导入的节点，如果是订阅链接中有的和以上有同样的缺点，如果不是可能还是会有速度很不错的节点的。 还有就是我所知道的免费节点应该是别人用爬虫爬的吧！当然这种免费的有安全隐患是肯定的，如果想找一个安全的可以直接买个软件用的时候打开就好了，好像也可以买机场，我所理解的机场就是一个飞到国外网络的机场，里面不仅仅是只有一架飞机。那种专业做这个服务的人可能会更安全一些。不过同样我觉得反正我没钱他要骗就让他骗吧。。。 （找较快节点）第二个就是在YouTube上面搜一些免费节点，这种速度应该会更快一点，毕竟要订阅人频道人可以拿到佣金呢 直接搜索节点两个字就可以，会有一些up主会发视频炫耀节点的速度并分享，有的有密码是需要从视频里面听密码的。我试了确实网速是要比那个github高star的速度快的。 1.1.3. 第三步，筛选节点 可以用软件直接测速，有各种选项测一下比较一下把不能用的删除掉，windows上的这个软件好像不准确，感觉手机上的比较好用。可以用手机，我是用手机弄的反正。批量删除无效节点，再在剩下的比较好用的节点中选择一个最好用的就好了。不能完全看测试，更多的还是看延迟加网速都高，不过不用太纠结非要一个最好的，毕竟过几天可能就不好了还要重新筛选。只要能满足自己的需要就足够了，比如看个YouTube的加载时间自己到达自己的接受范围。 1.1.4. 扩展 这里会写怎样将一个端转向多个端，从而做到星星之火的燎原 windows 在windows可以实现翻墙之后就可以直接将其转换到各个端了，只需要在windows上设备连接时进行简单的设置即可。 反正就是直接用电脑上的翻墙软件提供的网络连接从而做到让连接电脑热点的设备全局翻墙。 1.首先v2rayN连接节点后并确定可稳定访问Google后依次点击参数设置>v2rayN设置中的允许来自局域网的连接打勾 2.然后在CMD中输入ipconfig查看网卡信息，查看当前连接网络的网卡信息 3.然后将连接网络的ip设置为固定ip：依次点击设置-->网络和Internet-->网络与共享中心-->连接：XXX-->属性-->Internet协议版本4-->属性-->使用下面的ip地址 4.将第一个ip地址填写为cmd中的ipv4地址（可以自定为主机所在子网下的所有可用ip地址，需要记住），第二项子网掩码修改为当前连接网络的子网掩码，第三项默认网关修改为当前连接网络的默认网关。首选DNS服务器可填为8.8.8.8 在其他端连接热点时添加上代理为手动主机名为以上第四步中所填的ipv4地址，端口填写应用v2rayN的端口号10809即可，可以在软件下方看到HTTP:127.0.0.1：10809。即为这里的10809 连接之后其他端即可访问google Android 在安卓端成功翻墙之后就可以下载一些国外软件使用了。我使用的是小米手机所以可能才可以直接安装Google Play的，但据我实验，好像华为手机是不可以安装的，不过可以下载Gspace，好像可以在应用商店中下载到。我的手机是可以直接使用这些的，如果实在不行也可以选择安装一个虚拟机并在虚拟机中实现root+google。也可以尝试申请一个谷歌账号和邮箱，个人感觉用处挺大的。 在Google Play中可以下载安装v2rayNG然后也可以用同样的方式实现用手机给电脑开热点让电脑实现翻墙。只需要同windows中的四步就可以，不一样的是只需要在手机端开启热点和v2rayN设置中的允许来自局域网的连接打勾之后连接，直接在电脑端查看当前连接网络的默认网关设置为代理，端口号同样为10809.电脑端的设置代理位置依次点击设置-->网络和Internet-->代理-->手动设置代理 v2rayNG也可以直接在官网这里下载安卓版，当然以上提到的操作也可以将部分直接在手机上进行。 https://v2rayng.org中写到的**v2rayNG官网**下载地址：https://github.com/2dust/v2rayNG/releases 新手使用建议下载稳定版本，即版本号后标记为 Latest 的版本。这里注意往下拉，那里的Assets点开之后就是下载连接，因为我一开始一度找不到在哪。。。。。。 ios 可以下载用美区apple id下载小火箭（shadowrocket）然后导入节点，也可以自行注册一个美区apple id购买小火箭，或者下载免费的一个叫fair的软件，但是不好用好像。其他基本一样。 链接：https://applezz.com/shadowrocket/ios/ 总结 在连接热点时需要设置代理和端口好不要忘了 关于tiktok tiktok这个软件挺厉害，属于是中国人把中国人防的死死的，一旦手机上有中国的电话卡好像就是不能看的，只能用无卡的手机进行一些设置之后才可以看。 1.1.5. 重要：善用google搜索，大部分问题用Google搜索都可以解决 Copyright © MISIN 2022 | 豫ICP备2021006345号-1 all right reserved，powered by Gitbook该文件修订时间： 2022-12-16 11:24:35 "}}